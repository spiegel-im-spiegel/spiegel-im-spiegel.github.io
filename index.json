{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "それは Duck Typing ぢゃない（らしい）",
      "section": "remark",
      "description": "今回は Go と Rust との比較をちょっとポエミーに語ってみる（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/04/subtyping/",
      "published": "2020-04-10T10:37:23+00:00",
      "update": "2020-04-10T10:55:30+00:00",
      "content": "今回は Go と Rust との比較をちょっとポエミーに語ってみる（笑）\nそもそも duck typing は Ruby のような動的型付け言語における型推論の手法（のひとつ）である。 その由来は duck test から来ていて\nIf it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck. via Duck test - Wikipedia  というフレーズに集約されている。\n静的型付け言語である Go や Rust における抽象型を使った型推論を duck typing と呼ぶのは厳密には正しくない，らしい。 Go や Rust における interface や trait といった抽象型を用いた型推論は「部分型付け（subtyping）」と呼ばれる。 ただし Go と Rust では全く異なる戦略をとる。\nCat コマンドもどき（Go 版） ここで簡単なプログラムを書いてみよう。 UNIX 系のプラットフォームではおなじみの cat コマンドの「もどき」を書いてみる。\n本来の cat コマンドは複数の入力を結合（concatenate）して出力するものだが，真面目な実装をし始めるとキリがないので，今回は以下の2つの機能のみ実装する。\n コマンドライン引数で指定したファイルを1つのみ標準出力に出力する ファイルの指定がない場合は標準入力をそのまま標準出力に出力する  ぶっちゃけ，ただの「土管」である（笑） これを Go で書いたのが以下のコードだ。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func concatenate(w io.Writer, r io.Reader) error { _, err := io.Copy(w, r) return err } func main() { if len(os.Args) \u0026gt; 1 { file, err := os.Open(os.Args[1]) if err != nil { fmt.Fprintln(os.Stderr, err) return } defer file.Close() if err := concatenate(os.Stdout, file); err != nil { fmt.Fprintln(os.Stderr, err) return } } else { if err := concatenate(os.Stdout, os.Stdin); err != nil { fmt.Fprintln(os.Stderr, err) return } } } concatenate() 関数がメインのロジックで，引数の io.Writer, io.Reader および返り値の error は全て interface 型である。 まぁ concatenate() 関数を括り出す必然性は全くないのだが，後述の Rust のコードと比較しやすいよう敢えて分けている。\nconcatenate() 関数の呼び出しで，最初の\nif err := concatenate(os.Stdout, file); err != nil { fmt.Fprintln(os.Stderr, err) return } と次の\nif err := concatenate(os.Stdout, os.Stdin); err != nil { fmt.Fprintln(os.Stderr, err) return } は（当然ながら）同じ関数で，引数や返り値にどのようなインスタンスが入るかは実行時に決まる。 コンパイル時に決まるのは注入するインスタンスの構造が受け入れる interface 型の構造と合致していることだけだ（合致しなければコンパイル・エラー）。\nすンごい簡単に書かれているけど，これは「依存の注入（depencency injection）」の典型例であり「Go では duck typing ができる」とか言われる所以である。\nでは，これをリファレンスとして，今度は Rust を使って書いてみる。\nCat コマンドもどき（Rust 版，総称型編） とりあえず，えいやっで書いたコードがこちら。\nfn concatenate\u0026lt;W,R\u0026gt;(w: \u0026amp;mutW,r: \u0026amp;mutR)-\u0026gt; Result\u0026lt;(),std::io::Error\u0026gt;whereW: std::io::Write,R: std::io::Read,{letmutbuf=Vec::new();r.read_to_end(\u0026amp;mutbuf)?;w.write_all(\u0026amp;buf)?;Ok(())}fn main()-\u0026gt; Result\u0026lt;(),std::io::Error\u0026gt;{letargs=std::env::args();ifargs.len()\u0026gt;1{forsinargs.skip(1).take(1){concatenate(\u0026amp;mutstd::io::stdout(),\u0026amp;mutstd::io::BufReader::new(std::fs::File::open(s)?),)?;}}else{concatenate(\u0026amp;mutstd::io::stdout(),\u0026amp;mutstd::io::stdin())?;}Ok(())}std::io::Write と std::io::Read が trait 型なのだが，各 trait は総称型 W, R の制約条件として書かれているだけで実行時に機能するわけではない。 つまり最初の\nconcatenate(\u0026amp;mutstd::io::stdout(),\u0026amp;mutstd::io::BufReader::new(std::fs::File::open(s)?),)?;と次の\nconcatenate(\u0026amp;mutstd::io::stdout(),\u0026amp;mutstd::io::stdin())?;はコンパイル時に別の関数として展開される1。 これを（多態化（polymorphization）に対する）単態化（monomorphization）と呼ぶ。\nじゃあ Rust では依存の注入は書けないのかというと，勿論そんなことはない。\nCat コマンドもどき（Rust 版，依存注入編） 依存の注入ができるように書き換えたバージョンがこれ。\nfn concatenate(w: \u0026amp;mutBox\u0026lt;dynstd::io::Write\u0026gt;,r: \u0026amp;mutBox\u0026lt;dynstd::io::Read\u0026gt;,)-\u0026gt; Result\u0026lt;(),Box\u0026lt;dynstd::error::Error\u0026gt;\u0026gt;{letmutbuf=Vec::new();r.read_to_end(\u0026amp;mutbuf)?;w.write_all(\u0026amp;buf)?;Ok(())}fn main()-\u0026gt; Result\u0026lt;(),Box\u0026lt;dynstd::error::Error\u0026gt;\u0026gt;{letargs=std::env::args();letmutr: Box\u0026lt;dynstd::io::Read\u0026gt;=ifargs.len()\u0026gt;1{letfnam=matchargs.skip(1).next(){Some(s)=\u0026gt;s,_=\u0026gt;\u0026#34;\u0026#34;.to_string(),};Box::new(std::io::BufReader::new(std::fs::File::open(fnam)?))}else{Box::new(std::io::stdin())};letmutw: Box\u0026lt;dynstd::io::Write\u0026gt;=Box::new(std::io::stdout());concatenate(\u0026amp;mutw,\u0026amp;mutr)?;Ok(())}concatenate() 関数が同一のものであることを強調するために呼び出しをひとつに纏めているので少しまだるこしい書き方になっているが，ご容赦。 このように Rust では trait 型を Box\u0026lt;dyn Trait\u0026gt; の形式に落とし込むことで実行時の動的ディスパッチを可能にしている。\nAccept Interfaces, Return Structs Go の設計指針で有名な言葉に accept interfaces, return structs というのがある。 私自身は必ずしもこれに賛同しないが（システム内部のコンテキスト境界は interface にすべき），この指針は Go の特徴をよく表している。\nたとえば io.Reader と os.File は同じ Read() 関数を持つという点で関連しているけど，両者の間に明示された記述は存在しない。 それでも，その関係を以って io.Reader に os.File インスタンスを注入可能である。 Go プログラマは息をするように依存を注入するのだ。\nこのような関係を構造型の部分型付け（structural subtyping）と呼ぶそうな。\n構造型と公称型 Go の interface 型が構造型の部分型付けであるのに対し Rust の trait 型は公称型の部分型付け（nominal subtyping）に分類されるだろう。 たとえば std::io::Read と std::fs::File との間にはコード上で明示された関係がある。 その「明示された関係」がなければ，たとえ同じ構造を持っていたとしても，両者の間に関係があるとは見なされないのだ。\nRust の言語仕様がこのような制約を構成しているのには，勿論ちゃんとした理由がある。\nGo においてはメモリ管理や並列処理2 をランタイム・モジュールに「丸投げ」している。 なので，プログラマは富豪的な記述に専念できるが，バイナリは肥大化してしまうしコンパイル時の最適化にも限度がある3。\nRust はリソース管理等についてプログラマ側でかなり面倒を見なければならないが（それでも C/C++ などに比べれば全然楽だし安全），言い換えればコード上でのコントロールがし易くコンパイル時の最適化についてもかなり期待できる。 上述の cat コマンドもどきでも，コンパイル時の単態化を避けるコードをわざわざ書く理由はないだろう。\nこれはプログラム設計時の重要なトレードオフとなる。 まぁ「Go か Rust か」みたいな究極の選択をする状況はないと思うが，複数のプログラミング言語からどれかを選ぶ際にはこういったことも考慮していくべきだ（選ぶ余裕もない事案のほうが多いだろうけどw）。\n前にも書いたが，「それができる」ことと「そのように作られている」ことには天と地ほどの違いがある。 どうせ「書く」なら無茶せず楽しく書きたいものである。\nブックマーク   Rustでファイルの入出力 - Qiita\n  RustのファイルI/OにはBufReader, BufWriterを使いましょう、という話 - Qiita\n  Go言語のInterfaceの考え方、Accept interfaces,return structs - Qiita\n  継承できないなら注入すればいいじゃない！ : Go のイベント用に作ったスライド\n  参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n  Go言語による並行処理 Katherine Cox-Buday (著), 山口 能迪 (翻訳) オライリージャパン 2018-10-26 単行本（ソフトカバー） 4873118468 (ASIN), 9784873118468 (EAN), 4873118468 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版もある。感想はこちら。 Go 言語で並行処理を書くならこの本は必読書になるだろう。\nreviewed by Spiegel on 2020-01-13 (powered by PA-APIv5)\n   余談だが Rust では「ファイルを閉じる」操作は変数の生存期間満了時に暗黙的に行われるようだ。明示的に閉じるには drop 関数を使う。 \u0026#x21a9;\u0026#xfe0e;\n Go における並行処理と並列処理の違いについては『Go言語による並行処理』を読むことを強くおすすめする。 \u0026#x21a9;\u0026#xfe0e;\n 近年，特に組込み用途で注目されている TinyGo は LLVM 上で動作することを前提としていて，本家 Go に比べてかなり小さい実行バイナリを吐けるらしい。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "RSA-250 解読完了！",
      "section": "remark",
      "description": "実際には何万ものマシンを使って数ヶ月で解読したらしい。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/04/rsa-250-factored/",
      "published": "2020-04-09T01:45:03+00:00",
      "update": "2020-04-09T02:09:57+00:00",
      "content": "2月末の話で申し訳ないが（Bruce Schneier 先生の記事でさっき知ったのだ）， RSA-250 鍵が因数分解され解読完了したらしい。\n [Cado-nfs-discuss] Factorization of RSA-250 RSA-250 Factored - Schneier on Security  The total computation time was roughly 2700 core-years, using Intel Xeon Gold 6130 CPUs as a reference (2.1GHz):\nRSA-250 sieving: 2450 physical core-years RSA-250 matrix: 250 physical core-years  via Factorization of RSA-250  実際には何万ものマシンを使って数ヶ月で解読したらしい。\nThe computation involved tens of thousands of machines worldwide, and was completed in a few months. via RSA-250 Factored  RSA-240 が解けたのって，つい昨年末なんだけどねぇ（笑） RSA は近い将来，量子コンピュータの一般化を待たずにお払い箱になるんだろうね。\n参考図書  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n "
    },
    {
      "title": "Go 1.14.2 がリリースされた",
      "section": "release",
      "description": "セキュリティ・アップデートはなし，でいいかな。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/04/go-1_14_2-is-released/",
      "published": "2020-04-09T01:34:18+00:00",
      "update": "2020-04-09T01:36:29+00:00",
      "content": "Go 1.14.2 がリリースされた。\n Go 1.14.2 and Go 1.13.10 are released - Google group  セキュリティ・アップデートはなし，でいいかな。\ngo1.14.2 (released 2020/04/08) includes fixes to cgo, the go command, the runtime, os/exec, and testing packages. See the Go 1.14.2 milestone on our issue tracker for details. via Release History - The Go Programming Language  例によって Ubuntu の APT で管理している Go コンパイラは古いので，ダウンロードページからバイナリ（go1.14.2.linux-amd64.tar.gz）を取ってきて手動でインストールすることを強く推奨する。\n$ cd /usr/local/src $ sudo curl \u0026#34;https://dl.google.com/go/go1.14.2.linux-amd64.tar.gz\u0026#34; -O $ cd .. $ sudo unlink go # 以前の Go が入っている場合 $ sudo tar xvf src/go1.14.2.linux-amd64.tar.gz $ sudo mv go go1.14.2 $ sudo ln -s go1.14.2 go $ go version # /usr/local/go/bin にパスが通っている場合 go version go1.14.2 linux/amd64 アップデートは計画的に。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "Rust の型に関する覚え書き",
      "section": "rust-lang",
      "description": "思いつくまま脈絡なく随時更新予定。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/types/",
      "published": "2020-04-08T07:33:06+00:00",
      "update": "2020-04-09T07:33:39+00:00",
      "content": "この記事では Rust の型（type）に関することを思いつくまま脈絡なく書き記しておく。 随時更新予定。\n 組み込みデータ型 型エイリアス 構造体 列挙型 総称型  組み込みデータ型 組み込みデータ型には大きく分けてスカラ型と複合型がある。\nスカラ型 スカラ型はスカラ値を有する型である。 型によって値のサイズが決まっていて，受け渡しは copy semantics で行われる。\nスカラ型に分類される型は以下の通り。\n1. 整数型    サイズ 符号あり 符号なし 既定     8 bits i8 u8    16 bits i16 u16    32 bits i32 u32    64 bits i64 u64    — isize usize     isize/usize のサイズはアーキテクチャに依存する1。 また，リテラル表記時等での型推測の既定は i32 型となる2。\nletx=123;//type i32 ただしリテラル表記の後ろに型名を付けることで型を指定することが可能。\nletx=123i64;//type i64 もちろん変数に型注釈を付けて明示することも可能。\nletx: u8 =123;//type u8 2. 浮動小数点数型    サイズ 型名 既定     32 bits (仮数部 23 bits) f32    64 bits (仮数部 52 bits) f64     型の推定・評価は整数型と同じで，リテラル表記時等での型推測の既定は f64 型となる3。\nletx=1.23;//type f64 3. 文字型 文字型 char は Unicode 符号点を示す。 リテラル表記はこんな感じ。\nletc=\u0026#39;♡\u0026#39;;Rust における文字列と文字の関係については「Rust の文字列操作（1）」を参照のこと。\n4. 論理値型 論理値型 bool は true と false の2値のみ取り得る。\n複合型 複合型は複数の要素を組み合わせた型で，タプル型と配列型がある。\n複合型は定義毎に型と要素数が決まっている。 要素の型が全てスカラ型であれば copy semantics で値の受け渡しが可能。\n1. タプル型 タプル型は（名前の通り）複数の型を組み合わせた型で，こんな感じに記述できる。\nfn main(){lettup=(500,6.4,1u8);println!(\u0026#34;tup = {:?}\u0026#34;,tup);//Output: tup = (500, 6.4, 1) }2. 配列型 配列型は，単一の型で構成される複数要素の型で4，こんな感じに記述できる。\nfn main(){letary=[1,2,3];println!(\u0026#34;ary = {:?}\u0026#34;,ary);//Output: ary = [1, 2, 3] }型エイリアス 型の別名定義。 名前は変わっても機能は変わらない。 総称型と組み合わせると吉？\ntype Strings=Vec\u0026lt;String\u0026gt;;fn main(){letplanets: Strings=vec![\u0026#34;Mercury\u0026#34;.to_string(),\u0026#34;Venus\u0026#34;.to_string(),\u0026#34;Earth\u0026#34;.to_string(),\u0026#34;Mars\u0026#34;.to_string(),];planets.iter().for_each(|p|{println!(\u0026#34;{}\u0026#34;,p);});}構造体  0個以上のフィールド（型と名前）を含むデータ構造 構造体に紐づく関連関数およびメソッドを実装可能 トレイトからの実現（realization）が可能。構造体間の継承（inheritance）は不可  struct Planet{name: String,mass: f64,distance: f64,}構造体のインスタンス化 リテラル表現を使ったインスタンス化。\n#[derive(Debug)]struct Planet{name: String,mass: f64,distance: f64,}fn main(){letp=Planet{name: \u0026#34;Earth\u0026#34;.to_string(),mass: 1.0,distance: 1.0,};println!(\u0026#34;{:?}\u0026#34;,p);//Output: Planet { name: \u0026#34;Earth\u0026#34;, mass: 1.0, distance: 1.0 } }インスタンス化関数を実装してみる。\n#[derive(Debug)]struct Planet{name: String,mass: f64,distance: f64,}implPlanet{fn new(s: \u0026amp;str,mass: f64,distance: f64)-\u0026gt; Planet{Planet{name: s.to_string(),mass,distance,}}}fn main(){letp=Planet::new(\u0026#34;Earth\u0026#34;,1.0,1.0);println!(\u0026#34;{:?}\u0026#34;,p);//Output: Planet { name: \u0026#34;Earth\u0026#34;, mass: 1.0, distance: 1.0 } }構造体のコピー コピー用のメソッドを書いてみた。\nimplPlanet{fn copy(\u0026amp;self)-\u0026gt; Planet{Planet{name: self.name.clone(),..*self}}}あるいは derive 構文を使って Clone トレイトから clone() メソッドを自動生成する。\n#[derive(Debug, Clone)]struct Planet{name: String,mass: f64,distance: f64,}fn main(){letp=Planet::new(\u0026#34;Earth\u0026#34;,1.0,1.0);letcpy=p.clone();println!(\u0026#34;{:?}\u0026#34;,p);//Output: Planet { name: \u0026#34;Earth\u0026#34;, mass: 1.0, distance: 1.0 } println!(\u0026#34;{:?}\u0026#34;,cpy);//Output: Planet { name: \u0026#34;Earth\u0026#34;, mass: 1.0, distance: 1.0 } }なお String 等の Copy トレイトを実装できないフィールドを含む構造体は Copy トレイトを実装できないため，代入構文で値のコピーが発生しない。 この場合は move semantics により所有権が移動する。\nタプル構造体 構造体の特殊なパターンで，名前のないフィールドを定義する。 フィールドがタプルで定義される以外は通常の構造体と同じ。 関連関数およびメソッドも実装可能。\n#[derive(Debug, Copy, Clone)]struct Point(i64,i64);implPoint{fn new(x: i64,y: i64)-\u0026gt; Point{Point(x,y)}}fn main(){letp1=Point(1,2);letp2=Point::new(3,4);letp3=p1;//copy semantics println!(\u0026#34;{:?}\u0026#34;,p1);//Output: PPoint(1, 2) println!(\u0026#34;{:?}\u0026#34;,p2);//Output: PPoint(3, 4) println!(\u0026#34;{:?}\u0026#34;,p3);//Output: PPoint(1, 2) }列挙型 Rust の列挙型 enum はどちらかというと関数型プログラミング言語の影響を強く受けているらしい。\nenum VariantType{Int(i32),Float(f64),Text(String),}列挙型の評価には match 式を用いる。\nfn main(){letlist: Vec\u0026lt;VariantType\u0026gt;=vec![VariantType::Int(123),VariantType::Float(1.23),VariantType::Text(\u0026#34;hello\u0026#34;.to_string()),];list.iter().for_each(|e|{matche{VariantType::Int(v)=\u0026gt;println!(\u0026#34;{:#x}\u0026#34;,v),//Output: 0x7b VariantType::Float(v)=\u0026gt;println!(\u0026#34;{:e}\u0026#34;,v),//Output: 1.23e0 VariantType::Text(v)=\u0026gt;println!(\u0026#34;{:?}\u0026#34;,v),//Output: \u0026#34;hello\u0026#34; };});}列挙型も構造体と同じく関連関数やメソッドを実装できる。\nimplVariantType{fn is_integer(\u0026amp;self)-\u0026gt; bool {matchself{VariantType::Int(_)=\u0026gt;true,_=\u0026gt;false,//others }}}fn main(){letlist=vec![VariantType::Int(123),VariantType::Float(1.23),VariantType::Text(\u0026#34;hello\u0026#34;.to_string()),];list.iter().for_each(|e|{println!(\u0026#34;Is {:?} an integer?: {}\u0026#34;,e,e.is_integer());});}総称型 Rust ではオブジェクトの抽象化の手段として総称型をサポートしている。\n関数における総称型 以下の max() 関数で使われる型 T が総称型と呼ばれているもの。\nfn max\u0026lt;T: std::cmp::PartialOrd\u0026gt;(left: T,right: T)-\u0026gt; T{ifleft\u0026gt;=right{left}else{right}}fn main(){letx=1;lety=2;println!(\u0026#34;max({}, {}) = {}\u0026#34;,x,y,max(x,y));//Output: max(1, 2) = 2 }\u0026lt;T: std::cmp::PartialOrd\u0026gt; の表現は型 T の制約条件を示すもので std::cmp::PartialOrd トレイトを実装する型のみ max() 関数が有効になる。 このようなトレイトを使った制約の定義を「トレイト境界（trait bound）」と呼ぶらしい。\nトレイト境界は where 節を使って記述することもできる。\nfn max\u0026lt;T\u0026gt;(left: T,right: T)-\u0026gt; TwhereT: std::cmp::PartialOrd,{ifleft\u0026gt;=right{left}else{right}}トレイト境界の記述は煩雑になりがちなので，これで多少はスッキリするだろう。\nちなみに std::cmp::PartialOrd トレイトは \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;= の順序比較演算子を使うためのもので，少なくとも組み込みデータ型は全て std::cmp::PartialOrd トレイトを実装している。\nたとえば比較可能でない構造体\n#[derive(Debug)]struct Person{age: u32,name: String,}に max() 関数を使おうとしても\nfn max\u0026lt;\u0026#39;a,T: std::cmp::PartialOrd\u0026gt;(left: \u0026amp;\u0026#39;aT,right: \u0026amp;\u0026#39;aT)-\u0026gt; \u0026amp;\u0026#39;aT{ifleft\u0026gt;=right{left}else{right}}fn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};letp2=Person{age: 24,name: \u0026#34;Bob\u0026#34;.to_string(),};println!(\u0026#34;max({:?}, {:?}) = {:?}\u0026#34;,p1,p2,max(\u0026amp;p1,\u0026amp;p2));//Error: can\u0026#39;t compare `Person` with `Person` }コンパイルエラーになる。\n構造体における総称型 構造体のフィールドやメソッドも総称型で記述することができる。\nstruct Point\u0026lt;T\u0026gt;{x: T,y: T,}impl\u0026lt;T\u0026gt;Point\u0026lt;T\u0026gt;{fn new(x: T,y: T)-\u0026gt; Self{Self{x,y}}}impl\u0026lt;T: std::ops::Add\u0026lt;Output=T\u0026gt;+Copy\u0026gt;Point\u0026lt;T\u0026gt;{fn add(\u0026amp;self,p: \u0026amp;Self)-\u0026gt; Self{Self::new(self.x+p.x,self.y+p.y)}}impl\u0026lt;T: std::fmt::Display\u0026gt;std::fmt::DisplayforPoint\u0026lt;T\u0026gt;{fn fmt(\u0026amp;self,dest: \u0026amp;mutstd::fmt::Formatter)-\u0026gt; std::fmt::Result{write!(dest,\u0026#34;\u0026lt;{}, {}\u0026gt;\u0026#34;,self.x,self.y)}}fn main(){letp1=Point::new(1,2);letp2=Point::new(3,4);println!(\u0026#34;{} + {} = {}\u0026#34;,p1,p2,p1.add(\u0026amp;p2));//Output: \u0026lt;1, 2\u0026gt; }上述のように impl 構文毎に個別にトレイト境界を設定できる。\n列挙型における総称型 列挙型も構造体と同じように総称型が使える。 列挙型と総称型の組み合わせでもっとも有名なのが Result 型だろう。\nenum Result\u0026lt;T,E\u0026gt;{Ok(T),Err(E),}参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n  プログラミングRust Jim Blandy (著), Jason Orendorff (著), 中田 秀基 (翻訳) オライリージャパン 2018-08-10 単行本（ソフトカバー） 4873118557 (ASIN), 9784873118550 (EAN), 4873118557 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版あり。公式ドキュメントよりも系統的に書かれているので痒いところに手が届く感じ。ただし量が多いので，一度斜め読みしたらあとは傍らに置いて必要に応じてつまみ食いしていくのがいいだろう。\nreviewed by Spiegel on 2020-03-08 (powered by PA-APIv5)\n   isize/usize は C 言語等でいう int と同じと思って構わない。まぁ，どちらかと言うと size_t みたいな感じかもしれないけど。 \u0026#x21a9;\u0026#xfe0e;\n 現在のアーキテクチャの主流が 64 bits にも関わらず整数型の既定が i32 なのは， 32 bits アクセスのほうが「速い」かららしい。 \u0026#x21a9;\u0026#xfe0e;\n 浮動小数点数型の場合，単精度（f32）と倍精度（f64）の間でパフォーマンス上の違いは殆どないそうだ。それならサイズが大きい方を既定にすればいいよね，ってことらしい。 \u0026#x21a9;\u0026#xfe0e;\n 配列型でも列挙型（enum）と組み合わせることで複数の型に対応させることは可能。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "関数閉包で遊ぶ",
      "section": "rust-lang",
      "description": "関数閉包の記述では fn 構文は使えない。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/closure-and-currying/",
      "published": "2020-04-07T09:55:33+00:00",
      "update": "2020-04-08T07:33:29+00:00",
      "content": "今回は小ネタとして関数閉包（closure）で遊んでみる。 起点となるコードはこれにしよう。\nfn add(x: i32,y: i32)-\u0026gt; i32 {x+y}fn main(){letx=1;lety=2;println!(\u0026#34;{} + {} = {}\u0026#34;,x,y,add(x,y));//Output: 1 + 2 = 3 }add() 関数は見ての通り整数の足し算。 この関数を関数閉包で表してみたい。\n関数閉包で記述する 関数閉包の記述では fn 構文は使えない。 こんな感じに書く。\nfn main(){letadd=|x,y|{x+y};letx=1;lety=2;println!(\u0026#34;{} + {} = {}\u0026#34;,x,y,add(x,y));//Output: 1 + 2 = 3 }|...| で囲まれている部分で引数を定義し {...} で囲まれている部分が関数本体になる。 ちなみに，上のような記述であれば波括弧は省略できる。 ていうか rustfmt コマンドで整形すると問答無用で消される（笑）\nletadd=|x,y|x+y;引数や返り値の型は推論可能であれば省略できるが，型注釈で明示することもできる。\nletadd=|x: i32,y: i32|-\u0026gt; i32 {x+y};この関数閉包をもう少し弄ってみよう。\nスマートポインタ 関数閉包はスマートポインタを表すトレイト Box\u0026lt;T\u0026gt; で囲むことができる。\nfn main(){letadd=Box::new(|x,y|x+y);letx=1;lety=2;println!(\u0026#34;{} + {} = {}\u0026#34;,x,y,add(x,y));//Output: 1 + 2 = 3 }敢えて add に型注釈を付けるとこんな感じになる。\nletadd: Box\u0026lt;dynFn(i32,i32)-\u0026gt; i32\u0026gt;=Box::new(|x,y|x+y);ちなみに Fn は関数閉包を表すトレイトである。\nこれだけでは何も面白くないが，実は「高階関数（higher-order function）」で威力を発揮する。 高階関数の定番といえばアレだよね。 そう「カリー化（currying）」である1。\nカリー化と所有権 では早速 add() 関数をカリー化してみよう。 こんな感じ。\nfn add(x: i32)-\u0026gt; Box\u0026lt;dynFn(i32)-\u0026gt; i32\u0026gt;{Box::new(move|y|x+y)}fn main(){letx=1;lety=2;println!(\u0026#34;{} + {} = {}\u0026#34;,x,y,add(x)(y));//Output: 1 + 2 = 3 letincrement=add(x);//partial application println!(\u0026#34;add({}) -\u0026gt; increment({}) = {}\u0026#34;,x,y,increment(y));//Output: add(1) -\u0026gt; increment(2) = 3 }move キーワードを使って関数閉包内の変数 x の所有権を明示的に移動してる点に注意。 move を付けないと借用とみなされるが add() 関数を抜けるとスコープから外れるためコンパイルエラーになる。\nちなみに関数等のスコープ内であれば，もっと簡単に記述できる。 こんな感じ。\nfn main(){letadd=|x|move|y|x+y;letx=1;lety=2;println!(\u0026#34;{} + {} = {}\u0026#34;,x,y,add(x)(y));//Output: 1 + 2 = 3 letincrement=add(x);//partial application println!(\u0026#34;add({}) -\u0026gt; increment({}) = {}\u0026#34;,x,y,increment(y));//Output: add(1) -\u0026gt; increment(2) = 3 }よーし，うむうむ，よーし。\n参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n  プログラミングRust Jim Blandy (著), Jason Orendorff (著), 中田 秀基 (翻訳) オライリージャパン 2018-08-10 単行本（ソフトカバー） 4873118557 (ASIN), 9784873118550 (EAN), 4873118557 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版あり。公式ドキュメントよりも系統的に書かれているので痒いところに手が届く感じ。ただし量が多いので，一度斜め読みしたらあとは傍らに置いて必要に応じてつまみ食いしていくのがいいだろう。\nreviewed by Spiegel on 2020-03-08 (powered by PA-APIv5)\n   カリー化については拙文「カリー化に関する覚え書き」を参考にどうぞ。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "エラー・ハンドリングのキホン",
      "section": "rust-lang",
      "description": "やっぱ例外処理は要らんよね（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/error-handling/",
      "published": "2020-04-06T12:11:43+00:00",
      "update": "2020-04-09T07:27:39+00:00",
      "content": "今日の起点となるコードはこれにしよう。\nfn parse_string(s: \u0026amp;str)-\u0026gt; Result\u0026lt;u32,std::num::ParseIntError\u0026gt;{s.parse::\u0026lt;u32\u0026gt;()}fn main(){println!(\u0026#34;{:?}\u0026#34;,parse_string(\u0026#34;-1\u0026#34;));//Output: Err(ParseIntError { kind: InvalidDigit }) }parse_string() 関数の返り値の型 Result は列挙型 enum で1，以下の2つの列挙子（variant）で構成されている。\nenum Result\u0026lt;T,E\u0026gt;{Ok(T),Err(E),}Result など列挙型の評価には match 式を使う。 たとえば parse() に失敗した際に 0 をセットしたいなら\nfn main(){letn=matchparse_string(\u0026#34;-1\u0026#34;){Ok(x)=\u0026gt;x,Err(_)=\u0026gt;0,};println!(\u0026#34;{}\u0026#34;,n);//Output: 0 }などと書くことができる。\nResult 型を使ったエラー・ハンドリング このように Result 型を使うことで基本的なエラー・ハンドリングが可能になる。 いくつか例を挙げていこう。\nPanic を投げる parse_string() 関数が Err を返した場合に強制終了したいのであれば\nfn main(){letn=matchparse_string(\u0026#34;-1\u0026#34;){Ok(x)=\u0026gt;x,Err(e)=\u0026gt;panic!(e),//Output: thread \u0026#39;main\u0026#39; panicked at \u0026#39;Box\u0026lt;Any\u0026gt;\u0026#39;, src/main.rs:8:19 };println!(\u0026#34;{}\u0026#34;,n);//do not reach }と panic! マクロで panic を投げればよい。 ちなみに，環境変数 RUST_BACKTRACE に 1 をセットすると panic 時にスタックトレース情報も吐く。\n単に panic を投げればいいのであれば Result::unwrap() メソッドを使えば上述のコードとほぼ同じ結果が得られる。\nfn main(){letn=parse_string(\u0026#34;-1\u0026#34;).unwrap();//Output: thread \u0026#39;main\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }\u0026#39;, src/main.rs:6:13 println!(\u0026#34;{}\u0026#34;,n);//do not reach }Panic を投げる際のメッセージを指定するには Result::expect() メソッドを使う。\nfn main(){letn=parse_string(\u0026#34;-1\u0026#34;).expect(\u0026#34;error in parse_string() function\u0026#34;);//Output: thread \u0026#39;main\u0026#39; panicked at \u0026#39;error in parse_string() function: ParseIntError { kind: InvalidDigit }\u0026#39;, src/main.rs:6:13 println!(\u0026#34;{}\u0026#34;,n);//do not reach }Panic 以外のハンドリング エラー時に単に panic を投げるのではなく，何らかの処理を行って普通にプロセスを終了したいのであれば Result::unwrap_or_else() メソッドを使って\nfn main(){letn=parse_string(\u0026#34;-1\u0026#34;).unwrap_or_else(|e|{println!(\u0026#34;Error in parse_string() function: {:?}\u0026#34;,e);//Output: Error in parse_string() function: ParseIntError { kind: InvalidDigit } std::process::exit(1);});println!(\u0026#34;{}\u0026#34;,n);//do not reach }などとすることもできる。 プロセスを終了するのではなく，最初の例のように解析失敗時に 0 をセットしたいなら\nfn main(){letn=parse_string(\u0026#34;-1\u0026#34;).unwrap_or_else(|_|0);println!(\u0026#34;{}\u0026#34;,n);//Output: 0 }てな感じにも書ける。 あるいはもっと簡単に Result::unwrap_or() メソッドを使って\nfn main(){letn=parse_string(\u0026#34;-1\u0026#34;).unwrap_or(0);println!(\u0026#34;{}\u0026#34;,n);//Output: 0 }とも書ける。\nエラーの委譲 次に以下の関数を考える。 2つの数文字列を与えて組（tuple）にして返す。\nfn parse_pair_strings(s1: \u0026amp;str,s2: \u0026amp;str)-\u0026gt; Result\u0026lt;(u32,u32),std::num::ParseIntError\u0026gt;{letx=matchs1.parse::\u0026lt;u32\u0026gt;(){Ok(n)=\u0026gt;n,Err(e)=\u0026gt;returnErr(e),};lety=matchs2.parse::\u0026lt;u32\u0026gt;(){Ok(n)=\u0026gt;n,Err(e)=\u0026gt;returnErr(e),};Ok((x,y))}fn main(){println!(\u0026#34;{:?}\u0026#34;,parse_pair_strings(\u0026#34;1\u0026#34;,\u0026#34;-1\u0026#34;));//Output: Err(ParseIntError { kind: InvalidDigit }) }parse_pair_strings() の仮引数 s1 および s2 に対してそれぞれ parse() を行うのだが，返り値が Err の際にはエラーをそのまま返して呼び出し元にハンドリングを委譲している。\n返り値の型が同じ Result なら ? 演算子を使ってエラーの委譲をもっと簡単に書くことができる。 こんな感じ。\nfn parse_pair_strings(s1: \u0026amp;str,s2: \u0026amp;str)-\u0026gt; Result\u0026lt;(u32,u32),std::num::ParseIntError\u0026gt;{Ok((s1.parse::\u0026lt;u32\u0026gt;()?,s2.parse::\u0026lt;u32\u0026gt;()?))}すっきりー！\nエラーの汎化 今度は，引数に文字列を渡すのではなく，標準入力から文字列を取得して parse() してみよう。\nfn parse_from_stdin()-\u0026gt; Result\u0026lt;u32,std::num::ParseIntError\u0026gt;{letmutbuf=String::new();std::io::stdin().read_line(\u0026amp;mutbuf)?;//Compile error: `?` couldn\u0026#39;t convert the error to `std::num::ParseIntError` buf.trim().parse::\u0026lt;u32\u0026gt;()}当然ながらこれはコンパイルエラーになる。 何故なら read_line() 関数では Err の値が std::io::Error 型になるので std::num::ParseIntError 型とはマッチしないためだ。\nこれを解決するには std::error::Error 型を汎化型として使えばよい。\n std::error::Error 型を使う際は Box\u0026lt;dyn Trait\u0026gt; にするようだ。 こんな感じ。\nfn parse_from_stdin()-\u0026gt; Result\u0026lt;u32,Box\u0026lt;dynstd::error::Error\u0026gt;\u0026gt;{letmutbuf=String::new();std::io::stdin().read_line(\u0026amp;mutbuf)?;letn=buf.trim().parse::\u0026lt;u32\u0026gt;()?;Ok(n)}fn main(){println!(\u0026#34;{:?}\u0026#34;,parse_from_stdin());}実行するとこんな感じになる。\n$ echo -1 | cargo run Err(ParseIntError { kind: InvalidDigit }) main() 関数側でもう少し細かくエラーを見てみよう。 こんな感じかなぁ。\nfn main(){letn=matchparse_from_stdin(){Ok(x)=\u0026gt;x,Err(err)=\u0026gt;{matcherr.downcast_ref::\u0026lt;std::io::Error\u0026gt;(){Some(e)=\u0026gt;{println!(\u0026#34;io::Error in parse_from_stdin(): {}\u0026#34;,e);std::process::exit(1);}_=\u0026gt;(),};matcherr.downcast_ref::\u0026lt;std::num::ParseIntError\u0026gt;(){Some(e)=\u0026gt;{println!(\u0026#34;ParseIntError in parse_from_stdin(): {}\u0026#34;,e);std::process::exit(1);}_=\u0026gt;(),};println!(\u0026#34;Other error in parse_from_stdin(): {}\u0026#34;,err);std::process::exit(1);}};println!(\u0026#34;{}\u0026#34;,n);}こうすれば Box\u0026lt;dyn std::error::Error\u0026gt; 型からもとのエラー型を抽出して個別に処理できそう。 これを実行するとこんな感じ。\n$ echo -1 | cargo run ParseIntError in parse_from_stdin(): invalid digit found in string んー。 かなり面倒くさいな。 もう少しマシな戦略を探すべきか。\nOption 型を使ったエラー・ハンドリング 上述のコードにある downcast_ref() メソッドは Option 型の値を返す。 Option 型も列挙型で，以下の2つの列挙子で構成されている。\nenum Option\u0026lt;T\u0026gt;{Some(T),None,}None はいわゆる Null 値，つまり値がないことを示す。 関数の実行結果が Null 値を取り得る場合に Option 型を返すことで，呼び出し元に Null 値のハンドリングを促すことができる。\n起点のコードはこんな感じでどうだろうか。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;foriin0..4{println!(\u0026#34;{}: {:?}\u0026#34;,i,nihongo.chars().nth(i));}}実行するとこんな感じになる。\n$ cargo run 0: Some(\u0026#39;日\u0026#39;) 1: Some(\u0026#39;本\u0026#39;) 2: Some(\u0026#39;語\u0026#39;) 3: None Panic を投げる 結果が None なら panic を投げるようにしてみる。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;foriin0..4{letch=matchnihongo.chars().nth(i){Some(c)=\u0026gt;c,None=\u0026gt;panic!(\u0026#34;Out of bounds\u0026#34;),};println!(\u0026#34;{}: {}\u0026#34;,i,ch)}}実行するとこんな感じ。\n$ cargo run 0: 日 1: 本 2: 語 thread \u0026#39;main\u0026#39; panicked at \u0026#39;Out of bounds\u0026#39;, src/main.rs:6:21 また Option 型にも unwrap() や expect() といったメソッドがあり， None が返ったら panic を投げる。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;foriin0..4{println!(\u0026#34;{}: {}\u0026#34;,i,nihongo.chars().nth(i).expect(\u0026#34;Out of bounds\u0026#34;));}}$ cargo run 0: 日 1: 本 2: 語 thread \u0026#39;main\u0026#39; panicked at \u0026#39;Out of bounds\u0026#39;, src/main.rs:4:31 Panic 以外のハンドリング たとえば，こんな感じかな。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;foriin0..4{letch=matchnihongo.chars().nth(i){Some(c)=\u0026gt;c,None=\u0026gt;break,};println!(\u0026#34;{}: {}\u0026#34;,i,ch)}}$ cargo run 0: 日 1: 本 2: 語 まぁイテレータやコレクションでこんな書き方する人はおらんじゃろうけど。 あンまりいい例示じゃなくてすまん。\nやっぱ例外処理は要らんよね Rust の列挙型は（C/C++ や Java などと異なり）型の列挙を行い，パターン・マッチングによって処理を振り分ける。 この仕組みを上手く使ってエラー・ハンドリングを行っているわけだ。\nこうやってみると，やっぱ例外処理は要らんよね（笑）\nブックマーク  Rustのエラーハンドリングの基本 - hideoka’s blog Rust のエラーまわりの変遷 - Qiita Rustで複数のimpl Traitを返す - Qiita  参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n  プログラミングRust Jim Blandy (著), Jason Orendorff (著), 中田 秀基 (翻訳) オライリージャパン 2018-08-10 単行本（ソフトカバー） 4873118557 (ASIN), 9784873118550 (EAN), 4873118557 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版あり。公式ドキュメントよりも系統的に書かれているので痒いところに手が届く感じ。ただし量が多いので，一度斜め読みしたらあとは傍らに置いて必要に応じてつまみ食いしていくのがいいだろう。\nreviewed by Spiegel on 2020-03-08 (powered by PA-APIv5)\n   列挙型については「Rust の型に関する覚え書き」を参照のこと。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2020-04-05 のブックマーク",
      "section": "bookmarks",
      "description": "「Zoom の脆弱性対策について」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2020/04/05-bookmarks/",
      "published": "2020-04-05T04:38:24+00:00",
      "update": "2020-04-05T04:39:50+00:00",
      "content": "リリース情報  Minify config and more! | Hugo  Hugo 0.68.1: 1 bug fix | Hugo Hugo 0.68.2: A couple of Bug Fixes | Hugo Hugo 0.68.3: A couple of Bug Fixes | Hugo   LibreOffice 6.4.2 available for download - The Document Foundation Blog  セキュリティ＆プライバシー関連  Facial Recognition for People Wearing Masks - Schneier on Security 差し込むとマルウェア感染するUSBデバイスが届いた事例についてまとめてみた - piyolog Privacy vs. Surveillance in the Age of COVID-19 - Schneier on Security Phishing Alert: GitHub Website Spoofing | Perception Point IEの脆弱性 (CVE-2020-0674) とFirefoxの脆弱性 (CVE-2019-17026) を悪用する攻撃 - JPCERT/CC Eyes | JPCERTコーディネーションセンター公式ブログ Marriott Was Hacked \u0026ndash; Again - Schneier on Security Zoom の脆弱性対策について：IPA 独立行政法人 情報処理推進機構  Security and Privacy Implications of Zoom - Schneier on Security Zoom爆撃と予防策についてまとめてみた - piyolog 問題が相次いで発覚した「Zoom」でヴィデオ会議を開く際に、まずユーザーが考えるべきこと｜WIRED.jp    天文関連  星形成プロジェクト：近傍星形成領域の電波地図作り ニュース - 連星系で作られる惑星の軌道の謎に迫る - アルマ望遠鏡 「ハッブル宇宙望遠鏡」運用30周年記念プラモセットが登場 - sorae 宇宙へのポータルサイト  知財関連  DMCA削除通知によりオープンソースソフトウェアのKodiがGoogle検索から排除される | P2Pとかその辺のお話R  Linux または Ubuntu に関する話題  Ubuntu 20.04 その19 - Raspberry Piのサポート改善・Canonicalの新しい取り組み - kledgeb  その他  専門家会議の「クラスター対策」の解説　――新型コロナウイルスに対処する最後の希望｜吉峯 耕平｜note Mozilla、「Firefox 74」のTLS 1.0/1.1廃止を一時撤回 ～新型コロナウイルスの影響で - 窓の杜 アトラシアン、JiraやConfluenceなど期限なく無料提供開始。10名以下のチームに － Publickey GitHub - remeh/diago: Diago is a visualization tool for CPU profiles and heap snapshots generated with pprof. さくらのレンタルサーバ／マネージドサーバ PHP7.4提供開始 | さくらインターネット Section一覧について。 - 日本語 - HUGO コロナ危機でネタニヤフが延命　イスラエルで挙国一致内閣が成立の見通し：池内恵 | 池内恵の中東通信 | 新潮社　Foresight(フォーサイト) | 会員制国際情報サイト Dr. Lucie Guibault on What Scientists Should Know About Open Access - Creative Commons Hugo.386 | Hugo Themes ブンゴウサーチ by ブンゴウメール | 青空文庫の作品を読了時間で検索できるサービス How Google Ruined the Internet — Superhighway 98  ブログ: Googleは如何にインターネットを台無しにしたか   Visual Studio Codeの代替を狙う統合開発環境「Eclipse Theia 1.0」リリース。VS Codeの拡張機能を利用可能、デスクトップ版とWebブラウザ版に両対応 － Publickey AWS Systems Manager経由でssh不使用のOSリモートアクセスを試す - Qiita  "
    },
    {
      "title": "「はめふら」観るために Hulu 解約してしまった...",
      "section": "remark",
      "description": "この機会に Hulu から Netflix に乗り換えることにした。 両方課金し続ける財力はないからね。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/04/netflix/",
      "published": "2020-04-05T03:19:05+00:00",
      "update": "2020-04-05T03:19:44+00:00",
      "content": "いやー。 ついに始まりましたねぇ。\n TVアニメ『乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった…』公式サイト  ちなみに私の推しはメイドのアンです。\n公式サイトによると Netflix か d アニメストアならタイムラグなしで見れるらしい。 まぁ d アニメストアでの課金は論外だが Prime Video なら週遅れで見れるのかな？ Hulu では見れないっぽい。\n私は以前から Hulu を利用してたんだけど，なんか見れないアニメ番組が増えてきたんだよねぇ。 配信終了してしまったコンテンツも多いし。 これはそろそろ潮時かなぁ。\nちうわけで，この機会に Hulu から Netflix に乗り換えることにした。 両方課金し続ける財力はないからね（苦笑）\n 乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった… | Netflix  よーし，うむうむ，よーし。\nまぁ，週遅れの配信とかバカげてるよねぇ。 テレビ放送こそ週遅れでいいぢゃん（笑）\n参考図書  乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった…: 1 (一迅社文庫アイリス) 山口 悟 (著), ひだか なみ (イラスト) 一迅社 2015-08-20 (Release 2015-09-11) Kindle版 B014VZ4FLE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  今やテンプレな乙女ゲーム転生ものでコメディ寄りのラブコメ。つか，読んでて吹き出してしまった（笑）\nreviewed by Spiegel on 2020-04-05 (powered by PA-APIv5)\n  乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった…: 1【イラスト特典付】 (ZERO-SUMコミックス) ひだか なみ (著), 山口 悟 (著) 一迅社 2018-03-24 (Release 2018-03-24) Kindle版 B07BKT4RX5 (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  書籍版の絵師さんによるコミカライズ。流石に原作にマッチしていて面白い！\nreviewed by Spiegel on 2020-04-05 (powered by PA-APIv5)\n "
    },
    {
      "title": "天下無敵のプー太郎",
      "section": "remark",
      "description": "次の仕事が得られるまでどのくらい時間がかかるか分からないが，あり余る時間を趣味に没頭していく所存である。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/04/i-am-a-neet/",
      "published": "2020-04-01T12:59:18+00:00",
      "update": "2020-04-01T22:55:17+00:00",
      "content": "悪夢の4月1日 (エイプリルフール) を今年も無事やり過ごせたようなので，通常運転を再開しよう。\nWHO の situation report を見る限り，世界レベルではようやく峠を超えた感じだけど日本は今が正念場だよね（まぁ第3第4のピークが来ないとも限らないが）。\n私個人は3月いっぱいで目出度く職場をクビになったので，しばらく NEET (Not in Employment, Education or Training) でもしようかなぁ，という感じ。 せっかく自粛ムードだし，私は「人に会わない」ことに全くストレスを感じないので（むしろ実家で家族と顔をつきあわせる生活を1年以上続けられている自分を褒めたい），不謹慎ながら今の状況は大歓迎である。\n“The trade-offs are changing” SARS 2 関連について思うところは沢山あるし愚痴を書いたらキリがないが1，今回は以下の記事を紹介するに留める。\n EFF and COVID-19: Protecting Openness, Security, and Civil Liberties | Electronic Frontier Foundation As Coronavirus Surveillance Escalates, Personal Privacy Plummets - The New York Times Privacy vs. Surveillance in the Age of COVID-19 - Schneier on Security  例によって Bruce Schneier 先生の要約記事が分かりやすいので，そちらを参考にするが EFF の\nWe must be sure that measures taken in the name of responding to COVID-19 are, in the language of international human rights law, “necessary and proportionate” to the needs of society in fighting the virus. Above all, we must make sure that these measures end and that the data collected for these purposes is not re-purposed for either governmental or commercial ends. via Protecting Openness, Security, and Civil Liberties  という一文には激しく同意するものである。 ついでに以下の tweet も挙げておくか。\nかつてThe Economistは、「テロ対策と称して国家統制を許し、自由を捨てるな。テロで人が死ぬ。それがどうした」と言い放つ強さを持っていたけれど、いまコロナを前にして「国家統制を認めて自由を捨てるな。コロナで人が死ぬ。それがどうした」と言うだけの勇気はないらしい。でもそう言うべきだ。\n\u0026mdash; Hiroo Yamagata (@hiyori13) March 20, 2020  現代の人々にとって「健康」とは呪 (のろ) いのようなものかもしれない。\nリスク評価には「科学的リスク」と「政治的リスク」がある。 「政治的リスク」で重要なのは「その後」についてきちんと目配せできているかどうかである。 いくら危機的状況であっても「その後」に配慮しないその場しのぎの政策執行は悪手だ。\n リスクは事前と事後をセットで考える  そういう観点で是非とも議論していただきたいものである。 まぁ，私は（そういうのに巻き込まれたくないので）今年も政治的無関心を貫くけどね。 政治がどうこう言うような精神的余裕はない。\nそろそろ本格的に\u0026hellip; せっかく時間があり余ってるので，色々遊んでみたい。 プログラミング関連では\n Go Rust Haskell  の優先順位で 勉強 もとい遊んでみようかな，と。\nGo と Rust は同じ制御系言語なのに思想が真逆で実に面白い。\nGo は典型的な手続き型言語で並列処理やメモリ管理を隠蔽することでシンプルな記述を可能にしている。 Rust は並列処理やメモリ管理については剥き出しだが，その分（標準ライブラリを含めて）豊かな語彙を持っている。\nあと Rust を勉強し始めて痛感したが，やっぱ関数型プログラミング言語についてきちんと学ばないとダメだわ。 そういう意味で Haskell をもう一度勉強し直そうかと思っている。\n次の仕事が得られるまでどのくらい時間がかかるか分からないが，あり余る時間を趣味に没頭していく所存である（笑）\nブックマーク  クーリエ連載；エコノミスト紹介、自由のためなら人が死んでもいい（この中で紹介されている「自由の本当のコスト」の原文） 専門家会議の「クラスター対策」の解説　――新型コロナウイルスに対処する最後の希望｜吉峯 耕平｜note ある医師がエンジニアに寄せた“コロナにまつわる現場の本音” (1/10) - EE Times Japan    詳しくは Facebook の私の記述を参考にどうぞ。「友人」以外は読めないようにしてるけど（笑） \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "CommonMark と Hugo 0.68",
      "section": "remark",
      "description": "てっきり yuin/goldmark パーサのバグだと思っていたのだが，どうやら CommonMark の仕様らしい。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/03/commonmark-and-hugo/",
      "published": "2020-03-29T06:04:41+00:00",
      "update": "2020-03-29T09:05:07+00:00",
      "content": "先日 Hugo 0.68.x がリリースされたのだが\n Minify config and more! | Hugo Hugo 0.68.1: 1 bug fix | Hugo Hugo 0.68.2: A couple of Bug Fixes | Hugo Hugo 0.68.3: A couple of Bug Fixes | Hugo  どうもまた markdown 周りの挙動が変わったようだ。 例えば\n[string] を [][rune] に変換する。 [string]: http://golang.org/ref/spec#String_types [rune]: http://blog.golang.org/strings \u0026#34;Strings, bytes, runes and characters in Go - The Go Blog\u0026#34; をレンダリングすると\n\u0026lt;a href=\u0026#34;http://golang.org/ref/spec#String_types\u0026#34;\u0026gt;string\u0026lt;/a\u0026gt; を \u0026lt;a href=\u0026#34;http://blog.golang.org/strings\u0026#34; title=\u0026#34;Strings, bytes, runes and characters in Go - The Go Blog\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; に変換する。   string を  に変換する。  てな感じに [] 記述がまるっと抜け落ちて \u0026lt;a\u0026gt; 要素の中身も空になってしまう。 てっきり yuin/goldmark パーサのバグだと思っていたのだが，どうやらこれは CommonMark の仕様のようだ。\n具体的には\n[foo][bar] [bar]: http://bar と記述すると\n\u0026lt;a href=\u0026#34;http://bar\u0026#34;\u0026gt;foo\u0026lt;/a\u0026gt; のように [bar] で生成される \u0026lt;a\u0026gt; 要素の中身を foo に置き換えるらしい。 じゃあ今までがバグだったってこと？\nこれを回避するには\n\\[foo][bar]  [bar]: http://bar とエスケープすれば\n[foo]\u0026lt;a href=\u0026#34;http://bar\u0026#34;\u0026gt;bar\u0026lt;/a\u0026gt;   [foo]bar  と意図通りにレンダリングしてくれる。 なので最初の記述も\n[string] を \\[][rune] に変換する。  [string]: http://golang.org/ref/spec#String_types [rune]: http://blog.golang.org/strings \u0026#34;Strings, bytes, runes and characters in Go - The Go Blog\u0026#34; とすれば\n\u0026lt;a href=\u0026#34;http://golang.org/ref/spec#String_types\u0026#34;\u0026gt;string\u0026lt;/a\u0026gt; を []\u0026lt;a href=\u0026#34;http://blog.golang.org/strings\u0026#34; title=\u0026#34;Strings, bytes, runes and characters in Go - The Go Blog\u0026#34;\u0026gt;rune\u0026lt;/a\u0026gt; に変換する。   string を []rune に変換する。  とできた。\n私のブログでは影響が出たのが（結果的には）一箇所のみだったので直すのは簡単だったが，特に Go 言語では [] はスライスを意味する記述なので，今後は気をつけないとなぁ。 まぁ \u0026lt;code\u0026gt; 要素（`...`）で囲むのが無難か。\n改めて CommonMark の仕様を眺めてみたが，不可思議な記述が沢山ある。 たとえば\n[bar][] [bar]: http://bar と書くと\n\u0026lt;a href=\u0026#34;http://bar\u0026#34;\u0026gt;bar\u0026lt;/a\u0026gt; てな感じに，これまた [] が吸い込まれる。 しかも\n[bar][foo] [bar]: http://bar とすると，今度は \u0026lt;a\u0026gt; 要素が外れてただの\n[bar][foo] となる。 なんだよそれ orz\n雑すぎんだろ！ 一度ちゃんと文法を整理したほうがいいんじゃないのか？\n"
    }
  ]
}
