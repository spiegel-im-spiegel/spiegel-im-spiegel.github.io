{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "Writers パッケージを作ってみた",
      "section": "golang",
      "description": "言語的に面白いトピックはないし，手遊びということで。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/writers-package/",
      "published": "2020-03-28T11:40:05+00:00",
      "update": "2020-03-28T11:52:58+00:00",
      "content": "Twitter で\nできればLogレベルでファイル分割したいところですが、Goの情報はなかなか見つからなかった...。\nTrace/Debug/Info/Warning\nError/Fatal\nとかいう好きな単位でログファイルを切り替えられれば、別ツイのtail -f時のノイズ削減になりそう。https://t.co/MTyoOqyvgQ\n(分割について記載なすび)\n\u0026mdash; SIG (@sig_246) March 26, 2020  というのを見かけたので，試しに作ってみた。\n spiegel-im-spiegel/writers: Writer Collection  いや tee および grep コマンドを組み合わせれば出力の分割はできるんだけどね1。 まぁ，言語的に面白いトピックはないし，手遊びということで。\nたとえば，拙作の logf パッケージを使ってこんなログ出力を考えてみる。\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/logf\u0026#34; ) func main() { logf.SetOutput(os.Stdout) for i := 0; i \u0026lt; 6; i++ { logf.SetMinLevel(logf.TRACE + logf.Level(i)) logf.Tracef(\u0026#34;Traceing: No. %d\\n\u0026#34;, i+1) logf.Debugf(\u0026#34;Debugging: No. %d\\n\u0026#34;, i+1) logf.Printf(\u0026#34;Information: No. %d\\n\u0026#34;, i+1) logf.Warnf(\u0026#34;Warning: No. %d\\n\u0026#34;, i+1) logf.Errorf(\u0026#34;Erroring: No. %d\\n\u0026#34;, i+1) logf.Fatalf(\u0026#34;Fatal Erroring: No. %d\\n\u0026#34;, i+1) } } これを実行すると，こんな感じになる。\n$ go run sample.go 2020/03/28 14:44:44 [TRACE] Traceing: No. 1 2020/03/28 14:44:44 [DEBUG] Debugging: No. 1 2020/03/28 14:44:44 [INFO] Information: No. 1 2020/03/28 14:44:44 [WARN] Warning: No. 1 2020/03/28 14:44:44 [ERROR] Erroring: No. 1 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 1 2020/03/28 14:44:44 [DEBUG] Debugging: No. 2 2020/03/28 14:44:44 [INFO] Information: No. 2 2020/03/28 14:44:44 [WARN] Warning: No. 2 2020/03/28 14:44:44 [ERROR] Erroring: No. 2 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 2 2020/03/28 14:44:44 [INFO] Information: No. 3 2020/03/28 14:44:44 [WARN] Warning: No. 3 2020/03/28 14:44:44 [ERROR] Erroring: No. 3 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 3 2020/03/28 14:44:44 [WARN] Warning: No. 4 2020/03/28 14:44:44 [ERROR] Erroring: No. 4 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 4 2020/03/28 14:44:44 [ERROR] Erroring: No. 5 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 5 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 6 これを出発点とする。\n出力を多重化するには io.MultiWriter() 関数を使うとよい。 こんな感じ。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34;  \u0026#34;os\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/logf\u0026#34; ) func main() { file, err := os.Create(\u0026#34;log.txt\u0026#34;) if err != nil { fmt.Printf(\u0026#34;%#v\\n\u0026#34;, err) return } defer file.Close() ws := io.MultiWriter(file, os.Stdout) logf.SetOutput(ws)  for i := 0; i \u0026lt; 6; i++ { logf.SetMinLevel(logf.TRACE + logf.Level(i)) logf.Tracef(\u0026#34;Traceing: No. %d\\n\u0026#34;, i+1) logf.Debugf(\u0026#34;Debugging: No. %d\\n\u0026#34;, i+1) logf.Printf(\u0026#34;Information: No. %d\\n\u0026#34;, i+1) logf.Warnf(\u0026#34;Warning: No. %d\\n\u0026#34;, i+1) logf.Errorf(\u0026#34;Erroring: No. %d\\n\u0026#34;, i+1) logf.Fatalf(\u0026#34;Fatal Erroring: No. %d\\n\u0026#34;, i+1) } } これで標準出力と log.txt ファイルに全く同じ内容が出力される。\n次に，標準出力には [ERROR] と [FATAL] のログのみ出力したい。 そこでこんな型を考える。\npackage writers //FilterWriter type is Writer with filter type FilterWriter struct { word []byte writer io.Writer } この型に対して Write() メソッド\n//Write function writes bytes data. func (w *FilterWriter) Write(b []byte) (int, error) { if w.match(b) { return w.writer.Write(b) } return len(b), nil } func (w *FilterWriter) match(b []byte) bool { if len(b) == 0 { return false } if w.word == nil { return true } return bytes.Contains(b, w.word) } を組み込めば，設定したキーワードを含んでいる場合のみ書き込みを行うようになる。\nwriters.FilterWriter を使って先程のコードを書き換えてみよう。 こんな感じ。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/logf\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/writers\u0026#34; ) func main() { file, err := os.Create(\u0026#34;log.txt\u0026#34;) if err != nil { fmt.Printf(\u0026#34;%#v\\n\u0026#34;, err) return } defer file.Close() ws := io.MultiWriter( file, writers.Filter([]byte(\u0026#34;[ERROR]\u0026#34;), os.Stdout), writers.Filter([]byte(\u0026#34;[FATAL]\u0026#34;), os.Stdout), )  logf.SetOutput(ws) for i := 0; i \u0026lt; 6; i++ { logf.SetMinLevel(logf.TRACE + logf.Level(i)) logf.Tracef(\u0026#34;Traceing: No. %d\\n\u0026#34;, i+1) logf.Debugf(\u0026#34;Debugging: No. %d\\n\u0026#34;, i+1) logf.Printf(\u0026#34;Information: No. %d\\n\u0026#34;, i+1) logf.Warnf(\u0026#34;Warning: No. %d\\n\u0026#34;, i+1) logf.Errorf(\u0026#34;Erroring: No. %d\\n\u0026#34;, i+1) logf.Fatalf(\u0026#34;Fatal Erroring: No. %d\\n\u0026#34;, i+1) } } これで標準出力が\n$ go run sample.go 2020/03/28 14:44:44 [ERROR] Erroring: No. 1 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 1 2020/03/28 14:44:44 [ERROR] Erroring: No. 2 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 2 2020/03/28 14:44:44 [ERROR] Erroring: No. 3 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 3 2020/03/28 14:44:44 [ERROR] Erroring: No. 4 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 4 2020/03/28 14:44:44 [ERROR] Erroring: No. 5 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 5 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 6 となった。\n単純な比較のみだと複雑なパターンを構成し辛いので，正規表現バージョンも作ってみた。\n//RegexpWriter type is Writer with regular expression filter type RegexpWriter struct { re *regexp.Regexp writer io.Writer } //WriteString function writes string. func (w *RegexpWriter) Write(b []byte) (int, error) { if w.match(b) { return w.writer.Write(b) } return len(b), nil } func (w *RegexpWriter) match(b []byte) bool { if len(b) == 0 { return false } if w.re == nil { return true } return w.re.Match(b) } これを使えば，先程のコードはこんな感じにできる。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;regexp\u0026#34;  \u0026#34;github.com/spiegel-im-spiegel/logf\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/writers\u0026#34; ) func main() { file, err := os.Create(\u0026#34;log.txt\u0026#34;) if err != nil { fmt.Printf(\u0026#34;%#v\\n\u0026#34;, err) return } defer file.Close() ws := io.MultiWriter( file, writers.Regexp(regexp.MustCompile(`\\[(ERROR|FATAL)\\]`), os.Stdout), )  logf.SetOutput(ws) for i := 0; i \u0026lt; 6; i++ { logf.SetMinLevel(logf.TRACE + logf.Level(i)) logf.Tracef(\u0026#34;Traceing: No. %d\\n\u0026#34;, i+1) logf.Debugf(\u0026#34;Debugging: No. %d\\n\u0026#34;, i+1) logf.Printf(\u0026#34;Information: No. %d\\n\u0026#34;, i+1) logf.Warnf(\u0026#34;Warning: No. %d\\n\u0026#34;, i+1) logf.Errorf(\u0026#34;Erroring: No. %d\\n\u0026#34;, i+1) logf.Fatalf(\u0026#34;Fatal Erroring: No. %d\\n\u0026#34;, i+1) } } これで同じ結果が得られる。\n今回はベースの Writer に出力多重化やらフィルタやらの機能を被せているだけなので，色々と応用が効くだろう。 効くといいな（笑）\nブックマーク  Log パッケージで遊ぶ 正規表現に関する戯れ言  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n   ちなみに Go の標準パッケージにも io.TeeReader() 関数ってのがあって tee コマンドと同等のことができる。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Font Awesome 5.13 に COVID-19 関連アイコンが登場",
      "section": "remark",
      "description": "covid-19 タグで検索すると色々と見つかるので，参考にどうぞ",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/03/covid-19-icons-in-font-awesome/",
      "published": "2020-03-25T02:00:26+00:00",
      "update": "2020-03-25T02:00:43+00:00",
      "content": "先日リリースされた Font Awesome 5.13 には SARS-CoV-2，世間で言うところの COVID-19 関連のアイコンが追加されたそうな1。 たとえばこんな感じ。\n   アイコン コード      \u0026lt;i class=\u0026quot;fas fa-virus\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;    \u0026lt;i class=\u0026quot;fas fa-viruses\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;    \u0026lt;i class=\u0026quot;fas fa-virus-slash\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;    ウイルスのイメージって今後はこれで定着するのかねぇ。 私はバクテリオファージのインパクトが強すぎて，ウイルスといえば\n File:Tevenphage.png - Wikimedia Commons  これなんだけど（笑）\ncovid-19 タグで検索すると既存のアイコンも併せて医療関係のアイコンを見つけることができる。 参考にどうぞ。 個人的には\n   アイコン コード      \u0026lt;i class=\u0026quot;fas fa-toilet-paper-slash\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;    \u0026lt;i class=\u0026quot;fas fa-plane-slash\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;    に笑ってしまった。 世相を反映してるというか\u0026hellip;\n  SARS-CoV-2 はウイルスの分類名， COVID-19 は WHO が定義した SARS-CoV-2 によって引き起こされる病状等を指すIDコード，らしい。日本では今だに「新型コロナ（ウイルス）」という暫定名が流通しているが，それ以外では何故か COVID-19 の ID コードがよく使われている。私は面倒くさいので SARS 2 と呼んでいる。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Java 14 がリリースされた",
      "section": "release",
      "description": "まぁ，私は PlantUML が問題なく動けばいいので（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/03/java-14-is-released/",
      "published": "2020-03-22T07:29:03+00:00",
      "update": "2020-03-22T07:43:01+00:00",
      "content": "ちょっと前に予定通り Java 14 がリリースされた。 OpenJDK および同系列の Java のみのショート・サイクルのバージョンアップである。\n JDK 14 JDK 14 GA Release JDK 14 Release Notes  まぁ，私は PlantUML が問題なく動けばいいので1（笑）\nOpenJDK を APT で管理するメリットはないので，実行バイナリをリリースページから直接ダウンロードして配置する。\n$ cd /usr/local/src $ sudo curl \u0026#34;https://download.java.net/java/GA/jdk14/076bab302c7b4508975440c56f6cc26a/36/GPL/openjdk-14_linux-x64_bin.tar.gz\u0026#34; -O $ cd .. $ sudo unlink java # 以前のバージョンの Java 環境がある場合 $ sudo tar xvf src/openjdk-14_linux-x64_bin.tar.gz $ sudo ln -s jdk-14 java $ java -version # すでに PATH が通っている場合 openjdk version \u0026#34;14\u0026#34; 2020-03-17 OpenJDK Runtime Environment (build 14+36-1461) OpenJDK 64-Bit Server VM (build 14+36-1461, mixed mode, sharing) PlantUML のほうも試してみるかな。\n Factory Method Pattern  よーし，うむうむ，よーし。\nブックマーク  Java 14正式版が登場。テキストブロック、インストーラー作成ツールなど新機能。Solaris/SPARC版はついに引退 － Publickey 真面目に PlantUML  参考図書  Java言語で学ぶリファクタリング入門 結城 浩 (著) SBクリエイティブ 2007-01-26 (Release 2014-03-12) Kindle版 B00I8AT1EU (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  結城浩さんによる「リファクタリング本」の Kindle 版。意外にも Java 以外でも応用できる優れもの。\nreviewed by Spiegel on 2018-12-11 (powered by PA-APIv5)\n  増補改訂版 Java言語で学ぶデザインパターン入門 結城 浩 (著) SBクリエイティブ 2004-06-18 (Release 2014-03-12) Kindle版 B00I8ATHGW (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  結城浩さんによる通称「デザパタ本」。 Java 以外でも使える優れもの。\nreviewed by Spiegel on 2016-01-05 (powered by PA-APIv5)\n  増補改訂版 Java言語で学ぶデザインパターン入門 マルチスレッド編 結城 浩 (著) SBクリエイティブ 2004-06-18 (Release 2014-03-12) Kindle版 B00I8AT1BS (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  結城浩さんによる通称「デザパタ本」の Kindle 版。意外にも Java 以外でも応用できる優れもの。\nreviewed by Spiegel on 2018-12-07 (powered by PA-APIv5)\n   2020-03-19 に PlantUML V1.2020.5 がリリースされている。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2020-03-22 のブックマーク",
      "section": "bookmarks",
      "description": "「GitHubがJavaScriptのパッケージマネージャー「npm」を買収」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2020/03/22-bookmarks/",
      "published": "2020-03-22T04:59:05+00:00",
      "update": "2020-03-22T04:59:21+00:00",
      "content": "リリース情報  Hugo 0.67.0: Custom HTTP headers | Hugo Release 1.45.0 · atom/atom · GitHub Announcing Rust 1.42.0 | Rust Blog Hugo 0.67.1: A couple of Bug Fixes | Hugo JDK 14 GA Release  JDK 14 JDK 14 Release Notes Java 14正式版が登場。テキストブロック、インストーラー作成ツールなど新機能。Solaris/SPARC版はついに引退 － Publickey   LibreOffice 6.4.2 available for download - The Document Foundation Blog Minify config and more! | Hugo : Hugo 0.68  セキュリティ＆プライバシー関連  Ransomware getting more fearsome, but there\u0026rsquo;s reason for optimism - Help Net Security ハッカーがデバイス攻撃時に最初に試すパスワードとは - ZDNet Japan グーグルの認証アプリ「Authenticator」、ワンタイムパスワードが盗まれるおそれ - ZDNet Japan AMD製CPUが2つの新しい攻撃に対して脆弱 ～グラーツ工科大学などのセキュリティ研究者が指摘 - 窓の杜 私は暗号解読バックドア法案に反対する | TechCrunch Japan ソフトパッチによる対策が困難なCPU脆弱性“LVI” ～ルーバンKUなどの研究者が発表 - 窓の杜  インテルCPUに脆弱性、「LVI」攻撃について研究者が明らかに - ZDNet Japan   流出NEMの不正交換事案についてまとめてみた - piyolog The Whisper Secret-Sharing App Exposed Locations - Schneier on Security Microsoft SMBv3 の脆弱性 (CVE-2020-0796) に関する注意喚起  定例外で修正されたSMBv3の脆弱性（CVE-2020-0796）についてまとめてみた - piyolog   The EARN-IT Act - Schneier on Security 新型コロナで揺れるプリンセス・クルーズが過去のデータ漏洩を認める | TechCrunch Japan 「Docker for Visual Studio Code」が正式版に、Visual Studio Codeの拡張機能。WSL 2環境のDockerコンテナに対応 － Publickey New tricks: simulating adversary tactics in modern, macOS environments | F-Secure WordPress and Apache Struts account for 55% of all weaponized vulnerabilities | ZDNet SANS Security Awareness Work-from-Home Deployment Kit | SANS Security Awareness  Work-from-Home Security Advice - Schneier on Security   Work-from-Home Security Advice - Schneier on Security  ブログ: 在宅勤務のセキュリティに関するアドバイス   テキサス法科大学教授ロバート・チェスニーの電子書籍「サイバーセキュリティの法律、政策、制度」バージョン3.0が公開されている - YAMDAS現更新履歴 Emergency Surveillance During COVID-19 Crisis - Schneier on Security  天文関連  [2002.10463] Betelgeuse Just Isn\u0026rsquo;t That Cool: Effective Temperature Alone Cannot Explain the Recent Dimming of Betelgeuse Dimming Betelgeuse likely isn\u0026rsquo;t cold, just dusty, new study shows 2020年3月17日ニュース「日本最古の天文記録、正体はオーロラだった 極地研などが見解」 | SciencePortal ニュース - 新型コロナウイルスに関連したアルマ望遠鏡の対応について - アルマ望遠鏡  知財関連  MIT Tech Review: 人工知能は特許法の 「発明者」になれるのか？ The Unicode Standard Now Includes CC License Symbols - Creative Commons Announcing the CC Catalog API, Version 1.0 - Creative Commons 将棋ユーチューバー「棋譜使わせて」と連盟に直訴　ツイートもできず、ファン悲鳴 - 弁護士ドットコム  その他  DuckDuckGo is good enough for regular use | www.bitlog.com  ブログ: DuckDuckGoは通常使用には十分だ   2020年3月9日ニュース「世界の感染国・地域は100を、感染者は10万人を超えさらに増加 新型コロナでWHO集計」 | SciencePortal サービスメッシュのIstio、機能拡張にWebAssemblyを採用。EnvoyにV8エンジンのWebAssemblyランタイムを統合 － Publickey Flatten the curve | These guidelines are intended to help Flatten the Curve with the COVID19 outbreak, to help limit spread and reduce the load on hospitals and other healthcare.  ブログ: コロナウイルス(COVID-19)へのアドバイス   AWS、コンテナに最適化したLinuxベースのOS「Bottlerocket」をオープンソースで公開 － Publickey グーグルが英ユーザーのデータ管轄を米国に移す意味とその影響 - ZDNet Japan GitHubが宿題の自動採点やインラインフィードバックなどが可能な教師向け新ツールを公開 | TechCrunch Japan 香川県条例：依存症の不安を煽って子どもからネットやゲームを奪ったうえに『親学』推進までされたんじゃたまったもんじゃない | P2Pとかその辺のお話R Rust 製スタティックサイトジェネレーター Zola をつかう | hiromasa.another :o) 2020年3月16日ニュース「厚労省が新型コロナの発生状況を周知するためにクラスターマップを作成」 | SciencePortal GitHubがnpmの買収を発表、JavaScriptのパッケージ管理サービス。将来的にはGitHubとnpmを統合へ － Publickey GitHubがJavaScriptのパッケージマネージャー「npm」を買収 | TechCrunch Japan docs.rs now allows you to choose your build targets | Rust Blog  ブログ: 失効 (リボケーション)   イラン革命体制の高齢化した指導層は新型コロナに脆弱か：池内恵 | 池内恵の中東通信 | 新潮社　Foresight(フォーサイト) | 会員制国際情報サイト 早期に米国からの入国を止めたイスラエルの「先見の明」：池内恵 | 池内恵の中東通信 | 新潮社　Foresight(フォーサイト) | 会員制国際情報サイト 「GitHub」モバイルアプリがベータ版を卒業、一般提供が開始 - 窓の杜 EOF is not a character - Ruslan\u0026rsquo;s Blog  ブログ: EOFは文字ではない   マイクロソフト、次世代.NETフレームワーク「.NET 5」最初のプレビューリリース。.NET Framework、.NET Core、Xamarinの3つを統合 － Publickey  "
    },
    {
      "title": "GnuPG 2.2.20 がリリースされた",
      "section": "release",
      "description": "セキュリティ・アップデートはなし。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/03/gnupg-2_2_20-is-released/",
      "published": "2020-03-21T10:27:24+00:00",
      "update": "2020-03-21T10:27:39+00:00",
      "content": "GnuPG 2.2.20 がリリースされた。\n [Announce] GnuPG 2.2.20 released  メンテナンス・リリース。 セキュリティ・アップデートはなし。 詳細はこちら。\n Protect the error counter against overflow to guarantee that the tools can\u0026rsquo;t be tricked into returning success after an error. gpg: Make really sure that --verify-files always returns an error. gpg: Fix key listing --with-secret if a pattern is given. [#4061] gpg: Fix detection of certain keys used as default-key. [#4810] gpg: Fix default-key selection when a card is available. [#4850] gpg: Fix key expiration and key usage for keys created with a creation date of zero. [#4670] gpgsm: Fix import of some CR,LF terminated certificates. [#4847] gpg: New options --include-key-block and --auto-key-import to allow encrypted replies after an initial signed message. [#4856] gpg: Allow the use of a fingerprint with --trusted-key. [#4855] gpg: New property \u0026quot;fpr\u0026quot; for use by --export-filter. scdaemon: Disable the pinpad if a KDF DO is used. [#4832] dirmngr: Improve finding OCSP certificates. [#4536] Avoid build problems with LTO or gcc-10. [#4831]  Release-info: https://dev.gnupg.org/T4860 via GnuPG 2.2.20 released  アップデートは計画的に。\n参考図書  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n "
    },
    {
      "title": "Unicode 13 に CC Licenses シンボルが追加された",
      "section": "remark",
      "description": "実際にはフォントも対応しないといけないのだが，それはしばらくかかるかな。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/03/cc-license-symbols-in-unicode-13/",
      "published": "2020-03-20T13:04:19+00:00",
      "update": "2020-03-22T00:29:59+00:00",
      "content": "2020-03-10 にリリースされた Unicode 13 に Creative Commons Licenses のシンボルが追加されたらしい。\n The Unicode Standard Now Includes CC License Symbols - Creative Commons  追加された CC Licenses シンボルは以下の通り。\n   符号点 字形 名前     U+1F16D  CIRCLED CC   U+1F16E  CIRCLED C WITH OVERLAID BACKSLASH   U+1F16F  CIRCLED HUMAN FIGURE   U+1F10D  CIRCLED ZERO WITH SLASH   U+1F10E  CIRCLED ANTICLOCKWISE ARROW   U+1F10F  CIRCLED DOLLAR SIGN WITH OVERLAID BACKSLASH    ちなみに「改変禁止」を表す  は数学の演算子 CIRCLED EQUALS (U+229C) を流用するようだ。 なんだかなぁ。\nこれらのシンボルを使って CC Licenses の組み合わせは以下のように表現できる。\n    意味 FCL      公有（public domain）    \u0026nbsp; CC0    \u0026nbsp; 表示    \u0026nbsp;\u0026nbsp; 表示-継承    \u0026nbsp;\u0026nbsp; 表示-非営利    \u0026nbsp;\u0026nbsp;\u0026nbsp; 表示-非営利-継承    \u0026nbsp;\u0026nbsp; 表示-改変禁止    \u0026nbsp;\u0026nbsp;\u0026nbsp; 表示-非営利-改変禁止     ちなみに公有を除く上から3つが Free Culture Licenses に相当する（公有はライセンスじゃないので）。 しかし Free Culture というフレーズも遠くなったなぁ（笑）\n実際にはフォントも対応しないといけないのだが，それはしばらくかかるかな。\nブックマーク   Understanding Free Cultural Works - Creative Commons\n  改訂3版： CC Licenses について\n  Font Awesome 5.0.11 で Creative Commons アイコンに完全対応した\n  参考図書  クリエイティブ・コモンズ―デジタル時代の知的財産権 レッシグ,ローレンス (著), 敬士, 椙山 (著), 圭介, 上村 (著), 紘一郎, 林 (著), 絵美, 若槻 (著), 大洋, 土屋 (著), クリエイティブコモンズジャパン (編集), Lessig,Lawrence (原著) NTT出版 2005-03-01 単行本 475710152X (ASIN), 9784757101524 (EAN), 475710152X (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  残念ながら紙の本は実質的に絶版なんですよねぇ。是非デジタル化を希望します。\nreviewed by Spiegel on 2014-08-02 (powered by PA-APIv5)\n  オープン化する創造の時代　著作権を拡張するクリエイティブ・コモンズの方法論 (カドカワ・ミニッツブック) ドミニク・チェン (著) ブックウォーカー 2013-06-25 (Release 2013-06-27) Kindle版 B00DI8TMPU (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  手軽に読める。お薦め。\nreviewed by Spiegel on 2014-09-13 (powered by PA-APIv5)\n  著作権２．０ ウェブ時代の文化発展をめざして (NTT出版ライブラリー―レゾナント) 名和 小太郎 (著) NTT出版 2010-06-24 単行本（ソフトカバー） 4757102852 (ASIN), 9784757102859 (EAN), 4757102852 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  名著です。今すぐ買うべきです。\nreviewed by Spiegel on 2014-08-02 (powered by PA-APIv5)\n  FREE CULTURE ローレンス・レッシグ (著), 山形浩生 (翻訳), 守岡桜 (翻訳) 翔泳社 2004-07-22 (Release 2016-03-28) Kindle版 B01DJ5VE0W (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Free Culture の原典。白田秀彰さんの「FREE ANNOTATION」も併せてどうぞ。\nreviewed by Spiegel on 2015-02-04 (powered by PA-APIv5)\n "
    },
    {
      "title": "Go 1.14.1 がリリースされた",
      "section": "release",
      "description": "セキュリティ・アップデートはなし。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/03/go-1_14_1-is-released/",
      "published": "2020-03-20T11:42:38+00:00",
      "update": "2020-03-20T11:45:04+00:00",
      "content": "Go 1.14.1 がリリースされた。\n Go 1.14.1 and Go 1.13.9 are released - Google Group  セキュリティ・アップデートはなし。\ngo1.14.1 (released 2020/03/19) includes fixes to the go command, tools, and the runtime. See the Go 1.14.1 milestone on our issue tracker for details. via Release History - The Go Programming Language  例によって Ubuntu の APT で管理している Go コンパイラは古いので，ダウンロードページからバイナリ（go1.14.1.linux-amd64.tar.gz）を取ってきて手動でインストールすることを強く推奨する。\n$ cd /usr/local/src $ sudo curl \u0026#34;https://dl.google.com/go/go1.14.1.linux-amd64.tar.gz\u0026#34; -O $ cd .. $ sudo unlink go # 以前の Go が入っている場合 $ sudo tar xvf src/go1.14.1.linux-amd64.tar.gz $ sudo mv go go1.14.1 $ sudo ln -s go1.14.1 go $ go version # /usr/local/go/bin にパスが通っている場合 go version go1.14.1 linux/amd64 アップデートは計画的に。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "カリー化に関する覚え書き",
      "section": "remark",
      "description": "関数型プログラミング言語への馴染みが薄いせいですぐ忘れちゃうのよ。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/03/currying/",
      "published": "2020-03-20T05:30:42+00:00",
      "update": "2020-03-20T13:34:43+00:00",
      "content": "どこぞの某ウイルスのせいでメチャメチャ忙しい。 しかもここ1ヶ月くらいですっかり脅威扇動型ビジネス・モデルへと変貌したようで，ホンマにいい迷惑である。 もはやため息しか出ない。 ので，この件は無視することに決めた。\nと，まぁ近況はこれくらいにして，今回は「カリー化」の話。 いや，関数型プログラミング言語への馴染みが薄いせいですぐ忘れちゃうのよ。\nというわけで，覚え書きとして記しておく。\nカリーは 飲みもの 動詞 Wikipedia によると「カリー化（currying）」とは\n 複数の引数をとる関数を、引数が「もとの関数の最初の引数」で戻り値が「もとの関数の残りの引数を取り結果を返す関数」であるような関数にすること via カリー化 - Wikipedia  とある。 「カリー」は偉い数学者である Haskell B. Curry の名前から拝借したものらしい。 名前が動詞化しちゃってるのね（笑）\n詳しくは近所の数学オタクに訊きなはれ。\n関数型言語におけるカリー化 ガチの関数型プログラミング言語 Haskell ではカリー化は言語仕様に組み込まれていて，たとえば関数 add の定義\nadd x y = x + y は実際にはカリー化表現\nadd = \\x -\u0026gt; \\y -\u0026gt; x + y の糖衣構文となっている1。\nカリー化のメリットは関数の部分適用（partial application）が作れることで2，たとえば\nincrement = add 1 とすれば add を実引数 1 で部分適用とした新しい関数 increment をシンプルに記述できる。 もちろん，わざわざ名前を付けなくても無名関数として使えばいいのだが。\n関数型じゃなくてもカリー化はできる ガチの関数型プログラミング言語じゃなくても第一級関数（first-class function）をサポートするプログラミング言語であればカリー化の記述自体は可能である。\nたとえば Go 言語なら\npackage main import \u0026#34;fmt\u0026#34; func add(x int) func(int) int { return func(y int) int { return x + y } }  func main() { fmt.Println(add(1)(2)) //Output: 3 \tincrement := add(1) //partial application \tfmt.Println(increment(2)) //Output: 3 } のように書ける。 JavaScript でも\nfunction add(x) { return function(y) { return x + y; }; }  console.log(add(1)(2)); //Output: 3 let increment = add(1); //partial application console.log(increment(2)); //Output: 3 と書くことができる。 さらに JavaScript ではアロー関数式が使えるので，関数 add の定義を\nconst add = x =\u0026gt; y =\u0026gt; x + y; などと書くことも可能である。 ここまでくると，だいぶ関数型っぽいよね。\n「それができる」ことと「そのように作られている」ことには天と地ほどの違いがある この記事を書いて思い出したが，随分前に脊髄反射で\nそんなこと言ってたら Go でだって関数型モドキな記述はできる。「それができる」ことと「そのように作られている」ことには天と地ほどの違いがある。何言ってるんだ、こいつw https://t.co/6YsZ0ouDQY\n\u0026mdash; Der Spiegel im Spiegel (@spiegel_2007) February 20, 2020  と呟いた。 今回の話はまさにそれ。\nまぁ，そもそも Go 言語の場合はシンプルを旨とする思想な上に構文（statement）による制約が強いため，関数型っぽい記述には（書けるとしても）向いてない。\nJavaScript は ES5 以降から関数型の要素を大幅に取り込んでいるが， Haskell と比較すれば分かるとおり，「関数」に対する考え方の根本が異なっている。\nこれは良し悪しの問題ではない。 まさに「制約は構造を生む」で，そうして生み出される構造と実装するシステムとの間で無理なくバランスし続けることがシステムを上手に運用するコツで，それこそが言語を選択する最重要ポイントだと思う（仕事ならね）。\n 公理によって与えられる暗黙の制約。この制約が集合の要素同士をしっかり結びつける。単純にしばるのではない、相互に秩序ある関係を結ぶ。言い換えれば――公理によって与えられる制約が構造を生み出しているのだ via 数学ガール／フェルマーの最終定理  システムを維持するために遺産や負債を抱え続けなければならない場合もあるが（それでも限度というか寿命はあるけど），そうでないならわざわざレガシーを選択する必然性は微塵もない。\nブックマーク  Haskell 超入門 - Qiita カリー化と部分適用（JavaScriptとHaskell） - Qiita    Haskell では関数の引数は1つしかとれないためカリー化は必須の要件となる。意図的にカリー化を避けたいのであれば add (x, y) = x + y のように引数を組（tuple）にすればよい。 \u0026#x21a9;\u0026#xfe0e;\n 部分適用を上手く使えば，いわゆる OAOO (Once And Only Once) 原則に基づいて効率的なコードにできる。念のために言うと，部分適用を構成するのにカリー化は必要条件ではない。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Rust の文字列操作（2）",
      "section": "rust-lang",
      "description": "文字列と他の型の値との相互変換について。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/character-string-2/",
      "published": "2020-03-11T11:24:35+00:00",
      "update": "2020-03-11T12:07:44+00:00",
      "content": "前回の続き。 Rust の文字列操作についてオベンキョ中です。\n他の型の値を文字列に変換する ある型が ToString トレイトを実装していれば to_string() メソッドを使って文字列に変換できる。 整数や浮動小数点数などの基本型は ToString トレイトを実装している。 以下のようにリテラル表現に対して直接 to_string() メソッドを起動することもできる。\nfn main(){println!(\u0026#34;{}\u0026#34;,(123).to_string());//Output: 123 println!(\u0026#34;{}\u0026#34;,(1.23).to_string());//Output: 1.23 println!(\u0026#34;{}\u0026#34;,(true).to_string());//Output: true println!(\u0026#34;{}\u0026#34;,(\u0026#39;あ\u0026#39;).to_string());//Output: あ }同じ基本型でもタプルや配列は ToString トレイトを実装していないため to_string() メソッドは使えない。\nfn main(){println!(\u0026#34;{}\u0026#34;,([1,2,3]).to_string());//Error: no method named `to_string` found for type `[{integer}; 3]` in the current scope }変換する文字列を整形する 今までさんざん出てきたので今更だが， format! 等のマクロを使えば他の型の値を変換する際の文字列を整形できる。\n   マクロ名 機能     format! 文字列を整形して String として出力する   print!, println! 文字列を整形して標準出力に出力する   write!, writeln! 文字列を整形して指定したストリームに出力する   panic! 文字列を整形して panic 出力に付加する    たとえば，こんな感じ。\nfn main(){println!(\u0026#34;{{{} = {num:#04x} = {num:#010b}}}\u0026#34;,num=15);//Output: {15 = 0x0f = 0b00001111} }プレースホルダ {which:how} の中身の how の部分が C/C++ や Go の printf 文の書式（%d など）に相当する。 意味もだいたい同じ。\n   書式 意味     なし 既定のテキスト   b 2進数   o 8進数   x 16進数（小文字）   X 16進数（大文字）   e 浮動小数点数科学技術記法（小文字）   E 浮動小数点数科学技術記法（大文字）   ? デバッグ出力   p ポインタ値    実はこれらの書式には対応するトレイトがあって，独自に作成した型でもトレイトを実装することで書式に対応できる。\n   書式 トレイト     なし std::fmt::Display   b std::fmt::Binary   o std::fmt::Octal   x std::fmt::LowerHex   X std::fmt::UpperHex   e std::fmt::LowerExp   E std::fmt::UpperExp   ? std::fmt::Debug   p std::fmt::Pointer    たとえば，以下の構造体 Person に対して\nstruct Person{age: u32,name: String,}std::fmt::Display トレイトを実装してみる。 こんな感じ。\nusestd::fmt;struct Person{age: u32,name: String,}implfmt::DisplayforPerson{fn fmt(\u0026amp;self,dest: \u0026amp;mutfmt::Formatter)-\u0026gt; fmt::Result{write!(dest,\u0026#34;{} ({})\u0026#34;,self.name,self.age)}}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};println!(\u0026#34;p1 = {}\u0026#34;,p1);//Output: p1 = alice (24) println!(\u0026#34;p1 = {}\u0026#34;,p1.to_string());//Output: p1 = alice (24) }std::fmt::Display トレイトを実装すると ToString トレイトもセットで実装される。 便利！\nstd::fmt::Debug トレイトの実装はもっと簡単で， derive 構文を使って\n#[derive(Debug)]struct Person{age: u32,name: String,}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};println!(\u0026#34;p1 = {:?}\u0026#34;,p1);//Output: p1 = Person { age: 24, name: \u0026#34;alice\u0026#34; } }とすればよい。\nちなみに全ての組み込み型と標準ライブラリで定義される型は std::fmt::Debug トレイトを実装済みなので，さきほど to_string() メソッドが使えないと書いたタプルや配列でも\nfn main(){println!(\u0026#34;{:?}\u0026#34;,(123,1.13));//Output: (123, 1.13) println!(\u0026#34;{:?}\u0026#34;,[1,2,3]);//Output: [1, 2, 3] }のようにできる。\n文字列から他の型の値を取得する std::str::FromStr トレイトを実装している型であれば文字列からその型の値を取得できる。\npubtraitFromStr: Sized {type Err;fn from_str(s: \u0026amp;str)-\u0026gt; Result\u0026lt;Self,Self::Err\u0026gt;;}整数や浮動小数点数などの基本型は std::str::FromStr トレイトを実装している。 返り値は Result 型なので何らかのエラーハンドリングが必要だが，以下のコードでは端折っている。 ゴメンペコン。\nusestd::str::FromStr;fn main(){println!(\u0026#34;{:?}\u0026#34;,i64::from_str(\u0026#34;123\u0026#34;));//Output: Ok(123) println!(\u0026#34;{:?}\u0026#34;,f64::from_str(\u0026#34;1.23\u0026#34;));//Output: Ok(1.23) println!(\u0026#34;{:?}\u0026#34;,bool::from_str(\u0026#34;true\u0026#34;));//Output: Ok(true) }ちなみに大文字の \u0026quot;TRUE\u0026quot; はダメらしい（笑）\nusestd::str::FromStr;fn main(){println!(\u0026#34;{:?}\u0026#34;,bool::from_str(\u0026#34;TRUE\u0026#34;));//Output: Err(ParseBoolError { _priv: () }) }小文字に変換すればいいかな。\nusestd::str::FromStr;fn main(){println!(\u0026#34;{:?}\u0026#34;,bool::from_str(\u0026amp;\u0026#34;TRUE\u0026#34;.to_lowercase()));//Output: Ok(true) }文字列に対して parse() メソッドを使う方法もある。 parse() メソッド内部で from_str() を呼び出しているらしい。\nfn main(){println!(\u0026#34;{:?}\u0026#34;,\u0026#34;123\u0026#34;.parse::\u0026lt;i64\u0026gt;());//Output: Ok(123) println!(\u0026#34;{:?}\u0026#34;,\u0026#34;TRUE\u0026#34;.to_lowercase().parse::\u0026lt;bool\u0026gt;());//Output: Ok(true) }記述としてはどっちもどっちだな。\n参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n  プログラミングRust Jim Blandy (著), Jason Orendorff (著), 中田 秀基 (翻訳) オライリージャパン 2018-08-10 単行本（ソフトカバー） 4873118557 (ASIN), 9784873118550 (EAN), 4873118557 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版あり。公式ドキュメントよりも系統的に書かれているので痒いところに手が届く感じ。ただし量が多いので，一度斜め読みしたらあとは傍らに置いて必要に応じてつまみ食いしていくのがいいだろう。\nreviewed by Spiegel on 2020-03-08 (powered by PA-APIv5)\n "
    },
    {
      "title": "Rust の文字列操作（1）",
      "section": "rust-lang",
      "description": " Rust では「文字列」としての操作対象を Unicode/UTF-8 に限定している。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/character-string-1/",
      "published": "2020-03-08T14:08:47+00:00",
      "update": "2020-03-10T12:45:26+00:00",
      "content": "さて，所有権について何とな〜く分かったところで，目先を変えて文字・文字列・文字列操作について調べていこう。\nRust の「文字列」は Unicode/UTF-8 限定 文字列操作で何が面倒かって複数の文字セットと文字エンコーディングが混在している点である。 そこで今どきのプログラミング言語は「文字列」としての操作対象を Unicode/UTF-8 に限定していることが多い。 Rust もそうした言語のひとつである。\nこんにちは，世界！ まずは，以下のコードを書いてみる。\nfn main(){println!(\u0026#34;こんにちは，世界！\u0026#34;);}ここで \u0026quot;こんにちは，世界！\u0026quot; はリテラル文字列で，実行すると\n$ cargo run こんにちは，世界！ と表示される。 println! マクロ引数のリテラル文字列も出力される文字列も UTF-8 エンコーディングである。\nここでリテラル文字列の \u0026quot;こんにちは，世界！\u0026quot; を強引に Shift-JIS に書き換えて実行するとどうなるか。\n$ pushd src/ $ cp main.rs main.rs.utf8.txt $ gonkf conv -s utf8 -d sjis main.rs.utf8.txt \u0026gt; main.rs $ popd $ cargo run error: couldn\u0026#39;t read src/main.rs: stream did not contain valid UTF-8 というわけでコンパイルに失敗しました（笑）\nRust における文字と文字列 Rust では Unicode/UTF-8 文字および文字列を扱うために以下の3つの型が存在する。\n   型名 内部表現 内容     char u32 文字（Unicode 符号点）   String Vec\u0026lt;u8\u0026gt; 可変長文字列（UTF-8）   str [u8] 文字列への参照（UTF-8）    char および str は組み込み型， String は標準ライブラリで定義される型である。\nstr 型は文字列に対するスライスで，それ自体は所有権を持たず（値を持たないため）範囲指定付きビューとして機能する。 通常は \u0026amp;str と参照の形で使う。\nString と str の関係はこんな感じ。\nfn main(){lets: String =\u0026#34;Hello World\u0026#34;.to_string();lethw: \u0026amp;str =s.as_str();letw: \u0026amp;str =\u0026amp;s[6..11];println!(\u0026#34;{}\u0026#34;,s);//Output: Hello World println!(\u0026#34;{}\u0026#34;,hw);//Output: Hello World println!(\u0026#34;{}\u0026#34;,w);//Output: World }図にするとこんな感じだろうか。\n \u0026quot;Hello World\u0026quot; などのリテラル文字列は型としては \u0026amp;'static str と表現できる。 ちなみに 'static はライフタイム注釈の特殊な表現で，生存期間がプログラム全域に及ぶという恐ろしいものである（笑）\nリテラル文字列の後ろの to_string() メソッドは文字列のコピーを返す。 リテラル文字列そのものがセットされているわけではない。\n文字列から文字を抽出する Rust の文字列の中身は UTF-8 バイト列なので，文字列から文字（厳密には Unicode 符号点1）を抽出するのは単純ではない。 そもそも\nfn main(){lets=\u0026#34;日本語\u0026#34;;println!(\u0026#34;{}\u0026#34;,s[0]);//Error: the type `str` cannot be indexed by `{integer}` }とかやってもコンパイル・エラーになるだけである。\n文字列から文字を抽出するには，例えばこんな感じに書ける。\nfn main(){lets1=\u0026#34;日本語\u0026#34;;println!(\u0026#34;{:?}\u0026#34;,s1.chars().nth(0));//Output: Some(\u0026#39;日\u0026#39;) lets2=s1.to_string();println!(\u0026#34;{:?}\u0026#34;,s2.chars().nth(1));//Output: Some(\u0026#39;本\u0026#39;) }まず chars() メソッドで文字列を文字単位のイテレータ Chars に変換し，更に nth() メソッドで任意の位置の文字を抽出している。 nth() メソッドは Option 型の値を返すので本来は何らかのエラー・ハンドリングが必要だが，今回は横着している2。 ゴメンペコン。\nあるいはもっと簡単に collect() メソッドを使って Chars から配列 Vec\u0026lt;char\u0026gt; に変換して\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;letchs=nihongo.chars().collect::\u0026lt;Vec\u0026lt;char\u0026gt;\u0026gt;();println!(\u0026#34;{}\u0026#34;,chs[0]);//Output: 日 }てな感じにも記述できる。\n「文字」列から「文字列」を生成する 1文字ではなく，先頭の2文字を抽出して文字列を生成してみる。 まずは素朴にこんな感じだろうか。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;letmutnippon=String::new();for(i,c)innihongo.chars().enumerate(){nippon.push(c);ifi\u0026gt;0{break;}}println!(\u0026#34;{}\u0026#34;,nippon);//Output: 日本 }うーん，微妙。 たとえば take() メソッドを使えば先頭から指定した数だけ要素を有効にできる。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;letmutnippon=String::new();forcinnihongo.chars().take(2){nippon.push(c);}println!(\u0026#34;{}\u0026#34;,nippon);//Output: 日本 }いや，そもそも for 文で回すってのがダサいというか\u0026hellip; ふむむー，そっか。 fold() メソッドを使えばいいのか。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;letnippon=nihongo.chars().take(2).fold(String::new(),|muts,c|{s.push(c);s});println!(\u0026#34;{}\u0026#34;,nippon);//Output: 日本 }でも「先頭の2文字を抽出する」だけなのに，コードが大袈裟すぎないか？ と思ってたら，ゴメン。 collect() メソッドを使えば一発で String に変換できたわ。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;letnippon=nihongo.chars().take(2).collect::\u0026lt;String\u0026gt;();println!(\u0026#34;{}\u0026#34;,nippon);//Output: 日本 }なんだ，簡単ぢゃん orz\nブックマーク   Stringとstr入門 - Qiita\n  文字列操作 with Rust - Qiita\n  Rustで文字列の先頭文字や部分文字列を取得する - Qiita\n  spiegel-im-spiegel/charset_document: 「文字コードとその実装」 upLaTeX ドキュメント : 大昔に書いたドキュメントで内容が古いため，取り扱いには注意\n  spiegel-im-spiegel/text: Encoding/Decoding Text Package by Golang : gonkf コマンドはここで公開しています\n  参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n  プログラミングRust Jim Blandy (著), Jason Orendorff (著), 中田 秀基 (翻訳) オライリージャパン 2018-08-10 単行本（ソフトカバー） 4873118557 (ASIN), 9784873118550 (EAN), 4873118557 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版あり。公式ドキュメントよりも系統的に書かれているので痒いところに手が届く感じ。ただし量が多いので，一度斜め読みしたらあとは傍らに置いて必要に応じてつまみ食いしていくのがいいだろう。\nreviewed by Spiegel on 2020-03-08 (powered by PA-APIv5)\n   Unicode ではひとつの符号点がひとつの文字を表すとは限らない点に注意。これに関して以前に「Go 言語と Unicode 正規化」という記事を書いたので参考にどうぞ。 \u0026#x21a9;\u0026#xfe0e;\n エラー・ハンドリングについてはいつかどこかでやる予定。 \u0026#x21a9;\u0026#xfe0e;\n   "
    }
  ]
}
