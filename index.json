{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "Java 16 がリリースされた",
      "section": "release",
      "description": "OpenJDK および同系列 Java のショート・サイクルのバージョンアップ",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/java-16-is-released/",
      "published": "2021-03-17T10:32:20+00:00",
      "update": "2021-03-17T10:32:58+00:00",
      "content": "予定通り Java 16 がリリースされた。 OpenJDK および同系列 Java におけるショート・サイクルのバージョンアップである。\n JDK 16 JDK 16 GA Release JDK 16 Release Notes  OpenJDK を APT で管理するメリットはないので，実行バイナリをリリースページから直接ダウンロードして配置する。 以下は完全手動でのインストール（笑）\n$ cd /usr/local/src $ sudo curl -L \u0026#34;https://download.java.net/java/GA/jdk16/7863447f0ab643c585b9bdebf67c69db/36/GPL/openjdk-16_linux-x64_bin.tar.gz\u0026#34; -O $ cd .. $ sudo unlink java # 以前のバージョンの Java 環境がある場合 $ sudo tar xvf src/openjdk-16_linux-x64_bin.tar.gz $ sudo ln -s jdk-16 java $ java -version # すでに PATH が通っている場合 openjdk version \u0026#34;16\u0026#34; 2021-03-16 OpenJDK Runtime Environment (build 16+36-2231) OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing) 私としては PlantUML が動けばいいので，試しておく1。\nFactory Method Pattern  うむうむ。 ちゃんと動くな。\n参考図書  Effective Java 第3版 Joshua Bloch (著), 柴田 芳樹 (翻訳) 丸善出版 2018-10-30 単行本（ソフトカバー） 4621303252 (ASIN), 9784621303252 (EAN), 4621303252 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  再勉強中。 Kindle 版のほうがちょっと安いが，勤務先でも使いたかったので紙の本にした。\nreviewed by Spiegel on 2021-03-17 (powered by PA-APIv5)\n   2021-03-07 に PlantUML Version 1.2021.2 がリリースされている。 PlantUML の使い方等については拙文「真面目に PlantUML」シリーズを参考にどうぞ。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "『再発見の発想法』は非エンジニアこそ読んで欲しい",
      "section": "remark",
      "description": "3月14日は「円周率の日」で「数学の日」でアインシュタイン博士の誕生日である。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/the-essence-of-programming/",
      "published": "2021-03-13T22:31:13+00:00",
      "update": "2021-03-13T22:31:32+00:00",
      "content": "3月14日は「円周率の日」で「数学の日」でアインシュタイン博士の誕生日である。 世界の数学者と理学者と工学者は今日というめでたい日を盛大に祝うんだ！\nというわけで，今回は結城浩さん著作の『再発見の発想法』の感想文なんぞを書いてみる。 読書感想文は久しぶりだな（笑）\nソフトウェエア・エンジニアというのは不思議な職業で，それ単体では成立し得ない。 何故ならソフトウェアを使う人の多くはソフトウェエア・エンジニア以外の人たちだからだ。\nたとえば工場 (こうば) の工員さんやコールセンターの中の人，役場のお役人様やタクシーや長距離トラックの運ちゃん，そういった人たちのために私達エンジニアは日々頭を悩ませている。\n特に悩ましいのは業種や職場によって独自の用語や隠語があることだ。 だから私達はシステムを作る際にはまず「用語集」を作る。\n『再発見の発想法』6.2章に出てくる「ベンチマーク（benchmark）」という単語なんかが典型的だが，同じ言葉なのに業種によって少しずつ意味が異なることがある。 そうした言葉の背後にある差異に気づかず設計を推し進めると，後でとんでもないしっぺ返しを食らったりするのだ。\nでも，最初の段階でお互いに言葉をすり合わせて「用語集」を作っておくと，以後のコミュニケーションがスムーズになる。 特に考え方や手段といった目に見えないものに「名前」を付けることは重要で，名前を付けることで議論のアンカーもしくは原点として機能し始める。 私は名前の「正しさ」というものを全く信用していない不遜な人間だが，当事者がお互いに同じ言葉を同じ意味で話すことの重要性は理解しているつもりである。\nとはいえ，私達エンジニアが普段どんな言葉を喋ってどんな思考のもとに設計しコードを組み立てていくか知ってほしいというのも本音だ。\nそこで，いよいよ『再発見の発想法』の登場である。\nこの本は結城浩さんによる「Software Design」誌上の同名連載をまとめたものだそうで，さまざまな「技術用語」について解説したものだ。 しかし，内容は技術系雑誌に掲載されていたとは思えないほど平易な言葉で書かれている。\n用語の意味とその背後にある考え方と日常生活になぞらえた例示が絶妙なバランスで配置されていて，この辺のさじ加減の上手さは流石結城浩さんと言うしかない。 やはり《例示は理解の試金石》（by 数学ガール）なんだねぇ。\nソフトウェア・エンジニアリングの有名な格言（？）に「推測するな，計測せよ」というのがある。 『再発見の発想法』に出てくる技術用語の選択は，まさに 計測→評価→改修 というエンジニアリングの基本サイクルを意識している印象がある。\n技術系雑誌の連載が出自だし「再発見」というタイトルには私達エンジニアが普段使っている言葉を見直すという意味が含まれているのだろうが，私としてはこの本は非エンジニアの方々あるいはエンジニアを目指す若い方々にこそ読んで欲しい。 そして，本に出てくる言葉をエンジニアがつぶやいているときは「こういう風に考えてるんだなぁ」と感じていただければ幸いである。\nさて，積ん読状態の「数学ガール」シリーズも読み進めないとなぁ。 ようやく「本を読む」余裕が出てきたよ。\n参考図書  再発見の発想法 結城 浩 (著) SBクリエイティブ 2021-02-19 (Release 2021-02-20) Kindle版 B08S2LY9VG (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  「Software Design」誌の同名連載の書籍化。「技術用語」の解説書だが，平易な内容で読みやすい。\nreviewed by Spiegel on 2021-03-14 (powered by PA-APIv5)\n  プログラマの数学 第2版 結城 浩 (著) SBクリエイティブ 2018-01-16 (Release 2018-02-08) Kindle版 B079JLW5YN (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  タイトル通りプログラマ必読書。第2版では機械学習に関する章が付録に追加された。\nreviewed by Spiegel on 2018-03-19 (powered by PA-APIv5)\n  イミテーション・ゲーム／エニグマと天才数学者の秘密(字幕版) ベネディクト・カンバーバッチ (出演), キーラ・ナイトレイ (出演), マシュー・グード (出演), ロリー・キニア (出演), モルテン・ティルドゥム (監督), グラハム・ムーア (Writer)  (Release 2015-10-02) Prime Video B015SAFU42 (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  主人公であるアラン・チューリングは今もなお「天才」と称される数学者であり，「コンピュータの父」と呼ばれるほどの偉人である。そしてチューリングの偉業のひとつが，旧ナチス・ドイツの暗号機械「エニグマ」の解読である。作品はそのエニグマの解読を主軸に物語を展開していく。感想はこちら。\nreviewed by Spiegel on 2015-04-19 (powered by PA-APIv5)\n "
    },
    {
      "title": "Go 1.16.2 がリリースされた",
      "section": "release",
      "description": "セキュリティ・アップデートはなし。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/go-1_16_2-is-released/",
      "published": "2021-03-11T23:27:46+00:00",
      "update": "2021-03-11T23:30:23+00:00",
      "content": "Go 1.16.2 がリリースされた。\n Go 1.16.2 and Go 1.15.10 are released  セキュリティ・アップデートはなし。 一度に出せよ orz\ngo1.16.2 (released 2021/03/11) includes fixes to cgo, the compiler, linker, the go command, and the syscall and time packages. See the Go 1.16.2 milestone on our issue tracker for details. via Release History - The Go Programming Language  例によって Ubuntu の APT で管理している Go コンパイラは古いので，ダウンロードページからバイナリ（go1.16.2.linux-amd64.tar.gz）を取ってきて手動でインストールすることを強く推奨する。 以下は手動での作業例。\n$ cd /usr/local/src $ sudo curl -L \u0026#34;https://golang.org/dl/go1.16.2.linux-amd64.tar.gz\u0026#34; -O $ cd .. $ sudo unlink go # 以前の Go が入っている場合 $ sudo tar xvf src/go1.16.2.linux-amd64.tar.gz $ sudo mv go go1.16.2 $ sudo ln -s go1.16.2 go $ go version # /usr/local/go/bin にパスが通っている場合 go version go1.16.2 linux/amd64 アップデートは計画的に。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "TinyGo で WebAssembly",
      "section": "golang",
      "description": "Go および TinyGo を使って WebAssembly へのコンパイルを行い Web ブラウザ上で動作させるところまでやってみる",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/webassembly-with-tinygo/",
      "published": "2021-03-11T12:01:29+00:00",
      "update": "2021-03-11T12:01:50+00:00",
      "content": "TinyGo は本家 Go のサブセットと言えるもので LLVM を使った組み込み用途特化のコンパイラである。 しかも LLVM が WebAssembly バイナリを直接出力できるということもあって TinyGo と WebAssembly の相性は本家 Go 以上と言える。\nというわけで今回は， Go および TinyGo を使って WebAssembly へのコンパイルを行い， Web ブラウザ上で動作させるところまでやってみることにする。\nTinyGo のインストール TinyGo が動作するためには，あらかじめ本家 Go のツールチェーンが導入済みであることが前提となる。 この記事では Go は導入済みであるとして話を進める。\nTinyGo は以下のリポジトリから最新版をダウンロード\u0026amp;インストールする。\n tinygo-org/tinygo: Go compiler for small places. Microcontrollers, WebAssembly, and command-line tools. Based on LLVM.  2021-03-11 時点での最新版は 0.17.0 である。 Go 1.16 以降が推奨らしい。\nUbuntu の場合 Ubuntu の APT や Snap の公式リポジトリにはないので， deb ファイルをダウンロードし，手動でインストールする。\n$ curl -L https://github.com/tinygo-org/tinygo/releases/download/v0.17.0/tinygo_0.17.0_amd64.deb -O $ sudo dpkg -i tinygo_0.17.0_amd64.deb $ tinygo version tinygo version 0.17.0 linux/amd64 (using go version go1.16.1 and LLVM version 11.0.0) ちなみに WSL/WSL2 上の Ubuntu にもインストール可能だそうだ。\nWindows の場合 Windows なら Scoop を使うのが最も簡単である。 Scoop なら本家 Go も簡単にインストールできるし TinyGo 用の周辺ツールも Scoop で簡単に導入できる。\n$ scoop install tinygo $ tinygo version tinygo version 0.17.0 windows/amd64 (using go version go1.16.1 and LLVM version 11.0.0) Docker の場合 Docker 環境も用意されているそうだ。 詳しくはこちら。\n Docker :: TinyGo - Go on Microcontrollers and WASM  ファイル構成 今回のファイル構成はこんな感じ。\n$ tree . . ├── hello │ ├── hello.go │ ├── index.html │ ├── wasm.js │ └── wasm_exec.js └── main.go main.go は簡易サーバのコードで，こんな感じになっている。\npackage main import ( \u0026#34;embed\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/fs\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) //go:embed hello var assets embed.FS func main() { addr := \u0026#34;localhost:3000\u0026#34; fmt.Printf(\u0026#34;Open http://%s/\\n\u0026#34;, addr) fmt.Println(\u0026#34;Press ctrl+c to stop\u0026#34;) root, _ := fs.Sub(assets, \u0026#34;hello\u0026#34;) fs := http.FileServer(http.FS(root)) http.Handle(\u0026#34;/\u0026#34;, http.FileServer(http.FS(root))) if err := http.ListenAndServe(addr, http.HandlerFunc(func(resp http.ResponseWriter, req *http.Request) { resp.Header().Add(\u0026#34;Cache-Control\u0026#34;, \u0026#34;no-cache\u0026#34;) if strings.HasSuffix(req.URL.Path, \u0026#34;.wasm\u0026#34;) { resp.Header().Set(\u0026#34;content-type\u0026#34;, \u0026#34;application/wasm\u0026#34;) } fs.ServeHTTP(resp, req) })); err != nil { fmt.Fprintln(os.Stderr, err) } } embed パッケージと //go:embed ディレクティブが便利！ 簡易サーバのコードについては拙文「紙芝居用の簡易サーバを書く【Go 1.16 版】 」を参照のこと。 今回用の設定としては *.wasm ファイルの Content-Type を application/wasm にすることくらいかな。 あとは no-cache の設定ね。\nwasm_exec.js ファイルは Go および TinyGo が用意しているファイルで，以下からコピってそのまま使えばよい。\n   処理系 パス     Go $GOROOT/misc/wasm/wasm_exec.js   TinyGo $TINYGOROOT/targets/wasm_exec.js    $GOROOT および $TINYGOROOT の値は，以下のコマンドで取得できる。\n$ tinygo env GOOS=\u0026#34;linux\u0026#34; GOARCH=\u0026#34;amd64\u0026#34; GOROOT=\u0026#34;/usr/local/go1.16.1\u0026#34; GOPATH=\u0026#34;/home/username/go\u0026#34; GOCACHE=\u0026#34;/home/username/.cache/tinygo\u0026#34; CGO_ENABLED=\u0026#34;1\u0026#34; TINYGOROOT=\u0026#34;/usr/local/lib/tinygo\u0026#34; みんな大好き Hello World さて hello/hello.go ファイルの中身だが，まずはこんな感じで。\n// +build js,wasm  package main import \u0026#34;syscall/js\u0026#34; func main() { ch := make(chan struct{}) js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, \u0026#34;hello\u0026#34;).Set(\u0026#34;innerHTML\u0026#34;, \u0026#34;Hello, World!\u0026#34;) \u0026lt;-ch // Code must not finish } JavaScript の DOM 構造に慣れている人ならそんなに難しくないだろう。 ID 名 hello の要素に文字列 Hello, World! を突っ込むだけの簡単なお仕事（笑）\nこれを Go および TinyGo の各コンパイラでコンパイルしてみる。\n$ GOOS=js GOARCH=wasm go build -o hello1.wasm -trimpath $ tinygo build -o hello2.wasm -target wasm ./hello.go 前者が本家 Go によるコンパイルで，後者が TinyGo によるコンパイルだ。 コンパイル結果は以下の通り。\n$ ll *.wasm -rwxrwxr-x 1 username username 1364695 3月 10 23:59 hello1.wasm* -rwxrwxr-x 1 username username 67375 3月 10 23:59 hello2.wasm* おうふ。 こんなに違うのか。\n本家 Go のコードが大きいのは，良くも悪くも POSIX 互換環境への依存度が高く組み込み用途に使うには余計なコードを抱え込んでしまうという事情がある。\n一方 TinyGo は LLVM の制約を受けるため，ガベージコレクションや並行処理などで本家 Go とは異なる挙動になる（他にもいくつかの標準パッケージが使えない場合があるらしい）。\nたとえば先ほどの\nfunc main() { ch := make(chan struct{}) js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, \u0026#34;hello\u0026#34;).Set(\u0026#34;innerHTML\u0026#34;, \u0026#34;Hello, World!\u0026#34;) \u0026lt;-ch // Code must not finish } の最後を見ると，チャネル受信状態で処理が止まっているが（というか止めるためにわざわざこのように書いているのだが），これがないと TinyGo コンパイラがエラーを吐く場合があるようだ。\nWebAssembly コードのバインド hello/wasm.js ファイルは生成した WebAssembly コードを JavaScript 側にバインドするものである。 今回は以下のように書いてみた。\nfunction initWASM(url) { const go = new Go(); if (\u0026#39;instantiateStreaming\u0026#39; in WebAssembly) { WebAssembly.instantiateStreaming(fetch(url), go.importObject).then(function (obj) { go.run(obj.instance); }) } else { fetch(WASM_URL).then(resp =\u0026gt; resp.arrayBuffer() ).then(bytes =\u0026gt; WebAssembly.instantiate(bytes, go.importObject).then(function (obj) { go.run(obj.instance); }) ) } } これで\ninitWASM(\u0026#39;hello2.wasm\u0026#39;); という感じに任意の WebAssembly ファイルを取り込める。\nHTML の内容 以上を踏まえて hello/index.html ファイルの内容は以下のようにした。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;wasm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p id=\u0026#34;hello\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; initWASM(\u0026#34;hello2.wasm\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 実行結果 では，いよいよ動かしてみよう。\n$ go run main.go Open http://localhost:3000/ Press ctrl+c to stop 該当の URL を開くと\nHello  よーし，ちゃんと表示されているな。 ここまでは楽勝。\nWebAssembly の機能を JavaScript から呼び出す 以上のコードは WebAssembly 側から HTML 要素に値をセットしていたが，これではあまり応用できないだろう。 なので，今度は JavaScript 側から WebAssembly の機能を呼び出すことを考える。\nまずは hello/hello.go ファイルの内容を以下のように変更する。\n// +build js,wasm  package main import ( \u0026#34;strings\u0026#34; \u0026#34;syscall/js\u0026#34; ) func say(this js.Value, args []js.Value) interface{} { ss := []string{} for _, jss := range args { if s := jsString(jss); s != \u0026#34;\u0026#34; { ss = append(ss, s) } } return js.ValueOf(\u0026#34;Hello, \u0026#34; + strings.Join(ss, \u0026#34;, \u0026#34;)) } func jsString(j js.Value) string { if j.IsUndefined() || j.IsNull() { return \u0026#34;\u0026#34; } return j.String() } func main() { ch := make(chan struct{}) js.Global().Set(\u0026#34;say\u0026#34;, js.FuncOf(say)) \u0026lt;-ch // Code must not finish } JavaScript から呼び出す関数は\nfunc(this js.Value, args []js.Value) interface{} の関数型にする決まりのようだ。 また返り値は js.Value 型にして返すのだが，実際の Go の型と JavaScript の型の対応は以下のようになっているらしい。\n   Go JavaScript     js.Value [its value]   js.Func function   nil null   bool boolean   integers and floats number   string string   []interface{} new array   map[string]interface{} new object     via js - The Go Programming Language  さらに main() 関数内の\njs.Global().Set(\u0026#34;say\u0026#34;, js.FuncOf(say)) によって Go の say() 関数は JavaScript の global.say() 関数に紐付けられる。\nhello/wasm.js ファイルはそのままでOK。 hello/index.html ファイルの内容を以下のように書き換える。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;wasm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;Hello\u0026lt;/button\u0026gt; \u0026lt;p id=\u0026#34;hello\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; initWASM(\u0026#39;hello2.wasm\u0026#39;); document.querySelector(\u0026#39;button\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, event =\u0026gt; { document.getElementById(\u0026#34;hello\u0026#34;).innerHTML = global.say(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Chris\u0026#34;); }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; これで [Hello] ボタン押下で global.say() 関数が発火するはずである。 実行してみよう。\n$ go run main.go Open http://localhost:3000/ Press ctrl+c to stop この状態で画面を表示すると\nHello Button (1)  さらにボタンを押下すると\nHello Button (2)  よーし，うむうむ，よーし。\nこれなら応用が効きそうかな。 今回はここまで。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "OpenSSH 8.5 のリリース【セキュリティ・アップデート】",
      "section": "release",
      "description": "アップデートは計画的に",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/openssh-8_5-is-released/",
      "published": "2021-03-11T10:11:29+00:00",
      "update": "2021-03-11T10:13:04+00:00",
      "content": "先週の話で恐縮だが， 2021-03-03 にリリースされた OpenSSH 8.5 で CVE-2021-28041 の脆弱性の改修がされていたらしい。\nssh-agent in OpenSSH before 8.5 has a double free that may be relevant in a few less-common scenarios, such as unconstrained agent-socket access on a legacy operating system, or the forwarding of an agent to an attacker-controlled host. via NVD - CVE-2021-28041  ssh-agent のソケット周りとかヤバいぢゃん。\nCVSSv3 評価は以下の通り。\n CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H 深刻度: 緊急 (Score: 9.8)     基本評価基準 評価値     攻撃元区分 ネットワーク   攻撃条件の複雑さ 低   必要な特権レベル 不要   ユーザ関与レベル 不要   スコープ 変更なし   機密性への影響 高   完全性への影響 高   可用性への影響 高    実は Ubuntu で，これを修正したらしい OpenSSH 8.3 バックポート・パッチが出てたので気付いた次第。\n USN-4762-1: OpenSSH vulnerability | Ubuntu security notices | Ubuntu  まぁ，アップデートは計画的に，ということで。\n参考図書  SSH Mastery: OpenSSH, PuTTY, Tunnels and Keys (IT Mastery Book 12) (English Edition) Lucas, Michael W (著) Tilted Windmill Press 2018-02-06 (Release 2018-02-06) Kindle版 B079NL1L9K (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  タイトルを見て “SSH Mystery” と空目したアホは私です。洋書だけど英語不得手の私にも読める内容。\nreviewed by Spiegel on 2021-01-11 (powered by PA-APIv5)\n  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n "
    },
    {
      "title": "Go 1.16.1 のリリース【セキュリティ・アップデート】",
      "section": "release",
      "description": "今回は複数の脆弱性について改修されている。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/go-1_16_1-is-released/",
      "published": "2021-03-11T09:52:53+00:00",
      "update": "2021-03-11T23:28:07+00:00",
      "content": "予告通り， Go 1.16.1 がリリースされた。\n [security] Go 1.16.1 and Go 1.15.9 are released  今回は複数の脆弱性について改修されている。\ngo1.16.1 (released 2021/03/10) includes security fixes to the archive/zip and encoding/xml packages. See the Go 1.16.1 milestone on our issue tracker for details. via Release History - The Go Programming Language  encoding/xml: infinite loop when using xml.NewTokenDecoder with a custom TokenReader (CVE-2021-27918) The Decode, DecodeElement, and Skip methods of an xml.Decoder provided by xml.NewTokenDecoder may enter an infinite loop when operating on a custom xml.TokenReader which returns an EOF in the middle of an open XML element. via Go 1.16.1 and Go 1.15.9 are released  （以下未稿）\narchive/zip: panic when calling Reader.Open (CVE-2021-27919) The Reader.Open API, new in Go 1.16, will panic when used on a ZIP archive containing files that start with \u0026quot;../\u0026quot;. via Go 1.16.1 and Go 1.15.9 are released  （以下未稿）\n例によって\u0026hellip; Ubuntu の APT で管理している Go コンパイラは古いので，ダウンロードページからバイナリ（go1.16.1.linux-amd64.tar.gz）を取ってきて手動でインストールすることを強く推奨する。 以下は手動での作業例。\n$ cd /usr/local/src $ sudo curl -L \u0026#34;https://golang.org/dl/go1.16.1.linux-amd64.tar.gz\u0026#34; -O $ cd .. $ sudo unlink go # 以前の Go が入っている場合 $ sudo tar xvf src/go1.16.1.linux-amd64.tar.gz $ sudo mv go go1.16.1 $ sudo ln -s go1.16.1 go $ go version # /usr/local/go/bin にパスが通っている場合 go version go1.16.1 linux/amd64 アップデートは計画的に。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "Git v2.30.2 のリリース【セキュリテイ・アップデート】",
      "section": "release",
      "description": "アップデートは計画的に。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/git-2_30_2-is-released/",
      "published": "2021-03-10T09:41:10+00:00",
      "update": "2021-03-10T10:03:28+00:00",
      "content": "Git v2.30.2 がリリースされた。\n [ANNOUNCE] Git v2.30.2 and below for CVE-2021-21300 - Junio C Hamano  タイトルにもあるとおり，今回は CVE-2021-21300 の修正を含んでいる。\nA specially crafted repository that contains symbolic links as well as files using a clean/smudge filter such as Git LFS, may cause just-checked out script to be executed while cloning onto a case-insensitive file system such as NTFS, HFS+ or APFS (i.e. the default file systems on Windows and macOS).\nNote that clean/smudge filters have to be configured for that. Git for Windows configures Git LFS by default, and is therefore vulnerable.\n via malicious repositories can execute remote code while cloning · Advisory · git/git · GitHub  流石にク◯ったれな HFS+ は駆逐されていると思うが， NTFS と APFS をファイルシステムとして使っているプラットフォームは要注意である。 Windows や macOS パソコンだけじゃなくて， NTFS で NAS を構成している場合も結構ヤバいんじゃないかな？\nGit for Windows に関しては既にアップデートが出ている。\n Release MinGit v2.29.2.windows.4 · git-for-windows/git · GitHub Release Git for Windows 2.30.2 · git-for-windows/git · GitHub  他のプラットフォームでも順次アップデートしていくのがいいだろう。 今回の条件に該当するけどすぐにアップデートできない場合は，とりあえず\n$ git config --global core.symlinks false としてシンボリック・リンクを無効にすることで回避できるらしい。\nアップデートは計画的に。\nCVE-2021-21300 GitHub による評価：\n CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:N 深刻度: 重要 (Score: 8)     基本評価基準 評価値     攻撃元区分 ネットワーク   攻撃条件の複雑さ 高   必要な特権レベル 不要   ユーザ関与レベル 要   スコープ 変更あり   機密性への影響 高   完全性への影響 高   可用性への影響 なし    "
    },
    {
      "title": "Baldanders.info サイトにおける OpenPGP 鍵管理の変更",
      "section": "remark",
      "description": "来年から本気出す（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/changing-publickey-management/",
      "published": "2021-03-06T10:43:36+00:00",
      "update": "2021-03-06T10:47:09+00:00",
      "content": "このブログを含む Baldanders.info の各サイトでは，私個人の OpenPGP 公開鍵を公開している。 実は2013年から年次鍵の運用を止めて単一で永続的な鍵運用に切り替えたのだが，来年からまた短期の運用に戻すことにした。\n具体的には\n 現行の公開鍵の有効期限を 2022-03-31 に変更する（変更済） 2022年4月以降に使用する鍵は最長で2年の有効期限付きで作成する 単一の鍵で運用するのではなく目的別に鍵を分ける  OpenSSH のクライアント認証鍵は GnuPG ベースのものに切り替える 鍵同士の相互署名はしない    という感じで行こうかと。\n理由のひとつは，現在ドラフト中の NIST FIPS 186-5 から DSA が削除されるというもの。\n FIPS 186-5 (Draft), Digital Signature Standard (DSS) | CSRC  もうひとつの理由は GnuPG において第3者による OpenPGP 鍵への電子署名の社会的信頼度が下がってきたことだ。 もともと，第3者による OpenPGP 鍵への電子署名は「小切手の裏書き」みたいなもので，多数の署名が永続的に存在することで鍵の信頼性が担保できていたのだが，その前提が崩れ去ってしまったのだ。\n OpenPGP 公開鍵サーバにおける公開鍵の汚染問題  こうなると従来の OpenPGP 鍵サーバをベースにした鍵運用は大して意味がないし（せいぜい手渡しよりは便利という程度），単一の鍵を長期的に利用ドメインを跨いで使い回すのは却ってリスクになりかねない。\nさらに，強いて3つ目を挙げるなら「電子メールはオワコン」ということだろうか。 少なくとも署名・暗号化しないといけないようなメッセージ・データを電子メールで配送するというのはもうナシだろう。 PPAP 以前の問題。 Thunderbird による OpenPGP 鍵利用が使いものにならないというのもあるが（笑）\n暗号鍵の運用については NIST SP 800-57 が参考になるだろう。 この中で暗号鍵の使用期間と暗号期間について推奨値が示されている。 こんな感じ。\n main table.cryptoperiod th { vertical-align:middle; text-align: center; } main table.cryptoperiod td { vertical-align:middle; }    Key Type Cryptoperiod  Originator-Usage\nPeriod (OUP) Recipient-Usage\nPeriod     1. Private Signature Key 1 to 3 years −  2. Public Signature-VerificationKey Several years (depends on key size)  3. Symmetric Authentication Key $\\le 2$ years $\\le \\mathrm{OUP}+3$ years  4. Private Authentication Key 1 to 2 years  5. Public Authentication Key 1 to 2 years  6. Symmetric Data Encryption Keys $\\le 2$ years $\\le \\mathrm{OUP}+3$ years  7. Symmetric Key-Wrapping Key $\\le 2$ years $\\le \\mathrm{OUP}+3$ years  8. Symmetric RBG Keys See SP 800-90 −  9. Symmetric Master Key/Key Derivation Key About 1 year −  10. Private Key Transport Key $\\le 2$ years  11. Public Key Transport Key 1 to 2 years  12. Symmetric Key Agreement Key 1 to 2 years  13. Private Static Key Agreement Key 1 to 2 years  14. Public Static Key Agreement Key 1 to 2 years  15. Private Ephemeral Key Agreement Key One key-agreement transaction  16. Public Ephemeral Key Agreement Key One key-agreement transaction  17. Symmetric Authorization Key $\\le 2$ years  18. Private Authorization Key $\\le 2$ years    uggested cryptoperiods for key types (via SP 800-57 Part 1 Revision 5  5.3.6)  HTTPS など X.509 ベースで運用される公開鍵の有効期間が1年程度の短期運用に切り替わっているのに気付いている人も多いだろう。 OpenPGP 鍵は ad hoc 運用だし合わせる必要はないと思っていたが，永続的な鍵運用に価値がないならこっちに合わせるべきだよね。\nとりあえず，現行の OpenPGP 公開鍵は\n$ gpg --fetch-keys https://baldanders.info/pubkeys/spiegel.asc で有効期限付きのものに更新できる。\nぶっちゃけ個人で鍵を2,3年おきに更新するのって面倒くさいんだよね。 まぁ，実際の運用をどうするか（暗号デバイスの導入も含めて）これから3年以内には確立させる予定。 3年もあれば暗号界隈のシーンも変わっているだろうけど（笑）\nブックマーク  Kernel Maintainer PGP guide — The Linux Kernel documentation OpenPGP SSH access with Yubikey and GnuPG · GitHub セキュリティ関連NIST文書：IPA 独立行政法人 情報処理推進機構  鍵管理における推奨事項 第一部：一般事項    そろそろ GnuPG でも ECC を標準で使うのがいいんじゃないかな OpenSSH の認証鍵を GunPG で作成・管理する  参考図書  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n "
    },
    {
      "title": "RSA は砕けない（たぶん？）",
      "section": "remark",
      "description": "まだあわてるような時間じゃない（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/rsa-is-unbreakable/",
      "published": "2021-03-06T00:33:55+00:00",
      "update": "2021-03-06T00:44:23+00:00",
      "content": "こっち方面のアンテナがすっかり鈍ってしまって，気付いたのがやっと昨日なのだが\n Cryptology ePrint Archive: Report 2021/232 - Fast Factoring Integers by SVP Algorithms  という論文を巡ってちょっとした騒ぎになっていたらしい。 いや abstract に This destroys the RSA cryptosystem とか書いてあるもんで，その筋の方々が色めき立っちゃたようだ（笑）\nこれについて Bruce Schneier 先生も\nIt does not. At best, it’s an improvement in factoring — and I’m not sure it’s even that. via No, RSA Is Not Broken - Schneier on Security  とおっしゃっている。 論文自体の査読もまだだし，これから要検証という感じ。 少なくとも2020年時点で RSA-250 の解読には成功してるんだから，それとの比較で評価できるだろう。\n要するに「まだあわてるような時間じゃない」ということだ。 まぁ，でも，これから鍵を替えるなら ECC 鍵がいいんじゃないかな（笑）\n そろそろ GnuPG でも ECC を標準で使うのがいいんじゃないかな SSH の認証鍵を GunPG で作成・管理する Edwards-curve Digital Signature Algorithm  ブックマーク  Does Schnorr\u0026rsquo;s 2021 factoring method show that the RSA cryptosystem is not secure? - Cryptography Stack Exchange Schnorr\u0026rsquo;s factorization algorithm - Issuance Policy - Let\u0026rsquo;s Encrypt Community Support  参考図書  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n "
    },
    {
      "title": "特殊形式による式評価について",
      "section": "golang",
      "description": "Go の言語仕様を読みましょう（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/special-forms/",
      "published": "2021-03-04T10:27:13+00:00",
      "update": "2021-03-04T11:54:38+00:00",
      "content": "元ネタが Zenn の記事だし小ネタだし，どちらで書こうか悩んだが，今まで書いたことがない切り口な気がするので，こっち側で。\nいきなりだが，以下のコードを起点に話を始めよう。\npackage main import \u0026#34;fmt\u0026#34; func main() { ageMap := map[string]uint{ \u0026#34;Alice\u0026#34;: 18, \u0026#34;Teles\u0026#34;: 20, } fmt.Println(ageMap[\u0026#34;Alice\u0026#34;])  // Output  // 18 } このコードをみて分かるように，インデックス式 ageMap[x] の評価結果は uint 型になっている（インデックス値が存在しない場合はゼロ値がセットされる）。 まぁ，当たり前だよね。\nところが ageMap[x] の評価結果を (uint, bool) の組（tuple）で受けることもできるのだ1。 これによってコードを\npackage main import \u0026#34;fmt\u0026#34; func main() { ageMap := map[string]uint{ \u0026#34;Alice\u0026#34;: 18, \u0026#34;Teles\u0026#34;: 20, } if age, ok := ageMap[\u0026#34;Selene\u0026#34;]; ok { fmt.Println(age) } else { fmt.Println(\u0026#34;unknown\u0026#34;) }  // Output  // unknown } と書き換えることでき， ageMap[x] の評価に失敗した際の挙動を記述できる。 Go の言語仕様では，これを「特殊形式（special form）」と呼んでいる（日本語が怪しいのはご容赦）。\n言語仕様を眺めてみると，この特殊形式が適用可能なのは以下の3つのみのようだ。\n   # Expressions Normal Form Special Form     1 Index Expression on Map foo := bar[x] foo, ok := bar[x]   2 Type Assertion foo := bar.(T) foo, ok := bar.(T)   3 Receive Expression foo := \u0026lt;-ch foo, ok := \u0026lt;-ch    最初のはインデックス値 x が map にない場合に false になる。 2番目は型 T でのアサーションに失敗した場合に（panic を吐くことなく） false になる。 最後のはチャネル ch が閉じている場合に false になる。\n他の式評価や関数の返り値ではこのようなことはできない。 たとえば slice のインデックス式評価に特殊形式はない。 インデックス値が範囲外なら単に panic が投げられるだけだ。\n実は，特殊形式が上の3つの式評価でしか適用されないというのが分からなくて「どうして普通の関数の返り値とかではできないんだろう」とひとしきり悩んだことがあったのだった。 言語仕様を読めっての（笑）\nブックマーク  The Go Programming Language Specification - The Go Programming Language Goの言語仕様書精読のススメ \u0026amp; 英語彙集 Go言語における式の評価文脈を理解する  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n   厳密には，特殊形式 (T, bool) の2要素目は型付けなしの真偽値（untyped boolean）に評価される。「型付けなし（untyped）」というのは Go 特有の概念だそうで，具体的な型が決定される前の状態を指す。たとえば，定数 math.Pi は10進数64桁の小数点数で定義されている。型付けなし定数については『プログラミング言語Go』の3.6.2章にも解説がある。 \u0026#x21a9;\u0026#xfe0e;\n   "
    }
  ]
}
