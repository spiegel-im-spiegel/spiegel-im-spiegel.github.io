{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "Java のサポート期限ってどうなってるんだっけ？",
      "section": "release",
      "description": "アップデートは計画的に。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/java-support-roadmap/",
      "published": "2021-03-19T11:25:53+00:00",
      "update": "2021-03-19T22:41:30+00:00",
      "content": "ぶっちゃけ PlantUML を動かす程度の利用なら最新の OpenJDK だけ気にしていればよかったんだけど，仕事で Java を使うとなればそういうわけにもいかない。 けど，今の Java のサポート期限ってどうなってるんだっけ？\nまずは Oracle Java。 これははっきりしている。\n Oracle Java SE Support Roadmap  これによると\n   Release GA Date Premier Support Extended Support     7 2011-07 2019-07 2022-07   8 2014-03 2022-03 2030-12   9 2017-09 2018-03 -   10 2018-03 2018-09 -   11 (LTS) 2018-09 2023-09 2026-09   12 2019-03 2019-09 -   13 2019-09 2020-03 -   14 2020-03 2020-09 -   15 2020-09 2021-03 -   16 2021-03 2021-09 -   17 (LTS) 2021-09 2026-09 2029-03    ということらしい1（どのバージョンでも Sustaining Support は無期限で受けれるため省いた）。 つまり Premier Support を受けれるバージョンは現時点（2021-03）で 8, 11, 15/16 が対象となる（15 は 2021-03 まで）。 Extended Support なら 7 も含まれる（Java 7 なら費用は免除）。\n一方 OpenJDK はよく分からない。\nJava 10 以降なら（リリースサイクルが半年毎というだけで）特にサポート期限というものはないみたい。 向こうが「やーめた」と言うまではアップデートを出し続けるのかな？ 7u と 8u については記述がなかったが，四半期ごとのマイナーアップデートの対象になってるみたいなので，一応はサポートしていると思われる。 まぁ， Oracle Java や AdoptOpenJDK, OpenJ9 などからフィードバックがあるのかもしれない。\nちなみに AdoptOpenJDK のサポート期限は\n Support | AdoptOpenJDK - Open source, prebuilt OpenJDK binaries  によると\n   バージョン First Availability End of Availability     8 (LTS) 2014-03 at least 2022-05   9 2017-09 2018-03   10 2018-03 2018-09   11 (LTS) 2018-09 2024-10   12 2019-03 2019-09   13 2019-09 2020-03   14 2020-03 2020-09   15 2020-09 2021-03   16 2021-03 2021-09   17 (LTS) 2021-09 (TBC)    となっていた。 現時点（2021-03）では 8, 11, 15/16 がサポート対象だ（15 は 2021-03 まで）。\n今はクラウドサービスごとに独自のディストリビューションを提供してたりするので， 11 以降ならあまり気にする必要はないのかな。 今だに 8/8u を使ってるサービス（行政サービスとか多そうだw）は，そろそろ未来について（Java を捨てる選択肢も含めて）議論したほうがいいだろう。\nなお，年間のリリース・イベントは以下の通り。\n   月 バージョンアップ・イベント     1月 マイナー・バージョンアップ   2月    3月 メジャー・バージョンアップ   4月 マイナー・バージョンアップ   5月    6月    7月 マイナー・バージョンアップ   8月    9月 メジャー・バージョンアップ   10月 マイナー・バージョンアップ   11月    12月     アップデートは計画的に。\nブックマーク  Eclipse Adoptium | projects.eclipse.org  AdoptOpenJDKプロジェクトがEclipse Foundationへの合流を発表。合流後の新プロジェクト名は「Eclipse Adoptium」に － Publickey   AWS、「Java 8」を2026年まで、「Java 11」は2027年まで、現行より3年サポート期間延長を発表。独自JavaディストリビューションのCorretto 8とCorretto 11で － Publickey OpenJDKと各種JDKディストリビューションの情報源まとめ  参考図書  Effective Java 第3版 Joshua Bloch (著), 柴田 芳樹 (翻訳) 丸善出版 2018-10-30 単行本（ソフトカバー） 4621303252 (ASIN), 9784621303252 (EAN), 4621303252 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  再勉強中。 Kindle 版のほうがちょっと安いが，勤務先でも使いたかったので紙の本にした。\nreviewed by Spiegel on 2021-03-17 (powered by PA-APIv5)\n   Oracle Java 8 はクライアント側での利用と開発目的での利用のみ許可されている。サーバ側での運用は別途有償契約が必要（の筈）。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Go を褒め殺ししてみる",
      "section": "remark",
      "description": "はやく作って はやく改す",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/awesome-golang/",
      "published": "2021-03-18T11:16:13+00:00",
      "update": "2021-03-18T11:17:55+00:00",
      "content": "母国語としてのプログラム言語 以前紹介したのだが，結城浩さんの過去の連ツイに\n プログラミング言語との付き合い方というのはいろいろあってですね。自分の母国語という言語はある。それから現在学んでいる最中の言語というのもある。そして、仕事用の言語やら、他の人とのコミュニケーション用言語というのもある。そのあたりは、自然言語とちょっと似ている。\nITな業界で仕事をしているひとというのは、だいたいそういう感じでプログラミング言語とつきあっていると思っている。たった一つしかプログラミング言語ができないという人は少なくて、二つくらいは読み書きできる。三つ四つくらいはなんとなく読むのはできる。五つ六つくらいは何のソースか言える。\n 考えてみると結城はC, Perl, Javaの本は書いたけれど...より  という記述がある。\nまぁ「仕事用の言語」や「コミュニケーション用言語」ってのは独りで選ぶものではないので今回は除外するとして，「母国語」というのは上手い比喩だ。 自然言語と同じで「母国語」として定着しているプログラミング言語があればロジックや制御への理解も速いし，他言語を習得する際にも有利になる。\nでも最初から「◯◯言語を母国語として習得するぞ」とかいう人はいないだろう。 使い込んで手に馴染んでいって初めて「母国語」になり得る。 問題は「どの言語か」ではなく「手に馴染むまで使い込むほどの動機があるか」だと思う。\n「これからプログラミングを始めるならどの言語にすればいいか」という問いは今の季節の風物詩みたいなものだが，この問いだけでは「始める」動機が見えないし，その人が既に「母国語」と言えるものを持っているか否かで話も変わってくる。\n先日見かけた\n これから勉強するならGolangとRustのどちらがいいでしょうか？難易度も含めて推奨お願いします。 - Quora  という記事も似たような印象を受けたが，回答に挙がっている Rust と Go の比較はなかなか興味深く，また大いに共感した。 ただ，回答された方は Rust 寄りみたいなので，対抗して私は Go を褒め殺ししてみる（笑）\nなお，あらかじめ予防線を張っておくと，私は言語オタクでも文房具オタクでもないし，その手の宗教論争に巻き込まれたくないので，異論反論（当然あると思うけど）には反応しないのであしからず。\n（前説おわり）\nはやく作って はやく改（なお）す1 昔は「はやく作る」というのはスクリプト言語の独壇場だった。 近年のバズワードだった「AI」技術において Python が大きな牽引力として機能しているのは Python が「はやく作る」ことに特化した言語であることも大きいだろう。\nしかし Go がこの状況を変えていく。\nGo はコンパイル言語には珍しく（と言っていいのか分からないが）「はやく作る」ことに特化した言語と言っていい。 「はやく作る」というのは事前学習量やコンパイル速度やコード記述量を指しているのではなく「考えたことをそのまま書いて安全に組めるか」ということだ。 Go の言語仕様に組み込まれた簡便さも制約もこの目的のためにあると言ってよい。\nたとえば Go は Java などの伝統的オブジェクト指向プログラミング言語とよく比較されるが，例外処理や継承など「考えたことをそのまま書く」ことにおいてノイズにしかならないギミックをあっさり捨て去っている。 Goroutine 間に優先順位が存在しないのも sync.Mutex が再入不可なのもちゃんと理由があるのだ（Generics は結局組み込むみたいだけどw）。\nちなみに「はやく作る」ことは「雑に作る」ことではない。 近年の流行語である「技術的負債」の本来の意図は「はやく作る」ことと引き換えにしているものを金融用語の「負債」に喩えたことだそうだ。つまり技術的負債の「返済」とは，システムやプログラムを「直す」ことではなく「改（なお）す」つまりリファクタリングを指している。\nもうひとつの Go の特徴は，このリファクタリングに厚い言語であるということだ。 シンプルな言語仕様故に手を入れやすいし， interface 型による「構造型の部分型付け（structural subtyping）」によってオブジェクト間の関係を「疎」にできるため，再利用性の高い機能を別パッケージとして切り離したり，なんなら「出来のよくないパッケージを丸ごと入れ替える」なんてことも比較的容易だったりする。\n一言で言うなら「はやく作って はやく改せる」のが Go 最大のメリットである。 道具に耽溺するのでなく振り回されるのでなく，自らのアイデアを「いい感じ」に実装する手段としてプログラミング言語を求めるのなら Go を選択するのは悪くない，と言っておこう。\n「文」の制約 Go の言語仕様を読むところまで慣れた方なら気づいてると思うけど， Go は文（statement）の制約が強い言語である。 文の制約を強くすることで全体の言語仕様をシンプルにしている，とも言えるが。\nたとえば if, switch, for といった制御文や = などの代入文は式（expression）として評価できないため，式の一部または全部として組み込めない。 分かりやすい例としては C/C++ などでは悪名高いインクリメント2 “x++” は代入構文のバリエーションとして評価されるため，式の一部として組み込めない，とかいったことがある。\ny := ary[x++] // syntax error あるいはもっと簡単に\na = b = c = 1 // syntax error とかも無理。\nこういった制約は，特に関数型プログラミング言語から来た人には大きな不満となるだろう。 この理由で Go に馴染めないというのであれば Rust のほうをお勧めする（笑）\n富豪的プログラミングの代償 並列処理とメモリ管理はどんな言語でも悩ましい問題である。 特に両者が組み合わさると非常に厄介と言える。\nたとえばスクリプト言語や Virtual Machine 上の動作を前提とした処理系ではスクリプト・エンジンや VM が並列処理やメモリ管理の厄介な部分を引き受けてくれるが， Go ではこれらを実行モジュールに組み込むことで高いパフォーマンス（とシングル・バイナリでのデプロイ）を可能としている。\n富豪的プログラミングの観点からは，これらの仕組みはプログラマに有利に働く。 最初の節で紹介した Q\u0026amp;A の回答でも\n 言語仕様が小さくて、コンパイルがとても速く、GC (Garbage Collector)を採用してメモリ管理の煩わしさをなくすとともに、並列実行を容易にしています。\nその分、単体での実行速度については妥協していますが、速度を求めるのなら処理を並列化しつつマシン側（実行環境）を増強すれば良い、というクラウド時代の解決策をとっています。つまり、コードのちまちまとした最適化で悩んでいる暇があるなら札束で殴ってさっさと解決しろ、ということですね。とても効率的な考え方です。\n これから勉強するならGolangとRustのどちらがいいでしょうか？難易度も含めて推奨お願いします。 - Quoraより  と解説されている。まさに富豪的（笑）\nしかし，これと引き換えに「小さなシステム」に対しては無視できない代償を支払っている。 これは並列処理やメモリ管理を実行バイナリに埋め込むために POSIX への依存度が高くなっているためだ。\n小さなシステムやシビアなリアルタイム処理3 には Go は向かないだろう。ましてやデバイスドライバや pure Go な OS カーネルなど夢のまた夢である。 そういうものに興味があるのであれば Rust のほうがお勧めだ。\nなお，個人的に興味を持っている TinyGo なら LLVM ベースの小さいバイナリを生成することができる。組み込み用途であればこういった選択肢はありだと思う。\n本当は WebAssembly に興味があるのだが，少なくとも Go 側が WASI (WebAssembly System Interface) をサポートしてくれないと無理かなぁ。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n  プログラミングRust Jim Blandy (著), Jason Orendorff (著), 中田 秀基 (翻訳) オライリージャパン 2018-08-10 単行本（ソフトカバー） 4873118557 (ASIN), 9784873118550 (EAN), 4873118557 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版あり。公式ドキュメントよりも系統的に書かれているので痒いところに手が届く感じ。ただし量が多いので，一度斜め読みしたらあとは傍らに置いて必要に応じてつまみ食いしていくのがいいだろう。\nreviewed by Spiegel on 2020-03-08 (powered by PA-APIv5)\n  Effective Java 第3版 Joshua Bloch (著), 柴田 芳樹 (翻訳) 丸善出版 2018-10-30 単行本（ソフトカバー） 4621303252 (ASIN), 9784621303252 (EAN), 4621303252 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  再勉強中。 Kindle 版のほうがちょっと安いが，勤務先でも使いたかったので紙の本にした。\nreviewed by Spiegel on 2021-03-17 (powered by PA-APIv5)\n   「改す」を「なおす」と読むのは辞書的に正しい日本語ではありません。念のため（笑） \u0026#x21a9;\u0026#xfe0e;\n C/C++ ではインクリメント/デクリメント演算子は前置（++x）と後置（x++）があって機能が異なる。これに起因する不具合も多く，コーディング・ルールで「インクリメント/デクリメントの後置は禁止」とするところが多いらしい。 \u0026#x21a9;\u0026#xfe0e;\n ここでいうリアルタイム処理とは「分割されたジョブを決められたタイミングで決められた期間内に完了すること」を指す。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Java 16 がリリースされた",
      "section": "release",
      "description": "OpenJDK および同系列 Java のショート・サイクルのバージョンアップ",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/java-16-is-released/",
      "published": "2021-03-17T10:32:20+00:00",
      "update": "2021-03-19T09:39:05+00:00",
      "content": "予定通り Java 16 がリリースされた。 OpenJDK および同系列 Java におけるショート・サイクルのバージョンアップである。\n JDK 16 JDK 16 GA Release JDK 16 Release Notes  OpenJDK を APT で管理するメリットはないので，実行バイナリをリリースページから直接ダウンロードして配置する。 以下は完全手動でのインストール（笑）\n$ cd /usr/local/src $ sudo curl -L \u0026#34;https://download.java.net/java/GA/jdk16/7863447f0ab643c585b9bdebf67c69db/36/GPL/openjdk-16_linux-x64_bin.tar.gz\u0026#34; -O $ cd .. $ sudo unlink java # 以前のバージョンの Java 環境がある場合 $ sudo tar xvf src/openjdk-16_linux-x64_bin.tar.gz $ sudo ln -s jdk-16 java $ java -version # すでに PATH が通っている場合 openjdk version \u0026#34;16\u0026#34; 2021-03-16 OpenJDK Runtime Environment (build 16+36-2231) OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing) 私としては PlantUML が動けばいいので，試しておく1。\nFactory Method Pattern  うむうむ。 ちゃんと動くな。\nScoop で OpenJDK 16 を入れる Windows 環境では Scoop を使って OpenJDK を入れているのだが，なかなかアップデートされない。 そこでバケットの中を見てみたのだが\n$ scoop search openjdk \u0026#39;java\u0026#39; bucket: adoptopenjdk-hotspot-jre (15.0.2-7) adoptopenjdk-hotspot (15.0.2-7) adoptopenjdk-lts-hotspot-jre (11.0.10-9) adoptopenjdk-lts-hotspot (11.0.10-9) adoptopenjdk-lts-openj9-jre (11.0.10-9-0.24.0) adoptopenjdk-lts-openj9-xl-jre (11.0.10-9-0.24.0) adoptopenjdk-lts-openj9-xl (11.0.10-9-0.24.0) adoptopenjdk-lts-openj9 (11.0.10-9-0.24.0) adoptopenjdk-lts-upstream-jre (11.0.10-9) adoptopenjdk-lts-upstream (11.0.10-9) adoptopenjdk-openj9-jre (16-36-0.25.0) adoptopenjdk-openj9-xl-jre (15.0.2-7-0.24.0) adoptopenjdk-openj9-xl (15.0.2-7-0.24.0) adoptopenjdk-openj9 (16-36-0.25.0) openjdk-ea (16-36) openjdk (15.0.2-7) openjdk10 (10.0.2-13) openjdk11 (11.0.2-9) openjdk12 (12.0.2-10) openjdk13 (13.0.2-8) openjdk14 (14.0.2-12) openjdk15 (15.0.2-7) openjdk16 (16-36) openjdk7-unofficial (7u80-b32) openjdk8-redhat-jre (8u282-b08) openjdk8-redhat (8u282-b08) openjdk9 (9.0.4-12) んー。 openjdk だと 16 に上がらないのか。 どうやら openjdk16 のようにバージョンを指定したほうがいいようだ。\nというわけで\n$ scoop install openjdk16 Installing \u0026#39;openjdk16\u0026#39; (16-36) [64bit] openjdk-16_windows-x64_bin.zip (175.1 MB) [===================================================================] 100% Checking hash of openjdk-16_windows-x64_bin.zip ... ok. Extracting openjdk-16_windows-x64_bin.zip ... done. Linking ~\\scoop\\apps\\openjdk16\\current =\u0026gt; ~\\scoop\\apps\\openjdk16\\16-36 $ scoop uninstall openjdk Uninstalling \u0026#39;openjdk\u0026#39; (15.0.2-7). Unlinking ~\\scoop\\apps\\openjdk\\current Removing ~\\scoop\\apps\\openjdk\\current\\bin from your path. Removing older version (15.0.1-9). \u0026#39;openjdk\u0026#39; was uninstalled. という感じに入れ換えた。 Windows Terminal を起動し直して\n$ java -version openjdk version \u0026#34;16\u0026#34; 2021-03-16 OpenJDK Runtime Environment (build 16+36-2231) OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing) よしよし，ちゃんと 16 になったな。 ちなみに各パッケージの旧バージョンを削除する場合は\n$ scoop cleanup openjdk16 などとすれば，最新バージョン以外は削除される。\n参考図書  Effective Java 第3版 Joshua Bloch (著), 柴田 芳樹 (翻訳) 丸善出版 2018-10-30 単行本（ソフトカバー） 4621303252 (ASIN), 9784621303252 (EAN), 4621303252 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  再勉強中。 Kindle 版のほうがちょっと安いが，勤務先でも使いたかったので紙の本にした。\nreviewed by Spiegel on 2021-03-17 (powered by PA-APIv5)\n   2021-03-07 に PlantUML Version 1.2021.2 がリリースされている。 PlantUML の使い方等については拙文「真面目に PlantUML」シリーズを参考にどうぞ。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "『再発見の発想法』は非エンジニアこそ読んで欲しい",
      "section": "remark",
      "description": "3月14日は「円周率の日」で「数学の日」でアインシュタイン博士の誕生日である。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/the-essence-of-programming/",
      "published": "2021-03-13T22:31:13+00:00",
      "update": "2021-03-13T22:31:32+00:00",
      "content": "3月14日は「円周率の日」で「数学の日」でアインシュタイン博士の誕生日である。 世界の数学者と理学者と工学者は今日というめでたい日を盛大に祝うんだ！\nというわけで，今回は結城浩さん著作の『再発見の発想法』の感想文なんぞを書いてみる。 読書感想文は久しぶりだな（笑）\nソフトウェエア・エンジニアというのは不思議な職業で，それ単体では成立し得ない。 何故ならソフトウェアを使う人の多くはソフトウェエア・エンジニア以外の人たちだからだ。\nたとえば工場 (こうば) の工員さんやコールセンターの中の人，役場のお役人様やタクシーや長距離トラックの運ちゃん，そういった人たちのために私達エンジニアは日々頭を悩ませている。\n特に悩ましいのは業種や職場によって独自の用語や隠語があることだ。 だから私達はシステムを作る際にはまず「用語集」を作る。\n『再発見の発想法』6.2章に出てくる「ベンチマーク（benchmark）」という単語なんかが典型的だが，同じ言葉なのに業種によって少しずつ意味が異なることがある。 そうした言葉の背後にある差異に気づかず設計を推し進めると，後でとんでもないしっぺ返しを食らったりするのだ。\nでも，最初の段階でお互いに言葉をすり合わせて「用語集」を作っておくと，以後のコミュニケーションがスムーズになる。 特に考え方や手段といった目に見えないものに「名前」を付けることは重要で，名前を付けることで議論のアンカーもしくは原点として機能し始める。 私は名前の「正しさ」というものを全く信用していない不遜な人間だが，当事者がお互いに同じ言葉を同じ意味で話すことの重要性は理解しているつもりである。\nとはいえ，私達エンジニアが普段どんな言葉を喋ってどんな思考のもとに設計しコードを組み立てていくか知ってほしいというのも本音だ。\nそこで，いよいよ『再発見の発想法』の登場である。\nこの本は結城浩さんによる「Software Design」誌上の同名連載をまとめたものだそうで，さまざまな「技術用語」について解説したものだ。 しかし，内容は技術系雑誌に掲載されていたとは思えないほど平易な言葉で書かれている。\n用語の意味とその背後にある考え方と日常生活になぞらえた例示が絶妙なバランスで配置されていて，この辺のさじ加減の上手さは流石結城浩さんと言うしかない。 やはり《例示は理解の試金石》（by 数学ガール）なんだねぇ。\nソフトウェア・エンジニアリングの有名な格言（？）に「推測するな，計測せよ」というのがある。 『再発見の発想法』に出てくる技術用語の選択は，まさに 計測→評価→改修 というエンジニアリングの基本サイクルを意識している印象がある。\n技術系雑誌の連載が出自だし「再発見」というタイトルには私達エンジニアが普段使っている言葉を見直すという意味が含まれているのだろうが，私としてはこの本は非エンジニアの方々あるいはエンジニアを目指す若い方々にこそ読んで欲しい。 そして，本に出てくる言葉をエンジニアがつぶやいているときは「こういう風に考えてるんだなぁ」と感じていただければ幸いである。\nさて，積ん読状態の「数学ガール」シリーズも読み進めないとなぁ。 ようやく「本を読む」余裕が出てきたよ。\n参考図書  再発見の発想法 結城 浩 (著) SBクリエイティブ 2021-02-19 (Release 2021-02-20) Kindle版 B08S2LY9VG (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  「Software Design」誌の同名連載の書籍化。「技術用語」の解説書だが，平易な内容で読みやすい。\nreviewed by Spiegel on 2021-03-14 (powered by PA-APIv5)\n  プログラマの数学 第2版 結城 浩 (著) SBクリエイティブ 2018-01-16 (Release 2018-02-08) Kindle版 B079JLW5YN (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  タイトル通りプログラマ必読書。第2版では機械学習に関する章が付録に追加された。\nreviewed by Spiegel on 2018-03-19 (powered by PA-APIv5)\n  イミテーション・ゲーム／エニグマと天才数学者の秘密(字幕版) ベネディクト・カンバーバッチ (出演), キーラ・ナイトレイ (出演), マシュー・グード (出演), ロリー・キニア (出演), モルテン・ティルドゥム (監督), グラハム・ムーア (Writer)  (Release 2015-10-02) Prime Video B015SAFU42 (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  主人公であるアラン・チューリングは今もなお「天才」と称される数学者であり，「コンピュータの父」と呼ばれるほどの偉人である。そしてチューリングの偉業のひとつが，旧ナチス・ドイツの暗号機械「エニグマ」の解読である。作品はそのエニグマの解読を主軸に物語を展開していく。感想はこちら。\nreviewed by Spiegel on 2015-04-19 (powered by PA-APIv5)\n "
    },
    {
      "title": "Go 1.16.2 がリリースされた",
      "section": "release",
      "description": "セキュリティ・アップデートはなし。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/go-1_16_2-is-released/",
      "published": "2021-03-11T23:27:46+00:00",
      "update": "2021-03-11T23:30:23+00:00",
      "content": "Go 1.16.2 がリリースされた。\n Go 1.16.2 and Go 1.15.10 are released  セキュリティ・アップデートはなし。 一度に出せよ orz\ngo1.16.2 (released 2021/03/11) includes fixes to cgo, the compiler, linker, the go command, and the syscall and time packages. See the Go 1.16.2 milestone on our issue tracker for details. via Release History - The Go Programming Language  例によって Ubuntu の APT で管理している Go コンパイラは古いので，ダウンロードページからバイナリ（go1.16.2.linux-amd64.tar.gz）を取ってきて手動でインストールすることを強く推奨する。 以下は手動での作業例。\n$ cd /usr/local/src $ sudo curl -L \u0026#34;https://golang.org/dl/go1.16.2.linux-amd64.tar.gz\u0026#34; -O $ cd .. $ sudo unlink go # 以前の Go が入っている場合 $ sudo tar xvf src/go1.16.2.linux-amd64.tar.gz $ sudo mv go go1.16.2 $ sudo ln -s go1.16.2 go $ go version # /usr/local/go/bin にパスが通っている場合 go version go1.16.2 linux/amd64 アップデートは計画的に。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "TinyGo で WebAssembly",
      "section": "golang",
      "description": "Go および TinyGo を使って WebAssembly へのコンパイルを行い Web ブラウザ上で動作させるところまでやってみる",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/webassembly-with-tinygo/",
      "published": "2021-03-11T12:01:29+00:00",
      "update": "2021-03-11T12:01:50+00:00",
      "content": "TinyGo は本家 Go のサブセットと言えるもので LLVM を使った組み込み用途特化のコンパイラである。 しかも LLVM が WebAssembly バイナリを直接出力できるということもあって TinyGo と WebAssembly の相性は本家 Go 以上と言える。\nというわけで今回は， Go および TinyGo を使って WebAssembly へのコンパイルを行い， Web ブラウザ上で動作させるところまでやってみることにする。\nTinyGo のインストール TinyGo が動作するためには，あらかじめ本家 Go のツールチェーンが導入済みであることが前提となる。 この記事では Go は導入済みであるとして話を進める。\nTinyGo は以下のリポジトリから最新版をダウンロード\u0026amp;インストールする。\n tinygo-org/tinygo: Go compiler for small places. Microcontrollers, WebAssembly, and command-line tools. Based on LLVM.  2021-03-11 時点での最新版は 0.17.0 である。 Go 1.16 以降が推奨らしい。\nUbuntu の場合 Ubuntu の APT や Snap の公式リポジトリにはないので， deb ファイルをダウンロードし，手動でインストールする。\n$ curl -L https://github.com/tinygo-org/tinygo/releases/download/v0.17.0/tinygo_0.17.0_amd64.deb -O $ sudo dpkg -i tinygo_0.17.0_amd64.deb $ tinygo version tinygo version 0.17.0 linux/amd64 (using go version go1.16.1 and LLVM version 11.0.0) ちなみに WSL/WSL2 上の Ubuntu にもインストール可能だそうだ。\nWindows の場合 Windows なら Scoop を使うのが最も簡単である。 Scoop なら本家 Go も簡単にインストールできるし TinyGo 用の周辺ツールも Scoop で簡単に導入できる。\n$ scoop install tinygo $ tinygo version tinygo version 0.17.0 windows/amd64 (using go version go1.16.1 and LLVM version 11.0.0) Docker の場合 Docker 環境も用意されているそうだ。 詳しくはこちら。\n Docker :: TinyGo - Go on Microcontrollers and WASM  ファイル構成 今回のファイル構成はこんな感じ。\n$ tree . . ├── hello │ ├── hello.go │ ├── index.html │ ├── wasm.js │ └── wasm_exec.js └── main.go main.go は簡易サーバのコードで，こんな感じになっている。\npackage main import ( \u0026#34;embed\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/fs\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) //go:embed hello var assets embed.FS func main() { addr := \u0026#34;localhost:3000\u0026#34; fmt.Printf(\u0026#34;Open http://%s/\\n\u0026#34;, addr) fmt.Println(\u0026#34;Press ctrl+c to stop\u0026#34;) root, _ := fs.Sub(assets, \u0026#34;hello\u0026#34;) fs := http.FileServer(http.FS(root)) http.Handle(\u0026#34;/\u0026#34;, http.FileServer(http.FS(root))) if err := http.ListenAndServe(addr, http.HandlerFunc(func(resp http.ResponseWriter, req *http.Request) { resp.Header().Add(\u0026#34;Cache-Control\u0026#34;, \u0026#34;no-cache\u0026#34;) if strings.HasSuffix(req.URL.Path, \u0026#34;.wasm\u0026#34;) { resp.Header().Set(\u0026#34;content-type\u0026#34;, \u0026#34;application/wasm\u0026#34;) } fs.ServeHTTP(resp, req) })); err != nil { fmt.Fprintln(os.Stderr, err) } } embed パッケージと //go:embed ディレクティブが便利！ 簡易サーバのコードについては拙文「紙芝居用の簡易サーバを書く【Go 1.16 版】 」を参照のこと。 今回用の設定としては *.wasm ファイルの Content-Type を application/wasm にすることくらいかな。 あとは no-cache の設定ね。\nwasm_exec.js ファイルは Go および TinyGo が用意しているファイルで，以下からコピってそのまま使えばよい。\n   処理系 パス     Go $GOROOT/misc/wasm/wasm_exec.js   TinyGo $TINYGOROOT/targets/wasm_exec.js    $GOROOT および $TINYGOROOT の値は，以下のコマンドで取得できる。\n$ tinygo env GOOS=\u0026#34;linux\u0026#34; GOARCH=\u0026#34;amd64\u0026#34; GOROOT=\u0026#34;/usr/local/go1.16.1\u0026#34; GOPATH=\u0026#34;/home/username/go\u0026#34; GOCACHE=\u0026#34;/home/username/.cache/tinygo\u0026#34; CGO_ENABLED=\u0026#34;1\u0026#34; TINYGOROOT=\u0026#34;/usr/local/lib/tinygo\u0026#34; みんな大好き Hello World さて hello/hello.go ファイルの中身だが，まずはこんな感じで。\n// +build js,wasm  package main import \u0026#34;syscall/js\u0026#34; func main() { ch := make(chan struct{}) js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, \u0026#34;hello\u0026#34;).Set(\u0026#34;innerHTML\u0026#34;, \u0026#34;Hello, World!\u0026#34;) \u0026lt;-ch // Code must not finish } JavaScript の DOM 構造に慣れている人ならそんなに難しくないだろう。 ID 名 hello の要素に文字列 Hello, World! を突っ込むだけの簡単なお仕事（笑）\nこれを Go および TinyGo の各コンパイラでコンパイルしてみる。\n$ GOOS=js GOARCH=wasm go build -o hello1.wasm -trimpath $ tinygo build -o hello2.wasm -target wasm ./hello.go 前者が本家 Go によるコンパイルで，後者が TinyGo によるコンパイルだ。 コンパイル結果は以下の通り。\n$ ll *.wasm -rwxrwxr-x 1 username username 1364695 3月 10 23:59 hello1.wasm* -rwxrwxr-x 1 username username 67375 3月 10 23:59 hello2.wasm* おうふ。 こんなに違うのか。\n本家 Go のコードが大きいのは，良くも悪くも POSIX 互換環境への依存度が高く組み込み用途に使うには余計なコードを抱え込んでしまうという事情がある。\n一方 TinyGo は LLVM の制約を受けるため，ガベージコレクションや並行処理などで本家 Go とは異なる挙動になる（他にもいくつかの標準パッケージが使えない場合があるらしい）。\nたとえば先ほどの\nfunc main() { ch := make(chan struct{}) js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, \u0026#34;hello\u0026#34;).Set(\u0026#34;innerHTML\u0026#34;, \u0026#34;Hello, World!\u0026#34;) \u0026lt;-ch // Code must not finish } の最後を見ると，チャネル受信状態で処理が止まっているが（というか止めるためにわざわざこのように書いているのだが），これがないと TinyGo コンパイラがエラーを吐く場合があるようだ。\nWebAssembly コードのバインド hello/wasm.js ファイルは生成した WebAssembly コードを JavaScript 側にバインドするものである。 今回は以下のように書いてみた。\nfunction initWASM(url) { const go = new Go(); if (\u0026#39;instantiateStreaming\u0026#39; in WebAssembly) { WebAssembly.instantiateStreaming(fetch(url), go.importObject).then(function (obj) { go.run(obj.instance); }) } else { fetch(WASM_URL).then(resp =\u0026gt; resp.arrayBuffer() ).then(bytes =\u0026gt; WebAssembly.instantiate(bytes, go.importObject).then(function (obj) { go.run(obj.instance); }) ) } } これで\ninitWASM(\u0026#39;hello2.wasm\u0026#39;); という感じに任意の WebAssembly ファイルを取り込める。\nHTML の内容 以上を踏まえて hello/index.html ファイルの内容は以下のようにした。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;wasm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p id=\u0026#34;hello\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; initWASM(\u0026#34;hello2.wasm\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 実行結果 では，いよいよ動かしてみよう。\n$ go run main.go Open http://localhost:3000/ Press ctrl+c to stop 該当の URL を開くと\nHello  よーし，ちゃんと表示されているな。 ここまでは楽勝。\nWebAssembly の機能を JavaScript から呼び出す 以上のコードは WebAssembly 側から HTML 要素に値をセットしていたが，これではあまり応用できないだろう。 なので，今度は JavaScript 側から WebAssembly の機能を呼び出すことを考える。\nまずは hello/hello.go ファイルの内容を以下のように変更する。\n// +build js,wasm  package main import ( \u0026#34;strings\u0026#34; \u0026#34;syscall/js\u0026#34; ) func say(this js.Value, args []js.Value) interface{} { ss := []string{} for _, jss := range args { if s := jsString(jss); s != \u0026#34;\u0026#34; { ss = append(ss, s) } } return js.ValueOf(\u0026#34;Hello, \u0026#34; + strings.Join(ss, \u0026#34;, \u0026#34;)) } func jsString(j js.Value) string { if j.IsUndefined() || j.IsNull() { return \u0026#34;\u0026#34; } return j.String() } func main() { ch := make(chan struct{}) js.Global().Set(\u0026#34;say\u0026#34;, js.FuncOf(say)) \u0026lt;-ch // Code must not finish } JavaScript から呼び出す関数は\nfunc(this js.Value, args []js.Value) interface{} の関数型にする決まりのようだ。 また返り値は js.Value 型にして返すのだが，実際の Go の型と JavaScript の型の対応は以下のようになっているらしい。\n   Go JavaScript     js.Value [its value]   js.Func function   nil null   bool boolean   integers and floats number   string string   []interface{} new array   map[string]interface{} new object     via js - The Go Programming Language  さらに main() 関数内の\njs.Global().Set(\u0026#34;say\u0026#34;, js.FuncOf(say)) によって Go の say() 関数は JavaScript の global.say() 関数に紐付けられる。\nhello/wasm.js ファイルはそのままでOK。 hello/index.html ファイルの内容を以下のように書き換える。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;wasm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;Hello\u0026lt;/button\u0026gt; \u0026lt;p id=\u0026#34;hello\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; initWASM(\u0026#39;hello2.wasm\u0026#39;); document.querySelector(\u0026#39;button\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, event =\u0026gt; { document.getElementById(\u0026#34;hello\u0026#34;).innerHTML = global.say(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Chris\u0026#34;); }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; これで [Hello] ボタン押下で global.say() 関数が発火するはずである。 実行してみよう。\n$ go run main.go Open http://localhost:3000/ Press ctrl+c to stop この状態で画面を表示すると\nHello Button (1)  さらにボタンを押下すると\nHello Button (2)  よーし，うむうむ，よーし。\nこれなら応用が効きそうかな。 今回はここまで。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "OpenSSH 8.5 のリリース【セキュリティ・アップデート】",
      "section": "release",
      "description": "アップデートは計画的に",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/openssh-8_5-is-released/",
      "published": "2021-03-11T10:11:29+00:00",
      "update": "2021-03-11T10:13:04+00:00",
      "content": "先週の話で恐縮だが， 2021-03-03 にリリースされた OpenSSH 8.5 で CVE-2021-28041 の脆弱性の改修がされていたらしい。\nssh-agent in OpenSSH before 8.5 has a double free that may be relevant in a few less-common scenarios, such as unconstrained agent-socket access on a legacy operating system, or the forwarding of an agent to an attacker-controlled host. via NVD - CVE-2021-28041  ssh-agent のソケット周りとかヤバいぢゃん。\nCVSSv3 評価は以下の通り。\n CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H 深刻度: 緊急 (Score: 9.8)     基本評価基準 評価値     攻撃元区分 ネットワーク   攻撃条件の複雑さ 低   必要な特権レベル 不要   ユーザ関与レベル 不要   スコープ 変更なし   機密性への影響 高   完全性への影響 高   可用性への影響 高    実は Ubuntu で，これを修正したらしい OpenSSH 8.3 バックポート・パッチが出てたので気付いた次第。\n USN-4762-1: OpenSSH vulnerability | Ubuntu security notices | Ubuntu  まぁ，アップデートは計画的に，ということで。\n参考図書  SSH Mastery: OpenSSH, PuTTY, Tunnels and Keys (IT Mastery Book 12) (English Edition) Lucas, Michael W (著) Tilted Windmill Press 2018-02-06 (Release 2018-02-06) Kindle版 B079NL1L9K (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  タイトルを見て “SSH Mystery” と空目したアホは私です。洋書だけど英語不得手の私にも読める内容。\nreviewed by Spiegel on 2021-01-11 (powered by PA-APIv5)\n  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n "
    },
    {
      "title": "Go 1.16.1 のリリース【セキュリティ・アップデート】",
      "section": "release",
      "description": "今回は複数の脆弱性について改修されている。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/go-1_16_1-is-released/",
      "published": "2021-03-11T09:52:53+00:00",
      "update": "2021-03-11T23:28:07+00:00",
      "content": "予告通り， Go 1.16.1 がリリースされた。\n [security] Go 1.16.1 and Go 1.15.9 are released  今回は複数の脆弱性について改修されている。\ngo1.16.1 (released 2021/03/10) includes security fixes to the archive/zip and encoding/xml packages. See the Go 1.16.1 milestone on our issue tracker for details. via Release History - The Go Programming Language  encoding/xml: infinite loop when using xml.NewTokenDecoder with a custom TokenReader (CVE-2021-27918) The Decode, DecodeElement, and Skip methods of an xml.Decoder provided by xml.NewTokenDecoder may enter an infinite loop when operating on a custom xml.TokenReader which returns an EOF in the middle of an open XML element. via Go 1.16.1 and Go 1.15.9 are released  （以下未稿）\narchive/zip: panic when calling Reader.Open (CVE-2021-27919) The Reader.Open API, new in Go 1.16, will panic when used on a ZIP archive containing files that start with \u0026quot;../\u0026quot;. via Go 1.16.1 and Go 1.15.9 are released  （以下未稿）\n例によって\u0026hellip; Ubuntu の APT で管理している Go コンパイラは古いので，ダウンロードページからバイナリ（go1.16.1.linux-amd64.tar.gz）を取ってきて手動でインストールすることを強く推奨する。 以下は手動での作業例。\n$ cd /usr/local/src $ sudo curl -L \u0026#34;https://golang.org/dl/go1.16.1.linux-amd64.tar.gz\u0026#34; -O $ cd .. $ sudo unlink go # 以前の Go が入っている場合 $ sudo tar xvf src/go1.16.1.linux-amd64.tar.gz $ sudo mv go go1.16.1 $ sudo ln -s go1.16.1 go $ go version # /usr/local/go/bin にパスが通っている場合 go version go1.16.1 linux/amd64 アップデートは計画的に。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "Git v2.30.2 のリリース【セキュリテイ・アップデート】",
      "section": "release",
      "description": "アップデートは計画的に。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/git-2_30_2-is-released/",
      "published": "2021-03-10T09:41:10+00:00",
      "update": "2021-03-10T10:03:28+00:00",
      "content": "Git v2.30.2 がリリースされた。\n [ANNOUNCE] Git v2.30.2 and below for CVE-2021-21300 - Junio C Hamano  タイトルにもあるとおり，今回は CVE-2021-21300 の修正を含んでいる。\nA specially crafted repository that contains symbolic links as well as files using a clean/smudge filter such as Git LFS, may cause just-checked out script to be executed while cloning onto a case-insensitive file system such as NTFS, HFS+ or APFS (i.e. the default file systems on Windows and macOS).\nNote that clean/smudge filters have to be configured for that. Git for Windows configures Git LFS by default, and is therefore vulnerable.\n via malicious repositories can execute remote code while cloning · Advisory · git/git · GitHub  流石にク◯ったれな HFS+ は駆逐されていると思うが， NTFS と APFS をファイルシステムとして使っているプラットフォームは要注意である。 Windows や macOS パソコンだけじゃなくて， NTFS で NAS を構成している場合も結構ヤバいんじゃないかな？\nGit for Windows に関しては既にアップデートが出ている。\n Release MinGit v2.29.2.windows.4 · git-for-windows/git · GitHub Release Git for Windows 2.30.2 · git-for-windows/git · GitHub  他のプラットフォームでも順次アップデートしていくのがいいだろう。 今回の条件に該当するけどすぐにアップデートできない場合は，とりあえず\n$ git config --global core.symlinks false としてシンボリック・リンクを無効にすることで回避できるらしい。\nアップデートは計画的に。\nCVE-2021-21300 GitHub による評価：\n CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:N 深刻度: 重要 (Score: 8)     基本評価基準 評価値     攻撃元区分 ネットワーク   攻撃条件の複雑さ 高   必要な特権レベル 不要   ユーザ関与レベル 要   スコープ 変更あり   機密性への影響 高   完全性への影響 高   可用性への影響 なし    "
    },
    {
      "title": "Baldanders.info サイトにおける OpenPGP 鍵管理の変更",
      "section": "remark",
      "description": "来年から本気出す（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/changing-publickey-management/",
      "published": "2021-03-06T10:43:36+00:00",
      "update": "2021-03-06T10:47:09+00:00",
      "content": "このブログを含む Baldanders.info の各サイトでは，私個人の OpenPGP 公開鍵を公開している。 実は2013年から年次鍵の運用を止めて単一で永続的な鍵運用に切り替えたのだが，来年からまた短期の運用に戻すことにした。\n具体的には\n 現行の公開鍵の有効期限を 2022-03-31 に変更する（変更済） 2022年4月以降に使用する鍵は最長で2年の有効期限付きで作成する 単一の鍵で運用するのではなく目的別に鍵を分ける  OpenSSH のクライアント認証鍵は GnuPG ベースのものに切り替える 鍵同士の相互署名はしない    という感じで行こうかと。\n理由のひとつは，現在ドラフト中の NIST FIPS 186-5 から DSA が削除されるというもの。\n FIPS 186-5 (Draft), Digital Signature Standard (DSS) | CSRC  もうひとつの理由は GnuPG において第3者による OpenPGP 鍵への電子署名の社会的信頼度が下がってきたことだ。 もともと，第3者による OpenPGP 鍵への電子署名は「小切手の裏書き」みたいなもので，多数の署名が永続的に存在することで鍵の信頼性が担保できていたのだが，その前提が崩れ去ってしまったのだ。\n OpenPGP 公開鍵サーバにおける公開鍵の汚染問題  こうなると従来の OpenPGP 鍵サーバをベースにした鍵運用は大して意味がないし（せいぜい手渡しよりは便利という程度），単一の鍵を長期的に利用ドメインを跨いで使い回すのは却ってリスクになりかねない。\nさらに，強いて3つ目を挙げるなら「電子メールはオワコン」ということだろうか。 少なくとも署名・暗号化しないといけないようなメッセージ・データを電子メールで配送するというのはもうナシだろう。 PPAP 以前の問題。 Thunderbird による OpenPGP 鍵利用が使いものにならないというのもあるが（笑）\n暗号鍵の運用については NIST SP 800-57 が参考になるだろう。 この中で暗号鍵の使用期間と暗号期間について推奨値が示されている。 こんな感じ。\n main table.cryptoperiod th { vertical-align:middle; text-align: center; } main table.cryptoperiod td { vertical-align:middle; }    Key Type Cryptoperiod  Originator-Usage\nPeriod (OUP) Recipient-Usage\nPeriod     1. Private Signature Key 1 to 3 years −  2. Public Signature-VerificationKey Several years (depends on key size)  3. Symmetric Authentication Key $\\le 2$ years $\\le \\mathrm{OUP}+3$ years  4. Private Authentication Key 1 to 2 years  5. Public Authentication Key 1 to 2 years  6. Symmetric Data Encryption Keys $\\le 2$ years $\\le \\mathrm{OUP}+3$ years  7. Symmetric Key-Wrapping Key $\\le 2$ years $\\le \\mathrm{OUP}+3$ years  8. Symmetric RBG Keys See SP 800-90 −  9. Symmetric Master Key/Key Derivation Key About 1 year −  10. Private Key Transport Key $\\le 2$ years  11. Public Key Transport Key 1 to 2 years  12. Symmetric Key Agreement Key 1 to 2 years  13. Private Static Key Agreement Key 1 to 2 years  14. Public Static Key Agreement Key 1 to 2 years  15. Private Ephemeral Key Agreement Key One key-agreement transaction  16. Public Ephemeral Key Agreement Key One key-agreement transaction  17. Symmetric Authorization Key $\\le 2$ years  18. Private Authorization Key $\\le 2$ years    uggested cryptoperiods for key types (via SP 800-57 Part 1 Revision 5  5.3.6)  HTTPS など X.509 ベースで運用される公開鍵の有効期間が1年程度の短期運用に切り替わっているのに気付いている人も多いだろう。 OpenPGP 鍵は ad hoc 運用だし合わせる必要はないと思っていたが，永続的な鍵運用に価値がないならこっちに合わせるべきだよね。\nとりあえず，現行の OpenPGP 公開鍵は\n$ gpg --fetch-keys https://baldanders.info/pubkeys/spiegel.asc で有効期限付きのものに更新できる。\nぶっちゃけ個人で鍵を2,3年おきに更新するのって面倒くさいんだよね。 まぁ，実際の運用をどうするか（暗号デバイスの導入も含めて）これから3年以内には確立させる予定。 3年もあれば暗号界隈のシーンも変わっているだろうけど（笑）\nブックマーク  Kernel Maintainer PGP guide — The Linux Kernel documentation OpenPGP SSH access with Yubikey and GnuPG · GitHub セキュリティ関連NIST文書：IPA 独立行政法人 情報処理推進機構  鍵管理における推奨事項 第一部：一般事項    そろそろ GnuPG でも ECC を標準で使うのがいいんじゃないかな OpenSSH の認証鍵を GunPG で作成・管理する  参考図書  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n "
    }
  ]
}
