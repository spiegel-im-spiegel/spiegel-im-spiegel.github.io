{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "特殊形式による式評価について",
      "section": "golang",
      "description": "Go の言語仕様を読みましょう（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/special-forms/",
      "published": "2021-03-04T10:27:13+00:00",
      "update": "2021-03-04T11:54:38+00:00",
      "content": "元ネタが Zenn の記事だし小ネタだし，どちらで書こうか悩んだが，今まで書いたことがない切り口な気がするので，こっち側で。\nいきなりだが，以下のコードを起点に話を始めよう。\npackage main import \u0026#34;fmt\u0026#34; func main() { ageMap := map[string]uint{ \u0026#34;Alice\u0026#34;: 18, \u0026#34;Teles\u0026#34;: 20, } fmt.Println(ageMap[\u0026#34;Alice\u0026#34;])  // Output  // 18 } このコードをみて分かるように，インデックス式 ageMap[x] の評価結果は uint 型になっている（インデックス値が存在しない場合はゼロ値がセットされる）。 まぁ，当たり前だよね。\nところが ageMap[x] の評価結果を (uint, bool) の組（tuple）で受けることもできるのだ1。 これによってコードを\npackage main import \u0026#34;fmt\u0026#34; func main() { ageMap := map[string]uint{ \u0026#34;Alice\u0026#34;: 18, \u0026#34;Teles\u0026#34;: 20, } if age, ok := ageMap[\u0026#34;Selene\u0026#34;]; ok { fmt.Println(age) } else { fmt.Println(\u0026#34;unknown\u0026#34;) }  // Output  // unknown } と書き換えることでき， ageMap[x] の評価に失敗した際の挙動を記述できる。 Go の言語仕様では，これを「特殊形式（special form）」と呼んでいる（日本語が怪しいのはご容赦）。\n言語仕様を眺めてみると，この特殊形式が適用可能なのは以下の3つのみのようだ。\n   # Expressions Normal Form Special Form     1 Index Expression on Map foo := bar[x] foo, ok := bar[x]   2 Type Assertion foo := bar.(T) foo, ok := bar.(T)   3 Receive Expression foo := \u0026lt;-ch foo, ok := \u0026lt;-ch    最初のはインデックス値 x が map にない場合に false になる。 2番目は型 T でのアサーションに失敗した場合に（panic を吐くことなく） false になる。 最後のはチャネル ch が閉じている場合に false になる。\n他の式評価や関数の返り値ではこのようなことはできない。 たとえば slice のインデックス式評価に特殊形式はない。 インデックス値が範囲外なら単に panic が投げられるだけだ。\n実は，特殊形式が上の3つの式評価でしか適用されないというのが分からなくて「どうして普通の関数の返り値とかではできないんだろう」とひとしきり悩んだことがあったのだった。 言語仕様を読めっての（笑）\nブックマーク  The Go Programming Language Specification - The Go Programming Language Goの言語仕様書精読のススメ \u0026amp; 英語彙集 Go言語における式の評価文脈を理解する  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n   厳密には，特殊形式 (T, bool) の2要素目は型付けなしの真偽値（untyped boolean）に評価される。「型付けなし（untyped）」というのは Go 特有の概念だそうで，具体的な型が決定される前の状態を指す。たとえば，定数 math.Pi は10進数64桁の小数点数で定義されている。型付けなし定数については『プログラミング言語Go』の3.6.2章にも解説がある。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "GNKF: NKF ぽいなにか の v0.4.0 をリリースした",
      "section": "release",
      "description": "部首の正規化の対象に CJK 部首補助を含めるようにした。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/02/gnkf-v0_4_0-is-released/",
      "published": "2021-02-28T10:26:39+00:00",
      "update": "2021-02-28T10:27:33+00:00",
      "content": "Go 言語における文字列処理の習作 gnkf の v0.4.0 をリリースした。\n Release v0.4.0 · spiegel-im-spiegel/gnkf · GitHub  実は\n PDFのコピペが文字化けするのはなぜか？～CID/GIDと原ノ味フォント～  というスライドを見てたんだけど，康熙部首だけじゃなくて CJK 部首補助に化けることもあるらしいぢゃん。\ngnkf では norm サブコマンドに -k オプションを付けて\n$ echo ㈱埼⽟ | gnkf norm -n nfkc -k とかすれば康熙部首の「⽟（U+2F5F）」だけを正規化できるんだけど，この対象に CJK 部首補助を含めるようにした。 具体的には Unicode オフィシャルの\n EquivalentUnifiedIdeograph.txt  に従って変換している。\nあとは，お試し機能として completion サブコマンドを追加して各 shell 用の自動補完スクリプトを吐き出せるようにした。 Bash, Zsh, Fish, PowerShell の自動補完機能に対応している。\ngnkf completions -h とかすれば簡単なヘルプが出るので，よろしければどうぞ。\nブックマーク   やっかいな漢字 – CJK部首補助／康煕部首 – ものかの\n  GNKF: Network Kanji Filter by Golang\n  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "Markdown と VS Code",
      "section": "remark",
      "description": "Preview 機能は個人的に必要ないのでレビューしないが，仕事で使うようなことがあれば，そのうち記事にすることもあるだろう。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/02/markdown-with-vscode/",
      "published": "2021-02-28T03:45:02+00:00",
      "update": "2021-03-04T23:24:41+00:00",
      "content": " パソコンに Visual Studio Code を導入する（再チャレンジ） Go と VS Code Markdown と VS Code ← イマココ  今回は VS Code で markdown テキストを入出力する話。\nMarkdown All in One $ code --install-extension yzhang.markdown-all-in-one Markdown 関連の拡張機能は色々あるようだが，入力支援に関してはこれで必要十分ぽい。\nお気に入りはテーブル整形の機能で， Linux/Ubuntu なら [Ctrl+Shift+I] キー（Format Document）押下で綺麗に整形してくれる。\nところが Windows 版では [Shift+Alt+F] キーが Format Document に割り当てられているようだ。 プラットフォームによって違うのかよ。\nというわけで Windows 版の方にキー割当を合わせることにした。\n// Place your key bindings in this file to override the defaults [ { \u0026#34;key\u0026#34;: \u0026#34;shift+alt+f\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;editor.action.formatDocument\u0026#34;, \u0026#34;when\u0026#34;: \u0026#34;editorHasDocumentFormattingProvider \u0026amp;\u0026amp; editorTextFocus \u0026amp;\u0026amp; !editorReadonly \u0026amp;\u0026amp; !inCompositeEditor\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;ctrl+shift+i\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;-editor.action.formatDocument\u0026#34;, \u0026#34;when\u0026#34;: \u0026#34;editorHasDocumentFormattingProvider \u0026amp;\u0026amp; editorTextFocus \u0026amp;\u0026amp; !editorReadonly \u0026amp;\u0026amp; !inCompositeEditor\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;shift+alt+f\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;editor.action.formatDocument.none\u0026#34;, \u0026#34;when\u0026#34;: \u0026#34;editorTextFocus \u0026amp;\u0026amp; !editorHasDocumentFormattingProvider \u0026amp;\u0026amp; !editorReadonly\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;ctrl+shift+i\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;-editor.action.formatDocument.none\u0026#34;, \u0026#34;when\u0026#34;: \u0026#34;editorTextFocus \u0026amp;\u0026amp; !editorHasDocumentFormattingProvider \u0026amp;\u0026amp; !editorReadonly\u0026#34; } ] Prettier - Code formatter との競合 $ code --install-extension esbenp.prettier-vscode Markdown 専用というわけではないが JavaScript/TypeScript, CSS/SCSS/Less, HTML, JSON, GraphQL, YAML など幅広い言語に対応している整形ツールで，しかも plugin 拡張もできるらしい。 もちろん markdown テキストにも対応している。\nで，これと Markdown All in One の整形機能（Format Document）が被るわけですよ。 そこで，どちらの機能を使うか言語ごとに設定できるようになっている。 私は Markdown All in One 優先でこんな感じ。\n{ \u0026#34;[markdown]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;yzhang.markdown-all-in-one\u0026#34; } } さらにファイル保存時に変更した箇所だけを整形する，なんてな設定も言語ごとにできるようだ。\n{ \u0026#34;[markdown]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;yzhang.markdown-all-in-one\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.formatOnSaveMode\u0026#34;: \u0026#34;modifications\u0026#34;  } } ちなみに EditorConfig for VS Code が有効な場合は .editorconfig の設定（インデントや改行コードなど）を考慮してくれるようだ。 これを無効にするには “Use Editor Config” の項目を OFF にする。\n{ \u0026#34;prettier.useEditorConfig\u0026#34;: false } ただし， EditorConfig が有効な場合でも .prettierrc ファイルなどによる Prettier 独自の設定がある場合は，そちらのほうが優先されるようだ。 ややこしい\u0026hellip;\n自動補完を有効にする VS Code の売りのひとつはスニペットを含む強力な自動補完機能だが，何故か markdown ファイルには自動補完が効かない。 と思ったら，既定で無効になっているらしい。 いや，有効にしとけよ。\nというわけで settings.json に以下の設定を手動で書き込む。\n{ \u0026#34;[markdown]\u0026#34;: { \u0026#34;editor.quickSuggestions\u0026#34;: true, \u0026#34;editor.snippetSuggestions\u0026#34;: \u0026#34;top\u0026#34; }, } これでスニペットを優先して自動補完候補に挙げてくれる。\nMarkdown Preview 機能は必要か 私個人で言うなら No で，仕事なら場合によっては Yes かな。\nそもそも markdown テキストってのは，見出しや段落や箇条書き等の文書構造がそのままでも human-readable である点が利点と言える。 さらに言えば，ここのブログは Hugo の shortcodes 等で入力自体をカスタマイズしまくってるので，ただの markdown preview なんか使いものにならないのだ（Hugo はサーバ・モードで起動できるので，リアルタイムでブラウザ表示を確認しながら記事を書いている）。\n一方で， Office ツールなどレガシーな環境を捨てて markdown 等の構造化テキストをベースにしたドキュメンテーションをしようとするなら，それなりにリッチな markdown preview 機能と PDF 等へ「最終出力」するためのツールチェーンが必要となる。\nそのための手段（または道具立て）として VS Code をベースに環境を整えるというのは合理的と言えるかもしれない。\nというわけで，以降では PDF 等への「最終出力」を念頭に置いたドキュメントツールとして幾つかの拡張機能を紹介してみる。 上述したように，私個人は全く必要ないのでレビューしないが，仕事で使うようなことがあれば，そのうち記事にすることもあるだろう。\nMarkdown Preview Enhanced $ code --install-extension shd101wyy.markdown-preview-enhanced TeX の数学記法あるいは PlantUML や mermaid 等の記法も認識して preview 表示できるらしい。 DOT 言語も使えるのか。 CSS をカスタマイズ可能。\nHTML や PDF へ出力できるようだ（PDF 出力は Chrome 経由）。\nMarkdown PDF $ code --install-extension yzane.markdown-pdf コマンド一発で PDF 変換してくれる。 簡易的な出力しか出来ないのかと思ったら，意外にもかなりカスタマイズできるらしい。\n VSCode と Markdown で技術同人誌書いたので拡張機能とかまとめ - Qiita 【Visual Studio Code】Markdown PDF のスタイル(CSS)を変える方法 - Nekonote  Marp for VS Code $ code --install-extension marp-team.marp-vscode Marp を使って markdown テキストからスライドを生成する。 PDF へエクスポートできるらしい。\n 【VS Code + Marp】Markdown から爆速・自由自在なデザインで、プレゼンスライドを作る - Qiita  Draw.io Integration $ code --install-extension hediet.vscode-drawio Draw.io (diagrams.net) を利用した作図ツール。 データはテキストで保持して PNG や SVG へエクスポート可能って感じなのかな。\n VSCode で Draw.io が使えるようになったらしい！ - Qiita  PlantUML $ code --install-extension jebbs.plantuml PlantUML 作図・出力支援。 あらかじめ PlantUML 作図環境を用意する必要がある（ただし plantuml.jar ファイルは拡張機能内にあらかじめ格納されている？）。\n 真面目に PlantUML (1) : PlantUML のインストール  ブックマーク  VS Code エディタ入門 (2020 年 12 月 8 日追記)VSCode で Draw.io Integration 使用時にエクスポートできないことがある問題への対処 - Qiita インデントおよび行末は EditorConfig で始末する  参考図書  Software Design (ソフトウェアデザイン) 2020年8月号 [雑誌] Software Design 編集部 (編集) 技術評論社 2020-07-18 (Release 2020-07-18) Kindle版 B08CZ2C3NZ (ASIN)  特集記事は「Vim vs. Visual Studio Code」\nreviewed by Spiegel on 2021-02-28 (powered by PA-APIv5)\n "
    },
    {
      "title": "2021-02-28 のブックマーク",
      "section": "bookmarks",
      "description": "「Zennで発生した障害の原因と行なった対策のまとめ」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2021/02/28-bookmarks/",
      "published": "2021-02-28T00:54:18+00:00",
      "update": "2021-02-28T00:55:58+00:00",
      "content": "リリース情報  Release gopls/v0.6.6 · golang/tools · GitHub Release v0.4.4 · zetamatta/go-readline-ny · GitHub Release v0.4.5 · zetamatta/go-readline-ny · GitHub Release v0.4.6 · zetamatta/go-readline-ny · GitHub  セキュリティ＆プライバシー関連  GPS Vulnerabilities - Schneier on Security TrivyがRed Hatの認定脆弱性スキャナーになりました - knqyf263\u0026rsquo;s blog : Red Hat Vulnerability Scanner Certification の要件を完全に満たす実装はないらしい VMware vCenter Serverの脆弱性（CVE-2021-21972）に関する注意喚起 NTTドコモとKDDIが解約手続きページに「noindex」タグを挿入、検索で非表示にしていたと判明 | TechCrunch Japan  知財関連  「著作権フィルターに検出されそうな曲をかけてライブストリーミングを妨害しようとした警官」は氷山の一角に過ぎない | P2Pとかその辺のお話R  Go 言語関連  Contexts and structs - The Go Blog Developing and publishing modules - The Go Programming Language go installとgo getをどう使い分ければ良いのか調べた Goのスクリプト言語としてPrologを使う : 康熙部首だけじゃないのか。対応しなくちゃ  Rust 言語関連  Rust Foundationのよくある質問と回答（翻訳） Const generics MVP hits beta! | Rust Blog  その他  「ブドウを電子レンジでチンするとプラズマが発生する」という現象の原因がついに明らかに - GIGAZINE Qiita/Zennの投稿をGitHubプロフィールに自動反映するためのツールを作った 以前原書を紹介した本の邦訳を紹介（おバカな答えもAIしてる、感染の法則、マイケル・サンデル先生の新刊） - YAMDAS現更新履歴 マイクロソフト、オープンソースの分散アプリケーションランタイム「Dapr 1.0」リリース。Kubernetes対応、サービス間メッセージング、ステート管理など提供 － Publickey GitHubのTUIツールを作った マイクロソフト「.NET 6」初めてのプレビュー版リリース。Xamarin統合、マルチプラットフォームUI、Blazorでデスクトップアプリ、Apple M1ネイティブなど － Publickey Amazon EC2 MacインスタンスがBig surのサポートを開始。NFSサービス「Amazon EFS」へのマウントも可能に － Publickey 推薦書籍（ソフトウェアエンジニアの心得）：柴田 芳樹 (Yoshiki Shibata)：SSブログ Zennで発生した障害の原因と行なった対策のまとめ CGのための数学 The state of Go | The GoLand Blog PDFのコピペが文字化けするのはなぜか？～CID/GIDと原ノ味フォント～  "
    },
    {
      "title": "Go と VS Code",
      "section": "remark",
      "description": "ぶっちゃけ ATOM の go-plus よりも出来がいいので，ゆるゆると移行していきますよっと。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/02/golang-with-vscode/",
      "published": "2021-02-27T09:47:11+00:00",
      "update": "2021-03-02T21:31:16+00:00",
      "content": "どっちのセクションで書こう悩んだが，所詮ツールの話だし，こっち側で。\n パソコンに Visual Studio Code を導入する（再チャレンジ） Go と VS Code ← イマココ Markdown と VS Code  それでは前回の続き。 VS Code に Go 言語開発支援環境を入れる。 といっても一択だけどね。\n Go - Visual Studio Marketplace  インストールはこちら。\n$ code --install-extension golang.go 一応 Google が公式に参加している拡張機能らしい。\n The VS Code Go extension joins the Go project - The Go Blog Visual Studio Code Go extension joins the Go project  しかも最近，こちらも事実上のオフィシャルである gopls が，この拡張機能の既定の language server となったようだ。\n Gopls on by default in the VS Code Go extension - The Go Blog  個人的にひとつだけ気に入らないところがあって，既定の設定のままではプロジェクト・フォルダを開いたときにトップに go.mod ファイルがないと上手く動かないみたいなんだよね（モジュール対応モードの場合）。\n最初は拡張機能側の問題かと思っていたが，どうも gopls の制限らしい。\n tools/workspace.md at master · golang/tools · GitHub  一応の回避策はあって settings.json に以下のオプションを設定することでトップ以外の複数の go.mod ファイルに対応できるようだ。\n{ \u0026#34;gopls\u0026#34;: { \u0026#34;build.experimentalWorkspaceModule\u0026#34;: true } } ただし go.mod ファイルで定義したモジュール名は開いたプロジェクト・フォルダ内で一意でなければならない。 名前が被ってるとめっさ怒られる。\nまぁ，理屈は分からんでもないが，私の場合，ブログなどのドキュメント環境でサンプルコードを書き散らしていて，それらのモジュール名が大抵 \u0026ldquo;sample” だったりするので被りまくりなんだよなぁ sigh\u0026hellip;\nちなみに，この experimentalWorkspaceModule オプションは一時的な措置なので将来的にはなくなるようだ。 それまでには何とかするということだろう。\nそれ以外の部分ではぶっちゃけ ATOM の go-plus よりも出来がいいので，ゆるゆると移行していきますよっと。\n現時点での settings.json の内容はこんな感じ。\n{ \u0026#34;go.buildOnSave\u0026#34;: \u0026#34;off\u0026#34;, \u0026#34;go.autocompleteUnimportedPackages\u0026#34;: true, \u0026#34;go.formatTool\u0026#34;: \u0026#34;goimports\u0026#34;, \u0026#34;go.lintTool\u0026#34;: \u0026#34;golangci-lint\u0026#34;, \u0026#34;go.gotoSymbol.includeGoroot\u0026#34;: true, \u0026#34;go.testOnSave\u0026#34;: true, \u0026#34;go.coverageOptions\u0026#34;: \u0026#34;showUncoveredCodeOnly\u0026#34;, \u0026#34;go.coverOnSave\u0026#34;: true, \u0026#34;go.coverOnSingleTestFile\u0026#34;: true, \u0026#34;go.coverageDecorator\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;gutter\u0026#34; }, \u0026#34;gopls\u0026#34;: { \u0026#34;build.experimentalWorkspaceModule\u0026#34;: true } } 【2021-03-02 追記】 書き忘れていたが，コマンドパレットから\n\u0026gt;Go: Install/Update Tools と入力すると関連ツールのインストールおよびアップデートができる。\nGo: Install/Update Tools  これを実行すると\nTools environment: GOPATH=/home/username/go Installing 9 tools at /home/username/go/bin in module mode. gopkgs go-outline gotests gomodifytags impl goplay dlv golangci-lint gopls Installing github.com/uudashr/gopkgs/v2/cmd/gopkgs (/home/username/go/bin/gopkgs) SUCCEEDED Installing github.com/ramya-rao-a/go-outline (/home/username/go/bin/go-outline) SUCCEEDED Installing github.com/cweill/gotests/... (/home/username/go/bin/gotests) SUCCEEDED Installing github.com/fatih/gomodifytags (/home/username/go/bin/gomodifytags) SUCCEEDED Installing github.com/josharian/impl (/home/username/go/bin/impl) SUCCEEDED Installing github.com/haya14busa/goplay/cmd/goplay (/home/username/go/bin/goplay) SUCCEEDED Installing github.com/go-delve/delve/cmd/dlv (/home/username/go/bin/dlv) SUCCEEDED Installing github.com/golangci/golangci-lint/cmd/golangci-lint (/home/username/go/bin/golangci-lint) SUCCEEDED Installing golang.org/x/tools/gopls (/home/username/go/bin/gopls) SUCCEEDED All tools successfully installed. You are ready to Go :). てな感じで go install してくれるようだ。 自動でアップデートしてくれるといいのだが\u0026hellip;\n参考図書  Software Design (ソフトウェアデザイン) 2020年8月号 [雑誌] Software Design 編集部 (編集) 技術評論社 2020-07-18 (Release 2020-07-18) Kindle版 B08CZ2C3NZ (ASIN)  特集記事は「Vim vs. Visual Studio Code」\nreviewed by Spiegel on 2021-02-28 (powered by PA-APIv5)\n  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "パソコンに Visual Studio Code を導入する（再チャレンジ）",
      "section": "remark",
      "description": "まずはインストールと初期設定",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/02/installing-vscode-again/",
      "published": "2021-02-27T05:23:23+00:00",
      "update": "2021-03-02T21:31:16+00:00",
      "content": "今の職場では当然のように Windows 10 機を支給されていてテキスト・エディタ等の普段使いのツールであれば割と自由に使わせてくれるのはいいのだが，6 年ほど使い込んで手に馴染んでる筈の ATOM が使えなくてねぇ。 理由は大きく 2 つ。\n 起動が遅すぎる（もともと遅いが堪えられないほど遅い） Go 言語開発支援の go-plus が実質的に動かない  特に 2 番目が致命的。 私の観測範囲が狭いせいか，この手の話をほとんど聞かないのだが Windows で ATOM で Go で開発をしてる人はいないってことなのかねぇ。\nさらに言うと ATOM を開発している GitHub が VS Code を開発している Microsoft に買収され，オフィシャルの Go Language Server である gopls が，これまた Google オフィシャルの VS Code 用拡張機能の既定の Language Server になったというのも大きい。 ATOM の go-plus なんて今だに gocode 使ってるんだぜ。 完全に廃れているよなぁ orz\nというわけで，観念して VS Code を導入することにした。\n実は昨年 5 月に自宅の Ubuntu 機に VS Code を入れたんだけど，結局挫折して削除しちゃったんだよねぇ。 今回は職場の Windows 機で先行して導入している。 なので Windows 機と Ubuntu 機を比較しながら，何回かに分けて記事を書いていく予定である。\n パソコンに Visual Studio Code を導入する（再チャレンジ） ← イマココ Go と VS Code Markdown と VS Code  VS Code のインストール Windows 版のインストールはサイトからインストーラをダウンロードすればよい。\n問題は Ubuntu だが Snap 版と APT 版がある。 昨年の話だが Snap 版を入れたら日本語入力が壊滅してたので，今回も選択肢には入れない。\nAPT 版は Microsoft がリポジトリを公開しているので，これを設定してインストールする。\n $ curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor \u0026gt; microsoft.gpg $ sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg $ sudo sh -c \u0026#39;echo \u0026#34;deb [arch=amd64] http://packages.microsoft.com/repos/vscode stable main\u0026#34; \u0026gt; /etc/apt/sources.list.d/vscode.list\u0026#39; $ sudo apt update $ sudo apt install -y code  VS Codeエディタ本体のインストール方法｜VS Codeエディタ入門より  起動は Shell やコマンド・プロンプト等でファイル名またはディレクトリ名を指定して\n$ code . とすれば起動する1。 Windows 版の ATOM はコマンド・プロンプトから任意の場所を開けなくて往生したんだよなぁ。\nVS Code 本体以外の各種ファイルは以下のディレクトリに格納される。\n Windows 版  %USERPROFILE%\\.vscode\\ %APPDATA%\\Code\\   Ubuntu 版  $HOME/.vscode/ $HOME/.config/Code/    settings.json や keybindings.json といった設定ファイルやスニペットを格納する snippets/ ディレクトリは Code/User/ ディレクトリ直下にあるので，必要に応じてバックアップを取るのがいいだろう。\nぶっちゃけ日本語化は不要。 つか，コマンドパレットや検索フィルタを常用するなら下手に日本語化しても混乱するだけだろう。\nテレメトリの無効化 これは任意だが，ベンダ・メーカによるテレメトリを嫌うなら，最初の起動時に無効化の設定をしておく。 具体的には設定画面（[Ctrl+,] 押下で起動）で telemetry を入力し，出てきた項目のチェックを外す。\ntelemetry  テレメトリを無効化すると settings.json に以下の内容が書き込まれる。\n{ \u0026#34;telemetry.enableCrashReporter\u0026#34;: false, \u0026#34;telemetry.enableTelemetry\u0026#34;: false } VS Code の設定画面は拡張機能も含めて全てフラットに表示してしまうので，検索フィルタで絞り込まないとめちゃめちゃ使い辛い。 慣れるまでは設定画面で操作しながら settings.json の内容を確認していく（必要に応じてバックアップ）のがいいだろう。\nこういのが面倒くさいんだよなぁ， VS Code って。\nキー設定 まずはキー設定を確認しておく。 キー割当の公式情報が PDF で公開されているので，参考にするとよいだろう。\n Keyboard Shortcuts for Windows  Keyboard Shortcuts for Linux   拡張機能に「◯◯ エディタ風」とかまとめて設定できるものもあるが，歳をとるとそういうカスタマイズは面倒になってくる2。 今回はできるだけキー割当を変えないで Linux 版と Windows 版で挙動が異なるもののみに注目してチューニングしていく。\nなお，キー割当は “Keyboard Shortcuts” 画面で変更するのが無難で安全である。 settings.json と同じく，慣れるまでは keybindings.json の内容を確認しながら必要に応じてバックアップをとるのがいいだろう。\nコマンドパレット等 この辺は最低限おぼえておくべき。\n   キー割当 機能     [Ctrl+Shift+P]\n[F1] Show All Commands (コマンドパレット)   [Ctrl+,] Open Settings (UI)   [Ctrl+K] [Ctrl+S] Open Keyboard Shortcuts    最初から [F1] キーにコマンドパレットが割り当てられているのはありがたい。 まぁ，コマンドパレットさえ使えれば，あとはうろ覚えでも何とかなる（笑）\nマルチカーソル きょうびのテキスト・エディタでマルチカーソルが使えないのはク ◯ だろう（下品でごめん）。\n   キー割当 機能     [Ctrl+Alt+↑]\n[Shift+Alt+↑] Add Cursor Above   [Ctrl+Alt+↓]\n[Shift+Alt+↓] Add Cursor Below   [Ctrl+D] Add Selection To Next Find Match   [Ctrl+Shift+L] Select All Occurrences of Find Match   [Ctrl+F2] Change All Occurrences   [Shift+Alt+I] Add Cursors to Line Ends    Windows 版ではマルチカーソルの追加（上の 2 つの機能ね）が[Ctrl+Alt+↑] および [Ctrl+Alt+↓] にしか割り当てられてないんだけど，それやったらうちの環境ではモニタ表示の向きが変わってしまうんだよね。 うちだけの現象なのだろうか。\nちうわけで Windows 版では [Shift+Alt+↑], [Shift+Alt+↓] に変更する。 keybindings.json にはこんな感じに設定されるようだ。\n// Place your key bindings in this file to override the defaultsauto[] [ { \u0026#34;key\u0026#34;: \u0026#34;shift+alt+up\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;editor.action.insertCursorAbove\u0026#34;, \u0026#34;when\u0026#34;: \u0026#34;editorTextFocus\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;ctrl+alt+up\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;-editor.action.insertCursorAbove\u0026#34;, \u0026#34;when\u0026#34;: \u0026#34;editorTextFocus\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;shift+alt+down\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;editor.action.insertCursorBelow\u0026#34;, \u0026#34;when\u0026#34;: \u0026#34;editorTextFocus\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;ctrl+alt+down\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;-editor.action.insertCursorBelow\u0026#34;, \u0026#34;when\u0026#34;: \u0026#34;editorTextFocus\u0026#34; } ] 行の 2 重化 何故この機能がキーに割り当てられてないのだ！ というわけで [Ctrl+F10] に割り当てた。\n   キー割当 機能     [Ctrl+F10] Duplicate Selection    keybindings.json にはこんな感じに設定される。\n// Place your key bindings in this file to override the defaultsauto[] [ { \u0026#34;key\u0026#34;: \u0026#34;ctrl+f10\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;editor.action.duplicateSelection\u0026#34; } ] Integrated Terminal VS Code には標準でターミナル機能が付いている。 ありがたや。\n   キー割当 機能     [Ctrl+Shift+@] Toggle Integrated Terminal    この機能は頻繁に使うので [Ctrl+F1] キーに割り当て直す。 keybindings.json にはこんな感じに設定された。\n// Place your key bindings in this file to override the defaultsauto[] [ { \u0026#34;key\u0026#34;: \u0026#34;ctrl+f1\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;workbench.action.terminal.toggleTerminal\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;ctrl+shift+[BracketLeft]\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;-workbench.action.terminal.toggleTerminal\u0026#34; } ] Windows 版なら NYAGOS を shell として使いたいものである。 そこで settings.json に以下の設定を直接書き込む。\n{ \u0026#34;terminal.integrated.shell.windows\u0026#34;: \u0026#34;C:\\\\Users\\\\username\\\\scoop\\\\apps\\\\nyagos\\\\current\\\\nyagos.exe\u0026#34; } （Scoop で NYAGOS をインストールした場合）\nSearch Editor 簡単な検索と置換は [Ctrl+F] と [Ctrl+H] で可能だがファイルを跨いだ grep や grep 置換を行う場合は [Ctrl+Shift+F] または [Ctrl+Shift+H] でサイドバーを検索に切り替えた上で [Ctrl+Shift+J] で詳細項目を展開する。\nただサイドバーの操作ってマウス前提だし使い勝手がよくないんだよねぇ。\nと思ったら設定に Search Editor という項目があって，“Search: Mode” 項目を変更することで [Ctrl+Shift+F] キー押下時にどちらを起動するか選べるようだ。 これを newEditor に変更したら settings.json にはこんな感じに設定された。\n{ \u0026#34;search.mode\u0026#34;: \u0026#34;newEditor\u0026#34; } これでサイドバーではなくエディタのタブとして検索画面が開く。 検索結果から検索元のファイル：行にジャンプするには [F12] キー押下で OK（ソースコードのシンボル定義元へのジャンプと同じ）。\nGrep 置換機能には該当の項目がなくサイドバーから行うしかないようだ。 まぁ，ファイルを跨いでの一括置換処理は滅多にしないけどな（笑）\n【2021-03-02 追記】ウィンドウの設定 画面起動時のウィンドウ画面サイズ VS Code を起動する際のウィンドウ画面は前回時の状態を継承するのだが，そのまま 2 つ目を起動すると何故かウィンドウサイズが既定で起動してしまう。 これがめちゃめちゃストレスだったのだが，何と設定で変えれるらしい。 具体的には\n{ \u0026#34;window.newWindowDimensions\u0026#34;: \u0026#34;inherit\u0026#34; } とすれば 2 つ目以降もウィンドウの状態を「継承」してくれる。 つか，最初からこれを既定にしてくれよ orz\nウィンドウのタイトルバーを非表示にする Windows 版は既定でウィンドウのタイトルバーが非表示になっている。 今どきの Windows アプリケーションって大抵そんな見た目なのでそれが普通だと思っていたが，なんか設定で変えれるらしい。 具体的には\n{ \u0026#34;window.titleBarStyle\u0026#34;: \u0026#34;native\u0026#34; } とすれば，タイトルバーが表示されるようになった（VS Code 要再起動）。 まぁ，特に嬉しいわけではないのだけど。\nで，実は Linux 版でもこの値を custom にすることでタイトルバーを非表示にできるようだ。 早速試してみた。\nタイトルバーを非表示に  おー，ホンマじゃ。 これは嬉しい。\nカラー・テーマは\u0026hellip; 入れなくてもいいか 歳をとるとだんだん目が弱くなってくる。 Windows にせよ Ubuntu にせよ，パソコンのデスクトップ画面は基本的にダーク・テーマにしているのだが， VS Code もこれに合わせて自動的にダークテーマになるようだ。 これならカラー・テーマを別途入れる必要はないか。\nただし標準のままではカーソル行が分かりにくいので settings.json に以下の設定を直接書き込む。\n{ \u0026#34;workbench.colorCustomizations\u0026#34;: { \u0026#34;editor.lineHighlightBackground\u0026#34;: \u0026#34;#303030\u0026#34; } } よーし，うむうむ，よーし。\n必須の拡張機能 えっと，私にとって「ないと困る機能」だからね。 念のため。\nちなみに\n$ code --install-extension \u0026lt;package name\u0026gt; とすることでも拡張機能をインストールできる。 Shell スクリプト（またはバッチ・ファイル）にまとめておけば再インストールの際にちょっとは楽になると思う。\nEditorConfig for VS Code $ code --install-extension EditorConfig.EditorConfig コード書きなら EditorConfig は MUST だろう。\n インデントおよび行末は EditorConfig で始末する  zenkaku $ code --install-extension mosapride.zenkaku 全角空白を見やすく表示してくれる優れもの。 つか，滅びろ全角空白！\nZenkaku-Hankaku $ code --install-extension masakit.zenkaku-hankaku 全角半角変換。 日本語入力環境では必須。 というか半角カナとか全角英数とかマジで勘弁してほしい。\nRender Line Endings $ code --install-extension medo64.render-crlf 改行コードの可視化。 色々あったけどユーザが多そうだったのでコレにした。 行末の余分な空白文字も目立たせてくれるスグレモノ。 つか，改行コードを表示するのに拡張機能が必要なのかよ orz\nsettings.json はこんな感じに設定している。\n{ \u0026#34;code-eol.highlightExtraWhitespace\u0026#34;: true, \u0026#34;code-eol.highlightNonDefault\u0026#34;: true } ついでに設定の “Render Control Characters” も ON にしている。\n{ \u0026#34;editor.renderControlCharacters\u0026#34;: true } Duplicate action $ code --install-extension mrmlnc.vscode-duplicate VS Code のファイル・エクスプローラー機能がショボい。 特にファイルの duplicate 機能がないのは不便って思ってたら拡張機能にあった。 何故これを標準装備しないのだ！\nあるとよさげな拡張機能 Material Icon Theme $ code --install-extension PKief.material-icon-theme よい。\nBracket Pair Colorizer 2 $ code --install-extension CoenraadS.bracket-pair-colorizer-2 括弧の対応を色付きで見やすくしてくれる。 ホンマに見やすいな。 2 のほうが出来がいいらしい。\nGit Graph $ code --install-extension mhutchie.git-graph git commit などの基本的なコマンドはコマンドパレットから簡単に呼び出せるが， GUI で操作したいときもあるので。 しかも以下のオプションを付ければ電子署名の検証も表示してくれる。\n{ \u0026#34;git-graph.repository.commits.showSignatureStatus\u0026#34;: true } というわけで採用。 つか，これがあれば他の git GUI ツール要らなくね？\nキーボードで操作しやすいよう [Shift+F1] キー押下で表示するようにした。\n// Place your key bindings in this file to override the defaultss [ { \u0026#34;key\u0026#34;: \u0026#34;shift+f1\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;git-graph.view\u0026#34; } ] GitLens $ code --install-extension eamodio.gitlens 多分，チーム運用で相互レビューするときなんかには重宝するんだろう。 かなり詳細な情報が見れるんだけど，私個人にはちょっと過剰な機能なんだよなぁ。 とりあえず保留。\nExcel Viewer $ code --install-extension GrapeCity.gc-excelviewer GrapeCity が公開してるのか。 どーりで（笑）\n仕事で使うならよさげだけど，個人レベルじゃ特に要らないかな。\n 【レビュー】「Visual Studio Code」で Excel スプレッドシートや CSV データを表示「Excel Viewer」 - 窓の杜  現在日時を設定するスニペット 現在日時をセットする方法はいくつかあるようだが，スニペットを使うのがお手軽な感じである。\nCode/User/ ディレクトリ直下に snippets/datetime.code-snippets というファイルを作って3，以下の内容をセットすれば OK。\n{ \u0026#34;Today\u0026#34;: { \u0026#34;prefix\u0026#34;: [\u0026#34;today\u0026#34;], \u0026#34;body\u0026#34;: [\u0026#34;$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;Today (RFC3339)\u0026#34; }, \u0026#34;Now\u0026#34;: { \u0026#34;prefix\u0026#34;: [\u0026#34;now\u0026#34;], \u0026#34;body\u0026#34;: [\u0026#34;$CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND\u0026#34;], \u0026#34;description\u0026#34;: \u0026#34;Now time (local time)\u0026#34; }, \u0026#34;TodayFull\u0026#34;: { \u0026#34;prefix\u0026#34;: [\u0026#34;todaytime\u0026#34;], \u0026#34;body\u0026#34;: [ \u0026#34;$CURRENT_YEAR-$CURRENT_MONTH-${CURRENT_DATE}T$CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND+09:00\u0026#34; ], \u0026#34;description\u0026#34;: \u0026#34;Today and time (RFC3339)\u0026#34; } } これで today, now, todaytime の補完候補として表示される。 自動で表示されない場合は [Ctrl+space] で候補一覧が出る。\n単純な置換ならスニペットのほうがお手軽なので積極的に使っていきたいところである。\n Visual Studio Code スニペットで簡単日付入力 - はんなりと、ゆるやかに VsCode のスニペットのススメ - Qiita Snippets in Visual Studio Code  ブックマーク  VS Code エディタ入門 【随時更新】使ってる VSCode の拡張機能のまとめ Visual Studio Code のうれしい機能を使いこなして、初心者を最速で脱出する！《VSCode 実践入門》 - エンジニア Hub ｜若手 Web エンジニアのキャリアを考える！ VSCode に入れている拡張機能 2020 年版 – 未来をデザインするマーケティング会社 -ハイロックス VSCode 使い必見！？使って便利な Visual Studio Code 拡張機能 10 選 | ソフトウェア開発のギークフィード Visual Studio Code で現在の日時を入力するショートカットを設定する方法 - JavaScript 勉強会  参考図書  Software Design (ソフトウェアデザイン) 2020年8月号 [雑誌] Software Design 編集部 (編集) 技術評論社 2020-07-18 (Release 2020-07-18) Kindle版 B08CZ2C3NZ (ASIN)  特集記事は「Vim vs. Visual Studio Code」\nreviewed by Spiegel on 2021-02-28 (powered by PA-APIv5)\n   Windows 版でコマンド・プロンプトから開くには，インストール時に PATH を通す設定をする必要がある。また Windows 版ではエクスプローラのコンテキスト・メニューから開くオプションもあるので積極的に利用していいだろう。 \u0026#x21a9;\u0026#xfe0e;\n 大昔の Mifes や Vz Editor くらいしか選択肢がなかった頃ならともかく，今はいくらでも選択肢があるのにわざわざ「◯◯ エディタ風キーマップ」とかするくらいなら「◯◯ エディタ」を使えよ，と思うのは私だけだろうか。 \u0026#x21a9;\u0026#xfe0e;\n 汎用で使うスニペットを定義する場合，拡張子が .code-snippets なファイルであればいいらしい。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "紙芝居用の簡易サーバを書く【Go 1.16 版】",
      "section": "golang",
      "description": "Go 1.16 で追加された embed および io/fs 標準パッケージを使う。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/embeded-filesystem/",
      "published": "2021-02-24T10:53:56+00:00",
      "update": "2021-02-24T13:26:22+00:00",
      "content": "ずいぶん前に\n 紙芝居用の簡易 Web サーバを Go 言語で書く  という記事を書いたが，これで作ったコードは任意のディレクトリをドキュメント・ルートにできるという結構ヤバい代物である。\nところで Go 1.16 リリースで真っ先に思ったのは「これで安全に紙芝居ができるぢゃん」だった。 Go 1.16 で追加された embed および io/fs 標準パッケージを使えば，サードパーティの外部パッケージを使わずとも，簡単に「紙芝居」が作れる。\nさっそく試してみよう。 こんな感じかな。\npackage main import ( \u0026#34;embed\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) //go:embed html var assets embed.FS  func main() { addr := \u0026#34;localhost:3000\u0026#34; fmt.Printf(\u0026#34;Open http://%s/\\n\u0026#34;, addr) fmt.Println(\u0026#34;Press ctrl+c to stop\u0026#34;) http.Handle(\u0026#34;/\u0026#34;, http.FileServer(http.FS(assets)))  if err := http.ListenAndServe(addr, nil); err != nil { fmt.Fprintln(os.Stderr, err) } } ここで //go:embed ディレクティブがコンパイラに html の埋め込みを指示している部分である。 html は実在のディレクトリで，以下の内容の index.html ファイルを格納している1。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Hello World!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; embed.FS 型のインスタンスはそのままでは http.FileSystem 型として使えないので http.FS() 関数で http.FileSystem 型に適合するよう変換している。\n説明はこのくらいにして，とりあえず動かしてみよう。\n$ go run sample1.go Open http://localhost:3000/ Press ctrl+c to stop これでブラウザで http://localhost:3000/ にアクセスしてみると。\nlocalhost:3000/  ありゃりゃーん。 ちょっと切ない感じになってしまった。\nhtml ディレクトリをドキュメント・ルートに出来ないかな，と思って色々眺めてたら fs.Sub() 関数が使えるっぽい。\nというわけで，さきほどのコードを少し書き換える。\npackage main import ( \u0026#34;embed\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/fs\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) //go:embed html var assets embed.FS func main() { addr := \u0026#34;localhost:3000\u0026#34; fmt.Printf(\u0026#34;Open http://%s/\\n\u0026#34;, addr) fmt.Println(\u0026#34;Press ctrl+c to stop\u0026#34;) root, _ := fs.Sub(assets, \u0026#34;html\u0026#34;) http.Handle(\u0026#34;/\u0026#34;, http.FileServer(http.FS(root)))  if err := http.ListenAndServe(addr, nil); err != nil { fmt.Fprintln(os.Stderr, err) } } エラー処理をサボっているがご容赦。 では，このコードを起動してみる。\n$ go run sample2.go Open http://localhost:3000/ Press ctrl+c to stop ブラウザでアクセスしてみると。\nHello  よーし，うむうむ，よーし。 これで安全に紙芝居ができるな。 go build でシングル・バイナリにまとめれば持ち運びもOK（笑）\n//go:embed ディレクティブはかなり便利に使えるようで\npackage main import ( _ \u0026#34;embed\u0026#34; \u0026#34;fmt\u0026#34; ) //go:embed html/index.html var hello string func main() { fmt.Println(hello) } てな感じに，ファイル内容を []byte または string 型のデータに展開してくれる。\n$ go run sample3.go \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Hello World!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; こりゃあ，ひょっとしてテストが捗るねぇ。 データの読み込みを //go:embed ディレクティブで簡略化できるもんね。\nブックマーク  Big Sky :: Go に go:embed が入った。 go:embed 詳解 - 使用編 -  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n   //go:embed ディレクティブはあくまでもファイルに対してディレクトリ構造ごと埋め込むものなので，空のディレクトリは埋め込めない。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "gpgpdump v0.12.1 をリリースした",
      "section": "release",
      "description": "今回は Go 1.16 への対応が主。 機能上の修正・変更はない。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/02/gpgpdump-v0_12_1-is-released/",
      "published": "2021-02-23T12:25:43+00:00",
      "update": "2021-02-23T13:58:31+00:00",
      "content": "OpenPGP パケットの内容を可視化する gpgpdump の v0.12.1 をリリースした。\n Release v0.12.1 · spiegel-im-spiegel/gpgpdump · GitHub  今回は Go 1.16 への対応が主。 機能上の修正・変更はない。\nあと go.mod ファイルや GitHub Actions の設定等を調整して\n$ go install github.com/spiegel-im-spiegel/gpgpdump@latest で最新版をダウンロード\u0026amp;ビルド\u0026amp;インストールできるようにしてみた。\ngpgpdump が依存する自作パッケージも併せてバージョンアップしているが，そっちはまぁいいか。\nコンパイラのおかげなのか，依存している外部パッケージのおかげなのか分からないが，前のバージョンより実行バイナリのサイズがちょびっとだけ小さくなっている。 コンパイラのおかげだといいな。\nブックマーク  OpenPGP の実装 OpenPGP パケットを可視化する gpgpdump  参考図書  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n "
    },
    {
      "title": "Go 1.16 からのモジュール管理",
      "section": "golang",
      "description": "覚え書きとして記しておく",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/manage-modules/",
      "published": "2021-02-21T07:15:24+00:00",
      "update": "2021-02-24T23:17:18+00:00",
      "content": "先日リリースされた Go 1.16 でモジュール管理がいくつか変更になったので，覚え書きとして記しておく。 なお，このブログで書き散らした内容をまとめる形で 以下の Zenn 記事を書いた。 こちらも併せてどうぞ。\n Go のモジュール管理【バージョン 1.16 改訂版】  GO111MODULE 既定値の変更 環境変数 GO111MODULE の既定値が auto から on に変更になった。 GO111MODULE の取りうる値は以下の通り。\n   値 内容     on 常にモジュール対応モードで動作する   off 常に GOPATH モードで動作する   auto $GOPATH/src 以下のディレクトリに配置され go.mod を含まないパッケージは GOPATH モードで，それ以外はモジュール対応モードで動作する    GO111MODULE の値を auto に戻すのであれば go env コマンドで\n$ go env -w GO111MODULE=auto とする。 Go の環境変数の取り扱いについては，拙文「Go 言語の環境変数管理」を参照のこと。\ngo.mod および go.sum の自動更新の抑制 Go 1.15 までは go build や go test などのコマンドで go.mod や go.sum の内容が勝手に更新されていたが， 1.16 からは自動では更新されなくなった。\nなので，コード上の import で新しい外部パッケージを追加しても go.mod や go.sum に記述がないと\n$ go test ./... main.go:9:2: no required module provides package github.com/spiegel-im-spiegel/cov19jpn/chart; to add it: go get github.com/spiegel-im-spiegel/cov19jpn/chart とか\n$ go test ./... go: github.com/spiegel-im-spiegel/cov19jpn@v0.2.0: missing go.sum entry; to add it: go mod download github.com/spiegel-im-spiegel/cov19jpn みたいなエラーが出たりする。\ngo.mod や go.sum をいい感じに更新したいのであれば\n$ go mod tidy とするとよい。\nバージョン付きの go install go install コマンドで指定するパッケージパスにバージョン番号サフィックスを付けることができるようになった。\n$ go install golang.org/x/tools/gopls@v0.6.5 これでバージョンを指定してモジュールのビルド\u0026amp;インストールができる。 ただし go.mod ファイルが replace や exclude ディレクティブを含んでいると go install が失敗するみたい。\n$ go install github.com/spiegel-im-spiegel/cov19jpn@v0.2.0 go install github.com/spiegel-im-spiegel/cov19jpn@v0.2.0: github.com/spiegel-im-spiegel/cov19jpn@v0.2.0 The go.mod file for the module providing named packages contains one or more replace directives. It must not contain directives that would cause it to be interpreted differently than if it were the main module. この場合は今までどおり go get コマンドでビルドまでやってくれるが， go get コマンドによるビルドは将来的に廃止になるみたいなので，早めになんとかしたいものである。\nでもなぁ，私の場合「Go 依存パッケージの脆弱性検査」の誤検出対策に replace ディレクティブを使ってるから悩ましいんだよなぁ\u0026hellip;\n特定バージョンのモジュールの撤回 go.mod で retract ディレクティブを使って特定バージョンのモジュールを撤回できるようになった（go ディレクティブが 1.16 以上の場合）。\nこんな感じにコメントとともに指定するといいらしい（コメント付けられたのか）。\n// Remote-triggered crash in package foo. See CVE-2021-01234. retract v1.0.5 これでこのバージョンを使おうとしても\n$ go list -m -u all example.com/lib v1.0.0 (retracted) $ go get . go: warning: example.com/lib@v1.0.5: retracted by module author: Remote-triggered crash in package foo. See CVE-2021-01234. go: to switch to the latest unretracted version, run: go get example.com/lib@latest てな感じにコメントの内容で警告が表示されるそうだ。\nGOVCS によるバージョン管理ツールの制御 環境変数 GOVCS を使ってリポジトリとバージョン管理ツールを関連付けることができる。 これを使って悪意のあるリポジトリ・サーバへのアクセスを制限することを意図しているようだ。\n環境変数の設定は go env -w コマンドを使うとよいだろう。 たとえば\n$ go env -w \u0026#34;GOVCS=github.com:git,evil.com:off,*:git|hg\u0026#34; とすれば， github.com サイトでは git のみ許容し evil.com は使用禁止，その他のサイトでは git および mercurial のみ許容する，といった指定ができるらしい。\nなお GOVCS の既定値は public:git|hg,private:all となっている。\nブックマーク   New module changes in Go 1.16 - The Go Blog\n  Go モジュールのバージョン管理\n  Go 1.16 がリリースされた\n  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "io/ioutil の非推奨化について",
      "section": "golang",
      "description": "Refactoring は計画的に。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/deprecation-of-ioutil/",
      "published": "2021-02-21T03:06:59+00:00",
      "update": "2021-02-28T00:55:58+00:00",
      "content": "先日リリースされた Go 1.16 における大きな変更のひとつとして io/ioutil パッケージの非推奨化（deprecation）が挙げられる。 Deprecation といっても近い将来に（少なくともバージョン 1.x の間は）廃止されるわけではないのだが， io/ioutil パッケージは徐々にメンテナンスされなくなる可能性があるため，互換関数（または変数）へ置き換えていくことが推奨されている。\n対象となる変数・関数は以下の通り。\n   1.16 以降 非推奨 1.16 以降 推奨     ioutil.Discard io.Discard   ioutil.NopCloser() io.NopCloser()   ioutil.ReadAll() io.ReadAll()   ioutil.ReadDir() os.ReadDir()   ioutil.ReadFile() os.ReadFile()   ioutil.TempDir() os.MkdirTemp()   ioutil.TempFile() os.CreateTemp()   ioutil.WriteFile() os.WriteFile()    このうち ioutil.Discard, ioutil.NopCloser(), ioutil.ReadAll(), ioutil.ReadFile(), ioutil.WriteFile() については置き換え後の変数・関数のラッパーとして再実装されているので，特に気にする必要はないだろう。 何かのついでに refactoring していけばよい。\npackage ioutil import ( \u0026#34;io\u0026#34; \u0026#34;io/fs\u0026#34; \u0026#34;os\u0026#34; \u0026#34;sort\u0026#34; ) // ReadAll reads from r until an error or EOF and returns the data it read. // A successful call returns err == nil, not err == EOF. Because ReadAll is // defined to read from src until EOF, it does not treat an EOF from Read // as an error to be reported. // // As of Go 1.16, this function simply calls io.ReadAll. func ReadAll(r io.Reader) ([]byte, error) { return io.ReadAll(r) } // ReadFile reads the file named by filename and returns the contents. // A successful call returns err == nil, not err == EOF. Because ReadFile // reads the whole file, it does not treat an EOF from Read as an error // to be reported. // // As of Go 1.16, this function simply calls os.ReadFile. func ReadFile(filename string) ([]byte, error) { return os.ReadFile(filename) } // WriteFile writes data to a file named by filename. // If the file does not exist, WriteFile creates it with permissions perm // (before umask); otherwise WriteFile truncates it before writing, without changing permissions. // // As of Go 1.16, this function simply calls os.WriteFile. func WriteFile(filename string, data []byte, perm fs.FileMode) error { return os.WriteFile(filename, data, perm) } // NopCloser returns a ReadCloser with a no-op Close method wrapping // the provided Reader r. // // As of Go 1.16, this function simply calls io.NopCloser. func NopCloser(r io.Reader) io.ReadCloser { return io.NopCloser(r) } // Discard is an io.Writer on which all Write calls succeed // without doing anything. // // As of Go 1.16, this value is simply io.Discard. var Discard io.Writer = io.Discard ioutil.TempDir() と ioutil.TempFile() においては，入出力のインタフェースは os.MkdirTemp(), os.CreateTemp() と完全互換と言えるが，内部のロジックが微妙に異なる。 もしかしたら（並行処理下で使う場合など）何らかの検証が必要かもしれない。\nまぁ os.MkdirTemp(), os.CreateTemp() のほうが出来がいいと思うけど。 可能なら早めに置き換えたほうがいいだろう。\n問題は ioutil.ReadDir() と os.ReadDir() の差異だ。\nGo 1.16 の ioutil.ReadDir() は以下のように実装されている。\n// ReadDir reads the directory named by dirname and returns // a list of fs.FileInfo for the directory\u0026#39;s contents, // sorted by filename. If an error occurs reading the directory, // ReadDir returns no directory entries along with the error. // // As of Go 1.16, os.ReadDir is a more efficient and correct choice: // it returns a list of fs.DirEntry instead of fs.FileInfo, // and it returns partial results in the case of an error // midway through reading a directory. func ReadDir(dirname string) ([]fs.FileInfo, error) { f, err := os.Open(dirname) if err != nil { return nil, err } list, err := f.Readdir(-1) f.Close() if err != nil { return nil, err } sort.Slice(list, func(i, j int) bool { return list[i].Name() \u0026lt; list[j].Name() }) return list, nil } ここで fs.FileInfo 型は Go 1.16 で追加された io/fs パッケージで定義されているが，中身は 1.15 までの os.FileInfo 型と全く同じである。\n// A FileInfo describes a file and is returned by Stat. type FileInfo interface { Name() string // base name of the file  Size() int64 // length in bytes for regular files; system-dependent for others  Mode() FileMode // file mode bits  ModTime() time.Time // modification time  IsDir() bool // abbreviation for Mode().IsDir()  Sys() interface{} // underlying data source (can return nil) } // A FileMode represents a file\u0026#39;s mode and permission bits. // The bits have the same definition on all systems, so that // information about files can be moved from one system // to another portably. Not all bits apply to all systems. // The only required bit is ModeDir for directories. type FileMode uint32 なお Go 1.16 の os.FileInfo 型は fs.FileInfo の type alias として再定義されている。\npackage os import ( \u0026#34;io/fs\u0026#34; \u0026#34;syscall\u0026#34; ) // A FileInfo describes a file and is returned by Stat and Lstat. type FileInfo = fs.FileInfo 一方 os.ReadDir() は以下のように実装されている。\n// A DirEntry is an entry read from a directory // (using the ReadDir function or a File\u0026#39;s ReadDir method). type DirEntry = fs.DirEntry // ReadDir reads the named directory, // returning all its directory entries sorted by filename. // If an error occurs reading the directory, // ReadDir returns the entries it was able to read before the error, // along with the error. func ReadDir(name string) ([]DirEntry, error) { f, err := Open(name) if err != nil { return nil, err } defer f.Close() dirs, err := f.ReadDir(-1) sort.Slice(dirs, func(i, j int) bool { return dirs[i].Name() \u0026lt; dirs[j].Name() }) return dirs, err } ここで fs.DirEntry 型は以下のように定義されている。\n// A DirEntry is an entry read from a directory // (using the ReadDir function or a ReadDirFile\u0026#39;s ReadDir method). type DirEntry interface { // Name returns the name of the file (or subdirectory) described by the entry.  // This name is only the final element of the path (the base name), not the entire path.  // For example, Name would return \u0026#34;hello.go\u0026#34; not \u0026#34;/home/gopher/hello.go\u0026#34;.  Name() string // IsDir reports whether the entry describes a directory.  IsDir() bool // Type returns the type bits for the entry.  // The type bits are a subset of the usual FileMode bits, those returned by the FileMode.Type method.  Type() FileMode // Info returns the FileInfo for the file or subdirectory described by the entry.  // The returned FileInfo may be from the time of the original directory read  // or from the time of the call to Info. If the file has been removed or renamed  // since the directory read, Info may return an error satisfying errors.Is(err, ErrNotExist).  // If the entry denotes a symbolic link, Info reports the information about the link itself,  // not the link\u0026#39;s target.  Info() (FileInfo, error) } つまり返り値から fs.FileInfo の情報を取り出すには fs.DirEntry.Info() メソッドを使い，さらに返り値の error を評価する必要がある。\nこのように ioutil.ReadDir() と os.ReadDir() では返り値とその評価方法が異なるため，単純な置き換えではなく，若干のコードの変更が必要となる。\nRefactoring は計画的に。\nブックマーク  Go1.16で追加されたio#ReadAll関数から読むストリーミング中のバッファ拡張の仕方 - My External Storage #golang io/ioutil の非推奨化（deprecation）について  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    }
  ]
}
