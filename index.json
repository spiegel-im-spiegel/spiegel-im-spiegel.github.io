{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "SSH の認証鍵を GunPG で作成・管理する",
      "section": "openpgp",
      "description": "新たに鍵を作成する場合や今までの鍵を破棄して作り直す場合などの状況があれば検討してもいいだろう。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/openpgp/ssh-key-management-with-gnupg/",
      "published": "2021-01-06T14:06:57+00:00",
      "update": "2021-01-06T14:22:05+00:00",
      "content": "今回は GnuPG で作成した鍵を OpenSSH の認証鍵として使う方法について覚え書きとして記しておく。 現時点で運用できている認証鍵を置き換えるメリットはないが，新たに鍵を作成する場合や今までの鍵を破棄して作り直す場合などの状況があれば検討してもいいだろう。\nまず GnuPG で作成する鍵は機能別に以下の4種類に分類される（ひとつの鍵で複数の機能を持たせることもできる）。\n   機能 略称     署名 S   証明 C   認証 A   暗号化 E    このうち OpenSSH の認証鍵として使えるのは「認証」機能をもった鍵のみである。 認証機能は電子署名用の鍵であれば任意に付与することができるが，専用の副鍵を追加するのがセオリーらしい。\n認証用の副鍵を追加する まず以下の OpenPGP 鍵があるとする（主鍵には SC，副鍵には E の機能が付いてる点に注目）。\n$ gpg --list-keys alice pub ed25519 2021-01-06 [SC] [有効期限: 2021-01-13] 011C720B03D2E1D6BCFA98391DFF44901121B61D uid [ 究極 ] Alice \u0026lt;alice@example.com\u0026gt; sub cv25519 2021-01-06 [E] この鍵に認証用の副鍵を追加する。 鍵の追加には --edit コマンドを使う。 なお --expert オプションと一緒に使うと幸せになれる。\n$ gpg --expert --edit-key alice gpg (GnuPG) 2.2.26; Copyright (C) 2020 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. 秘密鍵が利用できます。 sec ed25519/1DFF44901121B61D 作成: 2021-01-06 有効期限: 2021-01-13 利用法: SC 信用: 究極 有効性: 究極 ssb cv25519/4FECD03BE5BE4454 作成: 2021-01-06 有効期限: 無期限 利用法: E [ 究極 ] (1). Alice \u0026lt;alice@example.com\u0026gt; gpg\u0026gt; ここで addkey コマンドを入力する。\ngpg\u0026gt; addkey ご希望の鍵の種類を選択してください: (3) DSA (署名のみ) (4) RSA (署名のみ) (5) Elgamal (暗号化のみ) (6) RSA (暗号化のみ) (7) DSA (機能をあなた自身で設定) (8) RSA (機能をあなた自身で設定) (10) ECC (署名のみ) (11) ECC (機能をあなた自身で設定)  (12) ECC (暗号化のみ) (13) 既存の鍵 (14) カードに存在する鍵 あなたの選択は? 今回は認証用の鍵の追加なので 7, 8, 11 のいずれかを選択する。 ここは個人的な好みで ECC 鍵を選択しよう。\nあなたの選択は? 11 鍵ECDSA/EdDSAに認められた操作: Sign Authenticate 現在の認められた操作: Sign  (S) 署名機能を反転する (A) 認証機能を反転する (Q) 完了 あなたの選択は? 現在は署名機能（Sign）のみ有効になっているが，欲しいのは認証機能のみなので S と A を一回づつ入力する。\nあなたの選択は? s 鍵ECDSA/EdDSAに認められた操作: Sign Authenticate 現在の認められた操作:  (S) 署名機能を反転する (A) 認証機能を反転する (Q) 完了 あなたの選択は? a 鍵ECDSA/EdDSAに認められた操作: Sign Authenticate 現在の認められた操作: Authenticate  (S) 署名機能を反転する (A) 認証機能を反転する (Q) 完了 あなたの選択は? これで認証機能（Authenticate）のみ有効になった。 Q を入力して次に進もう。\nあなたの選択は? q ご希望の楕円曲線を選択してください: (1) Curve 25519  (3) NIST P-256 (4) NIST P-384 (5) NIST P-521 (6) Brainpool P-256 (7) Brainpool P-384 (8) Brainpool P-512 (9) secp256k1 あなたの選択は? 個人的にお勧めの楕円曲線は “Curve 25519” である。 理由は以下の記事を参考のこと。\n Edwards-curve Digital Signature Algorithm  では 1 を入力して先に進む。\nあなたの選択は? 1 鍵の有効期限を指定してください。 0 = 鍵は無期限  \u0026lt;n\u0026gt; = 鍵は n 日間で期限切れ \u0026lt;n\u0026gt;w = 鍵は n 週間で期限切れ \u0026lt;n\u0026gt;m = 鍵は n か月間で期限切れ \u0026lt;n\u0026gt;y = 鍵は n 年間で期限切れ 鍵の有効期間は? (0)0 鍵は無期限です 有効期限は意味がないので無期限（0）を選択する。 理由は後述するのでちょっと待ってね。\n最終確認をして鍵を生成する。\nこれで正しいですか? (y/N) y 本当に作成しますか? (y/N) y たくさんのランダム・バイトの生成が必要です。キーボードを打つ、マウスを動か す、ディスクにアクセスするなどの他の操作を素数生成の間に行うことで、乱数生 成器に十分なエントロピーを供給する機会を与えることができます。 sec ed25519/1DFF44901121B61D 作成: 2021-01-06 有効期限: 2021-01-13 利用法: SC 信用: 究極 有効性: 究極 ssb cv25519/4FECD03BE5BE4454 作成: 2021-01-06 有効期限: 無期限 利用法: E ssb ed25519/230D446E390C3E49 作成: 2021-01-06 有効期限: 無期限 利用法: A [ 究極 ] (1). Alice \u0026lt;alice@example.com\u0026gt; gpg\u0026gt; save 最後は save コマンドを入力して結果を鍵束に保存する。 これで\n$ gpg --list-keys alice pub ed25519 2021-01-06 [SC] [有効期限: 2021-01-13] 011C720B03D2E1D6BCFA98391DFF44901121B61D uid [ 究極 ] Alice \u0026lt;alice@example.com\u0026gt; sub cv25519 2021-01-06 [E] sub ed25519 2021-01-06 [A] 認証用の鍵が追加できた。\nOpenSSH フォーマットの公開鍵を出力する。 OpenSSH フォーマットの公開鍵は --export-ssh-key コマンドで出力できる。\n$ gpg --export-ssh-key alice ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFfjejx/Saej929myfZoBQAKgusPi2iiOxdZZfpCLxh5 openpgp:0x390C3E49 このテキストをホスト機の ~/.ssh/authorized_keys ファイルに追記すれば仕込みは完了である。 パーミッションの変更を忘れずに（笑）\nこの操作で分かると思うが OpenSSH フォーマットで出力する時点で OpenPGP 鍵の情報はほぼ脱落している。 だから「有効期限は意味がない」のよ。\nちなみにこの操作は公開鍵に対して行われる。 たとえば，認証用の鍵を付加した OpenPGP 公開鍵をサーバ管理者に渡せば，サーバ管理者は集めた OpenPGP 公開鍵に署名して完全性を確保した後， OpenSSH 認証用公開鍵を抽出して各ユーザのディレクトリにまとめてセットする，といったこともできるだろう。\nローカル側の設定 念のためローカル側の設定についても記しておく。\nOpenSSH では ssh-agent を GnuPG の gpg-agent に置き換えることで鍵の管理を GnuPG 側に委譲できる。 gpg-agent は GnuPG 秘密鍵管理の中核コンポーネントで，自身は Pinentry で入力したパスフレーズを一定期間キャッシュすることでユーザの鍵操作を省力化できる（秘密鍵自体のキャッシュは行わない）。\ngpg-agent を OpenSSH のエージェントとして有効にするには ~/.gnupg/gpg-agent.conf ファイルに enable-ssh-support を書き加えればよい1。\nenable-ssh-support default-cache-ttl-ssh 1800 max-cache-ttl-ssh 7200 下2つのオプションは任意で，以下の意味を持つ。\n   オプション名 内容     default-cache-ttl-ssh 直前にアクセスしたキャッシュ・エントリの有効期間を秒単位で指定する。 既定値は 1800   max-cache-ttl-ssh キャッシュ・エントリの有効期間の最大値を秒単位で指定する。 アクセスの有無にかかわらずこの期間が過ぎるとキャッシュがクリアされる。 既定値は 7200    有効期間は大きすぎると漏洩リスクが高まるのでほどほどに（笑）\nGnuPG の鍵束の鍵を OpenSSH の認証鍵として使うには ~/.gnupg/sshcontrol ファイルへの登録が必要である。 先ほど作成した鍵であれば，まず以下のコマンドで\n$ gpg --list-keys --with-keygrip alice pub ed25519 2021-01-06 [SC] [有効期限: 2021-01-13] 011C720B03D2E1D6BCFA98391DFF44901121B61D Keygrip = 97249ABEB2A2FD9E88F6723BB19D4F84B90E261A uid [ 究極 ] Alice \u0026lt;alice@example.com\u0026gt; sub cv25519 2021-01-06 [E] Keygrip = 96CB831965E1A7EB4705577D6A7CB7F9E05C8192 sub ed25519 2021-01-06 [A] Keygrip = F5C774B5B418B6E0B5B7942F93DE82BF2FEF4C8E 該当する鍵の keygrip 値を調べる。 今回の例なら “F5C774B5B418B6E0B5B7942F93DE82BF2FEF4C8E” が該当する keygrip 値である。 これを ~/.gnupg/sshcontrol ファイルに追記する。\n$ echo F5C774B5B418B6E0B5B7942F93DE82BF2FEF4C8E 0 \u0026gt;\u0026gt; ~/.gnupg/sshcontrol これで ssh-add -L コマンドでこの鍵の内容が表示されればOK。\nちなみに keygrip 値の後ろの 0 はキャッシュ期間（秒）を指すらしい。 0 より大きければ gpg-agent.conf ファイルの指定より優先されるってことかな。 また行頭に ! マークを付けると鍵の使用を無効化できる。\n念のため sshcontrol ファイルも不用意に書き込みできないよう制限をかけておくとよいだろう。\nブックマーク  GnuPG チートシート（鍵作成から失効まで） そろそろ GnuPG でも ECC を標準で使うのがいいんじゃないかな OpenSSH 鍵をアップグレードする（さようなら SHA-1）  参考図書  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n   Windows 環境ではもう少し面倒な設定が必要である。詳しくは拙文「GnuPG for Windows : gpg-agent について」 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2021年の祝日・休日に関する注意喚起",
      "section": "remark",
      "description": "職場で知らなかった人が割とおられたので改めて。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/01/holiday-in-2021/",
      "published": "2021-01-05T09:46:07+00:00",
      "update": "2021-01-05T10:24:21+00:00",
      "content": "総務の方が職場中のカレンダーを修正しておられた。 組織内で正式に発行するカレンダーならいつでも差し替え可能だが，壁に貼ってある頂き物や市販のカレンダーは（当然ながら）古い祝日のまま。 マジでお疲れ様です。\nそれはともかく，2021年の祝日・休日1 の改正（改悪だろ！）について，職場で知らなかった人が割とおられたので，改めて注意喚起しておく。\n 具体的には，令和2年12月4日 法律第68号「平成三十二年東京オリンピック競技大会・東京パラリンピック競技大会特別措置法等の一部を改正する法律」により，令和3年に限り，海の日は東京オリンピック開会式前日の7月22日，スポーツの日は開会式当日の7月23日，山の日は閉会式当日の8月8日となった．なお，8月8日は日曜日にあたるため，翌8月9日は休日となる 令和3年の祝日と休日について - 国立天文台暦計算室より  この結果，2021年の祝日・休日は以下の通りとなった。\n   日付 曜日 内容 備考     2021-01-01 金 元日    2021-01-11 月 成人の日    2021-02-11 木 建国記念の日    2021-02-23 火 天皇誕生日    2021-03-20 土 春分の日    2021-04-29 木 昭和の日    2021-05-03 月 憲法記念日    2021-05-04 火 みどりの日    2021-05-05 水 こどもの日    2021-07-22 木 海の日 7月19日から移動   2021-07-23 金 スポーツの日 10月11日から移動   2021-08-08 日 山の日 8月11日から移動   2021-08-09 月 休日 振替休日   2021-09-20 月 敬老の日    2021-09-23 木 秋分の日    2021-11-03 水 文化の日    2021-11-23 火 勤労感謝の日     「出勤したら祝日でした」ってのならまだ笑い話で済むが，「祝日と思って休んだら平日で欠勤になっちゃいました」は割とシャレにならないと思うのだが，どうだろう。 特に10月は（予定通りならオリンピックも終わってるし）間違えて休んじゃう人が続出しそうな気が\u0026hellip;\nこんな全く間に合わない決定をするくらいなら，ハナからしないほうがマシだと思う（子供は夏休みだし大人は自力で休みにすればいい）。 してみると，何もしなかった前政権はまだマシだったか（笑）\nブックマーク  2021年の主な暦 国立天文台から最新の暦情報を取ってくる【広告記事】  参考図書  天文年鑑 2021年版 天文年鑑編集委員会 (編集) 誠文堂新光社 2020-11-24 単行本 4416620616 (ASIN), 9784416620618 (EAN), 4416620616 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  天文ファン必携。2021年版。なお，記載されている祝日・休日は改正前のものなのでご注意を。\nreviewed by Spiegel on 2020-11-25 (powered by PA-APIv5)\n   「国民の祝日」は休日となる。また『「国民の祝日」が日曜日に当たるときは、その日後においてその日に最も近い「国民の祝日」でない日を休日とする』（「国民の祝日に関する法律」より）。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "spiegel-im-spiegel/ml v0.3.0 をリリースした",
      "section": "release",
      "description": "ひょっとして zetamatta/go-readline-ny パッケージ使ったら CUI の簡易プロンプトがもっと簡単に実装できるんちゃうん？",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/01/makelink-0_3_0-is-released/",
      "published": "2021-01-03T07:12:38+00:00",
      "update": "2021-01-03T08:13:27+00:00",
      "content": "\u0026hellip;ついカッとなってやった。 反省はしない\u0026hellip;\nみなさま，あけましておめでとうございます。 本年も「書きたくないときには書かない」「他人の評価など気にしない」をモットーに，ゆるゆるとやっていく所存です。\n閑話休題 (それはさておき) ，正月早々 Zenn で\n 「コマンドラインシェル？？？　誰でも作れますよ」  という記事を眺めてて\n「あれ？ ひょっとして zetamatta/go-readline-ny パッケージ使ったら CUI の簡易プロンプトがもっと簡単に実装できるんちゃうん？」 と思いついてしまい，（たぶん私しか使ってないであろう）Markdown 形式のリンクを生成するツールに手を入れることにした。 その結果を v0.3.0 としてリリースしている。\n Release v0.3.0 · spiegel-im-spiegel/ml · GitHub  今回の変更は以下の3つ。\n リポジトリ名を mklink から ml に変更する spiegel-im-spiegel/ml リポジトリ直下に main.go を移動し，コマンドライン・ツールとして構成し直す 対話モードでの入力を zetamatta/go-readline-ny パッケージで書き直す  最初のはメインマシンを Ubuntu に換装した関係で先延ばしにしていたやつ。 Windows の内部コマンドに mklink てのがあって（シンボリックリンク操作のコマンド），それと名前が被ってたのだ。 実際には GitHub のリポジトリ設定から簡単にリネームできた（簡単ならとっととやれってば）。 旧 URL からのリダイレクトもやってくれている。 感謝。\n2番めは，近年私がよくやる変更。 昔は「Go コード用の外部パッケージとして書いて，その実装例としてコマンドラインツールも書く」というスタンスで構成していたが，機能がニッチ過ぎて汎用で再利用しづらいため「じゃあ最初からコマンドラインツールとして構成すればいいぢゃん」と考えを改めた。\n一応\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/ml/makelink\u0026#34; ) func main() { lnk, err := makelink.New(context.Background(), \u0026#34;https://git.io/vFR5M\u0026#34;) if err != nil { fmt.Fprintln(os.Stderr, err) return } _, _ = io.Copy(os.Stdout, lnk.Encode(makelink.StyleMarkdown)) // Output:  // [GitHub - spiegel-im-spiegel/ml: Make Link with Markdown Format](https://github.com/spiegel-im-spiegel/ml) } のように Go のコードに組み込むことも可能。\n3番目の zetamatta/go-readline-ny パッケージの組み込みはマジでやってよかった。 ざっと見た感じ，このパッケージの特徴は以下の通り。\n エコーバック（？）の Writer を指定できる 簡易ヒストリ機能を付けられる Ctrl+C および Ctrl+D を正しく拾ってエラー（readline.CtrlC および io.EOF）として返してくれる（上位レイヤでの SIGNAL 操作が不要）  たとえばこんな感じに書けるらしい。\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/mattn/go-colorable\u0026#34; \u0026#34;github.com/zetamatta/go-readline-ny\u0026#34; \u0026#34;github.com/zetamatta/go-readline-ny/simplehistory\u0026#34; ) func main() { history := simplehistory.New() editor := readline.Editor{ Prompt: func() (int, error) { return fmt.Print(\u0026#34;$ \u0026#34;) }, Writer: colorable.NewColorableStdout(), History: history, } fmt.Println(\u0026#34;Tiny Shell. Type Ctrl-D to quit.\u0026#34;) for { text, err := editor.ReadLine(context.Background()) if err != nil { fmt.Printf(\u0026#34;ERR=%s\\n\u0026#34;, err.Error()) return } fields := strings.Fields(text) if len(fields) \u0026lt;= 0 { continue } cmd := exec.Command(fields[0], fields[1:]...) cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.Stdin = os.Stdin cmd.Run() history.Add(text) } }  via zetamatta/go-readline-ny: Readline library for golang , used in nyagos  というわけで，拙作の spiegel-im-spiegel/ml でも対話モードのプロンプトに簡易ヒストリが使えるようにした。 めっさ便利！\nzetamatta/go-readline-ny パッケージは元々 NYAGOS をターゲットに書かれたもののようだが，私の Ubuntu 環境でも問題なく動作している。\nうんうん。 よかったよかった。\nブックマーク  Markdown 形式のリンクを生成するツールを作ってみた  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "Ubuntu で最新版 GnuPG をビルドする",
      "section": "openpgp",
      "description": "念のために警告しておくと，今回の自力ビルドは積極的にはお勧めしない。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/openpgp/build-gnupg-in-ubuntu/",
      "published": "2021-01-01T04:18:27+00:00",
      "update": "2021-01-06T11:29:55+00:00",
      "content": "Linux 環境では GnuPG は（ユーザは意識しないかもしれないが）セキュリティ中核部品のひとつだが， Ubuntu はかなり保守的な運用をしているそうで，滅多なことでは GnuPG をアップデートしないようだ。 かといって CVE ID が割り振られるような脆弱性まで長期間放置するのはいかがなものかと思うが。\nそこで，かねてから懸案だった GnuPG の自力ビルドを試してみることにした。\n念のために警告しておくと，今回の自力ビルドは積極的にはお勧めしない。 GnuPG の最新機能を試したいとか，何がなんでも最新版が欲しいとかいうのでない限り APT で配布されるバージョンを使うほうがよい。 まぁ「最悪はこういう手段も取れるよ」という感じで記憶の片隅にでも置いていただければ（笑）\nビルド対象のパッケージ GnuPG は複数のパッケージで構成されていて，個別にビルド\u0026amp;インストールしていく必要がある。 今回ビルド対象となるパッケージは以下の通り。\n   # パッケージ名 バージョン 公開日     1 Libgpg-error 1.41 2020-12-21   2 Libgcrypt 1.8.7 2020-10-23   3 Libassuan 2.5.4 2020-10-23   4 Libksba 1.5.0 2020-11-18   5 nPth 1.6 2018-07-16   6 ntbTLS 0.2.0 2020-08-27   7 GnuPG 2.2.26 2020-12-21    ビルド\u0026amp;インストールの順番は Libgpg-error を最初にして GnuPG を最後にすることさえ気をつければいいと思うが，特にこだわりがないのであれば上の順番でビルドしていくのがいいだろう。\n前準備 最初に，上に挙げた以外でビルドに必要なパッケージを APT でインストールしておく。\n$ sudo apt install libgnutls28-dev bzip2 make gettext texinfo gnutls-bin build-essential libbz2-dev zlib1g-dev libncurses5-dev libsqlite3-dev libldap2-dev 適当にググって見繕ったものなので，もしかしたらこんなに要らないかもしれないが，精査するのが面倒くさかったので今回はこれで（笑）\nビルド用にダウンロードしたファイルの完全性（integrity）をチェックするために電子署名を検証する。 たとえばこんな感じ。\ngpg --verify gnupg-2.2.26.tar.bz2.sig gnupg-2.2.26.tar.bz2 署名チェックに必要な OpenPGP 公開鍵は以下のページにある。\n GnuPG - Signature Key  クリップボード操作ができる xsel または xclip コマンドがあるなら，上のページに貼り付けられている公開鍵（ASCII armor 形式）をコピって\n$ xsel | gpg --import などとすれば公開鍵を取り込める。\n各パッケージのビルド ではパッケージを順にビルドしていこう。 ビルド用に適当なディレクトリをあらかじめ掘っておくとよい。\n$ sudo mkdir /var/local/gnupg-build $ cd /var/local/gnupg-build Libgpg-error のビルド 以下に手順だけ示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/libgpg-error/libgpg-error-1.41.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/libgpg-error/libgpg-error-1.41.tar.bz2.sig -O $ gpg -d libgpg-error-1.41.tar.bz2.sig # integrity check $ sudo tar xvf libgpg-error-1.41.tar.bz2 $ pushd libgpg-error-1.41/ $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。 configure コマンドは引数なしでも問題なさそうだ。\nLibgcrypt のビルド 同様に手順を示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/libgcrypt/libgcrypt-1.8.7.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/libgcrypt/libgcrypt-1.8.7.tar.bz2.sig -O $ gpg -d libgcrypt-1.8.7.tar.bz2.sig # integrity check $ sudo tar xvf libgcrypt-1.8.7.tar.bz2 $ pushd libgcrypt-1.8.7/ $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。\nLibassuan のビルド 同様に手順を示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/libassuan/libassuan-2.5.4.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/libassuan/libassuan-2.5.4.tar.bz2.sig -O $ gpg -d libassuan-2.5.4.tar.bz2.sig # integrity check $ sudo tar xvf libassuan-2.5.4.tar.bz2 $ pushd libassuan-2.5.4 $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。\nLibksba のビルド 同様に手順を示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/libksba/libksba-1.5.0.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/libksba/libksba-1.5.0.tar.bz2.sig -O $ gpg -d libksba-1.5.0.tar.bz2.sig # integrity check $ sudo tar xvf libksba-1.5.0.tar.bz2 $ pushd libksba-1.5.0 $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。\nnPth のビルド 同様に手順を示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/npth/npth-1.6.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/npth/npth-1.6.tar.bz2.sig -O $ gpg -d npth-1.6.tar.bz2.sig # integrity check $ sudo tar xvf npth-1.6.tar.bz2 $ pushd npth-1.6 $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。\nntbTLS のビルド 同様に手順を示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/ntbtls/ntbtls-0.2.0.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/ntbtls/ntbtls-0.2.0.tar.bz2.sig -O $ gpg -d ntbtls-0.2.0.tar.bz2.sig # integrity check $ sudo tar xvf ntbtls-0.2.0.tar.bz2 $ pushd ntbtls-0.2.0 $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。\nGnuPG のビルド ようやく本命。 今までと同様に手順を示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/gnupg/gnupg-2.2.26.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/gnupg/gnupg-2.2.26.tar.bz2.sig -O $ gpg -d gnupg-2.2.26.tar.bz2.sig # integrity check $ sudo tar xvf gnupg-2.2.26.tar.bz2 $ pushd gnupg-2.2.26 $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。 そうそう，最後に\n$ sudo ldconfig としておくのを忘れずに。 これで\n$ gpg --version gpg (GnuPG) 2.2.26 libgcrypt 1.8.7 Copyright (C) 2020 Free Software Foundation, Inc. License GNU GPL-3.0-or-later \u0026lt;https://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Home: /home/username/.gnupg サポートしているアルゴリズム: 公開鍵: RSA, ELG, DSA, ECDH, ECDSA, EDDSA 暗号方式: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256 ハッシュ: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224 圧縮: 無圧縮, ZIP, ZLIB, BZIP2 と最新版で起動できる。 念のため設定状況もチェックしておこう。\n$ gpgconf --list-components gpg:OpenPGP:/usr/local/bin/gpg gpg-agent:プライベート鍵:/usr/local/bin/gpg-agent scdaemon:スマートカード:/usr/local/libexec/scdaemon gpgsm:S/MIME:/usr/local/bin/gpgsm dirmngr:ネットワーク:/usr/local/bin/dirmngr pinentry:パスフレーズ入力:/usr/local/bin/pinentry $ gpgconf --list-dirs sysconfdir:/usr/local/etc/gnupg bindir:/usr/local/bin libexecdir:/usr/local/libexec libdir:/usr/local/lib/gnupg datadir:/usr/local/share/gnupg localedir:/usr/local/share/locale socketdir:/run/user/1000/gnupg dirmngr-socket:/run/user/1000/gnupg/S.dirmngr agent-ssh-socket:/run/user/1000/gnupg/S.gpg-agent.ssh agent-extra-socket:/run/user/1000/gnupg/S.gpg-agent.extra agent-browser-socket:/run/user/1000/gnupg/S.gpg-agent.browser agent-socket:/run/user/1000/gnupg/S.gpg-agent homedir:/home/username/.gnupg ふむむ。 上の設定に合わせて，もう少し弄っておこうか。\n$ cd /usr/local/bin/ $ sudo ln -s /etc/alternatives/pinentry pinentry こんな感じかな。 Pinentry は下手に弄ると絶対にドツボにはまるので今回は既存のものを使う。\nソケットががが（2021-01-06 変更） 上の gpgconf --list-dirs で示されるソケットについて\nsocketdir:/run/user/1000/gnupg dirmngr-socket:/run/user/1000/gnupg/S.dirmngr agent-ssh-socket:/run/user/1000/gnupg/S.gpg-agent.ssh agent-extra-socket:/run/user/1000/gnupg/S.gpg-agent.extra agent-browser-socket:/run/user/1000/gnupg/S.gpg-agent.browser agent-socket:/run/user/1000/gnupg/S.gpg-agent そもそも /run/user/1000/ ディレクトリ1 はブート時（？）に毎回初期化されるのだが，どうやら /usr/bin/ ディレクトリ以下のオリジナル・コンポーネントを使って初期化してるみたいで，そのままだと /usr/bin/gpg-agent のほうが常駐してしまう。\nで，いろいろ調べてみたんだけど /usr/lib/systemd/user/gpg-agent.service ファイルの内容が\n[Unit] Description=GnuPG cryptographic agent and passphrase cache Documentation=man:gpg-agent(1) Requires=gpg-agent.socket [Service] ExecStart=/usr/bin/gpg-agent --supervised ExecReload=/usr/bin/gpgconf --reload gpg-agent とかなっているのが原因のようだ。 最後の2行を\nExecStart=/usr/local/bin/gpg-agent --supervised ExecReload=/usr/local/bin/gpgconf --reload gpg-agent と変更したらちゃんと /usr/local/bin/gpg-agent のほうが起動するようになった。 これでしばらく様子見だな。\n\u0026#x1f647; -- 最後に動作確認 $ echo hello world | gpg -a -s -u mykey -----BEGIN PGP MESSAGE----- owGbwMvMwCG45Zb1ujqFHTKMp4WSGOLfTbPOSM3JyVcozy/KSeHqmMzCIMjBYC2m yCIdxHTby+542ccHayVgeliZQBpkZYoLMlPTU3P0MnP1oEyH9NzEzBy95PxcBi5O AZj6RwcY/scanE3cwbVrv0v/zA7njR1J8d7vTjwP28EmLvzWVuPhqnaG/4kBz24f 634aYBi/NW79/1WcDusyco91C7N6zWwVC114PRsA =/6XI -----END PGP MESSAGE----- 署名時に Pinentry が起動してパスフレーズが通ればOK。 よーし，うむうむ，よーし。\nブックマーク   Nitrokey/gnupg-docker: Build and use specific GnuPG version using Ubuntu image within Docker\u0026rsquo;s container : Docker 環境で GnuPG をビルド\u0026amp;セットアップする\n  GnuPG チートシート（鍵作成から失効まで）\n  Windows Terminal × NYAGOS × Scoop ＝ ♥ : Windows 版 GnuPG は Scoop 経由でインストールするのがオススメ\n    ちなみに 1000 はユーザIDを指す。ログインしている自身のユーザIDを知るには id -u で調べられる。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "宇宙は何色？",
      "section": "remark",
      "description": "Cosmic Latte というのは2002年に修正論文が発表された全宇宙の色の平均値のこと。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/12/cosmic-latte/",
      "published": "2020-12-30T04:56:08+00:00",
      "update": "2020-12-30T04:58:56+00:00",
      "content": "2020-12-27 の “Astronomy Picture of the Day” が “Cosmic Latte” でちょっとびっくりした（笑）\nCosmic Latte というのは2002年に修正論文1 が発表された全宇宙の色の平均値のこと。 当時のページはもう残ってないみたいなので Internet Archive から。\n The Cosmic Spectrum and the Color of the Universe By Karl Glazebrook \u0026amp; Ivan Baldry  WIRED の記事は残ってるみたい。 流石！\n Universe: Beige, not Turquoise | WIRED  実際にはこんな色。 Color-hex は #fff8e7。\n  via Cosmic Latte: The Average Color of the Universe  私も日記ページの背景色にしていたことがある。\nなんか懐かしいなぁ。\nブックマーク  APOD: 2002 July 2 - The Average Color of the Universe 再び発表された宇宙の色：「初期の宇宙は青かった」 宇宙の色は何色？ — 旧メイン・ブログ | Baldanders.info  参考図書  天体物理学 Arnab Rai Choudhuri (著), 森 正樹 (翻訳) 森北出版 2019-05-28 単行本 4627275110 (ASIN), 9784627275119 (EAN), 4627275110 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  興味本位で買うにはちょっとビビる値段なので図書館で借りて読んでいる。まえがきによると，この手のタイプの教科書はあまりないらしい。内容は非常に堅実で分かりやすい。理系の学部生レベルなら問題なく読めるかな。\nreviewed by Spiegel on 2019-11-13 (powered by PA-APIv5)\n   2001年に発表された論文では宇宙の平均色はトルコ石のような緑色とされていたが，その後，計算アルゴリズムにバグが見つかったとかで翌年2002年に修正論文が発表された。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "ルールを解釈で捻じ曲げる",
      "section": "remark",
      "description": "“People don't want to be educated, they want to be entertained”",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/12/rules-and-interpretations/",
      "published": "2020-12-29T07:06:27+00:00",
      "update": "2020-12-30T00:16:22+00:00",
      "content": "「数学ガール」シリーズでおなじみの結城浩さんが Twitter でゼロの偶奇を問うアンケートをされていて，その結果について\n「0は偶数です」を正しいとした方は58%で、驚くほどの低正解率でした。\n「0は偶数でも奇数でもありません」を正しいとした方が41%もいらっしゃいました。この回答をした方の理由をお聞きしたいです。https://t.co/reMDPiPM9f\n\u0026mdash; 結城浩 (@hyuki) December 28, 2020  と感想を tweet しておられた。\n実はこのアンケートには元ネタがあるそうで，それがこれ。\n The Parity Of Zero 「0は偶数ではない」と多くの人が信じているのは教育に問題があるという指摘 - GIGAZINE  わざわざこんな辺境の記事を読むような人には自明だろうが，念のためにいうと，偶数とは「2の整数倍数」あるいは「2で割り切れる整数」として 定義 されるものである。 プログラマ風に言うなら「2進数に展開した際に最下位ビットが0になる整数値」または「n\u0026amp;1==0 が true となる int n」でもいいだろう（笑） いずれにしてもゼロは偶数と言える，議論の余地なく。\nこの話のポイントは，偶奇の色分けは「定義」であるということだ。 言い方を変えるなら「2で割り切れる整数を偶数としましょう」という「ルール」である。 つまり「0は偶数でも奇数でもありません」と考えた人は，思い込みの解釈で偶奇のルールを捻じ曲げてしまったわけだ。\nこれで思い出したのが数年前に話題になった「掛け算は順序が大事」という話である。 もちろん掛け算に順序に関するルールはない。 その上で数の掛け算には「交換法則」が成り立つという点が算数の算数たる所以なのだが，そういうのを全部チャイして「順序が大事」と言っちゃってるわけだ。\n当時はこの話を聞いて「日本の学校教育 ＼(^o^)／ｵﾜﾀ」と思ったものだが，似たような話は世界中どこにでも転がっているということなのかもしれない。 これに関して，最初に挙げた記事の\nIt doesn’t necessarily need to be made “relevant.” Yes, for some people you can create the motivation that way, but for others, they will engage purely for the pleasure of finding things out, and the satisfaction in being able to see a reason behind things that were previously stated without justification. via The Parity Of Zero  という部分は結構重要なポイントに見える。 ものに喩えるのは私もよくやるが，喩えを行う場合はその「差異」を常に意識しないと，分かりやすい喩えの方に意識が引きずられてしまう。\nまぁ，日本の，いや世界の数学教育の話はここまでにしておいて，注目したい点は「ルールを解釈で捻じ曲げる」人が一定数いるということだろう。\n典型例は日本の「憲法九条」かな。 「解釈」で捻れまくっているよね。 あるいは知財やプライバシー・セキュリティ関連の法律など「ガイドライン」という名の解釈によって為政者に都合よく運用される風景が当たり前になっている。\nBruce Schneier 先生原著の『セキュリティはなぜやぶられたのか』では「抑止1」における教育の必要性を説く。\n 抑止が効果を持つためには、「教育」が必要だ。社会が犯罪から守られているのは、基本的に、攻撃に対する直接的な防御があるからではない。人々が法律を守るからだ。ほとんどの人は倫理や道徳を重んじる。倫理は人が生まれながらに持つ性質で、これがなかったら人は文明化できなかっただろう。道徳は、何が道徳的で善良な市民とはどういうものかという教育によって身につけるものだ セキュリティはなぜやぶられたのかより  倫理や道徳はともかく，ルールを作ってそれを守ってもらいたいなら，教える側にしても教わる側にしても，それをどのように解釈するか（あるいはされるか）については常に注意を払うべきかもしれない。 なにせ偶数の定義すら捻じ曲げて解釈してしまうのが人間なのだから（笑）\nあちこちの職場を渡り歩いて，その度に「セキュリテイ研修」を受けるが，ぶっちゃけルールを押し付けるだけのところが多く「何故」がないんだよね（まぁ「傭兵」相手に時間をかける気はないってことなんだろうけど）。 特にセキュリティ管理はルールの根拠をきちんと示さなければ守ろうとは思わないし，しぶしぶ守るとしても「解釈で捻じ曲げる」余地を与えてしまう。\nPeople don’t want to be educated, they want to be entertained. via The Parity Of Zero  私は「守られないルールは，ルール自体に問題がある」と考えるが「ルールを解釈で捻じ曲げる」事態が常態化するなら（教育を含めて）マネジメント全体を見直す最初のアラームとなるだろう。\n参考図書  数学ガールの誕生　理想の数学対話を求めて 結城 浩 (著) SBクリエイティブ 2013-09-13 (Release 2014-09-13) Kindle版 B00NAQA33A (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  結城浩さんの講演集。こういう場所に立ち会える今の学生さんは羨ましい。\nreviewed by Spiegel on 2013-09-21 (powered by PA-APIv5)\n  いかにして問題をとくか G. ポリア (著), Polya,G. (原著), 賢信, 柿内 (翻訳) 丸善 1975-04-01 単行本 4621045938 (ASIN), 9784621045930 (EAN), 4621045938 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  数学書。というか問いの立てかたやものの考え方についての指南書。のようなものかな。\nreviewed by Spiegel on 2014-09-26 (powered by PA-APIv5)\n  セキュリティはなぜやぶられたのか ブルース・シュナイアー (著), 井口 耕二 (翻訳) 日経BP 2007-02-15 単行本 4822283100 (ASIN), 9784822283100 (EAN), 4822283100 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  原書のタイトルが “Beyond Fear: Thinking Sensibly About Security in an Uncertain World” なのに対して日本語タイトルがどうしようもなくヘボいが中身は名著。とりあえず読んどきなはれ。ゼロ年代当時 9.11 およびその後の米国のセキュリティ政策と深く関連している内容なので，そのへんを加味して読むとよい。\nreviewed by Spiegel on 2019-02-11 (powered by PA-APIv5)\n   『セキュリティはなぜやぶられたのか』では「抑止」を「将来の攻撃をセキュリティシステムが防止するやり方」と定義している。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "「無人化システム」とメンタル・モデル",
      "section": "remark",
      "description": "20世紀なコードはもうケッコウ",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/12/mental-model/",
      "published": "2020-12-28T12:31:19+00:00",
      "update": "2020-12-28T21:55:14+00:00",
      "content": "先週のことで恐縮だが\n COBOLのコードは未だに我々の金を握っており、バリバリ現役である - YAMDAS現更新履歴  という記事が公開されていて，これを読んで思い出したのが20世紀に参加した某プロジェクトでの世間話。\nもう四半世紀前のうろ覚えでしかも人伝 (ひとづて) に聞いた内容だが，当時は意図的に難読化コードを書くプログラマも多かったらしい。 理由は単純で，コードを「属人化」してしまえば少なくともそのプロジェクトに関してはクビにならないから。\nというわけで COBOL プログラマはきっと「まだだ！ まだ終わらんよ！」と思っているだろう（笑）\n「無人化システム」 一方，上の記事が出る少し前に\n 「無人化システム」を駆逐する組織マネジメントとエンジニアリング  というのが Zenn で公開されていて，あまりの納得感に投げ銭 (サポート) してしまったのだが（笑），記事では「無人化システム」を\n システム運用が属人化し、かつその運用者が退職するとシステムが無人化します。我々の会社ではこのようなシステムを『無人化システム』と呼んでいます。\n無人化システムは「誰も詳細は知らないが、なぜか動いているシステム」です。\n 「無人化システム」を駆逐する組織マネジメントとエンジニアリングより  と定義しているようだ。\n「傭兵」時代は「汎用機＋COBOL」からのリプレイス案件を時々受けていたが，何が困るって，ドキュメント化されない「誰も知らないコード」が平気で紛れ込んでいて1，しかもそのコードに手を出すとどんな影響が出るか予測できないという事態にホンマに困っていた（あと，どうやっても正規化できないデータベースとかw）。\nまっ，要するに，時代や言語に関係なく，この手の話は割と普遍的に観測できるということなんだろう。\nメンタル・モデル 2017年に公開された記事だが\n Design Philosophy On Data And Semantics  というのを最近読んだ。 特に Go でコードを書く人はこの記事は必読だろう。\nいくつか拾い読みしてみる。\nA consistent use of value/pointer semantics, for a given type of data, is critical if you want to maintain integrity and readability throughout your software. Why? Because, if you are changing the semantics for a piece of data as it is passed between functions, you are making it difficult to maintain a clear and consistent mental model of the code. The larger the code base and the team becomes, the more bugs, data races and side effects will creep unseen into the code base. via Design Philosophy On Data And Semantics  Tom has also mentioned that a box of copy paper can hold 100k lines of code. Take a second to let that sink in. For what percentage of the code in that box could you maintain a mental model of? via Design Philosophy On Data And Semantics  “The hardest bugs are those where your mental model of the situation is just wrong, so you can’t see the problem at all” - Brian Kernighan via Design Philosophy On Data And Semantics  これ以降は Go をターゲットにした具体的な話に入っていくのだが，これが Go に限る話ではないということはお分かりいただけるだろう。\nプログラマにとって最も信頼できるドキュメントは動いているプログラムコードである。 だからこそコードは「文芸的2」であるべきだし，プログラマは要件定義の段階から積極的にコードを書くべきだと思う。 リファクタリングは何時でもできるのだから3。\n書いた人にしか分からない20世紀なコードはもうケッコウである。\nブックマーク  技術的負債とハッカー    勿論ちゃんとしてる企業もあるよ。コードを1行修正するのにも2重3重のレビューを行って，変更申請書が受理されないと変更できない，みたいなガチガチの企業もあったな。 \u0026#x21a9;\u0026#xfe0e;\n 「コードはもっと文芸的であるべき」というのはクヌース博士のいわゆる「文芸的プログラミング（literate programming）」とはちょっと違う。ごめんペコン。 \u0026#x21a9;\u0026#xfe0e;\n というか，これからの時代はリファクタリングに厚い言語を選択すべき。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2020-12-27 のブックマーク",
      "section": "bookmarks",
      "description": "「Hugo 0.79.1: One Security Patch for Hugo on Windows」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2020/12/27-bookmarks/",
      "published": "2020-12-27T01:17:03+00:00",
      "update": "2020-12-30T01:57:26+00:00",
      "content": "リリース情報  Hugo 0.79.1: One Security Patch for Hugo on Windows | Hugo  セキュリティ＆プライバシー関連  NSA on Authentication Hacks (Related to SolarWinds Breach) - Schneier on Security  SolarWindsのサプライチェーン攻撃についてまとめてみた - piyolog 米政府機関の“cyber breach”被害、破られたのは何？ - ITmedia NEWS Russia’s SolarWinds Attack - Schneier on Security   ジャーナリスト36人以上のiPhoneが「ゼロクリック」スパイウェアにハックされていたことが発覚 | TechCrunch Japan 情報を外部に送信している？　疑惑のWebブラウザ「Smooz」が配信停止に - ITmedia NEWS 「Emotet」と呼ばれるウイルスへの感染を狙うメールについて：IPA 独立行政法人 情報処理推進機構 : 事例の追加 TwitterがAPI機能を拡張、開発者は公開された会話の追跡が可能に | TechCrunch Japan Investigating the Navalny Poisoning - Schneier on Security China\u0026rsquo;s Secret War for U.S. Data Blew American Spies' Cover  How China Uses Stolen US Personnel Data - Schneier on Security    天文関連  2021年には軌道上での燃料補給や製造が理論から現実へ変わる | TechCrunch Japan 伊能忠敬が師事した江戸の天文学者・高橋至時をご存じか？（ブルーバックス編集部） | ブルーバックス | 講談社  Linux または Ubuntu に関する話題  Ubuntu 20.04 その216 - CentOSユーザーに贈るUbuntu LTSに移行する6つのポイント - kledgeb  Go 言語関連  [Go]os.Stdinへの全件読み込みを複数回すると、2回目以降先頭に余計な改行が必ず入ってきてしまう件 fzf ライクな fuzzy-finder を提供する Go ライブラリを書いた - blog.syfm  S3 のファイルをあいまい検索で操作できる s3fzf という CLI ツールをつくった   Goでライブラリを使用せずTwitterAPIを実装する - Qiita goで作るAPIのセキュリティを考えた - Qiita 【Go】imagick を使用して画像にテキストを書き込む Goにproperty based testingを布教したい GitHub - mattn/godown: Convert HTML into Markdown : HTML → markdown 変換  Go でモブログシステム作った   Go 製 CLI にプラグイン機構を作る方法n選  Rust 言語関連  [Rust] FFIでよく使う型変換  その他  「トランザクション張っておけば大丈夫」と思ってませんか？ バグの温床になる、よくある実装パターン GPG で複数の受取人で暗号化する時に \u0026ndash;group オプションが便利 - yu8mada Apple M1チップ対応「Docker Desktop」、x86用のコンテナイメージのビルドと実行も可能。Docker社が説明 － Publickey GitHubをチーム開発で利用する際に行った設定などを紹介 Kubernetesを用いてハイパーコンバージドインフラを実現する「Harvester」、Rancher Labsがオープンソースで公開 － Publickey COBOLのコードは未だに我々の金を握っており、バリバリ現役である - YAMDAS現更新履歴 Hugo で React + TypeScript を利用してサクッとウェブサイトに RSS リーダーを追加する  "
    },
    {
      "title": "ポインタが指し示す意味を考える",
      "section": "golang",
      "description": "Go では goroutine や interface 型を使った抽象化で並列処理やヒープ管理などの面倒くさい部分をランタイム・モジュールに丸投げする。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/value-pointer-semantic/",
      "published": "2020-12-26T06:08:29+00:00",
      "update": "2020-12-27T13:19:02+00:00",
      "content": "以下の記事がちょっと面白かったのでこの記事でも試してみる。\n Go: Should I Use a Pointer instead of a Copy of my Struct? | by Vincent Blanchon | A Journey With Go | Medium Goにおけるポインタの使いどころ  なお，大元の Should I Use a Pointer instead of a Copy of my Struct? が書かれたのは2019年5月で，おそらく Go のバージョンも 1.12 あたりだと思うので，その辺を考慮して読むといいだろう。 ちなみに A Journey With Go は Go の内部動作について割と詳しく解説されていてオススメの読み物である。\nヒープのコスト 起点 (トリガー) はこの構造体型。\ntype S struct { a, b, c int64 d, e, f string g, h, i float64 }  via Should I Use a Pointer instead of a Copy of my Struct?  そして，この型のインスタンスを生成する（実質的な）構築子を2つ用意する。\nfunc byCopy() S { return S{ a: 1, b: 1, c: 1, e: \u0026#34;foo\u0026#34;, f: \u0026#34;foo\u0026#34;, g: 1.0, h: 1.0, i: 1.0, } } func byPointer() *S { return \u0026amp;S{ a: 1, b: 1, c: 1, e: \u0026#34;foo\u0026#34;, f: \u0026#34;foo\u0026#34;, g: 1.0, h: 1.0, i: 1.0, } }  via Should I Use a Pointer instead of a Copy of my Struct?  2つの関数はいずれもリテラル表現で指定された内容のインスタンスを返すが， byCopy() 関数は値を byPointer() 関数はポインタを返すという違いがある。 また byCopy() 関数ではインスタンスをスタック上に置くが byPointer() 関数ではインスタンスをヒープ上に生成する1。\nこれらの関数の呼び出しコストを計測するベンチマーク・テストは以下の通り。\nfunc BenchmarkMemoryStack(b *testing.B) { var s S b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { s = byCopy() } b.StopTimer() _ = fmt.Sprintf(\u0026#34;%v\u0026#34;, s.a) } func BenchmarkMemoryHeap(b *testing.B) { var s *S b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { s = byPointer() } b.StopTimer() _ = fmt.Sprintf(\u0026#34;%v\u0026#34;, s.a) } 元記事のコードでは GC (Garbage Collection) の挙動を検証するために色々と仕込んでいるが，今回はコストだけを測ればいいので単純な構成にしてある。\n結果はこんな感じ。\n$ go test ./... -bench Memory -benchmem goos: linux goarch: amd64 pkg: pointer BenchmarkMemoryStack-4 132169167 9.04 ns/op 0 B/op 0 allocs/op BenchmarkMemoryHeap-4 15257716 71.6 ns/op 96 B/op 1 allocs/op PASS ok pointer 3.233s まぁ，元記事とだいたい同じ結果かな。 見にくいので表にまとめておこう。\n   関数名 実行時間\n(ナノ秒) Alloc\nサイズ Alloc\n回数     BenchmarkMemoryStack 9.0 0 0   BenchmarkMemoryHeap 71.6 96 1    言うまでもないが s = byCopy() は代入文で Go では代入時に必ずコピーが発生する。 ただし s = byCopy() がインスタンス自体のコピーなのに対し s = byPointer() ではポインタ値のみコピーされる。\nつまり上の結果はヒープ領域の割当と解放にかかる（GC を含む）時間コスト（の平均）がインスタンスのコピーよりもかなり大きいことを示している。 それでも（GC のオーバーヘッドを含めても）平均で100ナノ秒未満で済んでいるなら十分に優秀だと思うけどね。\n元記事でも解説されているが Go の GC は独立の goroutine で駆動するため，アーキテクチャ2 や使用するコア数の影響を大きく受ける。 GC を含めてシビアな評価が必要なのであれば，その辺の環境を含めて考えるべきだろう。\nコピーのコスト（2020-12-27 訂正） 元記事には続きがある。 さきほどの構造体 S に対し\n//go:noinline func (s S) stack(s1 S) {} //go:noinline func (s *S) heap(s1 *S) {}  via Should I Use a Pointer instead of a Copy of my Struct?  というメソッドを用意してベンチマークテストを以下のように書き直す3。\nfunc BenchmarkMemoryStack(b *testing.B) { var s S var s1 S s = byCopy() s1 = byCopy() for i := 0; i \u0026lt; b.N; i++ { for i := 0; i \u0026lt; 1000000; i++ { s.stack(s1) } } } func BenchmarkMemoryHeap(b *testing.B) { var s *S var s1 *S s = byPointer() s1 = byPointer() for i := 0; i \u0026lt; b.N; i++ { for i := 0; i \u0026lt; 1000000; i++ { s.heap(s1) } } }  via Should I Use a Pointer instead of a Copy of my Struct?  Go の関数引数は値渡し（call by value）なので引数として渡す時点でコピーが発生するが s.heap(s1) はポインタ値がコピーされるだけなので，単純に考えれば s.stack(s1) のほうがコストが大きいように思える。\n実際にこれを実行すると\n$ go test ./... -bench Memory -benchmem goos: linux goarch: amd64 pkg: pointer BenchmarkMemoryStack-4 174\t6794688 ns/op\t0 B/op\t0 allocs/op BenchmarkMemoryHeap-4 514\t2263913 ns/op\t0 B/op\t0 allocs/op PASS ok pointer\t3.285s てな感じになる。\nんー。 元記事とは少し違うが，3倍程度の差があるかな。 これも表にまとめておこう。\n   関数名 実行時間\n(μ秒) Alloc\nサイズ Alloc\n回数     BenchmarkMemoryStack 6.8 0 0   BenchmarkMemoryHeap 2.3 0 0    なお //go:noinline ディレクティブがないと最適化されてしまいほとんど差がなくなるようだ。\nInterface のコスト ではここで元記事にはなかったテストを考えてみよう。\n構造体 S に以下のメソッドを追加し\nfunc (s S) ValueA() int64 { return s.a } このメソッドを有効にする interface 型\ntype IS interface { ValueA() int64 } と，この型を返す構築子\nfunc byInterface() IS { return S{ a: 1, b: 1, c: 1, e: \u0026#34;foo\u0026#34;, f: \u0026#34;foo\u0026#34;, g: 1.0, h: 1.0, i: 1.0, } } を定義する。 この構築子を使ったベンチマークテストも書いておこう。\nfunc BenchmarkMemoryBox(b *testing.B) { var s IS b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { s = byInterface() } b.StopTimer() _ = fmt.Sprintf(\u0026#34;%v\u0026#34;, s.ValueA()) } これを最初のベンチマークテストと比較してみる。 結果はこんな感じ。\n$ go test ./... -bench Memory -benchmem goos: linux goarch: amd64 pkg: pointer BenchmarkMemoryStack-4 132085750 9.08 ns/op 0 B/op 0 allocs/op BenchmarkMemoryHeap-4 15357787 70.0 ns/op 96 B/op 1 allocs/op BenchmarkMemoryBox-4 14711439 76.0 ns/op 96 B/op 1 allocs/op PASS ok pointer 4.392s 表にまとめておこう。\n   関数名 実行時間\n(ナノ秒) Alloc\nサイズ Alloc\n回数     BenchmarkMemoryStack 9.1 0 0   BenchmarkMemoryHeap 70.0 96 1   BenchmarkMemoryBox 76.0 96 1    時間コストについて byCopy() 関数と byPointer() 関数を足したよりちょっと小さい，って感じだろうか。\nInterface 型の機能とはボックス化（boxing）である。 ボックス化されたインスタンスは必ずヒープ領域に置かれる。 その意味で byPointer() 関数と byInterface() 関数がメモリ管理で似たような挙動になるのは納得できるのではないだろうか。\nヒープを恐れるな ヒープメモリ操作が高コストなのは汎用 OS 下で動くアプリケーションであれば自明であり，そこに GC のオーバーヘッドが加わるのだから，そりゃあもう「あたり前田のクラッカー」という奴である。\n私のようなロートル世代ではヒープ管理は（可能であれば）忌避したい代物だった。 上述したように操作自体が高コストなのに加えて割当と解放を漏れなく矛盾なく記述しきらなければならないのだから面倒くさいことこの上ない。\nGo では goroutine や interface 型を使った抽象化と引き換えに並列処理やヒープ管理などの面倒くさい部分をランタイム・モジュールに丸投げする。 しかもその「面倒くさい部分」を細かく制御できず，これが Go プログラミングにおける重要なトレードオフとなっているのである。\nもしヒープ管理をテッペンから見下ろして完全掌握したいと考えるのなら GC は邪魔なだけだし，そもそも Go で書くインセンティブがない。 それこそ近ごろ流行りの Rust とかで書くべきだろう。\n今回の記事のような話を知識として知っておくのはいいことだと思うが，設計上の重要なポイントではない（むしろチューニングの話だ）。 ポインタを「概念」で捉えることができれば「ポインタが指し示す意味」について深く考察できるようになる。 それこそが本来の「プログラム設計」というやつである。\nブックマーク  Design Philosophy On Data And Semantics Big Sky :: Go のポインタの躓きやすい点  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n  Go言語による並行処理 Katherine Cox-Buday (著), 山口 能迪 (翻訳) オライリージャパン 2018-10-26 単行本（ソフトカバー） 4873118468 (ASIN), 9784873118468 (EAN), 4873118468 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版もある。感想はこちら。 Go 言語で並行処理を書くならこの本は必読書になるだろう。\nreviewed by Spiegel on 2020-01-13 (powered by PA-APIv5)\n  SAVED. ／ Be mine! 坂本　真綾 (メインアーティスト) FlyingDog 2014-02-05 (Release 2014-02-05) MP3 ダウンロード B00HY73M16 (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  「世界征服〜謀略のズヴィズダー〜」OP曲。万能感溢れるノリのいい曲である（笑）\nreviewed by Spiegel on 2020-12-26 (powered by PA-APIv5)\n   よく勘違いされるが（というか私も最初の頃は勘違いしていたが）リテラル表現で \u0026amp;S{ ... } と記述する場合は，どっかに固定のインスタンスがあって，その固定インスタンスへのポインタを示しているのではなく，暗黙的にヒープ上にインスタンスを生成してリテラルの内容で初期化している。つまり \u0026amp;S{} は new(S) と等価である。むしろリテラルで初期値を指定できる分だけ new() 関数より簡潔で優れている。詳しくは『プログラミング言語Go』の4.4.1章を参照のこと。これを知ってから組み込みの new() 関数はほとんど使わなくなった（笑） \u0026#x21a9;\u0026#xfe0e;\n 最近の goroutine はプリエンプティブ・マルチタスクが可能になったが，アーキテクチャによっては対応していない場合がある。 \u0026#x21a9;\u0026#xfe0e;\n 元記事では //go:noinline ディレクティブがなかったが，これがないと最適化されしまうため，コードを変更している。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "GnuPG 2.2.26 がリリースされた",
      "section": "release",
      "description": "LDAP のサポートが改善され， Active Directory の基本的なサポートが追加された。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/12/gnupg-2_2_26-is-released/",
      "published": "2020-12-22T10:21:54+00:00",
      "update": "2021-01-01T04:19:13+00:00",
      "content": "GnuPG 2.2.26 がリリースされた。\nこのバージョンでは\nThis is a maintenance release improving support for LDAP keyservers and enterprise use. via [Announce] GnuPG 2.2.26 released  とのことで，さらに Twitter では\nThe #EU_Commission might not like such software but here is another GnuPG release. This time with improved support for LDAP and basic support for Active Directory : https://t.co/QWlOjAwALO\n\u0026mdash; GNU Privacy Guard (@gnupg) December 21, 2020  とか tweet されていて，ちょっと笑ってしまった。 まぁ，今の OpenPGP 鍵サーバは明らかに設計限界に来てるからねぇ。 今後も注意して見ていこう。\nその他の詳細はこちら。\n gpg: New AKL method \u0026ldquo;ntds\u0026rdquo;. gpg: Fix \u0026ndash;trusted-key with fingerprint arg. scd: Fix writing of ECC keys to an OpenPGP card. [#5163] scd: Make an USB error fix specific to SPR532 readers. [#5167] dirmngr: With new LDAP keyservers store the new attributes. Never store the useless pgpSignerID. Fix a long standing bug storing me keys on an ldap server. dirmngr: Support the new Active Direcory LDAP schema for keyservers. dirmngr: Allow LDAP OpenPGP searches via fingerprint. dirmngr: Do not block other threads during keyserver LDAP calls. Support global configuration files. [#4788] Fix the iconv fallback handling to UTF-8. [#5038]  Release-info: https://dev.gnupg.org/T5153 via GnuPG 2.2.26 released  ビルド対象パッケージ 自前でビルドする際の対象パッケージは以下の通り。\n   # パッケージ名 バージョン 公開日 更新     1 Libgpg-error 1.41 2020-12-21    2 Libgcrypt 1.8.7 2020-10-23    3 Libassuan 2.5.4 2020-10-23    4 Libksba 1.5.0 2020-11-18    5 nPth 1.6 2018-07-16    6 ntbTLS 0.2.0 2020-08-27    7 GnuPG 2.2.26 2020-12-21     アップデートは計画的に。\nブックマーク   GnuPG and LDAP : GnuPG と LDAP との連携方法\n  OpenPGP の実装\n  参考図書  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n "
    }
  ]
}
