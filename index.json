{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "おそるべき絵文字",
      "section": "remark",
      "description": "なんでこんなカオスになっちゃったのかねぇ。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/terrible-emoji/",
      "published": "2021-03-30T10:58:27+00:00",
      "update": "2021-03-30T11:20:40+00:00",
      "content": "きっかけは以下の tweet:\nほら #golang ならこんなに簡単に絵文字を取り除けますよ！8ビット単位だとややこしい書き方が必要になっちゃう。https://t.co/AiELa8RlvS\n\u0026mdash; のぼのぼ📡 (@nobonobo) March 28, 2021  この tweet の元ネタである「Go言語の正規表現regexpが遅すぎる」というのは概ねその通りで，私も記事で書いた が，これはそもそも regexp パッケージの設計方針が\nThe regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. via regexp - The Go Programming Language  となっているためで，「遅くなりすぎない」ことのトレードオフとして（Ruby や Perl などと比べて）全体的に遅いのである1。\nただ，サンプルコードにある\nvar emojiRegex = regexp.MustCompile(\u0026#34;[\\U0001f000-\\U0001ffff]\u0026#34;) という正規表現はさすがに端折りすぎで，つい「そんな単純じゃねーよ」と脊髄反射してしまったのは許してほしい。\nでも，よく考えたら，ここのブログや Zenn でも絵文字の話をよく書くようになったが，まとまった記事としては書いてない。 というわけで，この記事である程度まとめてみたいと思う。\n以上，前説おわり。\nUnicode は1コード＝1文字じゃない まず大前提として Unicode は1コード＝1文字じゃない。 これは日本語圏で苦労している私たちには自明だと思うが，たとえば「ペンギン」という単語にしたって\n ペ：U+30D8 + U+309A ン：U+30F3 ギ：U+30AD + U+3099 ン：U+30F3  と濁点・半濁点が分離している場合がある 。 これは絵文字でも同様で，たとえば「土下座する男性 🙇‍♂️」を拙作の gnkf を使って Unicode 符号点（code point）に分解すると\n$ echo 🙇‍♂️ | gnkf dump --unicode 0x0001f647, 0x200d, 0x2642, 0xfe0f, 0x000a と，4つの符号点の合成列として構成されているのが分かる。 ちなみに各符号点の内容は\n   符号点 字形 名称     U+1F647 🙇 PERSON BOWING DEEPLY   U+200D  ZERO WIDTH JOINER   U+2642 ♂ MALE SIGN   U+FE0F  VARIATION SELECTOR-16    となっている。 これだけ見ても，絵文字を\nvar emojiRegex = regexp.MustCompile(\u0026#34;[\\U0001f000-\\U0001ffff]\u0026#34;) などと安直に括り出すのが如何にヤバいか分かるであろう。\nUnicode 文字列中の「文字」を真面目に分解して取り扱いたいなら，たとえば Go 言語なら rune ではなく []rune のように符号点の可変配列として取り扱う必要があるだろう。 かつ，各符号点の意味を考えながら「どこまでが1文字か」を解析するロジックが必要になる。\nちなみに Go では rivo/uniseg パッケージを使うといい感じに分解してくれるらしい。\n符号とフォントと入出力 これも言ってしまえば当たり前のことなのだが，絵文字は符号とフォントと入出力が揃ってはじめて絵文字として機能する。 先ほどの 🙇‍♂️ も\n$ echo 🙇‍♂️ | gnkf dump --unicode 0x0001f647, 0x200d, 0x2642, 0xfe0f, 0x000a という符号点の並びがひとつの絵文字であると解釈し，かつその文字に対応するフォントとグリフがあり，さらにそのグリフで表示できるアプリケーションがあってはじめて 🙇‍♂️ と表示できる。\nこの記事中の絵文字も，もしかしたらブラウザの種類やバージョン等によって 🙇♂ と2文字に見えているかもしれない。 もしくは変な記号に「文字化け」するとか，そもそも全く表示されないとか\u0026hellip;\nたとえば Twitter ではユーザ側の環境やアプリケーション間の差異を軽減するため，絵文字を独自の画像データに置き換えるツールキットを公開している。\n Twemoji  Zenn のアテンション用絵文字もこれを使って表示している筈。\nそれぞれの絵文字がどのように表示されるか（または表示されないか）については Unicode 公式ページにある\n Full Emoji List  が参考になるだろう。 2021年3月時点の最新版である v13.1 では1,816個の絵文字が定義されている。\n多いよ orz\nターミナル・エミュレータと絵文字 ブラウザとかスマホ・アプリならまだマシだと思うが， CUI ベースのターミナル・エミュレータは絵文字周りが特に冷遇されている印象がある。\n私は CLI ツールで対話モードを組むときに zetamatta/go-readline-ny パッケージ2 のお世話になるのだが，リリース情報を見るとホンマに絵文字で苦労されているのが分かる。 その一端が以下の Zenn 本に記されているので，是非ご覧あれ。\n Windows と Unicode とボク  プログラマが読んだら涙で前が見えなくなるよ（笑）\n“#” の Keycap はあるのに “A” の Keycap はないのか 上で紹介した “Full Emoji List” を眺めると，たとえば絵文字 #️⃣ は\n   符号点 字形 名称     U+0023 # NUMBER SIGN   U+FE0F  VARIATION SELECTOR-16   U+20E3  ⃣ COMBINING ENCLOSING KEYCAP    という並びになっている。 もう\nvar emojiRegex = regexp.MustCompile(\u0026#34;[\\U0001f000-\\U0001ffff]\u0026#34;) という正規表現に微塵もかからない（笑）\nいや，そうじゃなくて。 たしかに普通の半角記号である # が合成列の先頭に来ているのも驚きだが，その直後に絵文字用の異体字セレクタが来ているのにビックリした。 必ずしも異体字セレクタが最後に付くんじゃないのか。\nまぁ，でも意味は分かる。 #️⃣ は # 記号の絵文字異体字ってことで，先頭の符号点だけ見れば # と等価な文字として扱えるってことだよね。 そしてその後ろに keycap を表す結合文字がくっ付いている，と。\nそんじゃあ # の代わりに A とかの任意の文字でも keycap の絵文字が作れるんじゃね？ と一瞬思ったが “Full Emoji List” を見る限りそんなことはないようだ3。\nどういうルールなんだろうねぇ。\n肌色の異体字 最初に紹介した “PERSON BOWING DEEPLY” 🙇 には肌色の情報をくっ付けることができる。\nこんな感じ。\n   合成列 字形 名称     U+1F647 + U+1F3FB 🙇🏻 person bowing: light skin tone   U+1F647 + U+1F3FC 🙇🏼 person bowing: medium-light skin tone   U+1F647 + U+1F3FD 🙇🏽 person bowing: medium skin tone   U+1F647 + U+1F3FE 🙇🏾 person bowing: medium-dark skin tone   U+1F647 + U+1F3FF 🙇🏿 person bowing: dark skin tone    この肌色って人種を指すものじゃなくて “fitzpatrick skin typing” と呼ばれる紫外線への感受性を基にした分類らしい。\n   符号点 名称     U+1F3FB EMOJI MODIFIER FITZPATRICK TYPE-1-2   U+1F3FC EMOJI MODIFIER FITZPATRICK TYPE-3   U+1F3FD EMOJI MODIFIER FITZPATRICK TYPE-4   U+1F3FE EMOJI MODIFIER FITZPATRICK TYPE-5   U+1F3FF EMOJI MODIFIER FITZPATRICK TYPE-6    このコードは結合文字の一種のように見えるが，どんな絵文字にもくっ付くわけではないらしい。 有効な組み合わせは\n Full Emoji Modifier Sequences  を参考にするといいだろう。\nZWJ による絵文字の合成 最初の「土下座する男性 🙇‍♂️」に戻る。 男性があるのだから女性バージョン 🙇‍♀️ も当然ある。\n🙇‍♀️ の内容は以下の通り。\n   符号点 字形 名称     U+1F647 🙇 PERSON BOWING DEEPLY   U+200D  ZERO WIDTH JOINER   U+2640 ♀ FEMALE SIGN   U+FE0F  VARIATION SELECTOR-16    つまり “PERSON BOWING DEEPLY” に性差を示す “MALE SIGN” または “FEMALE SIGN” を “ZERO WIDTH JOINER” (ZWJ) を介してくっ付けることで異体字を構成している。\nこのように ZWJ を使って文字をくっ付けて異体字や新たな絵文字を作る方法にはかなりのバリエーションがあるようだが，どうもプラットフォームごとに勝手にコードを組み合わせているらしく上手く表示できないパターンがあるようだ。\nこのため Zenn では，以下のリストにない絵文字を排除することで対応しているそうだ。\n Recommended Emoji ZWJ Sequences  この一覧によると “PERSON BOWING DEEPLY” 🙇 には，前節の肌色バリエーションと男女性差のバリエーションを組み合わせて，合計10個の異体字がある，ということになる。\n国旗絵文字 個人的にこれが一番ワケワカメ。\nREGIONAL INDICATOR なるコードがあって\n   符号点 字形 名称     U+1F1E6 🇦 REGIONAL INDICATOR SYMBOL LETTER A   U+1F1E7 🇧 REGIONAL INDICATOR SYMBOL LETTER B   U+1F1E8 🇨 REGIONAL INDICATOR SYMBOL LETTER C   \u0026hellip; \u0026hellip; \u0026hellip;   U+1F1EF 🇯 REGIONAL INDICATOR SYMBOL LETTER J   \u0026hellip; \u0026hellip; \u0026hellip;   U+1F1F5 🇵 REGIONAL INDICATOR SYMBOL LETTER P   \u0026hellip; \u0026hellip; \u0026hellip;   U+1F1FF 🇿 REGIONAL INDICATOR SYMBOL LETTER Z    これを使って ISO 3166 (日本では JIS X 0304) の国別コードを組むと国旗の絵文字になるらしい。 日本の国別コードは JP なので\n   合成列 字形 名称     U+1F1EF + U+1F1F5 🇯🇵 flag: Japan    となる。\nところでこれ，ちゃんと国旗に見えてます？ かなり環境依存度が大きいようで Windows とかでは軒並みアウトっぽい。\nさらにアレなのが Unicode 10.0 で追加された subdivision-flag に分類されているもので，たとえば「イングランドの国旗 🏴󠁧󠁢󠁥󠁮󠁧󠁿」は\n   符号点 字形 名称     U+x1F3F4 🏴 WAVING BLACK FLAG   U+E0067  TAG LATIN SMALL LETTER G   U+E0062  TAG LATIN SMALL LETTER B   U+E0065  TAG LATIN SMALL LETTER E   U+E006E  TAG LATIN SMALL LETTER N   U+E0067  TAG LATIN SMALL LETTER G   U+E007F  CANCEL TAG    という並びになっている。 一般的には “WAVING BLACK FLAG” と “CANCEL TAG” の間に TAG LATIN SMALL LETTER A～Z (U+E0061 ～ U+E007A) を5つ並べる構成になっているらしい。\nなにその面倒くさいやつ。\n絵文字シーケンスのまとめ 以上をまとめると，絵文字の分類は以下のようになっているらしい（「Unicode 絵文字にまつわるあれこれ」を参考に分類）。\n singleton ： 単体のコードポイントからなる絵文字 emoji sequence ： 複数のコードポイントからなる絵文字  emoji core sequence ： 通常の絵文字  emoji combining sequence ： 囲み文字 emoji modifier sequence ： skin tone 絵文字 emoji flag sequence ： 国旗絵文字   emoji zwj sequence ： 家族絵文字、職業絵文字など emoji tag sequence ：タグ絵文字    この分類でいくと Keycap の絵文字は “emoji combining sequence” に相当する。 肌色の異体字は “emoji modifier sequence” やね。 ZWJ にとる文字の結合は “emoji zwj sequence” で，国旗絵文字はそのまま “emoji flag sequence”。 ただし subdivision-flag は “emoji tag sequence” に分類されるようだ。\nしかもこれってただの分類なので，実際の絵文字がどれに分類されるかは「知識」としてあらかじめ知ってないといけない。 プログラマ的に言うならロジックを書くだけでは足りなくてロジックを駆動する知識をデータベースとして何処かに保持っておく必要がある。\nなんでこんなカオスになっちゃったのかねぇ。 本当に「おそるべき絵文字」だよ。\n【余談】元号記号も絵文字と見做せばいいぢゃん 絵文字を調べてて思い出したのが，4年前に書いた\n 新元号「文字」という技術的負債  という記事。 「技術的負債」と口走ったのは私の黒歴史としてスルーしていただけるとありがたいが，よく考えたら「㍻ U+337B」とかを「文字」だと思うから不合理に感じるのであって「絵文字」と思えばアリなのか。 いや， Unicode では絵文字と定義しているわけじゃないけど。\nでも「©️ U+00A9」だって絵文字扱いなんだから ㍻ も絵文字でいいよね（笑）\nブックマーク Unicode における「絵文字」黎明期の話は，小形克宏さんの一連の記事が参考になる。\n 絵文字が開いてしまった「パンドラの箱」第1回\u0026ndash;日本の携帯電話キャリアが選んだ道 - CNET Japan 絵文字が開いてしまった「パンドラの箱」第2回\u0026ndash;Googleの開けてしまった箱の中味 - CNET Japan 絵文字が開いてしまった「パンドラの箱」第3回\u0026ndash;Unicode提案の限界とメリット - CNET Japan 絵文字が開いてしまった「パンドラの箱」第4回\u0026ndash;絵文字が引き起こしたUnicode-MLの“祭り” - CNET Japan 絵文字が開いてしまった「パンドラの箱」第5回\u0026ndash;絵文字と日本マンガの親密な関係 - CNET Japan 絵文字が開いてしまった「パンドラの箱」第6回\u0026ndash;Google・Apple提案とそのシナリオ - CNET Japan 絵文字が開いてしまった「パンドラの箱」第7回\u0026ndash;そして舞台はダブリンから東京へ - CNET Japan グーグルが絵文字を世界標準に提案した理由\u0026ndash;国際化エンジニアに聞くプロジェクトの舞台裏（前編） - CNET Japan グーグルが絵文字を世界標準に提案した理由\u0026ndash;国際化エンジニアに聞くプロジェクトの舞台裏（前編） - CNET Japan 「絵文字に平等をサポートしてください」人種差別の指摘にゆれるUnicode - INTERNET Watch Watch どんな人々がUnicodeの絵文字に「民族の多様性」を求めているのか？ - INTERNET Watch Watch 絵文字を「符号」として処理する難しさ～日本のモバイルウェブのカオスぶり - INTERNET Watch Watch 絵文字を「語」として処理する難しさ～定義通りとは限らない、絵文字の意味 - INTERNET Watch Watch 絵文字を「語」として処理する難しさ～「ビール」と「飲み会」見分ける技術 - INTERNET Watch Watch  その他のブックマーク：\n Let\u0026rsquo;s EMOJI｜絵文字一覧と絵文字検索🎉 絵文字と異体字と Markdown Unicode 文字種の判別 やっかいな日本語    regexp パッケージの設計については Regular Expression Matching Can Be Simple And Fast を参照のこと。 \u0026#x21a9;\u0026#xfe0e;\n zetamatta/go-readline-ny は同じ作者による NYAGOS からのスピンオフで，ターミナル・エミュレータからの入力制御に特化している。Emacs 風のキー・バインドでヒストリ機能を付けることもできる。元々は Windows 用だと思うが Ubuntu のターミナル・エミュレータでも問題なく機能するので重宝している。 \u0026#x21a9;\u0026#xfe0e;\n 処理系によっては任意のコードを組み合わせて勝手に絵文字を作れたりするのかもしれないが，互換性がなくなるので「情報交換用」としては使えない。ちなみに 🅰 という絵文字はあるが，これは血液型（A型）を表す絵文字らしい。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Google vs Oracle の訴訟の行方 3",
      "section": "remark",
      "description": "そういや，どうなったっけ？",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/google-vs-oracle-3/",
      "published": "2021-03-29T10:20:47+00:00",
      "update": "2021-03-30T12:39:19+00:00",
      "content": "先週の mimemagic 騒ぎに関する戯れ言を Zenn のほうに書いたが，これで思い出したのが「そういや Google vs Oracle の訴訟ってどうなったっけ？」だった。\nたしか Google による最高裁への上告が2019年に受理され（「コロナ」のせいで遅れに遅れて）翌2020年10月から審理が始まったんだよね。\n グーグルとオラクルとの「Android」関連訴訟、米最高裁での審理始まる - CNET Japan  んで，まだ判決は出てないってことでOK？\nこの訴訟は，私が一介のプログラマとして Java というか Oracle を見限るキッカケになったものなので（もちろん仕事なら Java だろうが何だろうが喜んで引き受けますよw），当初から注目はしていた。 まぁ，ここ2,3年は追いかける余裕がなかったのだが。\nせっかくなので今まで書いた分も含めて最初から書き直すか。\nJava API 特許権への侵害はなかったので\u0026hellip; 元々この訴訟は Andorid を巡って Google が Java API の「特許権」を侵害している，というのが Oracle の言い分だった。 特許権侵害については2012年の連邦地裁の判決で決着がついている。\n AndroidをめぐるOracle対Google裁判を振り返る（前編）～ Oracleが主張した特許侵害は認められず － Publickey AndroidをめぐるOracle対Google裁判を振り返る（後編）～ 残る課題はAPI著作権と9行のコード － Publickey  ここまでの経緯をかいつまんで紹介するとこんな感じ。\n 最初は著作権ではなく特許権の侵害（7件）の有無が訴訟の中心だった Oracle の申し立てた7件のうち5件は特許自体が無効とされ，残り2件については侵害は認められないとされた この判決を受け，争点が特許権の侵害から著作権の侵害へと移る。論点は以下の通り  37の Java API パッケージの互換コードについて， Oracle は Google が著作物全体の「構造、順序、構成」（Structure, Sequence, Organization; SSO）を侵害したと証明したか 「TimSort.java および互換コードの rangeCheck メソッド」の著作権侵害があったか   争点 3-1 については著作権侵害は認められるが「公正な利用（fair use）」については結論が出ず。争点 3-2 については侵害が認められた（ただし軽微）  上の争点 3-1 については，さらに2つの論点がある。\n API の構成要素である SSO について著作権が適用されるのかどうか 仮に著作権が適用されるとして公正な利用の範囲内かどうか  で，判決では，前者については yes，後者については不明（訴訟の範囲から外れるので）となった。 これに対し Google は「API に著作権なんかねーよ！」（←超意訳）と最高裁に上告したわけだ。\nその結果が以下。\n「API のコピー」は著作権に抵触するか  Oracle Am., Inc. v. Google Inc., No. 13-1021 (Fed. Cir. 2014) :: Justia : 判決文 グーグル対オラクルのJava訴訟、米最高裁がグーグルの上告を棄却\u0026ndash;Reuters - CNET Japan OracleとGoogleの判決文を斜め読む - Qiita Google v. Oracle API著作権裁判 · GitHub  こんな感じで最高裁への上告は棄却されたので，連邦地裁での判決および議論はそのまま持ち越されたことになった。 ここは（プログラマとして）大事なところなので，もう少し詳しく見ていこう。\n宣言コード この「API のコピー」の論点には大きく2つあるようだ。 ひとつは「宣言コード（declaring code）」の扱いで，もうひとつは「SSO の非逐語的コピー（non-literal copy）」である。\n宣言コードというのは，たとえば\npublic static int max(int x, int y) {  if (x \u0026gt; y) return x; else return y; } というコード（これは判決文の中に出てくる）の最初の行の部分を指す。 ちなみに，宣言コードに対する { ... } 内の記述を「実装コード（implementing code）」と呼ぶ。\nGoogle は，宣言コードは “method of operation” であり著作権は適用されないと主張したが1，最終的には認められなかった。\n Rather, the uncopyrightable \u0026ldquo;method of operation\u0026rdquo; or \u0026ldquo;system\u0026rdquo; or \u0026ldquo;process\u0026rdquo; is the underlying computer function triggered by the written code \u0026ndash; for example, an algorithm that the computer executes to sort a data set. The code itself, however, is eligible for copyright protection.  via Oracle Am., Inc. v. Google Inc., No. 13-1021  宣言コードは単なる「名前」ではなく，著作権の適用という点で宣言コードと実装コードを区別する意味はないということらしい。 その上で宣言コードの逐語的コピー（literal, verbatim copying of declaring code）があった，と認定されたわけだ。\n構造、順序、構成 もうひとつの SSO だが， Google は “merger doctrine” や “scènes à faire doctrine” を盾に JDK の SSO を著作権の適用外とするよう求めていたが，この点についても認められなかった。\nちなみに “merger doctrine” や “scènes à faire doctrine” てのは，アイデアなどに対する「表現」が限られたバリエーションしかない場合や，古典的あるいは標準的な表現の場合には著作権の適用外となるというものだそうだが，控訴審が「命名や構造化には無数の方法がある」と述べたことに対し Google は反論しなかったようだ。\n The Court thus decided the case based on what was effectively a merger analysis. Here, by contrast, petitioner does not dispute the court of appeals' statement that there were \u0026ldquo;unlimited\u0026rdquo; ways that respondent could have named and structured its methods, Pet. App. 33, and nothing logically required petitioner to copy respondent\u0026rsquo;s declaring code when it created the Android platform.  via Oracle Am., Inc. v. Google Inc., No. 13-1021  SSO のコピー自体は非逐語的コピーかもしれないが，もともと Android のプラットフォームや開発ツールが Java エンジニアへの利便性のために JDK に似せて作られている点と，宣言コードが明らかに逐語的コピーである点も合わせて，「独立した表現」であるとは言えない（SSO のコピーが逐語的であるかどうかの要件を問わない）ということのようだ。\nぶっちゃけて言うと『それ「API の著作権が云々』以前に，ただの丸パクリだろ」ってことらしい。 身も蓋もないな（笑）\n「公正な利用」は有効か（そして再び最高裁へ） 上の判断をふまえた上で API コードの利用2 に “fair use doctrine” が認められるかどうかについては結論を先送りとし「上告を棄却」となった。 ただし，この訴訟については Section 102(b) （著作権の適用範囲）で争うのではなく， API コードに著作権があるとした上で， Section 107 “fair use doctrine” の可否で争うべきだとの意見が添えられた。\n Rather, petitioner argues that programmers have become fluent in respondent's Java platform; that they will be deterred from writing programs for Android if they are required to learn all new commands; and that verbatim copying of respondent's declaring code was necessary for the familiar commands to work on the Android platform. The general concerns that petitioner raises are substantial and important, but Section 102(b) is not the appropriate statutory provision to address them. Rather, legitimate concerns with interoperability and lock-in effects are far better addressed through the fair-use doctrine codified at Section 107.  via Oracle Am., Inc. v. Google Inc., No. 13-1021  そこで争点は「API に著作権があるとした上で公正な利用を満たしているか」に移っていった。\n米国の著作権における「公正な利用」は以下の4要件について社会的に「公正」であるかを（訴訟を通じて）議論する。\n 利用の目的や本質 原作品の本質 抜粋の量や実質性 原作品の価値への影響  つまり「公正な利用」に争点が移った時点で個別案件となったのだ。 故に，たとえこの件で Google が勝ったとしても，あらゆる局面で「API の利用は『公正な利用』である」とは言えない。\n自由でないソフトウェアによる API の利用は常に著作権リスクを含んでいる。 このことは頭に入れておいて欲しい。\n実は，2016年の時点では陪審員団に Java API の利用が公正な利用であると認められていた。\n Google beats Oracle—Android makes “fair use” of Java APIs | Ars Technica Google’s fair use victory is good for open source | Ars Technica グーグル、Java API使用が「フェアユース」と認められる\u0026ndash;対オラクル訴訟 - CNET Japan Googleの「公正使用」勝訴後も残る著作権に関する疑問 | TechCrunch Japan Oracle v. Google API Fair Use訴訟の話（連邦地裁編） : 日本語解説ならこちらがオススメ  しかし2018年の判決では一転して Oracle 側の勝訴となっている。\n Oracle America, Inc. v. Google, Inc., No. 17-1118 (Fed. Cir. 2018) :: Justia : 判決文 OracleがJavaの著作権侵犯裁判でGoogleに勝利 | TechCrunch Japan  そしてこの記事の最初の話に戻るわけだ。\nブックマーク  Google Books の Library Book Scan すら Fair Use と言われたのに\u0026hellip; Google vs Oracle の訴訟の行方 2  参考図書  著作権法 第3版 中山 信弘 (著) 有斐閣 2020-09-04 単行本 4641243336 (ASIN), 9784641243330 (EAN), 4641243336 (ISBN)  第3版が出てた。第2版は図書館で借りて読んだが，途中でギブアップした。個人が興味本位で読める本ではないらしい（笑）\nreviewed by Spiegel on 2020-10-12 (powered by PA-APIv5)\n  〈海賊版〉の思想‐18世紀英国の永久コピーライト闘争 山田 奨治 (著) みすず書房 2007-12-20 単行本 4622073455 (ASIN), 9784622073451 (EAN), 4622073455 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  「コピーライト永久独占を目論む大書店主に挑む〈海賊出版者〉ドナルドソンの肖像。法廷闘争を軸に著作権を史的に考察する。」（帯文より）\nreviewed by Spiegel on 2018-11-13 (powered by PA-APIv5)\n  著作権２．０ ウェブ時代の文化発展をめざして (NTT出版ライブラリー―レゾナント) 名和 小太郎 (著) NTT出版 2010-06-24 単行本（ソフトカバー） 4757102852 (ASIN), 9784757102859 (EAN), 4757102852 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  名著です。今すぐ買うべきです。\nreviewed by Spiegel on 2014-08-02 (powered by PA-APIv5)\n   何故 “Method of operation” が著作権の適用外になるのかということについては「コンピュータ関係の創作保護についての最近の米国での話題（via Internet Archive）」あたりが参考になる。 なお「最近」と書かれているが1996年の記事である。 \u0026#x21a9;\u0026#xfe0e;\n 著作権では「使用」と「利用」を分けて考える。著作権は「利用」を除く「使用」について関知しない。著作権の「利用」について厳密な話は大変だが，概ね「複製」「配布」「改変」の3つだと覚えておけばいいだろう。この記事では Java API の「複製」が問題となっているわけだが，逐語的コピーでないなら「改変」も含むし，それを広く公開しているのだから「配布」も絡んでくる。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2021-03-28 のブックマーク",
      "section": "bookmarks",
      "description": "「Announcing Rust 1.51.0」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2021/03/28-bookmarks/",
      "published": "2021-03-28T05:11:55+00:00",
      "update": "2021-03-28T05:13:53+00:00",
      "content": "リリース情報  Hugo 0.82: Mostly bugfixes | Hugo  Release v0.82.0 · gohugoio/hugo · GitHub   Release 8.9.2 · mermaid-js/mermaid · GitHub Release v1.39.0 · golangci/golangci-lint · GitHub git/2.31.1.txt at v2.31.1 · git/git · GitHub  Release Git for Windows 2.31.1 · git-for-windows/git · GitHub    セキュリティ＆プライバシー関連  アップルの「Xcode」を利用する開発者狙う「XcodeSpy」マルウェア\u0026ndash;研究者が注意喚起 - ZDNet Japan 複数のBIG-IP製品の脆弱性（CVE-2021-22986）に関する注意喚起 Keyoxide | mitome.in : Keyoxide (opens new window)は、分散されたオンラインアイデンティティを確立する方法のひとつです。Keyoxideに則って電子署名を追加した公開鍵をOpenPGPに則って公開すれば、特定のサービスに依存せずオンラインのアイデンティティを確立し確認できます Google、脆弱性検出ツール「OSS-Fuzz」のJavaVM対応を発表。Java/Kotlin/Scalaなどの脆弱性を検出可能に － Publickey Androidの「WebView」アップデートに問題か ～複数のアプリで起動不能やエラーの報告相次ぐ【18:10追記】 - 窓の杜 LINE、個人データなどの国内完全保管を表明 - ZDNet Japan 中国がアプリによる過剰なユーザーデータ収集を5月から禁止 | TechCrunch Japan #SaveAnonymity：「あんしん」のための本人確認・年齢確認の義務化から匿名性を守るために | P2Pとかその辺のお話R つぎはぎされた「フランケンクラウド」モデルは最大のセキュリティーリスクなのか | TechCrunch Japan  天文関連  The Grabby Aliens Website  ブログ: 利己的エイリアンのシンプルなモデル    知財関連  YouTube、著作権者に収益を「奪われない」ようにする新機能「Checks」を発表 | P2Pとかその辺のお話R mimemagicの最新動向 - HackMD  Linux または Ubuntu に関する話題  Linuxでディスク使用量を確認するdufコマンドの使い方 | TECH+  Go 言語関連  GitHub - kyokomi/emoji: emoji terminal output for golang Java JIT vs Java AOT vs Go for small, short-lived processes. Mario Macias' handcrafted blog : 比較記事 [Go] go.uber.org/zapでNew Relic logs in contextをするためのライブラリを書き始めた - My External Storage Writing slower Go programs — Bitfield Consulting 📖 Build a RESTful API on Go: Fiber, PostgreSQL, JWT and Swagger docs in isolated Docker containers - DEV Community  Rust 言語関連  Announcing Rust 1.51.0 | Rust Blog  その他  yamlをインタラクティブに絞り込みできるCLIを作った フォードが世界的なチップ不足を理由に特定の部品を使わずにF-150トラックを生産 | TechCrunch Japan GitHub - litmuschaos/litmus: Litmus helps Kubernetes SREs and developers practice chaos engineering in a Kubernetes native way. Chaos experiments are published at the ChaosHub (https://hub.litmuschaos.io). Community notes is at https://hackmd.io/a4Zu_sH4TZGeih-xCimi3Q Raspberry PiにUbuntu Serverを入れてNew Relicで監視する ゲームとモラル・パニック - 井出草平の研究ノート GitHubがほぼ全面的に無料化 | TechCrunch Japan : 2020年4月のニュース 日立、DXの旗艦拠点「Lumada Innovation Hub Tokyo」を開設\u0026ndash;元日本MS澤氏がエバンジェリスト就任 - ZDNet Japan Web版「e-Tax」でスマホがマイナンバーカードリーダー代わりに ～“2次元バーコード認証”に対応 - 窓の杜 身売り検討の報道を受けてクラウドサービスBoxの株価が上昇 | TechCrunch Japan  Box、「Microsoft 365」プラットフォームとの連携機能を強化 - ZDNet Japan   AWSが2021年のパートナー戦略を発表\u0026ndash;内製開発支援も - ZDNet Japan FirebaseとBigQueryでランキングを作る マイクロソフト、2021年中にAzureを展開するすべての国のリージョンで「アベイラビリティゾーン」を提供 － Publickey 正規表現の必須要素を抽出する 「Spring Native」ベータ版公開、GraalVMによりSpring FramworkのJava/Kotlinアプリをネイティブイメージにコンパイル。JavaVMに依存せず瞬時に起動可能 － Publickey Web型Gitリポジトリマネージャ「GitLab 13.10」がリリース：CodeZine（コードジン） Javaの基礎を学び終えたアナタに贈る, SpringBoot/SpringSecurityによる掲示板開発ハンズオン AWS、次期CEOに現Tableau CEOのアダム・セルピスキー氏を指名 － Publickey 「形式手法はなぜ流行っていないのか」に対する異論 - interdb’s blog MDN localization in March — Tier 1 locales unfrozen, and future plans - Mozilla Hacks - the Web developer blog GitHub ActionsでZennブログの校正を自動化してみた  reviewdogによるGoのコードレビュー - DeNA Testing Blog : reviewdog の使い方は参考になるが，よく考えたら GitHub Actions が使えるなら要らんか？   GitHub - SpectralOps/teller: A secrets management tool for developers built in Go - never leave your command line for secrets. Statement on the Re-election of Richard Stallman to the FSF Board | Electronic Frontier Foundation  ブログ: リチャード・ストールマンのFSF理事への再選に関する声明 (EFF)    "
    },
    {
      "title": "「ウイルスの好物は心のスキ」などと言った首長がいるそうで",
      "section": "remark",
      "description": "自分が乗ってる舟のオールを他人任せにしないよう（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/why-japanese-people/",
      "published": "2021-03-28T03:26:31+00:00",
      "update": "2021-03-28T03:35:11+00:00",
      "content": "新聞系メディアにはリンクしないことにしているので何処の話とは言わないが「ウイルスの好物は心のスキ」などと言った首長がいるそうで，それじゃあ何時まで経っても収束しないに決まってるよね（笑）\n旧ブログで6年前に「「なぜなぜ分析」は人に責任を帰さないのが大原則」と書いたが，障害やトラブルが起きた際に，その原因や責任を「人」に帰するのは絶対にやってはいけないことである。\nもちろん，個人の心がけとして不注意やうっかりに気をつけるのは結構なことだ。\n20年以上前にちょっと死にかけたとき，当時の担当医に「絶対に風邪を引かないように」と無茶振りされたことがある。 念のためにいうと，もちろん（双方分かった上での）冗談話だからね。 でも私のような「高リスク群」に属する人はそのくらいの心づもりが必要なわけで，そのとき以来，私は「覚悟完了」している。 まぁ，それから20年も意地汚く生き残ってるわけだけど（笑）\n話が逸れた。\n人は間違いやうっかりをする生き物である。 それは人の持つ柔軟性や拡張性の裏面・副作用みたいなもので，むしろ肯定的に捉えるべきものだ。\n人的ミスが起きたときに「間違いやうっかり」をなくしましょうと言うのは何も対策しないのと同義である。 「なぜなぜ分析」の結論が「私の不注意でした」となるのは「なぜ」の掘り方を間違えている。\n人的ミスが起きたときあるいはミスが起きそうな状況のとき，上に立つ人間がやるべきことは以下の2つだ。\n ミスが減る方向に行動を誘導するためのシステム（環境やルール）を構築する ミスが起きた際に周辺に影響が拡大しないよう早く収束させる，またそのための体制づくりをする  そこまでやってはじめて「個人も気をつけましょう」と言えるわけだ。\nSARS-CoV-2 パンデミックに関しては，有効な手段として（変異種も含めて）期待できるのはワクチンの同時・集団接種くらいしかない。 しかし実際にはワクチンの調達や接種時期は国や地域によってバラツキがある。 日本なんか庶民にワクチンが降りるのは（シミュレーション（笑）や希望的観測ばかりで）いつになるやら。\nそういう現状を踏まえてロックダウンや段階的な移動規制の判断を行う（そしてそれによって不利益を被る経済的弱者に直接的な支援を行う）べきだし，中長期的には風邪やインフルエンザと同じく「SARS-CoV-2 系列のウイルスには誰もが罹る」前提で医療・福祉体制を整えていく必要がある。\nつか，そろそろ「緊急避難」を言い訳にした行きあたりばったりな政策は止めようや。\n少なくとも（全国レベルで感染規模が3月中旬から拡大傾向に転じているのに）緊急事態を解除して聖火リレーをするとか，その一方で「ウイルスの好物は心のスキ」などと曰う政治家いや政治屋どもの何を信用しろというのか。\n   spiegel-im-spiegel/covid-2019-report: 日本における COVID-2019 確認発症者のレポートより  というわけで，自分が乗ってる舟のオールを他人任せにしないよう（笑）\nブックマーク  Five reasons why COVID herd immunity is probably impossible  ブログ: 新型コロナの集団免疫がおそらく不可能である5つの理由     宙 船（そらふね） 中島みゆき (メインアーティスト) YAMAHA MUSIC COMMUNICATIONS CO., LTD. 2020-12-02 (Release 2020-12-02) MP3 ダウンロード B08MX57XXK (ASIN)  最近，メディアで政治ネタを見かける度に脳内BGMがこれになる（笑）\nreviewed by Spiegel on 2021-03-28 (powered by PA-APIv5)\n "
    },
    {
      "title": "OpenSSL 1.1.1k がリリースされた【セキュリティ・アップデート】",
      "section": "release",
      "description": "アップデートは計画的に",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/openssl-111k-is-released/",
      "published": "2021-03-26T10:10:57+00:00",
      "update": "2021-03-26T10:14:29+00:00",
      "content": "OpenSSL 1.1.1k がリリースされた。 2件の脆弱性の改修が行われている。\n OpenSSL Security Advisory [25 March 2021]  CVE-2021-3449 OpenSSL 側は “Severity: High” と評価している。\nAn OpenSSL TLS server may crash if sent a maliciously crafted renegotiation ClientHello message from a client. If a TLSv1.2 renegotiation ClientHello omits the signature_algorithms extension (where it was present in the initial ClientHello), but includes a signature_algorithms_cert extension then a NULL pointer dereference will result, leading to a crash and a denial of service attack. A server is only vulnerable if it has TLSv1.2 and renegotiation enabled (which is the default configuration). via CVE-2021-3449  （以下未稿）\nCVE-2021-3450 OpenSSL 側は “Severity: High” と評価している。\nThe X509_V_FLAG_X509_STRICT flag enables additional security checks of the certificates present in a certificate chain. It is not set by default. Starting from OpenSSL version 1.1.1h a check to disallow certificates in the chain that have explicitly encoded elliptic curve parameters was added as an additional strict check. An error in the implementation of this check meant that the result of a previous check to confirm that certificates in the chain are valid CA certificates was overwritten. This effectively bypasses the check that non-CA certificates must not be able to issue other certificates. via CVE-2021-3450  アップデートは計画的に Ubuntu はバックポートパッチを当てたバージョンを APT で配布している。\n USN-4891-1: OpenSSL vulnerability | Ubuntu security notices | Ubuntu  手動で更新するのであれば\n$ cd /usr/local/src/ $ sudo curl -L \u0026#34;https://www.openssl.org/source/openssl-1.1.1k.tar.gz\u0026#34; -O $ sudo curl -L \u0026#34;https://www.openssl.org/source/openssl-1.1.1k.tar.gz.asc\u0026#34; -O $ gpg -d openssl-1.1.1k.tar.gz.asc # 署名を確認する $ $ sudo tar xvf openssl-1.1.1k.tar.gz $ cd openssl-1.1.1k/ $ sudo ./config $ sudo make $ sudo make install $ sudo ldconfig # 念のため $ openssl version OpenSSL 1.1.1k 25 Mar 2021 などとする。\nアップデートは計画的に。\nブックマーク  OpenSSLの脆弱性（CVE-2021-3450、CVE-2021-3449）に関する注意喚起 Ubuntu に最新の OpenSSL を入れる  "
    },
    {
      "title": "Hugo Markdown でブロック要素にクラス属性を付与する",
      "section": "remark",
      "description": "お手軽装飾",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/add-attribute-in-hugo-markdown/",
      "published": "2021-03-22T08:14:37+00:00",
      "update": "2021-03-22T08:16:13+00:00",
      "content": "Hugo 0.81 からの機能らしいのだが， markdown テキスト中のブロック要素に対して class 属性を付けられるようだ（goldmark パーサを使う場合）。 これを有効にするには config.toml ファイルで\n[markup.goldmark.parser.attribute] block = true と指定する（既定値は false）。 YAML (config.yaml) で書くなら\nmarkup:goldmark:parser:attribute:block:trueてな感じかな。\nたとえば\n- One - Two - Three { .cloud .center } と箇条書きブロックの最後に { .cloud .center } とクラス名を付けると\n\u0026lt;ul class=\u0026#34;cloud center\u0026#34;\u0026gt; \u0026lt;li\u0026gt;One\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Two\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Three\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; という感じに展開してくれる。 ここで CSS 側を\nul.cloud { list-style: none; padding: 0 } ul.cloud \u0026gt; li { display: inline-block; margin: 0 0.5rem; } .center { text-align: center; } などと定義すれば\nOne Two Three   とできる。\nこれは HTML のブロック要素に相当するものであれば何でも適用できるみたいで，通常の段落でも\n*「人はなぜ大丈夫じゃないときに限って『大丈夫？』と訊くのだろう」* \u0026lt;br\u0026gt;（某ラノベ作品より） {.center} などと書けば\n「人はなぜ大丈夫じゃないときに限って『大丈夫？』と訊くのだろう」 （某ラノベ作品より） とできる。\n頻繁に使う表現なら shortcode を組んだほうがいいだろうが，ちょっとした装飾ならこちらのほうが手軽でいいかもしれない。\n"
    },
    {
      "title": "TinyGo で WASI 【失敗編】",
      "section": "golang",
      "description": "どうやったら動かせるのか。どなたか教えてください 🙇",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/wasi-with-tinygo/",
      "published": "2021-03-21T08:38:59+00:00",
      "update": "2021-03-28T05:13:53+00:00",
      "content": "前回は Go および TinyGo を使って WebAssembly コードを生成しブラウザ上で実行するところまでやった。\nしかし，クライアント側のブラウザ上で動かすだけではあまり面白くないよね。 そこで WASI (WebAssembly System Interface) という POSIX 風の標準規格があるそうな。 WASI に則った WebAssembly コードと，それを駆動するランタイム環境を用意することで “Write Once, Run Anywhere” の夢よもう一度，というわけ1（笑）\n実は本家 Go の wasm アーキテクチャは WASI に対応していない。 ただし TinyGo のほうはイケるみたいなので，今回は TinyGo オンリーでお送りする。\nWASI ランタイム スタンドアロンで動く WASI ランタイムには色々あるようで\n Lucet Wasmtime Wasmer WAVM SSVM  といった実装があるらしい。\nただ TinyGo のターゲット定義が\n{ \u0026#34;llvm-target\u0026#34;: \u0026#34;wasm32--wasi\u0026#34;, \u0026#34;build-tags\u0026#34;: [\u0026#34;wasm\u0026#34;, \u0026#34;wasi\u0026#34;], \u0026#34;goos\u0026#34;: \u0026#34;linux\u0026#34;, \u0026#34;goarch\u0026#34;: \u0026#34;arm\u0026#34;, \u0026#34;compiler\u0026#34;: \u0026#34;clang\u0026#34;, \u0026#34;linker\u0026#34;: \u0026#34;wasm-ld\u0026#34;, \u0026#34;libc\u0026#34;: \u0026#34;wasi-libc\u0026#34;, \u0026#34;cflags\u0026#34;: [ \u0026#34;--target=wasm32--wasi\u0026#34;, \u0026#34;--sysroot={root}/lib/wasi-libc/sysroot\u0026#34;, \u0026#34;-Oz\u0026#34; ], \u0026#34;ldflags\u0026#34;: [ \u0026#34;--allow-undefined\u0026#34;, \u0026#34;--stack-first\u0026#34;, \u0026#34;--export-dynamic\u0026#34;, \u0026#34;--no-demangle\u0026#34; ], \u0026#34;emulator\u0026#34;: [\u0026#34;wasmtime\u0026#34;],  \u0026#34;wasm-abi\u0026#34;: \u0026#34;generic\u0026#34; } と Wasmtime をリファレンスとしているみたいなので，今回はこれを使う。\nWasmtime の導入 Wasmtime のリポジトリでバイナリがリリースされているので，これを取ってきて PATH の通ったディレクトリに放り込んでおけばよい。\nあるいは\n$ curl https://wasmtime.dev/install.sh -sSf | bash とすれば $HOME/.wasmtime/bin/ ディレクトリを掘って入れてくれる。 さらに PATH を通すために $HOME/.bashrc ファイルを書き換えてくれやがるので，ご注意を。\nなお Wasmtime 自体のビルドには Rust と C++ (多分 GCC の g++) のビルド環境が必要らしい。 時代は Rust なんだねぇ。\n以下，動作確認。\n$ wasmtime --help wasmtime 0.25.0 Wasmtime WebAssembly Runtime USAGE: wasmtime \u0026lt;SUBCOMMAND\u0026gt; FLAGS: -h, --help Prints help information -V, --version Prints version information SUBCOMMANDS: config Controls Wasmtime configuration settings help Prints this message or the help of the given subcommand(s) run Runs a WebAssembly module wasm2obj Translates a WebAssembly module to native object file wast Runs a WebAssembly test script file If a subcommand is not provided, the `run` subcommand will be used. Usage examples: Running a WebAssembly module with a start function: wasmtime example.wasm Passing command line arguments to a WebAssembly module: wasmtime example.wasm arg1 arg2 arg3 Invoking a specific function (e.g. `add`) in a WebAssembly module: wasmtime example.wasm --invoke add 1 2 みんな大好き Hello World 何はともあれ，コードを用意しないとね。 いつものように，みんな大好き Hello World で。\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } これを TinyGo で処理する。\n$ tinygo build -o hello.wasm -target wasi ./hello.go ターゲットが wasi になっている点に注意。\nWasmtime で WASI コードを動かす んではビルドした hello.wasm ファイルを実行してみる。\n$ wasmtime run hello.wasm Hello, World! よーし，うむうむ，よーし。\nwasmtime-go で WASI ランタイムを組み込む【失敗編】 bytecodealliance/wasmtime-go を使うと Wasmtime のランタイム機能を Go のコードとして埋め込めるらしい（要 cgo）。 こんな感じかな。\npackage main import ( _ \u0026#34;embed\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/bytecodealliance/wasmtime-go\u0026#34; ) //go:embed hello.wasm var wasm []byte func main() { store := wasmtime.NewStore(wasmtime.NewEngine()) wasiConfig := wasmtime.NewWasiConfig() wasiConfig.InheritStdout() wasi, err := wasmtime.NewWasiInstance(store, wasiConfig, \u0026#34;wasi_snapshot_preview1\u0026#34;) if err != nil { fmt.Fprintln(os.Stderr, fmt.Errorf(\u0026#34;error in wasmtime.NewWasiInstance() : %w\u0026#34;, err)) return } linker := wasmtime.NewLinker(store) if err := linker.DefineWasi(wasi); err != nil { fmt.Fprintln(os.Stderr, fmt.Errorf(\u0026#34;error in wasmtime.Linker.DefineWasi() : %w\u0026#34;, err)) return } if err := wasmtime.ModuleValidate(store, wasm); err != nil { fmt.Fprintln(os.Stderr, fmt.Errorf(\u0026#34;error in wasmtime.ModuleValidate() : %w\u0026#34;, err)) return } module, err := wasmtime.NewModule(store.Engine, wasm) if err != nil { fmt.Fprintln(os.Stderr, fmt.Errorf(\u0026#34;error in wasmtime.NewModule() : %w\u0026#34;, err)) return } instance, err := linker.Instantiate(module) if err != nil { fmt.Fprintln(os.Stderr, fmt.Errorf(\u0026#34;error in wasmtime.Linker.Instantiate() : %w\u0026#34;, err)) return } if _, err := instance.GetExport(\u0026#34;_start\u0026#34;).Func().Call(); err != nil { fmt.Fprintln(os.Stderr, fmt.Errorf(\u0026#34;error in \\\u0026#34;_start\\\u0026#34; : %w\u0026#34;, err)) return } } では，これを動かしてみよう。\n$ go run sample.go error in wasmtime.Linker.Instantiate() : unknown import: `wasi_unstable::fd_write` has not been defined おうふ。 なんか足らんと言っている。\nTinyGo 側でなにか不備があるのかと思って以下のサンプル・コードもそのまま動かしてみたが\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;github.com/bytecodealliance/wasmtime-go\u0026#34; ) const TextWat = `(module ;; Import the required fd_write WASI function which will write the given io vectors to stdout ;; The function signature for fd_write is: ;; (File Descriptor, *iovs, iovs_len, nwritten) -\u0026gt; Returns number of bytes written (import \u0026#34;wasi_unstable\u0026#34; \u0026#34;fd_write\u0026#34; (func $fd_write (param i32 i32 i32 i32) (result i32))) (memory 1) (export \u0026#34;memory\u0026#34; (memory 0)) ;; Write \u0026#39;hello world\\n\u0026#39; to memory at an offset of 8 bytes ;; Note the trailing newline which is required for the text to appear (data (i32.const 8) \u0026#34;hello world\\n\u0026#34;) (func $main (export \u0026#34;_start\u0026#34;) ;; Creating a new io vector within linear memory (i32.store (i32.const 0) (i32.const 8)) ;; iov.iov_base - This is a pointer to the start of the \u0026#39;hello world\\n\u0026#39; string (i32.store (i32.const 4) (i32.const 12)) ;; iov.iov_len - The length of the \u0026#39;hello world\\n\u0026#39; string (call $fd_write (i32.const 1) ;; file_descriptor - 1 for stdout (i32.const 0) ;; *iovs - The pointer to the iov array, which is stored at memory location 0 (i32.const 1) ;; iovs_len - We\u0026#39;re printing 1 string stored in an iov - so one. (i32.const 20) ;; nwritten - A place in memory to store the number of bytes written ) drop ;; Discard the number of bytes written from the top of the stack ) )` func check(e error) { if e != nil { panic(e) } } func main() { dir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;out\u0026#34;) check(err) defer os.RemoveAll(dir) stdoutPath := filepath.Join(dir, \u0026#34;stdout\u0026#34;) engine := wasmtime.NewEngine() store := wasmtime.NewStore(engine) linker := wasmtime.NewLinker(store) // Configure WASI imports to write stdout into a file.  wasiConfig := wasmtime.NewWasiConfig() wasiConfig.SetStdoutFile(stdoutPath) // Set the version to the same as in the WAT.  wasi, err := wasmtime.NewWasiInstance(store, wasiConfig, \u0026#34;wasi_snapshot_preview1\u0026#34;) check(err) // Link WASI  err = linker.DefineWasi(wasi) check(err) // Create our module  wasm, err := wasmtime.Wat2Wasm(TextWat) check(err) module, err := wasmtime.NewModule(store.Engine, wasm) check(err) instance, err := linker.Instantiate(module) check(err) // Run the function  nom := instance.GetExport(\u0026#34;_start\u0026#34;).Func() _, err = nom.Call() check(err) // Print WASM stdout  out, err := ioutil.ReadFile(stdoutPath) check(err) fmt.Print(string(out)) } 結果は同じで wasi_unstable::fd_write なんぞ知らんと言ってくさる。 えっ？ みんなこのサンプルコード動かせるの？ どうやんだ？ 多分ランタイム側で何か足らないんだろうけど，よく分からん。 wasmtime-c-api を組み込めばいいのかなと思ったが，違うよなぁ？\nというところで挫折した orz どなたか教えてください \u0026#x1f647;\n【2021-03-22 追記】 Twitter で教えていただきました。 感謝！\nどうも TinyGo と wasmtime-go との間で WASI Application ABI (Application Binary Interface) が マッチしていない模様。 たしかに $TINYGOROOT/src/runtime/runtime_wasm.go に\n//go:wasm-module wasi_unstable //export fd_write func fd_write(id uint32, iovs *__wasi_iovec_t, iovs_len uint, nwritten *uint) (errno uint) って記述があるわ。 ふむむー。 //go:wasm-module ディレクティブをキーに調べてみればいいのかな。 参考になった。\nちなみに，アドバイスを参考に\nwasi, err := wasmtime.NewWasiInstance(store, wasiConfig, \u0026#34;wasi_snapshot_preview1\u0026#34;) の部分を\nwasi, err := wasmtime.NewWasiInstance(store, wasiConfig, \u0026#34;wasi_unstable\u0026#34;) に差し替えたら動き出した。 なるほどねー。\nTinyGo 側の PR は受理されてマージされているようなので，次のバージョンでは wasi_snapshot_preview1 で行けるだろう。\n【おまけ】 Node.js で WASI を動かす Node.js は v13 から WASI に対応しているらしい。\n$ npm i wasi でパッケージを組み込めば使えるようだ。 で，こんな感じのコードを書いて\n\u0026#39;use strict\u0026#39;; const fs = require(\u0026#39;fs\u0026#39;); const { WASI } = require(\u0026#39;wasi\u0026#39;); const wasi = new WASI({ args: process.argv, env: process.env, preopens: { } }); const importObject = { wasi_unstable: wasi.wasiImport }; // const importObject = { wasi_snapshot_preview1: wasi.wasiImport };  (async () =\u0026gt; { try { const wasm = await WebAssembly.compile(fs.readFileSync(\u0026#39;./hello.wasm\u0026#39;)); const instance = await WebAssembly.instantiate(wasm, importObject); wasi.start(instance); } catch (e) { console.error(e) } })(); 動かしてみると\n$ node --experimental-wasi-unstable-preview1 --experimental-wasm-bigint wasi.js (node:210549) ExperimentalWarning: WASI is an experimental feature. This feature could change at any time (Use `node --trace-warnings ...` to show where the warning was created) Hello, World! おー，動いた動いた。 これで Go のコードを WSAI 経由で JavaScript コードに埋め込めるわけだ。\nブックマーク  WASI - WebAssembly System Interface with Wasmtime - DEV Community コンテナ技術を捨て、 WASIを試す. こんにちは、NTTの藤田です。 | by FUJITA Tomonori | nttlabs | Medium TinyGo の開発版のビルド方法と、ビルドせずに開発版バイナリを手に入れる方法 - Qiita  参考図書  ソフトウェアデザイン 2021年3月号 谷本 心 (著), 水島 宏太 (著), 増田 亨 (著), 山本 悠滋 (著), 折原 レオナルド賢 (著), 米田 武 (著), 清水 洋治 (著), 結城 浩 (著), 刀根 諒 (著), 大串 肇 (著), 松本 直人 (著), クラスメソッド 木村(作) (著), エクスデザイン ninnzinn(画) (著), くつなりょうすけ (著), 広木 大地 (著), 中島 明日香 (著), 金谷 拓哉 (著), 高橋 永成 (著), 平岡 正寿 (著), 梶原 直人(監修) (著), 平櫛 貴章 (著), 星川 真麻 (著), けんちょん(大槻 兼資) (著), 大嶋 健容 (著), 職業「戸倉彩」 (著), mattn (著), 小野 輝也 (著), 濱田 康貴 (著), 森若 和雄 (著), 古川 菜摘 (著), 嘉山 陽一 (著), 平野 尚志 (著), 杉山 貴章 (著), Software Design編集部 (編集) 技術評論社 2021-02-18 (Release 2021-02-18) 雑誌 B08T7D2LFR (ASIN), 4910058270316 (EAN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  第2特集が「WebAssembly 入門」近年の動向を把握するには丁度いいだろう。\nreviewed by Spiegel on 2021-03-21 (powered by PA-APIv5)\n  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n   “Write Once, Run Anywhere” は初期の Java のキャッチフレーズだった。当時は UNIX 機のハードウェア非互換の問題が酷くて，なんとかバイナリ互換を確保する方法がないかみんな頭を悩ませていた。そこに登場したのが Sun Microsystems の Java だったわけ。でも実際にはプラットフォーム間の差異が微妙に残ってしまい，むしろ “Write Once, Debug Everywhere” などと揶揄されることもあった。それでも Virtual Machine 上で標準化されたバイトコードを駆動させるというアイデアは秀逸だったので Java 以外の処理系でも応用され，特に組み込み用途では重宝されている。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2021-03-20 のブックマーク",
      "section": "bookmarks",
      "description": "「Microsoft Exchange Server の脆弱性対策について」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2021/03/20-bookmarks/",
      "published": "2021-03-20T03:19:24+00:00",
      "update": "2021-03-20T03:20:09+00:00",
      "content": "リリース情報  Release v1.38.0 · golangci/golangci-lint · GitHub LibreOffice 7.1.1 Community available for download - The Document Foundation Blog Release February 2021 · microsoft/vscode · GitHub- Release February 2021 Recovery · microsoft/vscode · GitHub Release 4.4.9_4 · zetamatta/nyagos · GitHub Release 1.55.0 · atom/atom · GitHub Release v1.0.16 · sonatype-nexus-community/nancy · GitHub Release February 2021 Recovery 2 · microsoft/vscode · GitHub Release February 2021 Recovery 3 · microsoft/vscode · GitHub Release gopls/v0.6.7 · golang/tools · GitHub Release v1.0.17 · sonatype-nexus-community/nancy · GitHub Release gopls/v0.6.8 · golang/tools · GitHub Release gopls/v0.6.9 · golang/tools · GitHub  バベルのインターネット  「インターネットの表現の自由を守る原則」を守らねばならない | P2Pとかその辺のお話R 中国で人気上昇中の暗号化チャットアプリ「Signal」が禁止に | TechCrunch Japan Twitterの全面遮断を予告したロシア、ブロッキング回避を阻止するためにVPN遮断も示唆 | P2Pとかその辺のお話R  セキュリティ＆プライバシー関連  【注意喚起】VMware vCenter Serverの脆弱性（CVE-2021-21972）、早急な対策を | セキュリティ対策のラック データ移行で発生したみずほ銀行のシステム障害についてまとめてみた - piyolog Finding Evil Go Packages | Michael Henriksen - Security engineer \u0026amp; builder of tools レンタルサーバー運営会社に不正利用を通報したときの窓口と、各社の対応をまとめた。 - Qiita Goで書かれたマルウェアが増加傾向\u0026ndash;APTと犯罪グループの両方が利用 - ZDNet Japan : 犯罪者も Go を選ぶw Linuxカーネルのセキュリティ強化へ\u0026ndash;グーグルがフルタイムのメンテナーを支援する理由 - ZDNet Japan 更新：Microsoft Exchange Server の脆弱性対策について(CVE-2021-26855等)：IPA 独立行政法人 情報処理推進機構  Microsoft Exchange Serverの複数の脆弱性に関する注意喚起 Researcher Publishes Code to Exploit Microsoft Exchange Vulnerabilities on Github Chinese Hackers Stole an NSA Windows Exploit in 2014 - Schneier on Security 攻撃発生中のExchange Serverの脆弱性 ProxyLogonなどについてまとめてみた - piyolog 中国の国家ハッカーがExchange Serverの脆弱性をゼロデイ攻撃、マイクロソフトが警告 | TechCrunch Japan   ミッコ・ヒッポネン氏が警鐘を鳴らす2021年のセキュリティトピックとは (1/3)：EnterpriseZine（エンタープライズジン）  ヒッポネンの法則：『スマート』は脆弱の証 - F-Secure : ウケた   Googleに騙されてはいけない：FLoCは邪悪なアイデアである | P2Pとかその辺のお話R  グーグルが「Cookie廃止後、それに代わる他のユーザー追跡技術を採用するつもりはない」と発言 | TechCrunch Japan   GitHub security update: A bug related to handling of authenticated sessions - The GitHub Blog  “github.com”にセキュリティ問題、ユーザーの強制ログアウトを実施 - 窓の杜   iPhone用通話録音アプリのバグで数千件の通話記録が流出 | TechCrunch Japan 「Linux 5.12 rc1に厄介なバグ」、トーバルズ氏が警告 - ZDNet Japan : 正式リリースでは解消済み バイデン政権は暗号化政策の方針を転換せよ | P2Pとかその辺のお話R 暗号化と表現の自由を脅かす米EARN IT法案とは何か？ | P2Pとかその辺のお話R Red Hat、企業におけるオープンソースの調査レポート「The State of Enterprise Open Source」公開。87％がオープンソースはプロプライエタリと同等かそれ以上にセキュアと － Publickey サイバー犯罪のエコシステムは今\u0026ndash;CrowdStrikeの脅威レポートにみる - ZDNet Japan EU：エンド・ツー・エンド暗号化の解体に向けたタイムテーブル | P2Pとかその辺のお話R ブルース・シュナイアーと語る「暗号戦争」と「暗号化を守んなきゃいけない理由」 | P2Pとかその辺のお話R 「Google Chrome 89」にゼロデイ脆弱性 ～v89.0.4389.90への更新を - 窓の杜  「Microsoft Edge 89」の最新版が公開 ～「Blink」のゼロデイ脆弱性に対処 - 窓の杜   Security Analysis of Apple’s “Find My…” Protocol - Schneier on Security Metadata Left in Security Agency PDFs - Schneier on Security Fast Random Bit Generation - Schneier on Security 3月15日よりセキュリティの警告が出てWebサイトへアクセスできなくなったお客様へ – さくらのサポート情報 GoogleアプリがiOSで収集している個人情報の詳細が判明、あまりの多さに「隠したがっていたのも無理はない」との声 - GIGAZINE Dropbox、無料プランでもパスワード管理ツール「Dropbox Passwords」を提供へ - ZDNet Japan : 「パスワードを任意の相手とセキュアな方法で共有する機能」という発想がそもそも間違っていると思うが\u0026hellip; 管理不備と報じられたLINEの問題についてまとめてみた - piyolog : 行政側が慌ててるのが笑かすw E2EE を開発していて思うこと. ここ数ヶ月は自社製品向けの End to End (Media)… | by V | Medium : 「今後 E2EE は安全すぎるために解析できないと困る部分で脅威」ってのはいかにもサービス提供者側の論理だよな A Hacker Got All My Texts for $16    Easy SMS Hijacking - Schneier on Security     Exploiting Spectre Over the Internet - Schneier on Security  知財関連  GitHub Wants to Get Rid Of the DMCA\u0026rsquo;s Anti-Circumvention FUD * TorrentFreak Overbroad DMCA Takedown Campaign Almost Wipes Dictionary Entries From Google * TorrentFreak EU High Court: Embedding Protected Images Can Breach Copyright Law * TorrentFreak  Linux または Ubuntu に関する話題  Ubuntu 21.10 その2 - 新しいUbuntu Desktopインストーラーのデザイン公開と協力の呼びかけ - kledgeb  Windows に関する話題  「Windows Terminal 1.7」プレビュー、GUI設定画面が既定に。JSONスニペットの共有でカスタマイズも簡単 - 窓の杜 Windows, 共有リソースへの別ユーザー名でのアクセスについて - プログラマーのメモ書き 「Windows 10」次期機能アップデート「21H1」はどうなる？ - ZDNet Japan  Go 言語関連  Complete Golang Microservice example | by Suraj Batuwana | Medium bimg (libvips Goバインディング) でサムネイル画像作成を高速化する - Quipper Product Team Blog Go 1.16で追加されたiotest.ErrReaderを使ってio.Readerの異常系をテストする 【Golang】Exit, panic, Goexitの違い | SharpKnock golang.jp ブログ: golang.jpのドメインを譲渡頂きました Goのリトライ処理で考慮すること GitHub - piprate/json-gold: A JSON-LD processor for Go Go言語における式の評価文脈を理解する Goエラーハンドリング戦略 go:embed を使った場合に GitHub Actions をどうするか : 機微情報を実行バイナリに埋め込むのは感心せんけどねー。まぁ，そういうやり方もあるよってことで VSCodeでbeegoをデバッグする - Qiita : VS Code で Go コードのデバッグ 【Golang】go-i18n/v2 の動作サンプル（2021年03月版）【国際化対応】 - Qiita : gettext みたいなやつ？ yaml.v3 - gopkg.in/yaml.v3 : v3 になってた Self Contained Blog Server with Go 1.16 Go Developer Survey 2020 Results - The Go Blog Manage PostgreSQL JSON data with Go(golang) | by Jorge Quitério | iostrap | Mar, 2021 | Medium Go と prisma と lit-html と ky で作るモダンな TODO アプリ How fast can you Go?. Today I will explore how profiling… | by Aymeric Augustin | Fractal Ideas | Feb, 2021 | Medium JWT を Go で処理するためのパッケージ - Qiita Go言語で複数のシェルスクリプトを実行するcliツールを作ってみた : goroutine リークの解析など参考になる Twitter APIの使い方まとめ（認証情報の種類・Goサンプル実装） Goアセンブリの書き方 - Plan 9とGo言語のブログ RaspberryPi-PicoをTinyGoでLチカする方法 - 144Labグループ開発者ブログ GitHub - google/go-licenses: Reports on the licenses used by a Go package and its dependencies. GitHub - jwalton/gchalk: Terminal string styling for go done right, with full and painless Windows 10 support. : ターミナルエミュレータに表示する文字に装飾できる。 Windows 10 対応？  Rust 言語関連  Rust入門 Building a shared vision for Async Rust | Rust Blog  その他  「Red Hat OpenShift 4.7」正式リリース。既存の仮想マシンをKubernetes管理下へ移行するツール提供、vSphere上のWinowsコンテナをサポート － Publickey マイクロソフト、マルチプラットフォームUIを実現する「.NET Multi-platform App UI」（MAUI）を実際にデモ。単一コードからWebとWindowsアプリを生成 － Publickey Google、Kubernetesを自動運用してくれる「GKE Autopilot」正式リリース。ノードのプロビジョニング、マルチゾーン展開、スケーリングなど自動的に最適実行 － Publickey ［速報］「AWS大阪リージョン」正式オープン。大阪ローカルリージョンを拡張し3つのアベイラビリティゾーンから構成、事前申し込みなど不要に － Publickey Excelの数式をベースにしたプログラミング言語「Microsoft Power Fx」登場。オープンソースで公開予定。Microsoft Ignite 2021 － Publickey GraphQL入門 scoop bucket を作成する - enjoy struggling マイクロソフトが会議で文字起こしや翻訳を行うアプリ「Group Transcribe」を発表 | TechCrunch Japan Flash対応を廃止。「Electron 12」が正式リリース ～SSE3命令が必須に - 窓の杜 マイクロソフト、RPA機能を「Windows 10」ユーザーに無償提供 - ZDNet Japan The lessons of Fukushima - Nuclear power must be well regulated, not ditched | Leaders | The Economist 「Windows Server 2022」プレビュー版が登場、安全なブートなどセキュリティ強化。Microsoft Ignite 2021 － Publickey マイクロソフト、「Universal Print」正式リリースを発表。プリンタサーバをクラウド化し、プリンタドライバを不要に。Microsoft Ignite 2021 － Publickey グーグルがChromeのリリースサイクルを6週から4週に短縮 | TechCrunch Japan  「Microsoft Edge」のリリース間隔も4週間へ短縮 ～「Edge 94」から実施 - 窓の杜   Splitting the ping  ブログ: pingを分割する   The Third Age of JavaScript 図解 CSR, SSR, SSG, ISR Google発の画像圧縮ツール「Squoosh」を使ってみた : これ，クラウドで処理してる？ Javaでもう一度学び直すオブジェクト指向プログラミングを関数型プログラミングで考え直す 〜第1章〜 理研のスーパーコンピューター「富岳」が完成、共用を開始 - ZDNet Japan OrbitDB : Peer-to-Peer Databases for the Decentralized Web Raspberry PiとJetson Nano(2GB)のUSBポートのデバイスを物理的に抜き差しせず、ソフトウェアで制御する 住所オープンデータ提供Web APIの使い方 「GitHub Discussions」がプライベートリポジトリでも利用可能に。電子掲示板を用いたコミュニティ機能を追加 － Publickey チームにdockerを布教することになったので、布教の教材を作ってみた。 「Wireshark」v3.4.4が公開 ～脆弱性を1件修正 - 窓の杜 Slack社はSlackをどう使っているのか - Slack利用ガイドラインの話 - Qiita ハネウェル、量子コンピューター「System Model H1」の性能を4倍に - ZDNet Japan Dart言語のフレームワーク「Flutter 2」公開。単一コードでiOS/Android/Web/Win/Mac/Linuxのネイティブアプリ実現。WebAssemblyによるレンダリングエンジン搭載 － Publickey グローバルIP無しのセキュアなリモート開発環境を構築 by VSCode Remote Development x GCP x IAP AWS、わざとクラウド障害を起こす新サービス「AWS Fault Injection Simulator」提供開始。カオスエンジニアリングをマネージドサービスで － Publickey フリーのお手軽PDF編集ツール「CubePDF Utility」がベータ版を卒業、v1.0.0に - 窓の杜 「Geekbench 5.4」がLinux/ARMとLinux/RISC-Vにプレビュー対応 ～シングルボードなどでも利用可能に - 窓の杜 Windowsで環境を極力汚さずにPythonを動かす方法 (Scoop編) - Qiita Google Colabで日本語要約してみた Improving large monorepo performance on GitHub - The GitHub Blog  マイクロサービスの部分で Go への置き換えが始まっているらしい GitHub における大規模なモノリポのパフォーマンスの向上 - GitHubブログ   デジタル・デトックスでは幸福にもならないし、充実した社会生活が送れるわけでもない - 井出草平の研究ノート NotionのようなUIのTrelloっぽいKanbanツールのOSSの Focalboard を触ってみた : オンプレミスで構築できる オラクルがOracle Autonomous Data Warehouseを強化。SQLを知らないビジネスユーザーでもデータ分析を容易にする自動化とUIなど追加 － Publickey Unreal Build: Automotive 2021 - Unreal Engine Pythonでmathライブラリ使わずlog計算をしたくて、math.log()関数を自作してみた。  "
    },
    {
      "title": "Java のサポート期限ってどうなってるんだっけ？",
      "section": "release",
      "description": "アップデートは計画的に。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/java-support-roadmap/",
      "published": "2021-03-19T11:25:53+00:00",
      "update": "2021-03-19T22:41:30+00:00",
      "content": "ぶっちゃけ PlantUML を動かす程度の利用なら最新の OpenJDK だけ気にしていればよかったんだけど，仕事で Java を使うとなればそういうわけにもいかない。 けど，今の Java のサポート期限ってどうなってるんだっけ？\nまずは Oracle Java。 これははっきりしている。\n Oracle Java SE Support Roadmap  これによると\n   Release GA Date Premier Support Extended Support     7 2011-07 2019-07 2022-07   8 2014-03 2022-03 2030-12   9 2017-09 2018-03 -   10 2018-03 2018-09 -   11 (LTS) 2018-09 2023-09 2026-09   12 2019-03 2019-09 -   13 2019-09 2020-03 -   14 2020-03 2020-09 -   15 2020-09 2021-03 -   16 2021-03 2021-09 -   17 (LTS) 2021-09 2026-09 2029-03    ということらしい1（どのバージョンでも Sustaining Support は無期限で受けれるため省いた）。 つまり Premier Support を受けれるバージョンは現時点（2021-03）で 8, 11, 15/16 が対象となる（15 は 2021-03 まで）。 Extended Support なら 7 も含まれる（Java 7 なら費用は免除）。\n一方 OpenJDK はよく分からない。\nJava 10 以降なら（リリースサイクルが半年毎というだけで）特にサポート期限というものはないみたい。 向こうが「やーめた」と言うまではアップデートを出し続けるのかな？ 7u と 8u については記述がなかったが，四半期ごとのマイナーアップデートの対象になってるみたいなので，一応はサポートしていると思われる。 まぁ， Oracle Java や AdoptOpenJDK, OpenJ9 などからフィードバックがあるのかもしれない。\nちなみに AdoptOpenJDK のサポート期限は\n Support | AdoptOpenJDK - Open source, prebuilt OpenJDK binaries  によると\n   バージョン First Availability End of Availability     8 (LTS) 2014-03 at least 2022-05   9 2017-09 2018-03   10 2018-03 2018-09   11 (LTS) 2018-09 2024-10   12 2019-03 2019-09   13 2019-09 2020-03   14 2020-03 2020-09   15 2020-09 2021-03   16 2021-03 2021-09   17 (LTS) 2021-09 (TBC)    となっていた。 現時点（2021-03）では 8, 11, 15/16 がサポート対象だ（15 は 2021-03 まで）。\n今はクラウドサービスごとに独自のディストリビューションを提供してたりするので， 11 以降ならあまり気にする必要はないのかな。 今だに 8/8u を使ってるサービス（行政サービスとか多そうだw）は，そろそろ未来について（Java を捨てる選択肢も含めて）議論したほうがいいだろう。\nなお，年間のリリース・イベントは以下の通り。\n   月 バージョンアップ・イベント     1月 マイナー・バージョンアップ   2月    3月 メジャー・バージョンアップ   4月 マイナー・バージョンアップ   5月    6月    7月 マイナー・バージョンアップ   8月    9月 メジャー・バージョンアップ   10月 マイナー・バージョンアップ   11月    12月     アップデートは計画的に。\nブックマーク  Eclipse Adoptium | projects.eclipse.org  AdoptOpenJDKプロジェクトがEclipse Foundationへの合流を発表。合流後の新プロジェクト名は「Eclipse Adoptium」に － Publickey   AWS、「Java 8」を2026年まで、「Java 11」は2027年まで、現行より3年サポート期間延長を発表。独自JavaディストリビューションのCorretto 8とCorretto 11で － Publickey OpenJDKと各種JDKディストリビューションの情報源まとめ  参考図書  Effective Java 第3版 Joshua Bloch (著), 柴田 芳樹 (翻訳) 丸善出版 2018-10-30 単行本（ソフトカバー） 4621303252 (ASIN), 9784621303252 (EAN), 4621303252 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  再勉強中。 Kindle 版のほうがちょっと安いが，勤務先でも使いたかったので紙の本にした。\nreviewed by Spiegel on 2021-03-17 (powered by PA-APIv5)\n   Oracle Java 8 はクライアント側での利用と開発目的での利用のみ許可されている。サーバ側での運用は別途有償契約が必要（の筈）。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Go を褒め殺ししてみる",
      "section": "remark",
      "description": "はやく作って はやく改す",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/awesome-golang/",
      "published": "2021-03-18T11:16:13+00:00",
      "update": "2021-03-18T11:17:55+00:00",
      "content": "母国語としてのプログラム言語 以前紹介したのだが，結城浩さんの過去の連ツイに\n プログラミング言語との付き合い方というのはいろいろあってですね。自分の母国語という言語はある。それから現在学んでいる最中の言語というのもある。そして、仕事用の言語やら、他の人とのコミュニケーション用言語というのもある。そのあたりは、自然言語とちょっと似ている。\nITな業界で仕事をしているひとというのは、だいたいそういう感じでプログラミング言語とつきあっていると思っている。たった一つしかプログラミング言語ができないという人は少なくて、二つくらいは読み書きできる。三つ四つくらいはなんとなく読むのはできる。五つ六つくらいは何のソースか言える。\n 考えてみると結城はC, Perl, Javaの本は書いたけれど...より  という記述がある。\nまぁ「仕事用の言語」や「コミュニケーション用言語」ってのは独りで選ぶものではないので今回は除外するとして，「母国語」というのは上手い比喩だ。 自然言語と同じで「母国語」として定着しているプログラミング言語があればロジックや制御への理解も速いし，他言語を習得する際にも有利になる。\nでも最初から「◯◯言語を母国語として習得するぞ」とかいう人はいないだろう。 使い込んで手に馴染んでいって初めて「母国語」になり得る。 問題は「どの言語か」ではなく「手に馴染むまで使い込むほどの動機があるか」だと思う。\n「これからプログラミングを始めるならどの言語にすればいいか」という問いは今の季節の風物詩みたいなものだが，この問いだけでは「始める」動機が見えないし，その人が既に「母国語」と言えるものを持っているか否かで話も変わってくる。\n先日見かけた\n これから勉強するならGolangとRustのどちらがいいでしょうか？難易度も含めて推奨お願いします。 - Quora  という記事も似たような印象を受けたが，回答に挙がっている Rust と Go の比較はなかなか興味深く，また大いに共感した。 ただ，回答された方は Rust 寄りみたいなので，対抗して私は Go を褒め殺ししてみる（笑）\nなお，あらかじめ予防線を張っておくと，私は言語オタクでも文房具オタクでもないし，その手の宗教論争に巻き込まれたくないので，異論反論（当然あると思うけど）には反応しないのであしからず。\n（前説おわり）\nはやく作って はやく改（なお）す1 昔は「はやく作る」というのはスクリプト言語の独壇場だった。 近年のバズワードだった「AI」技術において Python が大きな牽引力として機能しているのは Python が「はやく作る」ことに特化した言語であることも大きいだろう。\nしかし Go がこの状況を変えていく。\nGo はコンパイル言語には珍しく（と言っていいのか分からないが）「はやく作る」ことに特化した言語と言っていい。 「はやく作る」というのは事前学習量やコンパイル速度やコード記述量を指しているのではなく「考えたことをそのまま書いて安全に組めるか」ということだ。 Go の言語仕様に組み込まれた簡便さも制約もこの目的のためにあると言ってよい。\nたとえば Go は Java などの伝統的オブジェクト指向プログラミング言語とよく比較されるが，例外処理や継承など「考えたことをそのまま書く」ことにおいてノイズにしかならないギミックをあっさり捨て去っている。 Goroutine 間に優先順位が存在しないのも sync.Mutex が再入不可なのもちゃんと理由があるのだ（Generics は結局組み込むみたいだけどw）。\nちなみに「はやく作る」ことは「雑に作る」ことではない。 近年の流行語である「技術的負債」の本来の意図は「はやく作る」ことと引き換えにしているものを金融用語の「負債」に喩えたことだそうだ。つまり技術的負債の「返済」とは，システムやプログラムを「直す」ことではなく「改（なお）す」つまりリファクタリングを指している。\nもうひとつの Go の特徴は，このリファクタリングに厚い言語であるということだ。 シンプルな言語仕様故に手を入れやすいし， interface 型による「構造型の部分型付け（structural subtyping）」によってオブジェクト間の関係を「疎」にできるため，再利用性の高い機能を別パッケージとして切り離したり，なんなら「出来のよくないパッケージを丸ごと入れ替える」なんてことも比較的容易だったりする。\n一言で言うなら「はやく作って はやく改せる」のが Go 最大のメリットである。 道具に耽溺するのでなく振り回されるのでなく，自らのアイデアを「いい感じ」に実装する手段としてプログラミング言語を求めるのなら Go を選択するのは悪くない，と言っておこう。\n「文」の制約 Go の言語仕様を読むところまで慣れた方なら気づいてると思うけど， Go は文（statement）の制約が強い言語である。 文の制約を強くすることで全体の言語仕様をシンプルにしている，とも言えるが。\nたとえば if, switch, for といった制御文や = などの代入文は式（expression）として評価できないため，式の一部または全部として組み込めない。 分かりやすい例としては C/C++ などでは悪名高いインクリメント2 “x++” は代入構文のバリエーションとして評価されるため，式の一部として組み込めない，とかいったことがある。\ny := ary[x++] // syntax error あるいはもっと簡単に\na = b = c = 1 // syntax error とかも無理。\nこういった制約は，特に関数型プログラミング言語から来た人には大きな不満となるだろう。 この理由で Go に馴染めないというのであれば Rust のほうをお勧めする（笑）\n富豪的プログラミングの代償 並列処理とメモリ管理はどんな言語でも悩ましい問題である。 特に両者が組み合わさると非常に厄介と言える。\nたとえばスクリプト言語や Virtual Machine 上の動作を前提とした処理系ではスクリプト・エンジンや VM が並列処理やメモリ管理の厄介な部分を引き受けてくれるが， Go ではこれらを実行モジュールに組み込むことで高いパフォーマンス（とシングル・バイナリでのデプロイ）を可能としている。\n富豪的プログラミングの観点からは，これらの仕組みはプログラマに有利に働く。 最初の節で紹介した Q\u0026amp;A の回答でも\n 言語仕様が小さくて、コンパイルがとても速く、GC (Garbage Collector)を採用してメモリ管理の煩わしさをなくすとともに、並列実行を容易にしています。\nその分、単体での実行速度については妥協していますが、速度を求めるのなら処理を並列化しつつマシン側（実行環境）を増強すれば良い、というクラウド時代の解決策をとっています。つまり、コードのちまちまとした最適化で悩んでいる暇があるなら札束で殴ってさっさと解決しろ、ということですね。とても効率的な考え方です。\n これから勉強するならGolangとRustのどちらがいいでしょうか？難易度も含めて推奨お願いします。 - Quoraより  と解説されている。まさに富豪的（笑）\nしかし，これと引き換えに「小さなシステム」に対しては無視できない代償を支払っている。 これは並列処理やメモリ管理を実行バイナリに埋め込むために POSIX への依存度が高くなっているためだ。\n小さなシステムやシビアなリアルタイム処理3 には Go は向かないだろう。ましてやデバイスドライバや pure Go な OS カーネルなど夢のまた夢である。 そういうものに興味があるのであれば Rust のほうがお勧めだ。\nなお，個人的に興味を持っている TinyGo なら LLVM ベースの小さいバイナリを生成することができる。組み込み用途であればこういった選択肢はありだと思う。\n本当は WebAssembly に興味があるのだが，少なくとも Go 側が WASI (WebAssembly System Interface) をサポートしてくれないと無理かなぁ。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n  プログラミングRust Jim Blandy (著), Jason Orendorff (著), 中田 秀基 (翻訳) オライリージャパン 2018-08-10 単行本（ソフトカバー） 4873118557 (ASIN), 9784873118550 (EAN), 4873118557 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版あり。公式ドキュメントよりも系統的に書かれているので痒いところに手が届く感じ。ただし量が多いので，一度斜め読みしたらあとは傍らに置いて必要に応じてつまみ食いしていくのがいいだろう。\nreviewed by Spiegel on 2020-03-08 (powered by PA-APIv5)\n  Effective Java 第3版 Joshua Bloch (著), 柴田 芳樹 (翻訳) 丸善出版 2018-10-30 単行本（ソフトカバー） 4621303252 (ASIN), 9784621303252 (EAN), 4621303252 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  再勉強中。 Kindle 版のほうがちょっと安いが，勤務先でも使いたかったので紙の本にした。\nreviewed by Spiegel on 2021-03-17 (powered by PA-APIv5)\n   「改す」を「なおす」と読むのは辞書的に正しい日本語ではありません。念のため（笑） \u0026#x21a9;\u0026#xfe0e;\n C/C++ ではインクリメント/デクリメント演算子は前置（++x）と後置（x++）があって機能が異なる。これに起因する不具合も多く，コーディング・ルールで「インクリメント/デクリメントの後置は禁止」とするところが多いらしい。 \u0026#x21a9;\u0026#xfe0e;\n ここでいうリアルタイム処理とは「分割されたジョブを決められたタイミングで決められた期間内に完了すること」を指す。 \u0026#x21a9;\u0026#xfe0e;\n   "
    }
  ]
}
