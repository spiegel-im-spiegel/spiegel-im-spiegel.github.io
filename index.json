{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "spiegel-im-spiegel/ml v0.3.0 をリリースした",
      "section": "release",
      "description": "ひょっとして zetamatta/go-readline-ny パッケージ使ったら CUI の簡易プロンプトがもっと簡単に実装できるんちゃうん？",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/01/makelink-0_3_0-is-released/",
      "published": "2021-01-03T07:12:38+00:00",
      "update": "2021-01-03T08:13:27+00:00",
      "content": "\u0026hellip;ついカッとなってやった。 反省はしない\u0026hellip;\nみなさま，あけましておめでとうございます。 本年も「書きたくないときには書かない」「他人の評価など気にしない」をモットーに，ゆるゆるとやっていく所存です。\n閑話休題 (それはさておき) ，正月早々 Zenn で\n 「コマンドラインシェル？？？　誰でも作れますよ」  という記事を眺めてて\n「あれ？ ひょっとして zetamatta/go-readline-ny パッケージ使ったら CUI の簡易プロンプトがもっと簡単に実装できるんちゃうん？」 と思いついてしまい，（たぶん私しか使ってないであろう）Markdown 形式のリンクを生成するツールに手を入れることにした。 その結果を v0.3.0 としてリリースしている。\n Release v0.3.0 · spiegel-im-spiegel/ml · GitHub  今回の変更は以下の3つ。\n リポジトリ名を mklink から ml に変更する spiegel-im-spiegel/ml リポジトリ直下に main.go を移動し，コマンドライン・ツールとして構成し直す 対話モードでの入力を zetamatta/go-readline-ny パッケージで書き直す  最初のはメインマシンを Ubuntu に換装した関係で先延ばしにしていたやつ。 Windows の内部コマンドに mklink てのがあって（シンボリックリンク操作のコマンド），それと名前が被ってたのだ。 実際には GitHub のリポジトリ設定から簡単にリネームできた（簡単ならとっととやれってば）。 旧 URL からのリダイレクトもやってくれている。 感謝。\n2番めは，近年私がよくやる変更。 昔は「Go コード用の外部パッケージとして書いて，その実装例としてコマンドラインツールも書く」というスタンスで構成していたが，機能がニッチ過ぎて汎用で再利用しづらいため「じゃあ最初からコマンドラインツールとして構成すればいいぢゃん」と考えを改めた。\n一応\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/ml/makelink\u0026#34; ) func main() { lnk, err := makelink.New(context.Background(), \u0026#34;https://git.io/vFR5M\u0026#34;) if err != nil { fmt.Fprintln(os.Stderr, err) return } _, _ = io.Copy(os.Stdout, lnk.Encode(makelink.StyleMarkdown)) // Output:  // [GitHub - spiegel-im-spiegel/ml: Make Link with Markdown Format](https://github.com/spiegel-im-spiegel/ml) } のように Go のコードに組み込むことも可能。\n3番目の zetamatta/go-readline-ny パッケージの組み込みはマジでやってよかった。 ざっと見た感じ，このパッケージの特徴は以下の通り。\n エコーバック（？）の Writer を指定できる 簡易ヒストリ機能を付けられる Ctrl+C および Ctrl+D を正しく拾ってエラー（readline.CtrlC および io.EOF）として返してくれる（上位レイヤでの SIGNAL 操作が不要）  たとえばこんな感じに書けるらしい。\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/mattn/go-colorable\u0026#34; \u0026#34;github.com/zetamatta/go-readline-ny\u0026#34; \u0026#34;github.com/zetamatta/go-readline-ny/simplehistory\u0026#34; ) func main() { history := simplehistory.New() editor := readline.Editor{ Prompt: func() (int, error) { return fmt.Print(\u0026#34;$ \u0026#34;) }, Writer: colorable.NewColorableStdout(), History: history, } fmt.Println(\u0026#34;Tiny Shell. Type Ctrl-D to quit.\u0026#34;) for { text, err := editor.ReadLine(context.Background()) if err != nil { fmt.Printf(\u0026#34;ERR=%s\\n\u0026#34;, err.Error()) return } fields := strings.Fields(text) if len(fields) \u0026lt;= 0 { continue } cmd := exec.Command(fields[0], fields[1:]...) cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.Stdin = os.Stdin cmd.Run() history.Add(text) } }  via zetamatta/go-readline-ny: Readline library for golang , used in nyagos  というわけで，拙作の spiegel-im-spiegel/ml でも対話モードのプロンプトに簡易ヒストリが使えるようにした。 めっさ便利！\nzetamatta/go-readline-ny パッケージは元々 NYAGOS をターゲットに書かれたもののようだが，私の Ubuntu 環境でも問題なく動作している。\nうんうん。 よかったよかった。\nブックマーク  Markdown 形式のリンクを生成するツールを作ってみた  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "Ubuntu で最新版 GnuPG をビルドする",
      "section": "openpgp",
      "description": "念のために警告しておくと，今回の自力ビルドは積極的にはお勧めしない。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/openpgp/build-gnupg-in-ubuntu/",
      "published": "2021-01-01T04:18:27+00:00",
      "update": "2021-01-02T01:24:00+00:00",
      "content": "Linux 環境では GnuPG は（ユーザは意識しないかもしれないが）セキュリティ中核部品のひとつだが， Ubuntu はかなり保守的な運用をしているそうで，滅多なことでは GnuPG をアップデートしないようだ。 かといって CVE ID が割り振られるような脆弱性まで長期間放置するのはいかがなものかと思うが。\nそこで，かねてから懸案だった GnuPG の自力ビルドを試してみることにした。\n念のために警告しておくと，今回の自力ビルドは積極的にはお勧めしない。 GnuPG の最新機能を試したいとか，何がなんでも最新版が欲しいとかいうのでない限り APT で配布されるバージョンを使うほうがよい。 まぁ「最悪はこういう手段も取れるよ」という感じで記憶の片隅にでも置いていただければ（笑）\nビルド対象のパッケージ GnuPG は複数のパッケージで構成されていて，個別にビルド\u0026amp;インストールしていく必要がある。 今回ビルド対象となるパッケージは以下の通り。\n   # パッケージ名 バージョン 公開日     1 Libgpg-error 1.41 2020-12-21   2 Libgcrypt 1.8.7 2020-10-23   3 Libassuan 2.5.4 2020-10-23   4 Libksba 1.5.0 2020-11-18   5 nPth 1.6 2018-07-16   6 ntbTLS 0.2.0 2020-08-27   7 GnuPG 2.2.26 2020-12-21    ビルド\u0026amp;インストールの順番は Libgpg-error を最初にして GnuPG を最後にすることさえ気をつければいいと思うが，特にこだわりがないのであれば上の順番でビルドしていくのがいいだろう。\n前準備 最初に，上に挙げた以外でビルドに必要なパッケージを APT でインストールしておく。\n$ sudo apt install libgnutls28-dev bzip2 make gettext texinfo gnutls-bin build-essential libbz2-dev zlib1g-dev libncurses5-dev libsqlite3-dev libldap2-dev 適当にググって見繕ったものなので，もしかしたらこんなに要らないかもしれないが，精査するのが面倒くさかったので今回はこれで（笑）\nビルド用にダウンロードしたファイルの完全性（integrity）をチェックするために電子署名を検証する。 たとえばこんな感じ。\ngpg --verify gnupg-2.2.26.tar.bz2.sig gnupg-2.2.26.tar.bz2 署名チェックに必要な OpenPGP 公開鍵は以下のページにある。\n GnuPG - Signature Key  クリップボード操作ができる xsel または xclip コマンドがあるなら，上のページに貼り付けられている公開鍵（ASCII armor 形式）をコピって\n$ xsel | gpg --import などとすれば公開鍵を取り込める。\n各パッケージのビルド ではパッケージを順にビルドしていこう。 ビルド用に適当なディレクトリをあらかじめ掘っておくとよい。\n$ sudo mkdir /var/local/gnupg-build $ cd /var/local/gnupg-build Libgpg-error のビルド 以下に手順だけ示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/libgpg-error/libgpg-error-1.41.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/libgpg-error/libgpg-error-1.41.tar.bz2.sig -O $ gpg -d libgpg-error-1.41.tar.bz2.sig # integrity check $ sudo tar xvf libgpg-error-1.41.tar.bz2 $ pushd libgpg-error-1.41/ $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。 configure コマンドは引数なしでも問題なさそうだ。\nLibgcrypt のビルド 同様に手順を示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/libgcrypt/libgcrypt-1.8.7.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/libgcrypt/libgcrypt-1.8.7.tar.bz2.sig -O $ gpg -d libgcrypt-1.8.7.tar.bz2.sig # integrity check $ sudo tar xvf libgcrypt-1.8.7.tar.bz2 $ pushd libgcrypt-1.8.7/ $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。\nLibassuan のビルド 同様に手順を示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/libassuan/libassuan-2.5.4.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/libassuan/libassuan-2.5.4.tar.bz2.sig -O $ gpg -d libassuan-2.5.4.tar.bz2.sig # integrity check $ sudo tar xvf libassuan-2.5.4.tar.bz2 $ pushd libassuan-2.5.4 $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。\nLibksba のビルド 同様に手順を示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/libksba/libksba-1.5.0.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/libksba/libksba-1.5.0.tar.bz2.sig -O $ gpg -d libksba-1.5.0.tar.bz2.sig # integrity check $ sudo tar xvf libksba-1.5.0.tar.bz2 $ pushd libksba-1.5.0 $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。\nnPth のビルド 同様に手順を示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/npth/npth-1.6.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/npth/npth-1.6.tar.bz2.sig -O $ gpg -d npth-1.6.tar.bz2.sig # integrity check $ sudo tar xvf npth-1.6.tar.bz2 $ pushd npth-1.6 $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。\nntbTLS のビルド 同様に手順を示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/ntbtls/ntbtls-0.2.0.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/ntbtls/ntbtls-0.2.0.tar.bz2.sig -O $ gpg -d ntbtls-0.2.0.tar.bz2.sig # integrity check $ sudo tar xvf ntbtls-0.2.0.tar.bz2 $ pushd ntbtls-0.2.0 $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。\nGnuPG のビルド ようやく本命。 今までと同様に手順を示しておく。\n$ sudo curl -L https://gnupg.org/ftp/gcrypt/gnupg/gnupg-2.2.26.tar.bz2 -O $ sudo curl -L https://gnupg.org/ftp/gcrypt/gnupg/gnupg-2.2.26.tar.bz2.sig -O $ gpg -d gnupg-2.2.26.tar.bz2.sig # integrity check $ sudo tar xvf gnupg-2.2.26.tar.bz2 $ pushd gnupg-2.2.26 $ ./configure $ make $ sudo make install $ popd これで /usr/local/ ディレクトリ以下の各ディレクトリにビルド結果がインストールされる。 そうそう，最後に\n$ sudo ldconfig としておくのを忘れずに。 これで\n$ gpg --version gpg (GnuPG) 2.2.26 libgcrypt 1.8.7 Copyright (C) 2020 Free Software Foundation, Inc. License GNU GPL-3.0-or-later \u0026lt;https://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Home: /home/username/.gnupg サポートしているアルゴリズム: 公開鍵: RSA, ELG, DSA, ECDH, ECDSA, EDDSA 暗号方式: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256 ハッシュ: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224 圧縮: 無圧縮, ZIP, ZLIB, BZIP2 と最新版で起動できる。 念のため設定状況もチェックしておこう。\n$ gpgconf --list-components gpg:OpenPGP:/usr/local/bin/gpg gpg-agent:プライベート鍵:/usr/local/bin/gpg-agent scdaemon:スマートカード:/usr/local/libexec/scdaemon gpgsm:S/MIME:/usr/local/bin/gpgsm dirmngr:ネットワーク:/usr/local/bin/dirmngr pinentry:パスフレーズ入力:/usr/local/bin/pinentry $ gpgconf --list-dirs sysconfdir:/usr/local/etc/gnupg bindir:/usr/local/bin libexecdir:/usr/local/libexec libdir:/usr/local/lib/gnupg datadir:/usr/local/share/gnupg localedir:/usr/local/share/locale socketdir:/run/user/1000/gnupg dirmngr-socket:/run/user/1000/gnupg/S.dirmngr agent-ssh-socket:/run/user/1000/gnupg/S.gpg-agent.ssh agent-extra-socket:/run/user/1000/gnupg/S.gpg-agent.extra agent-browser-socket:/run/user/1000/gnupg/S.gpg-agent.browser agent-socket:/run/user/1000/gnupg/S.gpg-agent homedir:/home/username/.gnupg ふむむ。 上の設定に合わせて，もう少し弄っておこうか。\n$ cd /usr/local/bin/ $ sudo ln -s /etc/alternatives/pinentry pinentry こんな感じかな。 Pinentry は下手に弄ると絶対にドツボにはまるので今回は既存のものを使う。\nソケットががが\u0026hellip; 上の gpgconf --list-dirs で示されるソケットについて\nsocketdir:/run/user/1000/gnupg dirmngr-socket:/run/user/1000/gnupg/S.dirmngr agent-ssh-socket:/run/user/1000/gnupg/S.gpg-agent.ssh agent-extra-socket:/run/user/1000/gnupg/S.gpg-agent.extra agent-browser-socket:/run/user/1000/gnupg/S.gpg-agent.browser agent-socket:/run/user/1000/gnupg/S.gpg-agent そもそも /run/user/1000/ ディレクトリ1 はブート時（？）に毎回初期化されるのだが，どうやら /usr/bin/ ディレクトリ以下のオリジナル・コンポーネントを使って初期化してるみたいで，そのままだと /usr/bin/gpg-agent のほうが常駐してしまう。\nこれでは面白くないし gpg-agent 経由でなにか操作をする度に gpg-agent のバージョンが古いと怒られるので，以下のコマンドでソケットを再作成する。\n$ gpgconf --kill all $ gpgconf --remove-socketdir $ gpgconf --create-socketdir $ gpg-connect-agent --quiet /bye これで /usr/local/ ディレクトリ以下のコンポーネントに対応したソケットを再作成してくれる。 下３行はまとめて ~/.bashrc 等に書いておくといいかもしれない。 いずれにせよ，かなりダサいやり方という自覚はありますよ。\nこれ，最初のソケット初期化時にやってくれないかなぁ。 GnuPG のサイトにはそもそもあまり情報がないし，ググっても情報が上手く見つけられなくて困っている。\nどなたか情報をご存知でしたら教えてください \u0026#x1f647;\n最後に動作確認。\n$ echo hello world | gpg -a -s -u mykey -----BEGIN PGP MESSAGE----- owGbwMvMwCG45Zb1ujqFHTKMp4WSGOLfTbPOSM3JyVcozy/KSeHqmMzCIMjBYC2m yCIdxHTby+542ccHayVgeliZQBpkZYoLMlPTU3P0MnP1oEyH9NzEzBy95PxcBi5O AZj6RwcY/scanE3cwbVrv0v/zA7njR1J8d7vTjwP28EmLvzWVuPhqnaG/4kBz24f 634aYBi/NW79/1WcDusyco91C7N6zWwVC114PRsA =/6XI -----END PGP MESSAGE----- 署名時に Pinentry が起動してパスフレーズが通ればOK。 よーし，うむうむ，よーし。\nブックマーク   Nitrokey/gnupg-docker: Build and use specific GnuPG version using Ubuntu image within Docker\u0026rsquo;s container : Docker 環境で GnuPG をビルド\u0026amp;セットアップする\n  GnuPG チートシート（鍵作成から失効まで）\n  Windows Terminal × NYAGOS × Scoop ＝ ♥ : Windows 版 GnuPG は Scoop 経由でインストールするのがオススメ\n    ちなみに 1000 はユーザIDを指す。ログインしている自身のユーザIDを知るには id -u で調べられる。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "宇宙は何色？",
      "section": "remark",
      "description": "Cosmic Latte というのは2002年に修正論文が発表された全宇宙の色の平均値のこと。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/12/cosmic-latte/",
      "published": "2020-12-30T04:56:08+00:00",
      "update": "2020-12-30T04:58:56+00:00",
      "content": "2020-12-27 の “Astronomy Picture of the Day” が “Cosmic Latte” でちょっとびっくりした（笑）\nCosmic Latte というのは2002年に修正論文1 が発表された全宇宙の色の平均値のこと。 当時のページはもう残ってないみたいなので Internet Archive から。\n The Cosmic Spectrum and the Color of the Universe By Karl Glazebrook \u0026amp; Ivan Baldry  WIRED の記事は残ってるみたい。 流石！\n Universe: Beige, not Turquoise | WIRED  実際にはこんな色。 Color-hex は #fff8e7。\n  via Cosmic Latte: The Average Color of the Universe  私も日記ページの背景色にしていたことがある。\nなんか懐かしいなぁ。\nブックマーク  APOD: 2002 July 2 - The Average Color of the Universe 再び発表された宇宙の色：「初期の宇宙は青かった」 宇宙の色は何色？ — 旧メイン・ブログ | Baldanders.info  参考図書  天体物理学 Arnab Rai Choudhuri (著), 森 正樹 (翻訳) 森北出版 2019-05-28 単行本 4627275110 (ASIN), 9784627275119 (EAN), 4627275110 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  興味本位で買うにはちょっとビビる値段なので図書館で借りて読んでいる。まえがきによると，この手のタイプの教科書はあまりないらしい。内容は非常に堅実で分かりやすい。理系の学部生レベルなら問題なく読めるかな。\nreviewed by Spiegel on 2019-11-13 (powered by PA-APIv5)\n   2001年に発表された論文では宇宙の平均色はトルコ石のような緑色とされていたが，その後，計算アルゴリズムにバグが見つかったとかで翌年2002年に修正論文が発表された。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "ルールを解釈で捻じ曲げる",
      "section": "remark",
      "description": "“People don't want to be educated, they want to be entertained”",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/12/rules-and-interpretations/",
      "published": "2020-12-29T07:06:27+00:00",
      "update": "2020-12-30T00:16:22+00:00",
      "content": "「数学ガール」シリーズでおなじみの結城浩さんが Twitter でゼロの偶奇を問うアンケートをされていて，その結果について\n「0は偶数です」を正しいとした方は58%で、驚くほどの低正解率でした。\n「0は偶数でも奇数でもありません」を正しいとした方が41%もいらっしゃいました。この回答をした方の理由をお聞きしたいです。https://t.co/reMDPiPM9f\n\u0026mdash; 結城浩 (@hyuki) December 28, 2020  と感想を tweet しておられた。\n実はこのアンケートには元ネタがあるそうで，それがこれ。\n The Parity Of Zero 「0は偶数ではない」と多くの人が信じているのは教育に問題があるという指摘 - GIGAZINE  わざわざこんな辺境の記事を読むような人には自明だろうが，念のためにいうと，偶数とは「2の整数倍数」あるいは「2で割り切れる整数」として 定義 されるものである。 プログラマ風に言うなら「2進数に展開した際に最下位ビットが0になる整数値」または「n\u0026amp;1==0 が true となる int n」でもいいだろう（笑） いずれにしてもゼロは偶数と言える，議論の余地なく。\nこの話のポイントは，偶奇の色分けは「定義」であるということだ。 言い方を変えるなら「2で割り切れる整数を偶数としましょう」という「ルール」である。 つまり「0は偶数でも奇数でもありません」と考えた人は，思い込みの解釈で偶奇のルールを捻じ曲げてしまったわけだ。\nこれで思い出したのが数年前に話題になった「掛け算は順序が大事」という話である。 もちろん掛け算に順序に関するルールはない。 その上で数の掛け算には「交換法則」が成り立つという点が算数の算数たる所以なのだが，そういうのを全部チャイして「順序が大事」と言っちゃってるわけだ。\n当時はこの話を聞いて「日本の学校教育 ＼(^o^)／ｵﾜﾀ」と思ったものだが，似たような話は世界中どこにでも転がっているということなのかもしれない。 これに関して，最初に挙げた記事の\nIt doesn’t necessarily need to be made “relevant.” Yes, for some people you can create the motivation that way, but for others, they will engage purely for the pleasure of finding things out, and the satisfaction in being able to see a reason behind things that were previously stated without justification. via The Parity Of Zero  という部分は結構重要なポイントに見える。 ものに喩えるのは私もよくやるが，喩えを行う場合はその「差異」を常に意識しないと，分かりやすい喩えの方に意識が引きずられてしまう。\nまぁ，日本の，いや世界の数学教育の話はここまでにしておいて，注目したい点は「ルールを解釈で捻じ曲げる」人が一定数いるということだろう。\n典型例は日本の「憲法九条」かな。 「解釈」で捻れまくっているよね。 あるいは知財やプライバシー・セキュリティ関連の法律など「ガイドライン」という名の解釈によって為政者に都合よく運用される風景が当たり前になっている。\nBruce Schneier 先生原著の『セキュリティはなぜやぶられたのか』では「抑止1」における教育の必要性を説く。\n 抑止が効果を持つためには、「教育」が必要だ。社会が犯罪から守られているのは、基本的に、攻撃に対する直接的な防御があるからではない。人々が法律を守るからだ。ほとんどの人は倫理や道徳を重んじる。倫理は人が生まれながらに持つ性質で、これがなかったら人は文明化できなかっただろう。道徳は、何が道徳的で善良な市民とはどういうものかという教育によって身につけるものだ セキュリティはなぜやぶられたのかより  倫理や道徳はともかく，ルールを作ってそれを守ってもらいたいなら，教える側にしても教わる側にしても，それをどのように解釈するか（あるいはされるか）については常に注意を払うべきかもしれない。 なにせ偶数の定義すら捻じ曲げて解釈してしまうのが人間なのだから（笑）\nあちこちの職場を渡り歩いて，その度に「セキュリテイ研修」を受けるが，ぶっちゃけルールを押し付けるだけのところが多く「何故」がないんだよね（まぁ「傭兵」相手に時間をかける気はないってことなんだろうけど）。 特にセキュリティ管理はルールの根拠をきちんと示さなければ守ろうとは思わないし，しぶしぶ守るとしても「解釈で捻じ曲げる」余地を与えてしまう。\nPeople don’t want to be educated, they want to be entertained. via The Parity Of Zero  私は「守られないルールは，ルール自体に問題がある」と考えるが「ルールを解釈で捻じ曲げる」事態が常態化するなら（教育を含めて）マネジメント全体を見直す最初のアラームとなるだろう。\n参考図書  数学ガールの誕生　理想の数学対話を求めて 結城 浩 (著) SBクリエイティブ 2013-09-13 (Release 2014-09-13) Kindle版 B00NAQA33A (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  結城浩さんの講演集。こういう場所に立ち会える今の学生さんは羨ましい。\nreviewed by Spiegel on 2013-09-21 (powered by PA-APIv5)\n  いかにして問題をとくか G. ポリア (著), Polya,G. (原著), 賢信, 柿内 (翻訳) 丸善 1975-04-01 単行本 4621045938 (ASIN), 9784621045930 (EAN), 4621045938 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  数学書。というか問いの立てかたやものの考え方についての指南書。のようなものかな。\nreviewed by Spiegel on 2014-09-26 (powered by PA-APIv5)\n  セキュリティはなぜやぶられたのか ブルース・シュナイアー (著), 井口 耕二 (翻訳) 日経BP 2007-02-15 単行本 4822283100 (ASIN), 9784822283100 (EAN), 4822283100 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  原書のタイトルが “Beyond Fear: Thinking Sensibly About Security in an Uncertain World” なのに対して日本語タイトルがどうしようもなくヘボいが中身は名著。とりあえず読んどきなはれ。ゼロ年代当時 9.11 およびその後の米国のセキュリティ政策と深く関連している内容なので，そのへんを加味して読むとよい。\nreviewed by Spiegel on 2019-02-11 (powered by PA-APIv5)\n   『セキュリティはなぜやぶられたのか』では「抑止」を「将来の攻撃をセキュリティシステムが防止するやり方」と定義している。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "「無人化システム」とメンタル・モデル",
      "section": "remark",
      "description": "20世紀なコードはもうケッコウ",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/12/mental-model/",
      "published": "2020-12-28T12:31:19+00:00",
      "update": "2020-12-28T21:55:14+00:00",
      "content": "先週のことで恐縮だが\n COBOLのコードは未だに我々の金を握っており、バリバリ現役である - YAMDAS現更新履歴  という記事が公開されていて，これを読んで思い出したのが20世紀に参加した某プロジェクトでの世間話。\nもう四半世紀前のうろ覚えでしかも人伝 (ひとづて) に聞いた内容だが，当時は意図的に難読化コードを書くプログラマも多かったらしい。 理由は単純で，コードを「属人化」してしまえば少なくともそのプロジェクトに関してはクビにならないから。\nというわけで COBOL プログラマはきっと「まだだ！ まだ終わらんよ！」と思っているだろう（笑）\n「無人化システム」 一方，上の記事が出る少し前に\n 「無人化システム」を駆逐する組織マネジメントとエンジニアリング  というのが Zenn で公開されていて，あまりの納得感に投げ銭 (サポート) してしまったのだが（笑），記事では「無人化システム」を\n システム運用が属人化し、かつその運用者が退職するとシステムが無人化します。我々の会社ではこのようなシステムを『無人化システム』と呼んでいます。\n無人化システムは「誰も詳細は知らないが、なぜか動いているシステム」です。\n 「無人化システム」を駆逐する組織マネジメントとエンジニアリングより  と定義しているようだ。\n「傭兵」時代は「汎用機＋COBOL」からのリプレイス案件を時々受けていたが，何が困るって，ドキュメント化されない「誰も知らないコード」が平気で紛れ込んでいて1，しかもそのコードに手を出すとどんな影響が出るか予測できないという事態にホンマに困っていた（あと，どうやっても正規化できないデータベースとかw）。\nまっ，要するに，時代や言語に関係なく，この手の話は割と普遍的に観測できるということなんだろう。\nメンタル・モデル 2017年に公開された記事だが\n Design Philosophy On Data And Semantics  というのを最近読んだ。 特に Go でコードを書く人はこの記事は必読だろう。\nいくつか拾い読みしてみる。\nA consistent use of value/pointer semantics, for a given type of data, is critical if you want to maintain integrity and readability throughout your software. Why? Because, if you are changing the semantics for a piece of data as it is passed between functions, you are making it difficult to maintain a clear and consistent mental model of the code. The larger the code base and the team becomes, the more bugs, data races and side effects will creep unseen into the code base. via Design Philosophy On Data And Semantics  Tom has also mentioned that a box of copy paper can hold 100k lines of code. Take a second to let that sink in. For what percentage of the code in that box could you maintain a mental model of? via Design Philosophy On Data And Semantics  “The hardest bugs are those where your mental model of the situation is just wrong, so you can’t see the problem at all” - Brian Kernighan via Design Philosophy On Data And Semantics  これ以降は Go をターゲットにした具体的な話に入っていくのだが，これが Go に限る話ではないということはお分かりいただけるだろう。\nプログラマにとって最も信頼できるドキュメントは動いているプログラムコードである。 だからこそコードは「文芸的2」であるべきだし，プログラマは要件定義の段階から積極的にコードを書くべきだと思う。 リファクタリングは何時でもできるのだから3。\n書いた人にしか分からない20世紀なコードはもうケッコウである。\nブックマーク  技術的負債とハッカー    勿論ちゃんとしてる企業もあるよ。コードを1行修正するのにも2重3重のレビューを行って，変更申請書が受理されないと変更できない，みたいなガチガチの企業もあったな。 \u0026#x21a9;\u0026#xfe0e;\n 「コードはもっと文芸的であるべき」というのはクヌース博士のいわゆる「文芸的プログラミング（literate programming）」とはちょっと違う。ごめんペコン。 \u0026#x21a9;\u0026#xfe0e;\n というか，これからの時代はリファクタリングに厚い言語を選択すべき。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2020-12-27 のブックマーク",
      "section": "bookmarks",
      "description": "「Hugo 0.79.1: One Security Patch for Hugo on Windows」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2020/12/27-bookmarks/",
      "published": "2020-12-27T01:17:03+00:00",
      "update": "2020-12-30T01:57:26+00:00",
      "content": "リリース情報  Hugo 0.79.1: One Security Patch for Hugo on Windows | Hugo  セキュリティ＆プライバシー関連  NSA on Authentication Hacks (Related to SolarWinds Breach) - Schneier on Security  SolarWindsのサプライチェーン攻撃についてまとめてみた - piyolog 米政府機関の“cyber breach”被害、破られたのは何？ - ITmedia NEWS Russia’s SolarWinds Attack - Schneier on Security   ジャーナリスト36人以上のiPhoneが「ゼロクリック」スパイウェアにハックされていたことが発覚 | TechCrunch Japan 情報を外部に送信している？　疑惑のWebブラウザ「Smooz」が配信停止に - ITmedia NEWS 「Emotet」と呼ばれるウイルスへの感染を狙うメールについて：IPA 独立行政法人 情報処理推進機構 : 事例の追加 TwitterがAPI機能を拡張、開発者は公開された会話の追跡が可能に | TechCrunch Japan Investigating the Navalny Poisoning - Schneier on Security China\u0026rsquo;s Secret War for U.S. Data Blew American Spies' Cover  How China Uses Stolen US Personnel Data - Schneier on Security    天文関連  2021年には軌道上での燃料補給や製造が理論から現実へ変わる | TechCrunch Japan 伊能忠敬が師事した江戸の天文学者・高橋至時をご存じか？（ブルーバックス編集部） | ブルーバックス | 講談社  Linux または Ubuntu に関する話題  Ubuntu 20.04 その216 - CentOSユーザーに贈るUbuntu LTSに移行する6つのポイント - kledgeb  Go 言語関連  [Go]os.Stdinへの全件読み込みを複数回すると、2回目以降先頭に余計な改行が必ず入ってきてしまう件 fzf ライクな fuzzy-finder を提供する Go ライブラリを書いた - blog.syfm  S3 のファイルをあいまい検索で操作できる s3fzf という CLI ツールをつくった   Goでライブラリを使用せずTwitterAPIを実装する - Qiita goで作るAPIのセキュリティを考えた - Qiita 【Go】imagick を使用して画像にテキストを書き込む Goにproperty based testingを布教したい GitHub - mattn/godown: Convert HTML into Markdown : HTML → markdown 変換  Go でモブログシステム作った   Go 製 CLI にプラグイン機構を作る方法n選  Rust 言語関連  [Rust] FFIでよく使う型変換  その他  「トランザクション張っておけば大丈夫」と思ってませんか？ バグの温床になる、よくある実装パターン GPG で複数の受取人で暗号化する時に \u0026ndash;group オプションが便利 - yu8mada Apple M1チップ対応「Docker Desktop」、x86用のコンテナイメージのビルドと実行も可能。Docker社が説明 － Publickey GitHubをチーム開発で利用する際に行った設定などを紹介 Kubernetesを用いてハイパーコンバージドインフラを実現する「Harvester」、Rancher Labsがオープンソースで公開 － Publickey COBOLのコードは未だに我々の金を握っており、バリバリ現役である - YAMDAS現更新履歴 Hugo で React + TypeScript を利用してサクッとウェブサイトに RSS リーダーを追加する  "
    },
    {
      "title": "ポインタが指し示す意味を考える",
      "section": "golang",
      "description": "Go では goroutine や interface 型を使った抽象化で並列処理やヒープ管理などの面倒くさい部分をランタイム・モジュールに丸投げする。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/value-pointer-semantic/",
      "published": "2020-12-26T06:08:29+00:00",
      "update": "2020-12-27T13:19:02+00:00",
      "content": "以下の記事がちょっと面白かったのでこの記事でも試してみる。\n Go: Should I Use a Pointer instead of a Copy of my Struct? | by Vincent Blanchon | A Journey With Go | Medium Goにおけるポインタの使いどころ  なお，大元の Should I Use a Pointer instead of a Copy of my Struct? が書かれたのは2019年5月で，おそらく Go のバージョンも 1.12 あたりだと思うので，その辺を考慮して読むといいだろう。 ちなみに A Journey With Go は Go の内部動作について割と詳しく解説されていてオススメの読み物である。\nヒープのコスト 起点 (トリガー) はこの構造体型。\ntype S struct { a, b, c int64 d, e, f string g, h, i float64 }  via Should I Use a Pointer instead of a Copy of my Struct?  そして，この型のインスタンスを生成する（実質的な）構築子を2つ用意する。\nfunc byCopy() S { return S{ a: 1, b: 1, c: 1, e: \u0026#34;foo\u0026#34;, f: \u0026#34;foo\u0026#34;, g: 1.0, h: 1.0, i: 1.0, } } func byPointer() *S { return \u0026amp;S{ a: 1, b: 1, c: 1, e: \u0026#34;foo\u0026#34;, f: \u0026#34;foo\u0026#34;, g: 1.0, h: 1.0, i: 1.0, } }  via Should I Use a Pointer instead of a Copy of my Struct?  2つの関数はいずれもリテラル表現で指定された内容のインスタンスを返すが， byCopy() 関数は値を byPointer() 関数はポインタを返すという違いがある。 また byCopy() 関数ではインスタンスをスタック上に置くが byPointer() 関数ではインスタンスをヒープ上に生成する1。\nこれらの関数の呼び出しコストを計測するベンチマーク・テストは以下の通り。\nfunc BenchmarkMemoryStack(b *testing.B) { var s S b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { s = byCopy() } b.StopTimer() _ = fmt.Sprintf(\u0026#34;%v\u0026#34;, s.a) } func BenchmarkMemoryHeap(b *testing.B) { var s *S b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { s = byPointer() } b.StopTimer() _ = fmt.Sprintf(\u0026#34;%v\u0026#34;, s.a) } 元記事のコードでは GC (Garbage Collection) の挙動を検証するために色々と仕込んでいるが，今回はコストだけを測ればいいので単純な構成にしてある。\n結果はこんな感じ。\n$ go test ./... -bench Memory -benchmem goos: linux goarch: amd64 pkg: pointer BenchmarkMemoryStack-4 132169167 9.04 ns/op 0 B/op 0 allocs/op BenchmarkMemoryHeap-4 15257716 71.6 ns/op 96 B/op 1 allocs/op PASS ok pointer 3.233s まぁ，元記事とだいたい同じ結果かな。 見にくいので表にまとめておこう。\n   関数名 実行時間\n(ナノ秒) Alloc\nサイズ Alloc\n回数     BenchmarkMemoryStack 9.0 0 0   BenchmarkMemoryHeap 71.6 96 1    言うまでもないが s = byCopy() は代入文で Go では代入時に必ずコピーが発生する。 ただし s = byCopy() がインスタンス自体のコピーなのに対し s = byPointer() ではポインタ値のみコピーされる。\nつまり上の結果はヒープ領域の割当と解放にかかる（GC を含む）時間コスト（の平均）がインスタンスのコピーよりもかなり大きいことを示している。 それでも（GC のオーバーヘッドを含めても）平均で100ナノ秒未満で済んでいるなら十分に優秀だと思うけどね。\n元記事でも解説されているが Go の GC は独立の goroutine で駆動するため，アーキテクチャ2 や使用するコア数の影響を大きく受ける。 GC を含めてシビアな評価が必要なのであれば，その辺の環境を含めて考えるべきだろう。\nコピーのコスト（2020-12-27 訂正） 元記事には続きがある。 さきほどの構造体 S に対し\n//go:noinline func (s S) stack(s1 S) {} //go:noinline func (s *S) heap(s1 *S) {}  via Should I Use a Pointer instead of a Copy of my Struct?  というメソッドを用意してベンチマークテストを以下のように書き直す3。\nfunc BenchmarkMemoryStack(b *testing.B) { var s S var s1 S s = byCopy() s1 = byCopy() for i := 0; i \u0026lt; b.N; i++ { for i := 0; i \u0026lt; 1000000; i++ { s.stack(s1) } } } func BenchmarkMemoryHeap(b *testing.B) { var s *S var s1 *S s = byPointer() s1 = byPointer() for i := 0; i \u0026lt; b.N; i++ { for i := 0; i \u0026lt; 1000000; i++ { s.heap(s1) } } }  via Should I Use a Pointer instead of a Copy of my Struct?  Go の関数引数は値渡し（call by value）なので引数として渡す時点でコピーが発生するが s.heap(s1) はポインタ値がコピーされるだけなので，単純に考えれば s.stack(s1) のほうがコストが大きいように思える。\n実際にこれを実行すると\n$ go test ./... -bench Memory -benchmem goos: linux goarch: amd64 pkg: pointer BenchmarkMemoryStack-4 174\t6794688 ns/op\t0 B/op\t0 allocs/op BenchmarkMemoryHeap-4 514\t2263913 ns/op\t0 B/op\t0 allocs/op PASS ok pointer\t3.285s てな感じになる。\nんー。 元記事とは少し違うが，3倍程度の差があるかな。 これも表にまとめておこう。\n   関数名 実行時間\n(μ秒) Alloc\nサイズ Alloc\n回数     BenchmarkMemoryStack 6.8 0 0   BenchmarkMemoryHeap 2.3 0 0    なお //go:noinline ディレクティブがないと最適化されてしまいほとんど差がなくなるようだ。\nInterface のコスト ではここで元記事にはなかったテストを考えてみよう。\n構造体 S に以下のメソッドを追加し\nfunc (s S) ValueA() int64 { return s.a } このメソッドを有効にする interface 型\ntype IS interface { ValueA() int64 } と，この型を返す構築子\nfunc byInterface() IS { return S{ a: 1, b: 1, c: 1, e: \u0026#34;foo\u0026#34;, f: \u0026#34;foo\u0026#34;, g: 1.0, h: 1.0, i: 1.0, } } を定義する。 この構築子を使ったベンチマークテストも書いておこう。\nfunc BenchmarkMemoryBox(b *testing.B) { var s IS b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { s = byInterface() } b.StopTimer() _ = fmt.Sprintf(\u0026#34;%v\u0026#34;, s.ValueA()) } これを最初のベンチマークテストと比較してみる。 結果はこんな感じ。\n$ go test ./... -bench Memory -benchmem goos: linux goarch: amd64 pkg: pointer BenchmarkMemoryStack-4 132085750 9.08 ns/op 0 B/op 0 allocs/op BenchmarkMemoryHeap-4 15357787 70.0 ns/op 96 B/op 1 allocs/op BenchmarkMemoryBox-4 14711439 76.0 ns/op 96 B/op 1 allocs/op PASS ok pointer 4.392s 表にまとめておこう。\n   関数名 実行時間\n(ナノ秒) Alloc\nサイズ Alloc\n回数     BenchmarkMemoryStack 9.1 0 0   BenchmarkMemoryHeap 70.0 96 1   BenchmarkMemoryBox 76.0 96 1    時間コストについて byCopy() 関数と byPointer() 関数を足したよりちょっと小さい，って感じだろうか。\nInterface 型の機能とはボックス化（boxing）である。 ボックス化されたインスタンスは必ずヒープ領域に置かれる。 その意味で byPointer() 関数と byInterface() 関数がメモリ管理で似たような挙動になるのは納得できるのではないだろうか。\nヒープを恐れるな ヒープメモリ操作が高コストなのは汎用 OS 下で動くアプリケーションであれば自明であり，そこに GC のオーバーヘッドが加わるのだから，そりゃあもう「あたり前田のクラッカー」という奴である。\n私のようなロートル世代ではヒープ管理は（可能であれば）忌避したい代物だった。 上述したように操作自体が高コストなのに加えて割当と解放を漏れなく矛盾なく記述しきらなければならないのだから面倒くさいことこの上ない。\nGo では goroutine や interface 型を使った抽象化と引き換えに並列処理やヒープ管理などの面倒くさい部分をランタイム・モジュールに丸投げする。 しかもその「面倒くさい部分」を細かく制御できず，これが Go プログラミングにおける重要なトレードオフとなっているのである。\nもしヒープ管理をテッペンから見下ろして完全掌握したいと考えるのなら GC は邪魔なだけだし，そもそも Go で書くインセンティブがない。 それこそ近ごろ流行りの Rust とかで書くべきだろう。\n今回の記事のような話を知識として知っておくのはいいことだと思うが，設計上の重要なポイントではない（むしろチューニングの話だ）。 ポインタを「概念」で捉えることができれば「ポインタが指し示す意味」について深く考察できるようになる。 それこそが本来の「プログラム設計」というやつである。\nブックマーク  Design Philosophy On Data And Semantics Big Sky :: Go のポインタの躓きやすい点  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n  Go言語による並行処理 Katherine Cox-Buday (著), 山口 能迪 (翻訳) オライリージャパン 2018-10-26 単行本（ソフトカバー） 4873118468 (ASIN), 9784873118468 (EAN), 4873118468 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版もある。感想はこちら。 Go 言語で並行処理を書くならこの本は必読書になるだろう。\nreviewed by Spiegel on 2020-01-13 (powered by PA-APIv5)\n  SAVED. ／ Be mine! 坂本　真綾 (メインアーティスト) FlyingDog 2014-02-05 (Release 2014-02-05) MP3 ダウンロード B00HY73M16 (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  「世界征服〜謀略のズヴィズダー〜」OP曲。万能感溢れるノリのいい曲である（笑）\nreviewed by Spiegel on 2020-12-26 (powered by PA-APIv5)\n   よく勘違いされるが（というか私も最初の頃は勘違いしていたが）リテラル表現で \u0026amp;S{ ... } と記述する場合は，どっかに固定のインスタンスがあって，その固定インスタンスへのポインタを示しているのではなく，暗黙的にヒープ上にインスタンスを生成してリテラルの内容で初期化している。つまり \u0026amp;S{} は new(S) と等価である。むしろリテラルで初期値を指定できる分だけ new() 関数より簡潔で優れている。詳しくは『プログラミング言語Go』の4.4.1章を参照のこと。これを知ってから組み込みの new() 関数はほとんど使わなくなった（笑） \u0026#x21a9;\u0026#xfe0e;\n 最近の goroutine はプリエンプティブ・マルチタスクが可能になったが，アーキテクチャによっては対応していない場合がある。 \u0026#x21a9;\u0026#xfe0e;\n 元記事では //go:noinline ディレクティブがなかったが，これがないと最適化されしまうため，コードを変更している。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "GnuPG 2.2.26 がリリースされた",
      "section": "release",
      "description": "LDAP のサポートが改善され， Active Directory の基本的なサポートが追加された。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/12/gnupg-2_2_26-is-released/",
      "published": "2020-12-22T10:21:54+00:00",
      "update": "2021-01-01T04:19:13+00:00",
      "content": "GnuPG 2.2.26 がリリースされた。\nこのバージョンでは\nThis is a maintenance release improving support for LDAP keyservers and enterprise use. via [Announce] GnuPG 2.2.26 released  とのことで，さらに Twitter では\nThe #EU_Commission might not like such software but here is another GnuPG release. This time with improved support for LDAP and basic support for Active Directory : https://t.co/QWlOjAwALO\n\u0026mdash; GNU Privacy Guard (@gnupg) December 21, 2020  とか tweet されていて，ちょっと笑ってしまった。 まぁ，今の OpenPGP 鍵サーバは明らかに設計限界に来てるからねぇ。 今後も注意して見ていこう。\nその他の詳細はこちら。\n gpg: New AKL method \u0026ldquo;ntds\u0026rdquo;. gpg: Fix \u0026ndash;trusted-key with fingerprint arg. scd: Fix writing of ECC keys to an OpenPGP card. [#5163] scd: Make an USB error fix specific to SPR532 readers. [#5167] dirmngr: With new LDAP keyservers store the new attributes. Never store the useless pgpSignerID. Fix a long standing bug storing me keys on an ldap server. dirmngr: Support the new Active Direcory LDAP schema for keyservers. dirmngr: Allow LDAP OpenPGP searches via fingerprint. dirmngr: Do not block other threads during keyserver LDAP calls. Support global configuration files. [#4788] Fix the iconv fallback handling to UTF-8. [#5038]  Release-info: https://dev.gnupg.org/T5153 via GnuPG 2.2.26 released  ビルド対象パッケージ 自前でビルドする際の対象パッケージは以下の通り。\n   # パッケージ名 バージョン 公開日 更新     1 Libgpg-error 1.41 2020-12-21    2 Libgcrypt 1.8.7 2020-10-23    3 Libassuan 2.5.4 2020-10-23    4 Libksba 1.5.0 2020-11-18    5 nPth 1.6 2018-07-16    6 ntbTLS 0.2.0 2020-08-27    7 GnuPG 2.2.26 2020-12-21     アップデートは計画的に。\nブックマーク   GnuPG and LDAP : GnuPG と LDAP との連携方法\n  OpenPGP の実装\n  参考図書  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n "
    },
    {
      "title": "Ubuntu に Docker を入れる",
      "section": "remark",
      "description": "なんか以前より面倒くさくなってないか？",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/12/installing-docker-in-ubuntu/",
      "published": "2020-12-20T12:55:25+00:00",
      "update": "2020-12-20T12:56:00+00:00",
      "content": "ちょっと思いついて onatype-nexus-community/nancy を Docker で動かそうと思ったのだが，メイン・マシンに入れてないことに気がついた。 そういや実験用のノートPCに入れただけでメイン・マシンには入れてなかったか。\nというわけで，改めて Ubuntu に Docker を入れようとしたのだが，なんか以前より面倒くさくなってないか？ 一応，覚え書きとして残しておこう。\nまず Ubuntu の APT 標準リポジトリに入ってるものは微妙に古くてダメぽい感じ。 なので，既に入っている場合はいったん消しておく。\n$ sudo apt remove docker docker-engine docker.io containerd runc まっさらになったらリポジトリの登録から始める。\nその前に以下のパッケージが未インストールなら先にインストールする。\nsudo apt install apt-transport-https ca-certificates curl software-properties-common インストールできたら Docker インストール用の OpenPGP 公開鍵をインポートする1。\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 一応，鍵指紋を確認しておくね。\n$ sudo apt-key fingerprint 0EBFCD88 pub rsa4096 2017-02-22 [SCEA] 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 uid [ 不明 ] Docker Release (CE deb) \u0026lt;docker@docker.com\u0026gt; sub rsa4096 2017-02-22 [S] 無駄にデカい鍵を使ってる気がするが，まぁいいや。 鍵指紋が 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 なら無問題。\nそして，ようやくリポジトリの登録である。\nsudo add-apt-repository \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; stable の他に nightly と test があるそうだが， Docker 自体で遊ぶわけではないので stable でええじゃろ。 sudo apt update で最新化しておくのをお忘れなく。\nあとは普通にインストールすればよい。\nsudo apt install docker-ce docker-ce-cli containerd.io Docker のインストールが成功すると daemon として起動する。 状態を確認するには以下のコマンドでOK。\n$ sudo systemctl status docker ● docker.service - Docker Application Container Engine Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled) Active: active (running) since Sun 2020-12-20 00:00:00 UTC; 21min ago TriggeredBy: ● docker.socket Docs: https://docs.docker.com Main PID: 849 (dockerd) Tasks: 14 Memory: 112.1M CGroup: /system.slice/docker.service └─849 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock うんうん，ちゃんと動いてるね。\nDocker を自身のアカウントで動かしたい場合は\n$ sudo usermod -aG docker username などとして docker グループに組み入れる。 ログインし直さないと有効にならないので注意。\nほんじゃあ，いよいよ onatype-nexus-community/nancy を動かしてみますかね。\n$ go list -json -m all | docker run --rm -i sonatypecommunity/nancy:latest sleuth -n ┏━━━━━━━━━━━━━━━┓ ┃ Summary ┃ ┣━━━━━━━━━━━━━┳━┫ ┃ Audited Dependencies ┃ 9┃ ┣━━━━━━━━━━━━━╋━┫ ┃ Vulnerable Dependencies ┃ 0┃ ┗━━━━━━━━━━━━━┻━┛ よーし，うむうむ，よーし。\nブックマーク   Install Docker Engine on Ubuntu | Docker Documentation\n  How To Install and Use Docker on Ubuntu 20.04 | DigitalOcean\n  Ubuntuにdockerをインストールする - Qiita\n  Dockerは非推奨じゃないし今すぐ騒ぐのをやめろ - Cloud Penguins\n  Go 依存パッケージの脆弱性検査\n  参考図書  イラストでわかるDockerとKubernetes Software Design plus 徳永 航平 (著) 技術評論社 2020-12-05 (Release 2020-12-05) Kindle版 B08PNMRXKN (ASIN)  とりあえず Kindle 版を買ったがまだ読んでない。年末年始の課題図書にする予定。\nreviewed by Spiegel on 2020-12-20 (powered by PA-APIv5)\n   インポートする前に公開鍵の中身を gpgpdump で確認することができる。コマンドラインで gpgpdump fetch https://download.docker.com/linux/ubuntu/gpg とすればよい。宣伝でした（笑） \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "gpgpdump v0.11.0 をリリースした",
      "section": "release",
      "description": "クリップボードに読み込まれている OpenPGP パケットを直接ダンプできるようにした。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/12/gpgpdump-v0_11_0-is-released/",
      "published": "2020-12-20T10:59:58+00:00",
      "update": "2020-12-20T11:40:45+00:00",
      "content": "OpenPGP パケットの内容を可視化する gpgpdump の v0.11.0 をリリースした。\n Release v0.11.0 · spiegel-im-spiegel/gpgpdump · GitHub  --clipboard オプションを追加し，クリップボードに読み込まれている OpenPGP パケットを直接ダンプできるようにした。 公開鍵をメール本文に直接貼り付けたり Web ページに \u0026lt;pre\u0026gt; 要素で貼り付けたりとか今だにあるようなので，そろそろ私が面倒くさくなってきたのですよ（笑）\nたとえば\n$ cat testdata/eccsig.asc -----BEGIN PGP SIGNATURE----- Version: GnuPG v2 iF4EARMIAAYFAlTDCN8ACgkQMfv9qV+7+hg2HwEA6h2iFFuCBv3VrsSf2BREQaT1 T1ZprZqwRPOjiLJg9AwA/ArTwCPz7c2vmxlv7sRlRLUI6CdsOqhuO1KfYXrq7idI =ZOTN -----END PGP SIGNATURE----- のようなテキストがクリップボードに読み込まれているとすると\n$ gpgpdump --clipboard --utc Signature Packet (tag 2) (94 bytes) Version: 4 (current) Signiture Type: Signature of a canonical text document (0x01) Public-key Algorithm: ECDSA public key algorithm (pub 19) Hash Algorithm: SHA2-256 (hash 8) Hashed Subpacket (6 bytes) Signature Creation Time (sub 2): 2015-01-24T02:52:15Z Unhashed Subpacket (10 bytes) Issuer (sub 16): 0x31fbfda95fbbfa18 Hash left 2 bytes 36 1f ECDSA value r (256 bits) ECDSA value s (252 bits) てな感じで処理できる。\nなお --clipboard オプションによる入力は ASCII armor テキストのみ受け入れる。 また --file オプションと同時に指定できない（エラーになる）。\n$ gpgpdump --clipboard -f testdata/eccsig.asc Error: cannot set --clipborad and --file options at onece 更に UNIX 系の環境では xclip または xsel コマンドがインストールされていることが前提となる。 macOS では pbpaste てのを使うみたいだが，これは標準で入ってるのかな？\nとまぁ制約が多いが，悪しからず。\nブックマーク   atotto/clipboard: clipboard for golang\n  OpenPGP の実装\n  OpenPGP パケットを可視化する gpgpdump\n  参考図書  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n "
    }
  ]
}
