{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "参照と借用",
      "section": "rust-lang",
      "description": "ちょっとした数理パズルだと思えばいい（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/references-and-borrowing/",
      "published": "2020-03-07T15:51:00+00:00",
      "update": "2020-03-07T15:51:19+00:00",
      "content": "前回の続きで，所有権に絡む話。\n参照と借用 まずはこのコードを出発点にしよう。\nstruct Person{age: u32,name: String,}fn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};println!(\u0026#34;{} ({})\u0026#34;,p1.name1,p.age);//Output: Alice (24) }毎回 println! マクロで出力を整形するのはかったるいので，整形を行う関数を考えてみる。 こんな感じ。\nstruct Person{age: u32,name: String,}fn display_person(p: Person)-\u0026gt; String {letmuts=p.name;s.push_str(\u0026#34; (\u0026#34;);s.push_str(\u0026amp;p.age.to_string());s.push_str(\u0026#34;)\u0026#34;);s}fn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};println!(\u0026#34;{}\u0026#34;,display_person(p1));//Output: Alice (24) }一見うまく行っているようだが，次の1行を足すとコンパイル・エラーになる。\nfn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};println!(\u0026#34;{}\u0026#34;,display_person(p1));println!(\u0026#34;{}\u0026#34;,p1.name);//Error: borrow of moved value: `p1` }これは 変数の p1 の値の所有権が display_person() 関数の引数 p に移動したからである。\n変数を引数にセットするたびに所有権が移るのは鬱陶しいので，変数の「参照」を引数にセットする。 こんな感じに書き換えてみよう。\nfn display_person(p: \u0026amp;Person)-\u0026gt; String {letmuts=p.name.clone();s.push_str(\u0026#34; (\u0026#34;);s.push_str(\u0026amp;p.age.to_string());s.push_str(\u0026#34;)\u0026#34;);s}2行目の宣言文も変わってることに注意。 実は2行目を\nfn display_person(p: \u0026amp;Person)-\u0026gt; String {letmuts=p.name;//Error: cannot move out of `p.name` which is behind a shared reference s.push_str(\u0026#34; (\u0026#34;);s.push_str(\u0026amp;p.age.to_string());s.push_str(\u0026#34;)\u0026#34;);s}のままにするとコンパイル・エラーになる。 引数 p は元の変数の値を「借用」しているに過ぎないので，所有権の移動はできないのである。 ていうか，最初の display_person() 関数は引数の値を壊してたのか。 コワイコワイ（笑）\n全体のコードは以下の通り。\nstruct Person{age: u32,name: String,}fn display_person(p: \u0026amp;Person)-\u0026gt; String {letmuts=p.name.clone();s.push_str(\u0026#34; (\u0026#34;);s.push_str(\u0026amp;p.age.to_string());s.push_str(\u0026#34;)\u0026#34;);s}fn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};println!(\u0026#34;{}\u0026#34;,display_person(\u0026amp;p1));//Output: Alice (24) println!(\u0026#34;{}\u0026#34;,p1.name);//Output: Alice }変数と参照の関係を図式化するとこんな感じだろうか。\n display_person() 関数の引数である参照変数 p は，値を直接参照しているのではなく，値の所有権を持つ変数 p1 を参照している点がポイントである。 このことを示す例を挙げてみよう。\n参照されている変数の値の所有権は移動できない 先程の main() 関数を少し弄って\nfn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};letp2=\u0026amp;p1;letp3=p1;//Error: cannot move out of `p1` because it is borrowed println!(\u0026#34;{}\u0026#34;,display_person(p2));println!(\u0026#34;{}\u0026#34;,p3.name);}とするとコンパイル・エラーになる。 参照されている変数の値の所有権は移動できないようだ。 まぁ，当たり前か。\nただし println! マクロの位置を少し変えると\nfn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};letp2=\u0026amp;p1;println!(\u0026#34;{}\u0026#34;,display_person(p2));//Output: Alice (24) letp3=p1;println!(\u0026#34;{}\u0026#34;,p3.name);//Output: Alice }問題なく動く。 これは参照変数 p2 のライフタイム（lifetime）が display_person() 関数実行完了をもって満了しているため。 その後の let p3 = p1; 宣言文では p1 を参照している変数はないので問題なく所有権を移動できる。\n変数のライフタイムを超えた参照はできない ちょっとへんてこりんなコードだが\nfn main(){letlong_p;{letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};long_p=\u0026amp;p1;//Error: `p1` does not live long enough println!(\u0026#34;{}\u0026#34;,p1.name);}println!(\u0026#34;{}\u0026#34;,display_person(long_p));}これもコンパイル・エラーになる。\n変数 p1 のライフタイムは\nfn main(){letlong_p;{letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};long_p=\u0026amp;p1;//Error: `p1` does not live long enough println!(\u0026#34;{}\u0026#34;,p1.name);}println!(\u0026#34;{}\u0026#34;,display_person(long_p));}このスコープだが，参照変数 long_p のライフタイムは main() 関数全域に及ぶため，最後の\nfn main(){letlong_p;{letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};long_p=\u0026amp;p1;//Error: `p1` does not live long enough println!(\u0026#34;{}\u0026#34;,p1.name);}println!(\u0026#34;{}\u0026#34;,display_person(long_p));}println! マクロ実行時で，元の変数 p1 のライフタイムは満了しているのに参照変数 long_p はまだ生きているという不整合が発生しているわけだ。\nコンパイル・エラーのメッセージだけ見ても分かりにくいかもしれないが，変数のライフタイムを頭に入れながら考えれば分かりやすいだろう。 ちょっとした数理パズルだと思えばいい（笑）\nライフタイム注釈 ここでもうひとつ関数を考えてみる。\n欲しいのは2つの Person インスタンスの age が小さい方を選択する関数である。 とりあえず何も考えずに書いてみよう。\nfn younger(l: \u0026amp;Person,r: \u0026amp;Person)-\u0026gt; \u0026amp;Person{//Error: missing lifetime specifier ifl.age\u0026lt;r.age{l}else{r}}残念。 コンパイルエラーになってしまった。\nこの関数では参照変数 l と r のうちどちらかを返すが，どちらを返すかは実行時にしか分からない。 したがって，以下の main() 関数内で\nfn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};letp2=Person{age: 18,name: \u0026#34;Bob\u0026#34;.to_string(),};letp3=younger(\u0026amp;p1,\u0026amp;p2);println!(\u0026#34;{}\u0026#34;,display_person(p3));}参照変数 p3 が参照しているのが p1 なのか p2 なのか（コンパイル時に）決定できないためライフタイムも決まらないのである。\nこういうときは younger() 関数に「ライフタイム注釈（lifetime annotation）」を付けるとよい。 こんな感じ。\nfn younger\u0026lt;\u0026#39;a\u0026gt;(l: \u0026amp;\u0026#39;aPerson,r: \u0026amp;\u0026#39;aPerson)-\u0026gt; \u0026amp;\u0026#39;aPerson{ifl.age\u0026lt;r.age{l}else{r}}ここでは 'a がライフタイム注釈に相当する。 アポストロフィ（'）から続く文字列で構成されている。 新しい younger() 関数では引数と返り値の \u0026amp;Person 参照変数が同じライフタイムであることをコンパイラに知らせている。\n全体のコードはこんな感じ。\nstruct Person{age: u32,name: String,}fn display_person(p: \u0026amp;Person)-\u0026gt; String {letmuts=p.name.clone();s.push_str(\u0026#34; (\u0026#34;);s.push_str(\u0026amp;p.age.to_string());s.push_str(\u0026#34;)\u0026#34;);s}fn younger\u0026lt;\u0026#39;a\u0026gt;(l: \u0026amp;\u0026#39;aPerson,r: \u0026amp;\u0026#39;aPerson)-\u0026gt; \u0026amp;\u0026#39;aPerson{ifl.age\u0026lt;r.age{l}else{r}}fn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};letp2=Person{age: 18,name: \u0026#34;Bob\u0026#34;.to_string(),};println!(\u0026#34;{}\u0026#34;,display_person(younger(\u0026amp;p1,\u0026amp;p2)));//Output: Bob (18) }よーし，うむうむ，よーし。\n参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n "
    },
    {
      "title": "変数束縛",
      "section": "rust-lang",
      "description": "「値」は所有者である「変数」に束縛される。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/variable-bindings/",
      "published": "2020-03-01T12:08:53+00:00",
      "update": "2020-03-07T13:33:30+00:00",
      "content": "Rust の所有権（ownership）のルールは以下の3つ。\n Each value in Rust has a variable that’s called its owner (Rustの各値は、所有者と呼ばれる変数と対応している) There can only be one owner at a time (いかなる時も所有者は一つである) When the owner goes out of scope, the value will be dropped (所有者がスコープから外れたら、値は破棄される)  「値」は所有者である「変数」に束縛される。 これを「変数束縛（variable bindings）」と呼ぶ。\n実際に変数束縛がどのように機能しているかを見てみよう。\nCopy Semantics Rust で定義されるデータ型は以下の通り。\n スカラー型  整数 (i8, u8, \u0026hellip;, isize, usize) 浮動小数点型（f32, f64） 論理値型（bool） 文字型（char）: Unicode コードポイント？   複合型  タプル型 配列型    タプル型はこんな感じで記述できる。\nfn main(){lettup=(500,6.4,1);println!(\u0026#34;tup = {:?}\u0026#34;,tup);//Output: tup = (500, 6.4, 1) }配列はこんな感じ。\nfn main(){letary=[1,2,3];println!(\u0026#34;ary = {:?}\u0026#34;,ary);//Output: ary = [1, 2, 3] }これらのデータ型は値と変数が一体になっていて（値が直接スタックに積まれるため），代入時に値のコピーが発生する。\nfn main(){letmutary1=[1,2,3];letary2=ary1;ary1[0]*=100;println!(\u0026#34;ary1 = {:?}\u0026#34;,ary1);//Output: ary1 = [100, 2, 3] println!(\u0026#34;ary2 = {:?}\u0026#34;,ary2);//Output: ary2 = [1, 2, 3] }イメージとしてはこんな感じ。\n このようにデータ型では値をコピーすることによって変数束縛を担保している。\nちなみに mut は変数が可変（mutable）であることを示す。 Rust では，全ての変数は宣言時に mut キーワードを付けない限り不変（immutable）である。\nMove Semantics Rust には上述のデータ型以外にもいくつかの型が存在する。 以下に主なものを挙げる。\n 構造体（struct） コレクション  文字列（String） ベクタ（Vec\u0026lt;T\u0026gt;）    たとえば構造体なら\nstruct Person{age: u32,name: String,}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};println!(\u0026#34;p1 = {} ({})\u0026#34;,p1.name,p1.age);//Output: p1 = alice (24) }てな感じに書ける。\nデータ型との違いは，変数で示しているものが，値そのものではなく，値への参照（のようなもの）という点である。\n 今度は変数 p1 の値を別の変数に代入してみよう。\nstruct Person{age: u32,name: String,}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};println!(\u0026#34;p1 = {} ({})\u0026#34;,p1.name,p1.age);//Output: p1 = alice (24) letp2=p1;println!(\u0026#34;p2 = {} ({})\u0026#34;,p2.name,p2.age);//Output: p2 = alice (24) }一見うまく言っているようだが，println! マクロ1 の位置を変えると\nstruct Person{age: u32,name: String,}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};letp2=p1;println!(\u0026#34;p1 = {} ({})\u0026#34;,p1.name,p1.age);//Error: value borrowed here after move println!(\u0026#34;p2 = {} ({})\u0026#34;,p2.name,p2.age);}コンパイルエラーになる。\nこれは\nletp2=p1;の部分で値がコピーされず，所有権のみ移動してしまうため。\n 構造体やコレクションの各型の値はヒープ領域に置かれる。 ヒープ上の値に対して代入等を行うたびにコピーを行うのは高コストだし，かといって野放図に参照を増やすとヒープ管理が煩雑になってしまう。\nそこで所有権を「移動」することでヒープ管理の最適化を行うわけだ。\nCopy/Clone Trait じゃあ，構造体やコレクションのコピーはできないのかというと，ちゃんと救済措置はある。\nRust の標準ライブラリには Clone および Copy トレイトが用意されていてこれらを実装することで値のコピーが可能になる。\nちなみに「トレイト（trait）」とは，ここでは C++ や Java で言うところの interface クラスのようなものだと思っておけばよい。 トレイトに関しては多分その内ちゃんとした記事を書くと思う（笑）\nたとえば先程の Person 構造体であれば\nstruct Person{age: u32,name: String,}implCloneforPerson{fn clone(\u0026amp;self)-\u0026gt; Self{Person{age: self.age,name: self.name.clone(),}}}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};letp2=p1.clone();println!(\u0026#34;p1 = {} ({})\u0026#34;,p1.name,p1.age);//Output: p1 = alice (24) println!(\u0026#34;p2 = {} ({})\u0026#34;,p2.name,p2.age);//Output: p2 = alice (24) }とすればよい（トレイトの実装詳細については割愛する）。\n あるいはもっと簡単に\n#[derive(Clone)]struct Person{age: u32,name: String,}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};letp2=p1.clone();println!(\u0026#34;p1 = {} ({})\u0026#34;,p1.name,p1.age);//Output: p1 = alice (24) println!(\u0026#34;p2 = {} ({})\u0026#34;,p2.name,p2.age);//Output: p2 = alice (24) }といった記述もできる2。\n実を言うと\n#[derive(Copy, Clone)]とすれば代入時に自動でコピーが走るのだが， Person 構造体ではコンパイルエラーになってしまい上手く行かなかった。 色々試してみたが，どうも String を含む構造体の Copy トレイトは実装できないらしい？\nなので，たとえば\n#[derive(Copy, Clone)]struct Complex{real: f64,image: f64,}fn main(){letc1=Complex{real: 1.23,image: 4.5,};letc2=c1;println!(\u0026#34;c1 = {} + {}i\u0026#34;,c1.real,c1.image);//Output: c1 = 1.23 + 4.5i println!(\u0026#34;c2 = {} + {}i\u0026#34;,c2.real,c2.image);//Output: c2 = 1.23 + 4.5i }とかいったコードは問題なく書ける。\nふむむー。\nブックマーク  RustのコピーセマンティクスをCopyトレイトを実装して確認する ｜ Developers.IO  参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n   println! って関数じゃなくてマクロなんですよ，奥さん。 \u0026#x21a9;\u0026#xfe0e;\n derive はマクロに似た拡張構文の一種。詳細については割愛する。ていうか，これから勉強する（笑） \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2020-03-01 のブックマーク",
      "section": "bookmarks",
      "description": "「GraphQLの開発を単純化するHasuraが約10億円調達」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2020/03/01-bookmarks/",
      "published": "2020-03-01T03:06:25+00:00",
      "update": "2020-03-01T03:08:56+00:00",
      "content": "リリース情報  Go 1.14 is released - The Go Blog The Document Foundation announces LibreOffice 6.4.1 - The Document Foundation Blog Announcing Rust 1.41.1 | Rust Blog  バベルのインターネット  MIT Tech Review: ツイッター、「ブルームバーグ支持」アカウントを大量停止  セキュリティ＆プライバシー関連  マスクの注文確認を装った返信狙いスパムメールについてまとめてみた - piyolog マイクロソフト、Linux用のマルウェア対策ソフト「Microsoft Defender ATP for Linux」パブリックプレビュー － Publickey Apache Tomcat における脆弱性（CVE-2020-1938）について：IPA 独立行政法人 情報処理推進機構  Apache Tomcat の脆弱性 (CVE-2020-1938) に関する注意喚起   Firefox Enables DNS over HTTPS - Schneier on Security セキュリティに関する情報源を整理してみた 2020年版 - トリコロールな猫/セキュリティ Newly Declassified Study Demonstrates Uselessness of NSA\u0026rsquo;s Phone Metadata Program - Schneier on Security Securing the Internet of Things through Class-Action Lawsuits - Schneier on Security 全国初のダークウェブ一斉摘発キャンペーンについてまとめてみた - piyolog  天文関連  大型低温重力波望遠鏡KAGRA観測開始 | 国立天文台(NAOJ) MITの研究者が「小惑星の地球衝突を回避する方法」を考案 - sorae 宇宙へのポータルサイト ESA - The most powerful black hole eruption in the Universe : へびつかい座銀河団に天の川銀河が15個ぐらい入るサイズの空洞を発見。光速まで加速された電子で満たされており、超巨大ブラックホールが引き起こした爆発で作られたらしい  知財関連  YouTube Fair Use: Documentary Makers Defeat Gaye, Thicke, Bee Gees \u0026amp; Jackson - TorrentFreak Copyright Troll Now Has its Own Piracy Tracking Tool - TorrentFreak 侵害コンテンツのダウンロード違法範囲拡大は、どういう目的で導入されようとし、どういう制度になろうとしているのか？ | HON.jp News Blog  その他  ブログ: ローコードとノーコードプラットフォームはプログラミングに革命をもたらすか? どこまで実現できるか\u0026ndash;「Raspberry Pi」をデータセンターで活用 - ZDNet Japan Google、Active Directoryのマネージドサービスを正式サービスとして開始 － Publickey 日米合意でMIDI 2.0が正式規格としてリリース。MIDI 2.0で変わる新たな電子楽器の世界 | | 藤本健の \u0026ldquo;DTMステーション\u0026rdquo; 2020年2月25日ニュース「地域で増えた患者は一般医療機関でも対応、と政府が基本方針 専門家会議は『この1～2週が急速拡大か瀬戸際』」 | SciencePortal ブログ: Fuchsiaのプログラミング言語ポリシー Coming soon: A new site for fully free collaboration — Free Software Foundation — working together for free software 「さくらのレンタルサーバ/マネージドサーバ」および「さくらのメールボックス」一部機能提供終了のお知らせ（2020年2月27日11：45修正） | さくらインターネット 1200人以上の全社員がリモートワーク。GitLabが公開する「リモートワークマニフェスト」は何を教えているか？ － Publickey GraphQLの開発を単純化するHasuraが約10億円調達 | TechCrunch Japan Raspberry Pi 4が価格据え置きでメモリー容量を2GBに倍増 | TechCrunch Japan 実装言語を「Go」から「Rust」に変更、ゲーマー向けチャットアプリ「Discord」の課題とは：Rustで処理速度を改善 - ＠IT さようなら、TypeScript enum | Kabuku Developers Blog  "
    },
    {
      "title": "LibreOffice 6.4 へのアップグレード",
      "section": "release",
      "description": "前回と同じく今回も公式サイトからファイルを取ってきてインストールした。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/03/upgrade-libreoffice-6_4/",
      "published": "2020-03-01T01:46:04+00:00",
      "update": "2020-03-01T01:48:45+00:00",
      "content": "LibreOffice 6.4 がリリースされた。\n Performance-focused LibreOffice 6.4 is available for download - The Document Foundation Blog The Document Foundation announces LibreOffice 6.4.1 - The Document Foundation Blog  Ubuntu で LibreOffice を導入する方法はいくつかあるが，前回と同じく今回も公式サイトから *.deb ファイルを取ってきてインストールした。 細かくチェックしたわけではないが 6.4 でも OpenPGP 鍵で暗号化したファイルが開けたので，まぁ問題なかろう。\n6.3 系と 6.4 系はパソコン上で共存できてしまうので 6.4 系のみを使うのであれば以前の 6.3 系は削除する。\n$ sudo apt remove libreoffice6.3* libobasis6.3* 6.4 系を削除する場合も\n$ sudo apt remove libreoffice6.4* libobasis6.4* でよい。\nブックマーク  Ubuntu に LibreOffice をインストールする3つの方法  "
    },
    {
      "title": "Go 1.14 がリリースされた",
      "section": "release",
      "description": "アップデートは計画的に。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/02/go-1_14-is-released/",
      "published": "2020-02-26T03:28:32+00:00",
      "update": "2020-02-26T03:31:05+00:00",
      "content": "Go 1.14 がリリースされた。 今回は2月中にリリースできてよかったね（笑）\n Go 1.14 is released - Google group Go 1.14 is released - The Go Blog Go 1.14 Release Notes - The Go Programming Language  主な変更点は以下の通り。\n Module support in the go command is now ready for production use. We encourage all users to migrate to go modules for dependency management. Embedding interfaces with overlapping method sets Improved defer performance Goroutines are asynchronously preemptible The page allocator is more efficient Internal timers are more efficient  via Go 1.14 is released - The Go Blog  個人的に気になっている点は以前「Go 1.14 リリース候補版」に書いているので，参考にどうぞ。\n例によって Ubuntu の APT で管理している Go コンパイラは古いので，ダウンロードページからバイナリ（go1.14.linux-amd64.tar.gz）を取ってきて手動でインストールすることを強く推奨する。\n$ cd /usr/local/src $ sudo curl \u0026#34;https://dl.google.com/go/go1.14.linux-amd64.tar.gz\u0026#34; -O $ cd .. $ sudo unlink go # 以前の Go が入っている場合 $ sudo tar xvf src/go1.14.linux-amd64.tar.gz $ sudo mv go go1.14 $ sudo ln -s go1.14 go $ go version # /usr/local/go/bin にパスが通っている場合 go version go1.14 linux/amd64 アップデートは計画的に。\nブックマーク  Changes to interfaces in Go1.14 - Dylan Meeus - Medium A Go Module Testbed « null program Inlined defers in Go · Go, the unwritten parts Go1.14で来るGo Modules関連の変更を見てみる - Qiita Go 1.14 リリースノート 日本語訳 - Qiita Go1.14のcontextは何が変わるのか - Qiita What\u0026rsquo;s new Go 1.14?  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n  Go言語による並行処理 Katherine Cox-Buday (著), 山口 能迪 (翻訳) オライリージャパン 2018-10-26 単行本（ソフトカバー） 4873118468 (ASIN), 9784873118468 (EAN), 4873118468 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版もある。感想はこちら。 Go 言語で並行処理を書くならこの本は必読書になるだろう。\nreviewed by Spiegel on 2020-01-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "みんな大好き Hello World",
      "section": "rust-lang",
      "description": "というわけで， Rust の勉強を始めることにしました。ゆっくりのんびりとね。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/hello/",
      "published": "2020-02-25T15:00:15+00:00",
      "update": "2020-02-26T11:36:30+00:00",
      "content": "というわけで， Rust の勉強を始めることにしました。 どぞよろしく。 まぁ，仕事じゃないので，ゆっくりのんびりとね。\n余談だが，英語不得手な私は “Rust” を「ルスト」と読んでいた。 マジンガーZ1 か！\nRust ツールチェーンのインストール まずは Rust ツールチェーンのインストールから。\nインストールの方法はいくつかあるが， Ubuntu 等の Linux プラットフォームであれば rustup-init.sh をダウンロードして実行するのが手っ取り早い。\n$ curl https://sh.rustup.rs -sSf | sh info: downloading installer Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. It will add the cargo, rustc, rustup and other commands to Cargo\u0026#39;s bin directory, located at: /home/username/.cargo/bin This can be modified with the CARGO_HOME environment variable. Rustup metadata and toolchains will be installed into the Rustup home directory, located at: /home/username/.rustup This can be modified with the RUSTUP_HOME environment variable. This path will then be added to your PATH environment variable by modifying the profile file located at: /home/username/.profile You can uninstall at any time with rustup self uninstall and these changes will be reverted. Current installation options: default host triple: x86_64-unknown-linux-gnu default toolchain: stable profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation \u0026gt; ここで 1 を選択する。\ninfo: profile set to \u0026#39;default\u0026#39; info: default host triple is x86_64-unknown-linux-gnu info: syncing channel updates for \u0026#39;stable-x86_64-unknown-linux-gnu\u0026#39; info: latest update on 2020-01-30, rust version 1.41.0 (5e1a79984 2020-01-27) info: downloading component \u0026#39;cargo\u0026#39; info: downloading component \u0026#39;clippy\u0026#39; info: downloading component \u0026#39;rust-docs\u0026#39; 12.0 MiB / 12.0 MiB (100 %) 5.7 MiB/s in 2s ETA: 0s info: downloading component \u0026#39;rust-std\u0026#39; 17.5 MiB / 17.5 MiB (100 %) 7.2 MiB/s in 2s ETA: 0s info: downloading component \u0026#39;rustc\u0026#39; 57.9 MiB / 57.9 MiB (100 %) 6.5 MiB/s in 9s ETA: 0s info: downloading component \u0026#39;rustfmt\u0026#39; info: installing component \u0026#39;cargo\u0026#39; info: installing component \u0026#39;clippy\u0026#39; info: installing component \u0026#39;rust-docs\u0026#39; 12.0 MiB / 12.0 MiB (100 %) 10.0 MiB/s in 1s ETA: 0s info: installing component \u0026#39;rust-std\u0026#39; info: installing component \u0026#39;rustc\u0026#39; 57.9 MiB / 57.9 MiB (100 %) 11.6 MiB/s in 5s ETA: 0s info: installing component \u0026#39;rustfmt\u0026#39; info: default toolchain set to \u0026#39;stable\u0026#39; stable installed - rustc 1.41.0 (5e1a79984 2020-01-27) Rust is installed now. Great! To get started you need Cargo\u0026#39;s bin directory ($HOME/.cargo/bin) in your PATH environment variable. Next time you log in this will be done automatically. To configure your current shell run source $HOME/.cargo/env これで Rust のツールチェーン一式が ~/.cargo/ および ~/.rustup/ ディレクトリ以下にインストールされた。 いや，どうせなら XDG Base Directory に対応してくれよ orz \u0026hellip;まぁいいや。\nちなみに ~/.profile ファイルの末尾に\nexport PATH=\u0026#34;$HOME/.cargo/bin:$PATH\u0026#34; と追記されるが，私の好みで以下のように書き換えた。\n# set PATH so it includes user\u0026#39;s private bin if it exists if [ -d \u0026#34;$HOME/.cargo/bin\u0026#34; ] ; then PATH=\u0026#34;$PATH:$HOME/.cargo/bin\u0026#34; fi Rust ツールチェーンのうち主なコマンドを以下に挙げる。\n   コマンド名 機能     rustup ツールチェーンの導入および更新   rustc コンパイラ本体   rustfmt ソースコードのフォーマット   cargo パッケージ管理   rls Rust Language Server    たとえば\n$ rustup update info: syncing channel updates for \u0026#39;stable-x86_64-unknown-linux-gnu\u0026#39; info: checking for self-updates stable-x86_64-unknown-linux-gnu unchanged - rustc 1.41.0 (5e1a79984 2020-01-27) info: cleaning up downloads \u0026amp; tmp directories てな感じにツールチェーンのアップデートも簡単にできる。\nリンカに注意 Rust ではリンカについては自前のものを持っていないようだ。 Ubuntu 等の Linux プラットフォームであれば GCC が標準で入っているため問題ないが， Windows の場合は Visual Studio 等の開発環境が必要になる。\nRust ではクロスコンパイルも可能だが，リンカはプラットフォーム毎に用意する必要があるため注意が必要である。 まぁ Docker 等を使えばいいんだろうけど。\nエディタ機能の拡張 Rust の Tools には各種エディタや IDE で使える拡張機能が紹介されている。 私は ATOM を使うので ide-rust を使えばいいようだ。 rls に対応してるぞ。\nみんな大好き Hello World 適当なディレクトリに hello.rs ファイルを作って，以下のコードを書く。\nfn main(){println!(\u0026#34;Hello, world!\u0026#34;);}これをコンパイル\u0026amp;実行する。\n$ rustc hello.rs $ ./hello Hello, world! よーし，うむうむ，よーし。\nCargo でプロジェクト・ベースの環境を作る cargo コマンドを使ってプロジェクト・ベースの環境の雛形を作ることができる。\n$ cargo new hello --vcs none Created binary (application) `hello` package このコマンドにより hello ディレクトリが作成され，以下のディレクトリ・ファイルが作成される。\n$ tree hello hello ├── Cargo.toml └── src └── main.rs src/main.rs の中身は先程の main() 関数と同じ内容である。 Cargo.toml の中身は以下の通り。\n[package] name = \u0026#34;hello\u0026#34; version = \u0026#34;0.1.0\u0026#34; authors = [\u0026#34;username \u0026lt;username@example.com\u0026gt;\u0026#34;] edition = \u0026#34;2018\u0026#34; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] どうも authors の項目は git のグローバル設定を読み取ってるらしい。\nちなみに，先程のコマンドの --vcs none オプションを外すと git のリポジトリとして構築される。 また GitHub に空のリポジトリを作ってローカルに clone し\n$ git clone https://github.com/spiegel-im-spiegel/rust-hello.git hello $ cargo init hello Created binary (application) package てな感じに初期化することもできる。\ncargo コマンドで作った環境下では cargo コマンド経由でビルドやデバッグなどができる。\nたとえば cargo run コマンドを使えば\n$ cd hello $ cargo run Compiling hello v0.1.0 (/home/username/rust/hello) Finished dev [unoptimized + debuginfo] target(s) in 0.32s Running `target/debug/hello` Hello, world! てな感じにコンパイル\u0026amp;実行が一気にできる。 リリース用のビルドは\n$ cargo build --release Compiling hello v0.1.0 (/home/username/rust/hello) Finished release [optimized] target(s) in 0.18s $ ./target/release/hello Hello, world! という感じ。\n外部関数インターフェイス Rust は外部関数インターフェイス（Foreign Function Interface；FFI）の仕組みを持っていて，他言語の関数を呼び出したり，逆に Rust の関数を他言語から呼び出したりすることができる。\n今回は詳細な説明は省いて medimatrix/rust-plus-golang リポジトリにあるサンプルコードを紹介するに留める。\n$ git clone https://github.com/medimatrix/rust-plus-golang.git $ tree rust-plus-golang/ rust-plus-golang/ ├── LICENSE ├── Makefile ├── README.md ├── lib │ ├── hello │ │ ├── Cargo.toml │ │ └── src │ │ └── lib.rs │ └── hello.h └── main.go lib/hello/Cargo.toml の中身はこんな感じ。\n[package] name = \u0026#34;hello\u0026#34; version = \u0026#34;0.1.0\u0026#34; [lib] crate-type = [\u0026#34;cdylib\u0026#34;] [dependencies] libc = \u0026#34;0.2.2\u0026#34; 更に lib/hello/src/lib.rs の中身はこんな感じ。\nexterncratelibc;usestd::ffi::CStr;#[no_mangle]pubextern\u0026#34;C\u0026#34;fn hello(name: *constlibc::c_char){letbuf_name=unsafe{CStr::from_ptr(name).to_bytes()};letstr_name=String::from_utf8(buf_name.to_vec()).unwrap();println!(\u0026#34;Hello {}!\u0026#34;,str_name);}この hello() 関数を呼び出す main.go の中身はこんな感じ。\npackage main /* #cgo LDFLAGS: -L./lib -lhello #include \u0026#34;./lib/hello.h\u0026#34; */ import \u0026#34;C\u0026#34; func main() { C.hello(C.CString(\u0026#34;John Smith\u0026#34;)) } ほんじゃあ，まぁ，ビルドしてみよっか。\n$ make cd lib/hello \u0026amp;\u0026amp; cargo build --release Updating crates.io index Downloaded libc v0.2.67 Compiling libc v0.2.67 Compiling hello v0.1.0 (/home/username/rust/rust-plus-golang/lib/hello) Finished release [optimized] target(s) in 27.05s cp lib/hello/target/release/libhello.so lib/ go build -ldflags=\u0026#34;-r /home/username/rust/rust-plus-golang/lib\u0026#34; main.go $ ./main Hello John Smith! よしよし。\n今回は C 言語のインタフェースを使って Go から Rust の関数を呼び出していたが，他にも Ruby や Python などとも連携可能らしい。\nブックマーク  Rustのクロスコンパイル（Linux, MacOSで作ったものをWindowsで動かす）｜IT会計キャリア Rustでクロスコンパイルしてみた | 思案試行  参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n   マジンガーZの「ルスト・ハリケーン」は “rust hurricane” という説があるらしい。しかも “rust” を「ラスト」と読むと “last” と勘違いするからわざと「ルスト」と読んでいるという説まであるそうな。まぁ，真実は命名者に聞かないと分からないが（笑） \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Rust 勉強会，面白かった！",
      "section": "remark",
      "description": "しばらくはマジで Rust の勉強をしようかなぁ，とか思ったり。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/02/hello-rust-world/",
      "published": "2020-02-24T12:58:44+00:00",
      "update": "2020-02-25T15:01:19+00:00",
      "content": "以前から気になっていた Rust の勉強会を松江でやるというので参加してきた。\n east-shimane.rs #0 - connpass  いやぁ，面白かった！ C/C++ のコードを Rust に置き換えようという動きがあるのは知っていたが，マジで「アリ」だわ，これ。 やはり時代は Rust か。\n実は今回，どうにかコンパイル環境のインストールまでは済ませたが事前学習が全くできなくて，初心者講座でイチから教えてもらうことにした。 以下に勉強会の内容を一部紹介する。\nRust の最大の特徴は GC (Garbage Collection) をランタイム・モジュール内に持たないことだろう。 かといって C/C++ のように自前で明示的に alloc/free するわけでもない。\nどうするのかというと， Rust にはインスタンスに対して「所有権（ownership）」や「ライフタイム（lifetime）」といった概念があり，野放図にインスタンスを参照することを防いでいる。 また変数は基本的に不変（immutable）な値として宣言され，可変（mutable）にしたいのであれば可変であることを明示して宣言する必要がある。 これらの仕組みによってコンパイラが alloc/free のタイミングを決めることができる（または決められない処理についてはコンパイル・エラーにできる）わけだ。\nGo の実装にも見られるように「GC ＝ 遅い」とは言えなくなりつつあるのだが，ランタイム・モジュールに GC を組み込まなくていいというのはそれだけで設計の自由度が上がる。 それこそ，その言語で OS を組もうかと考えたくなるほどに。\nコンパイル（VM 用の JIT コンパイルや他言語へのトランス・コンパイルではなく，いわゆる AOT コンパイル）言語の評価ポイントは，個人的には以下の2つと思っている1。\n その言語自身でコンパイラが書けるか その言語を使って OS が書けるか  たとえば Go は1番目は満たすが2番目は難しい。 メモリ管理や並列処理等についてランタイム・モジュールに強く依存しているからだ。 Rust は両方を満たす2。\n他にも enum と match 式を組み合わせたエラー・ハンドリングとか興味深いものが色々あった。 しばらくはマジで Rust の勉強をしようかなぁ，とか思ったり。\nブックマーク  The Rust Programming Language  The Rust Programming Language : 日本語版   Rust by Example : 日本語版 Rust Playground  参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n  実践Rust入門　[言語仕様から開発手法まで] κeen (著), 河野 達也 (著), 小松 礼人 (著) 技術評論社 2019-04-26 (Release 2019-04-26) Kindle版 B07QVQ7RDG (ASIN)  勉強会で薦められた本。「内容がすごく重い」とのこと。読んでないが，目次を見る限りは事例が豊富な感じ？\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n   オブジェクト指向がどうとか関数型がどうとかいうのはジオングの脚のような些末な話である。 \u0026#x21a9;\u0026#xfe0e;\n ただし Rust はリンカについては GCC 等の外部のツールチェーンに依存しているようだ。なのでクロス・コンパイルは（Go に比べると）少し面倒くさい。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "【セキュリティ・アップデート】 golang.org/x/crypto/ssh",
      "section": "release",
      "description": "モジュール管理している場合はバージョンに要注意。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/02/update-ssh-package/",
      "published": "2020-02-23T12:07:30+00:00",
      "update": "2020-02-24T00:34:44+00:00",
      "content": "golang.org/x/crypto/ssh パッケージについてアップデートのアナウンスがあった。\n [security] Vulnerability in golang.org/x/crypto/ssh - Google group  セキュリティ・アップデートを含んでいるので利用者は要注意である。\nAn attacker can craft an ssh-ed25519 or sk-ssh-ed25519@openssh.com public key, such that the library will panic when trying to verify a signature with it. Clients can deliver such a public key and signature to any golang.org/x/crypto/ssh server with a PublicKeyCallback, and servers can deliver them to any golang.org/x/crypto/ssh client. via Vulnerability in golang.org/x/crypto/ssh  CVE-2020-9283 未稿\ngo.mod に注意 他パッケージを go.md ファイルでモジュールとして管理している場合はバージョンに要注意。 とりあえず latest をセットして最新バージョンに差し替えればいいだろう。\nアップデートは計画的に。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "2020-02-23 のブックマーク",
      "section": "bookmarks",
      "description": "「Policy vs Technology」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2020/02/23-bookmarks/",
      "published": "2020-02-23T06:00:57+00:00",
      "update": "2020-02-26T02:20:43+00:00",
      "content": "リリース情報  0.65.0: Hugo Reloaded! | Hugo  Hugo 0.65.1: A couple of Bug Fixes | Hugo Hugo 0.65.2: A couple of Bug Fixes | Hugo Hugo 0.65.3: A couple of Bug Fixes | Hugo   LibreOffice 6.3.5 available for download - The Document Foundation Blog  セキュリティ＆プライバシー関連  500個ものChrome拡張機能が個人情報を盗んでいたことが判明、被害者は170万人を超える - GIGAZINE Voatz Internet Voting App Is Insecure - Schneier on Security Hacking McDonald\u0026rsquo;s for Free Food - Schneier on Security マイクロソフト、ウイルス対策の「Defender ATP」をiOSとAndroid向けに提供へ - ZDNet Japan 不正アクセス事案を受けたシステム保守委託先への損害賠償請求についてまとめてみた - piyolog Policy vs Technology - Schneier on Security  ブログ: 政策対テクノロジー   日本国内の組織を狙ったマルウエアLODEINFO - JPCERT/CC Eyes | JPCERTコーディネーションセンター公式ブログ ストーカーウェア「KidsGuard」を端末から駆除する方法 | TechCrunch Japan Not your Software not your Bitcoin - Combatnerd  天文関連  MIT Tech Review: 雪だるま形のカイパーベルト天体が明かす、惑星の起源 観測成果 - 直接撮像で迫る太陽系外巨大ガス惑星と褐色矮星の形成過程 - すばる望遠鏡 光害対策型の防犯灯・道路灯が、国内メーカー初「星空に優しい照明」の認証を取得 | プレスリリース | Panasonic Newsroom Japan ニュース - オリオン座に潜む赤ちゃん星たちのポートレート - アルマ望遠鏡  Linux または Ubuntu に関する話題  Ubuntu 18.04 その380 - Raspberry Piと既知の問題 - kledgeb Ubuntu 20.04 その11 - Ubuntu 20.04 LTSにおけるPython2の削除方針と対応方針 - kledgeb Ubuntu 20.04 その12 - Ruby 2.7への移行 - kledgeb  その他  Novel Coronavirus Infection in Hospitalized Infants Under 1 Year of Age in China | Global Health | JAMA | JAMA Network マイクロソフト、「Windows Terminal」機能確定版リリース。複数タブ、ペイン分割、プログラミング用フォントなどを含む、4月正式リリース予定 － Publickey MIT Tech Review: 新型手術支援ロボ、0.3ミリの血管吻合試験をクリア RFC 8700 - Fifty Years of RFCs Kubernetesを利用したクラウドネイティブな開発と運用とは何か？ これまでと何が違うのか？ サイバーエージェント青山氏が語る（前編） July Tech Festa 2019 － Publickey  Kubernetesを利用したクラウドネイティブな開発と運用とは何か？ これまでと何が違うのか？ サイバーエージェント青山氏が語る（後編） July Tech Festa 2019 － Publickey   CSS Variables - DEV Community 👩‍💻👨‍💻 Ubuntu Terminal in CSS - DEV Community 👩‍💻👨‍💻 GraphQL for beginners - DEV Community 👩‍💻👨‍💻 MIT Tech Review: 中国、新型コロナ対策で小中高生1億8000万人がネット授業に Add a GraphQL API to your Hugo site with AWS Amplify | AWS Mobile Blog Open Source Guides  Open Source Guidesの日本語版を公開しました - GitHubブログ GitHub、“Open Source Guides”の日本語訳を公開 ～OSSコミュニティのベストプラクティスを集約 - 窓の杜   2020年2月18日ニュース「導電性高分子、半導体と金属の境で熱電変換性能が最大に フレキシブルなIoT電源に道」 | SciencePortal 「アラビア石油」興亡の歴史の「誤解」を解く：岩瀬昇 | エネルギーの部屋 | 新潮社　Foresight(フォーサイト) | 会員制国際情報サイト GitHub Enterprise、BtoBスタートアップ向け支援プログラムで無料提供と発表。Microsoft for Startupsを通じて － Publickey NFCタグをWebアプリで読み書きできる「Web NFC」、Chrome 81ベータで実装開始 － Publickey 2020年2月20日ニュース「『クルーズ船の防止策不十分だった可能性』とCDC 『客室待機後も感染広がった』と国立感染研」 | SciencePortal Using Windows IoT, SignalR, Azure Custom Vision and Xamarin Forms to Flush a Toilet – DVLUP AWS Lambda、最新のRuby 2.7サポートを発表 － Publickey 元NSAとAmazonのエンジニアが「データのGitHub」を開発中 | TechCrunch Japan  "
    },
    {
      "title": "Web 3.0 は「絶滅」を回避できるか",
      "section": "remark",
      "description": "重要なのは「誰が『情報力』の制御を握るか」である。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/02/web-3_0/",
      "published": "2020-02-23T05:17:16+00:00",
      "update": "2020-02-23T05:19:02+00:00",
      "content": "最近，面白い記事を立て続けに見かけたので覚え書きとして記しておく。\n最初は yomoyomo さんの記事。\n Web 3.0がもたらす3つの革命 - YAMDAS現更新履歴  この記事によると Web 3.0 は以下のように特徴づけられるらしい。\n Web 3.0 is about re-decentralizing the Web.（Web 3.0 はウェブを再度脱中央集権化する） via Web 3.0がもたらす3つの革命 - YAMDAS現更新履歴  たとえば Bitcoin/Blockchain は当初「脱中央集権化」の象徴として注目されたが，現在は「チューリップの球根」程度の価値しかなく，決済手段としては ransomware の身代金くらいしか見かけなくなってしまった（偏見）。 G20 がこれらを（仮想通貨でも暗号通貨でもなく）「暗号資産」と呼んだのは慧眼だったというほかない（笑）\nBitcoin/Blockchain がここまで堕したのは，中核要素である PoW (Proof of Work) がネットを含む社会における階級化の制約条件（のひとつ）になっているからである。\n Not your Software not your Bitcoin - Combatnerd ブログ: 自分のソフトウェアではないなら、自分のビットコインではない  であるなら，重要なのは「誰が『情報力』の制御を握るか」である。 Bitcoin/Blockchain は PoW の問題を解決しない限り “re-decentralizing” の反対側に進み続けるだろう。\nもうひとつは Bruce Schneier さんの記事。\n Inrupt, Tim Berners-Lee\u0026rsquo;s Solid, and Me - Schneier on Security  Schneier 先生ってば最近はこんな仕事をされてるんだねぇ。\nおそらく，この Solid が最初に挙げた記事とこの記事とをリンクするキーワードなのだろう。\nThe idea behind Solid is both simple and extraordinarily powerful. Your data lives in a pod that is controlled by you. Data generated by your things \u0026ndash; your computer, your phone, your IoT whatever \u0026ndash; is written to your pod. You authorize granular access to that pod to whoever you want for whatever reason you want. Your data is no longer in a bazillion places on the Internet, controlled by you-have-no-idea-who. It\u0026rsquo;s yours. If you want your insurance company to have access to your fitness data, you grant it through your pod. If you want your friends to have access to your vacation photos, you grant it through your pod. If you want your thermostat to share data with your air conditioner, you give both of them access through your pod. via Inrupt, Tim Berners-Lee\u0026#39;s Solid, and Me  ただ，一方で\nIt\u0026rsquo;s also a little surreal working on a project conceived and spearheaded by Tim Berners-Lee. But at this point, I feel that I should only work on things that matter to society. So here I am. via Inrupt, Tim Berners-Lee\u0026#39;s Solid, and Me  とも書かれており， Solid プロジェクトそのものよりも「情報および情報力の制御を『個人』に回帰させる」ための研究や開発を促していくことが，今は重要なんだと思わせる。\nWeb 3.0 で VRM (Vendor Relationship Management; 企業関係管理) の夢よ，もう一度。 とかなれば面白いんだろうけど，もうしばらく様子を見てみますかね。\nブックマーク   元NSAとAmazonのエンジニアが「データのGitHub」を開発中 | TechCrunch Japan\n  搾取と狂狷\n  参考図書  もうすぐ絶滅するという開かれたウェブについて 続・情報共有の未来 yomoyomo (著) 達人出版会 2017-12-25 (Release 2019-03-02) デジタル書籍 infoshare2 (tatsu-zine.com) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  WirelessWire News 連載の書籍化。感想はこちら\nreviewed by Spiegel on 2018-12-31\n  インテンション・エコノミー～顧客が支配する経済 Doc Searls (著), 栗原潔 (翻訳) 翔泳社 2013-03-14 (Release 2013-06-20) Kindle版 B00DIM6BE6 (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  時代はソーシャル CRM から VRM へ。俺達がインターネットだ！ 感想文はこちら。\nreviewed by Spiegel on 2015-04-26 (powered by PA-APIv5)\n  グリゴリの捕縛 白田 秀彰  2001-11-26 (Release 2014-09-17) 青空文庫 4307 (図書カードNo.) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  白田秀彰さんの「グリゴリの捕縛」が青空文庫に収録されていた。 内容は 怪獣大決戦 おっと憲法（基本法）についてのお話。 古代社会 → 中世社会 → 近代社会 → 現代社会 と順を追って法と慣習そして力（power）との関係について解説し，その中で憲法（基本法）がどのように望まれ実装されていったか指摘してる。 その後，現代社会の次のパラダイムに顕現する「情報力」と社会との関係に言及していくわけだ。\nreviewed by Spiegel on 2019-03-30 (powered by aozorahack)\n "
    }
  ]
}
