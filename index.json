{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "エラー・ハンドリングのキホン",
      "section": "rust-lang",
      "description": "やっぱ例外処理は要らんよね（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/error-handling/",
      "published": "2020-04-06T12:11:43+00:00",
      "update": "2020-04-06T12:12:43+00:00",
      "content": "今日の起点となるコードはこれにしよう。\nfn parse_string(s: \u0026amp;str)-\u0026gt; Result\u0026lt;u32,std::num::ParseIntError\u0026gt;{s.parse::\u0026lt;u32\u0026gt;()}fn main(){println!(\u0026#34;{:?}\u0026#34;,parse_string(\u0026#34;-1\u0026#34;));//Output: Err(ParseIntError { kind: InvalidDigit }) }parse_string() 関数の返り値の型 Result は列挙型（enum）で，以下の2つの列挙子（variant）で構成されている。\nenum Result\u0026lt;T,E\u0026gt;{Ok(T),Err(E),}Result 型の評価には match 式が使える。 たとえば parse() に失敗した際に 0 をセットしたいなら\nfn main(){letn=matchparse_string(\u0026#34;-1\u0026#34;){Ok(x)=\u0026gt;x,Err(_)=\u0026gt;0,};println!(\u0026#34;{}\u0026#34;,n);//Output: 0 }などと書くことができる。\nResult 型を使ったエラー・ハンドリング Result 型を使うことで基本的なエラー・ハンドリングが可能になる。 以降で例を挙げていこう。\nPanic を投げる parse_string() 関数が Err を返した場合に強制終了したいのであれば\nfn main(){letn=matchparse_string(\u0026#34;-1\u0026#34;){Ok(x)=\u0026gt;x,Err(e)=\u0026gt;panic!(e),//Output: thread \u0026#39;main\u0026#39; panicked at \u0026#39;Box\u0026lt;Any\u0026gt;\u0026#39;, src/main.rs:8:19 };println!(\u0026#34;{}\u0026#34;,n);//do not reach }と panic! マクロで panic を投げればよい。 ちなみに，環境変数 RUST_BACKTRACE に 1 をセットすると panic 時にスタックトレース情報も吐く。\n単に panic を投げればいいのであれば Result::unwrap() メソッドを使えば上述のコードとほぼ同じ結果が得られる。\nfn main(){letn=parse_string(\u0026#34;-1\u0026#34;).unwrap();//Output: thread \u0026#39;main\u0026#39; panicked at \u0026#39;called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }\u0026#39;, src/main.rs:6:13 println!(\u0026#34;{}\u0026#34;,n);//do not reach }Panic を投げる際のメッセージを指定するには Result::expect() メソッドを使う。\nfn main(){letn=parse_string(\u0026#34;-1\u0026#34;).expect(\u0026#34;error in parse_string() function\u0026#34;);//Output: thread \u0026#39;main\u0026#39; panicked at \u0026#39;error in parse_string() function: ParseIntError { kind: InvalidDigit }\u0026#39;, src/main.rs:6:13 println!(\u0026#34;{}\u0026#34;,n);//do not reach }Panic 以外のハンドリング エラー時に単に panic を投げるのではなく，何らかの処理を行って普通にプロセスを終了したいのであれば Result::unwrap_or_else() メソッドを使って\nfn main(){letn=parse_string(\u0026#34;-1\u0026#34;).unwrap_or_else(|e|{println!(\u0026#34;Error in parse_string() function: {:?}\u0026#34;,e);//Output: Error in parse_string() function: ParseIntError { kind: InvalidDigit } std::process::exit(1);});println!(\u0026#34;{}\u0026#34;,n);//do not reach }などとすることもできる。 プロセスを終了するのではなく，最初の例のように解析失敗時に 0 をセットしたいなら\nfn main(){letn=parse_string(\u0026#34;-1\u0026#34;).unwrap_or_else(|_|0);println!(\u0026#34;{}\u0026#34;,n);//Output: 0 }てな感じにも書ける。 あるいはもっと簡単に Result::unwrap_or() メソッドを使って\nfn main(){letn=parse_string(\u0026#34;-1\u0026#34;).unwrap_or(0);println!(\u0026#34;{}\u0026#34;,n);//Output: 0 }とも書ける。\nエラーの委譲 次に以下の関数を考える。\nfn parse_pair_strings(s1: \u0026amp;str,s2: \u0026amp;str)-\u0026gt; Result\u0026lt;(u32,u32),std::num::ParseIntError\u0026gt;{letx=matchs1.parse::\u0026lt;u32\u0026gt;(){Ok(n)=\u0026gt;n,Err(e)=\u0026gt;returnErr(e),};lety=matchs2.parse::\u0026lt;u32\u0026gt;(){Ok(n)=\u0026gt;n,Err(e)=\u0026gt;returnErr(e),};Ok((x,y))}parse_pair_strings() の仮引数 s1, および s2 に対してそれぞれ parse() を行うのだが，結果がエラーの際には， Err をそのまま返して関数元にハンドリングを委譲している。 この関数の実行結果はこんな感じ。\nfn main(){println!(\u0026#34;{:?}\u0026#34;,parse_pair_strings(\u0026#34;1\u0026#34;,\u0026#34;-1\u0026#34;));//Output: Err(ParseIntError { kind: InvalidDigit }) }関数の返り値が Result 型なら， ? 演算子を使って，エラーの委譲をもっと簡単に書くことができる。 こんな感じ。\nfn parse_pair_strings(s1: \u0026amp;str,s2: \u0026amp;str)-\u0026gt; Result\u0026lt;(u32,u32),std::num::ParseIntError\u0026gt;{Ok((s1.parse::\u0026lt;u32\u0026gt;()?,s2.parse::\u0026lt;u32\u0026gt;()?))}エラーの汎化 今度は，引数に文字列を渡すのではなく，標準入力から文字列を取得して parse() してみよう。\nfn parse_from_stdin()-\u0026gt; Result\u0026lt;u32,std::num::ParseIntError\u0026gt;{letmutbuf=String::new();std::io::stdin().read_line(\u0026amp;mutbuf)?;//Compile error: `?` couldn\u0026#39;t convert the error to `std::num::ParseIntError` buf.trim().parse::\u0026lt;u32\u0026gt;()}当然ながらこれはコンパイルエラーになる。 read_line() 関数がエラーの際に吐く型は std::io::Error なので std::num::ParseIntError 型とはマッチしないためだ。\n解決するには，これらの型の汎化である std::error::Error 型を使えばよい。\n 標準ライブラリで定義される各種エラー型はどれも std::error::Error 型からの特化である。\nstd::error::Error 型を使う際は Box\u0026lt;dyn Trait\u0026gt; を使うようだ。 こんな感じ。\nfn parse_from_stdin()-\u0026gt; Result\u0026lt;u32,Box\u0026lt;dynstd::error::Error\u0026gt;\u0026gt;{letmutbuf=String::new();std::io::stdin().read_line(\u0026amp;mutbuf)?;letn=buf.trim().parse::\u0026lt;u32\u0026gt;()?;Ok(n)}fn main(){println!(\u0026#34;{:?}\u0026#34;,parse_from_stdin());}実行するとこんな感じになる。\n$ echo -1 | cargo run Err(ParseIntError { kind: InvalidDigit }) main() 関数側でもう少し細かくエラーを見てみよう。 こんな感じかなぁ。\nfn main(){letn=matchparse_from_stdin(){Ok(x)=\u0026gt;x,Err(err)=\u0026gt;{matcherr.downcast_ref::\u0026lt;std::io::Error\u0026gt;(){Some(e)=\u0026gt;{println!(\u0026#34;io::Error in parse_from_stdin(): {}\u0026#34;,e);std::process::exit(1);}_=\u0026gt;(),};matcherr.downcast_ref::\u0026lt;std::num::ParseIntError\u0026gt;(){Some(e)=\u0026gt;{println!(\u0026#34;ParseIntError in parse_from_stdin(): {}\u0026#34;,e);std::process::exit(1);}_=\u0026gt;(),};println!(\u0026#34;Other error in parse_from_stdin(): {}\u0026#34;,err);std::process::exit(1);}};println!(\u0026#34;{}\u0026#34;,n);}実行するとこんな感じになる。\n$ echo -1 | cargo run ParseIntError in parse_from_stdin(): invalid digit found in string Option 型を使ったエラー・ハンドリング 上述のコードにある downcast_ref() メソッドは Option 型の値を返す。 Option 型も列挙型（enum）で，以下の2つの列挙子（variant）で構成されている。\nenum Option\u0026lt;T\u0026gt;{Some(T),None,}None はいわゆる Null 値，つまり値がないことを示す。 関数の実行結果が Null 値を取り得る場合に Option 型を返すことで，呼び出し元に Null 値のハンドリングを促すことができる。\n起点のコードはこんな感じでどうだろうか。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;foriin0..4{println!(\u0026#34;{}: {:?}\u0026#34;,i,nihongo.chars().nth(i));}}実行するとこんな感じになる。\n$ cargo run 0: Some(\u0026#39;日\u0026#39;) 1: Some(\u0026#39;本\u0026#39;) 2: Some(\u0026#39;語\u0026#39;) 3: None Panic を投げる 結果が None なら panic を投げるようにしてみる。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;foriin0..4{letch=matchnihongo.chars().nth(i){Some(c)=\u0026gt;c,None=\u0026gt;panic!(\u0026#34;Out of bounds\u0026#34;),};println!(\u0026#34;{}: {}\u0026#34;,i,ch)}}実行するとこんな感じ。\n$ cargo run 0: 日 1: 本 2: 語 thread \u0026#39;main\u0026#39; panicked at \u0026#39;Out of bounds\u0026#39;, src/main.rs:6:21 また Option 型にも unwrap() や expect() といったメソッドがあり， None が返ったら panic を投げる。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;foriin0..4{println!(\u0026#34;{}: {}\u0026#34;,i,nihongo.chars().nth(i).expect(\u0026#34;Out of bounds\u0026#34;));}}$ cargo run 0: 日 1: 本 2: 語 thread \u0026#39;main\u0026#39; panicked at \u0026#39;Out of bounds\u0026#39;, src/main.rs:4:31 Panic 以外のハンドリング たとえば，こんな感じかな。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;foriin0..4{letch=matchnihongo.chars().nth(i){Some(c)=\u0026gt;c,None=\u0026gt;break,};println!(\u0026#34;{}: {}\u0026#34;,i,ch)}}$ cargo run 0: 日 1: 本 2: 語 まぁイテレータやコレクションでこんな書き方する人はおらんじゃろうけど。 あンまりいい例示じゃなくてすまん。\nやっぱ例外処理は要らんよね Rust の列挙型は（C/C++ や Java などと異なり）型の列挙を行い，パターン・マッチングによって処理を振り分ける。 この仕組みを上手く使ってエラー・ハンドリングを行っているわけだ。\nこうやってみると，やっぱ例外処理は要らんよね（笑）\nブックマーク  Rustのエラーハンドリングの基本 - hideoka’s blog Rustで複数のimpl Traitを返す - Qiita  参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n  プログラミングRust Jim Blandy (著), Jason Orendorff (著), 中田 秀基 (翻訳) オライリージャパン 2018-08-10 単行本（ソフトカバー） 4873118557 (ASIN), 9784873118550 (EAN), 4873118557 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版あり。公式ドキュメントよりも系統的に書かれているので痒いところに手が届く感じ。ただし量が多いので，一度斜め読みしたらあとは傍らに置いて必要に応じてつまみ食いしていくのがいいだろう。\nreviewed by Spiegel on 2020-03-08 (powered by PA-APIv5)\n "
    },
    {
      "title": "2020-04-05 のブックマーク",
      "section": "bookmarks",
      "description": "「Zoom の脆弱性対策について」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2020/04/05-bookmarks/",
      "published": "2020-04-05T04:38:24+00:00",
      "update": "2020-04-05T04:39:50+00:00",
      "content": "リリース情報  Minify config and more! | Hugo  Hugo 0.68.1: 1 bug fix | Hugo Hugo 0.68.2: A couple of Bug Fixes | Hugo Hugo 0.68.3: A couple of Bug Fixes | Hugo   LibreOffice 6.4.2 available for download - The Document Foundation Blog  セキュリティ＆プライバシー関連  Facial Recognition for People Wearing Masks - Schneier on Security 差し込むとマルウェア感染するUSBデバイスが届いた事例についてまとめてみた - piyolog Privacy vs. Surveillance in the Age of COVID-19 - Schneier on Security Phishing Alert: GitHub Website Spoofing | Perception Point IEの脆弱性 (CVE-2020-0674) とFirefoxの脆弱性 (CVE-2019-17026) を悪用する攻撃 - JPCERT/CC Eyes | JPCERTコーディネーションセンター公式ブログ Marriott Was Hacked \u0026ndash; Again - Schneier on Security Zoom の脆弱性対策について：IPA 独立行政法人 情報処理推進機構  Security and Privacy Implications of Zoom - Schneier on Security Zoom爆撃と予防策についてまとめてみた - piyolog 問題が相次いで発覚した「Zoom」でヴィデオ会議を開く際に、まずユーザーが考えるべきこと｜WIRED.jp    天文関連  星形成プロジェクト：近傍星形成領域の電波地図作り ニュース - 連星系で作られる惑星の軌道の謎に迫る - アルマ望遠鏡 「ハッブル宇宙望遠鏡」運用30周年記念プラモセットが登場 - sorae 宇宙へのポータルサイト  知財関連  DMCA削除通知によりオープンソースソフトウェアのKodiがGoogle検索から排除される | P2Pとかその辺のお話R  Linux または Ubuntu に関する話題  Ubuntu 20.04 その19 - Raspberry Piのサポート改善・Canonicalの新しい取り組み - kledgeb  その他  専門家会議の「クラスター対策」の解説　――新型コロナウイルスに対処する最後の希望｜吉峯 耕平｜note Mozilla、「Firefox 74」のTLS 1.0/1.1廃止を一時撤回 ～新型コロナウイルスの影響で - 窓の杜 アトラシアン、JiraやConfluenceなど期限なく無料提供開始。10名以下のチームに － Publickey GitHub - remeh/diago: Diago is a visualization tool for CPU profiles and heap snapshots generated with pprof. さくらのレンタルサーバ／マネージドサーバ PHP7.4提供開始 | さくらインターネット Section一覧について。 - 日本語 - HUGO コロナ危機でネタニヤフが延命　イスラエルで挙国一致内閣が成立の見通し：池内恵 | 池内恵の中東通信 | 新潮社　Foresight(フォーサイト) | 会員制国際情報サイト Dr. Lucie Guibault on What Scientists Should Know About Open Access - Creative Commons Hugo.386 | Hugo Themes ブンゴウサーチ by ブンゴウメール | 青空文庫の作品を読了時間で検索できるサービス How Google Ruined the Internet — Superhighway 98  ブログ: Googleは如何にインターネットを台無しにしたか   Visual Studio Codeの代替を狙う統合開発環境「Eclipse Theia 1.0」リリース。VS Codeの拡張機能を利用可能、デスクトップ版とWebブラウザ版に両対応 － Publickey AWS Systems Manager経由でssh不使用のOSリモートアクセスを試す - Qiita  "
    },
    {
      "title": "「はめふら」観るために Hulu 解約してしまった...",
      "section": "remark",
      "description": "この機会に Hulu から Netflix に乗り換えることにした。 両方課金し続ける財力はないからね。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/04/netflix/",
      "published": "2020-04-05T03:19:05+00:00",
      "update": "2020-04-05T03:19:44+00:00",
      "content": "いやー。 ついに始まりましたねぇ。\n TVアニメ『乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった…』公式サイト  ちなみに私の推しはメイドのアンです。\n公式サイトによると Netflix か d アニメストアならタイムラグなしで見れるらしい。 まぁ d アニメストアでの課金は論外だが Prime Video なら週遅れで見れるのかな？ Hulu では見れないっぽい。\n私は以前から Hulu を利用してたんだけど，なんか見れないアニメ番組が増えてきたんだよねぇ。 配信終了してしまったコンテンツも多いし。 これはそろそろ潮時かなぁ。\nちうわけで，この機会に Hulu から Netflix に乗り換えることにした。 両方課金し続ける財力はないからね（苦笑）\n 乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった… | Netflix  よーし，うむうむ，よーし。\nまぁ，週遅れの配信とかバカげてるよねぇ。 テレビ放送こそ週遅れでいいぢゃん（笑）\n参考図書  乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった…: 1 (一迅社文庫アイリス) 山口 悟 (著), ひだか なみ (イラスト) 一迅社 2015-08-20 (Release 2015-09-11) Kindle版 B014VZ4FLE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  今やテンプレな乙女ゲーム転生ものでコメディ寄りのラブコメ。つか，読んでて吹き出してしまった（笑）\nreviewed by Spiegel on 2020-04-05 (powered by PA-APIv5)\n  乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった…: 1【イラスト特典付】 (ZERO-SUMコミックス) ひだか なみ (著), 山口 悟 (著) 一迅社 2018-03-24 (Release 2018-03-24) Kindle版 B07BKT4RX5 (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  書籍版の絵師さんによるコミカライズ。流石に原作にマッチしていて面白い！\nreviewed by Spiegel on 2020-04-05 (powered by PA-APIv5)\n "
    },
    {
      "title": "天下無敵のプー太郎",
      "section": "remark",
      "description": "次の仕事が得られるまでどのくらい時間がかかるか分からないが，あり余る時間を趣味に没頭していく所存である。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/04/i-am-a-neet/",
      "published": "2020-04-01T12:59:18+00:00",
      "update": "2020-04-01T22:55:17+00:00",
      "content": "悪夢の4月1日 (エイプリルフール) を今年も無事やり過ごせたようなので，通常運転を再開しよう。\nWHO の situation report を見る限り，世界レベルではようやく峠を超えた感じだけど日本は今が正念場だよね（まぁ第3第4のピークが来ないとも限らないが）。\n私個人は3月いっぱいで目出度く職場をクビになったので，しばらく NEET (Not in Employment, Education or Training) でもしようかなぁ，という感じ。 せっかく自粛ムードだし，私は「人に会わない」ことに全くストレスを感じないので（むしろ実家で家族と顔をつきあわせる生活を1年以上続けられている自分を褒めたい），不謹慎ながら今の状況は大歓迎である。\n“The trade-offs are changing” SARS 2 関連について思うところは沢山あるし愚痴を書いたらキリがないが1，今回は以下の記事を紹介するに留める。\n EFF and COVID-19: Protecting Openness, Security, and Civil Liberties | Electronic Frontier Foundation As Coronavirus Surveillance Escalates, Personal Privacy Plummets - The New York Times Privacy vs. Surveillance in the Age of COVID-19 - Schneier on Security  例によって Bruce Schneier 先生の要約記事が分かりやすいので，そちらを参考にするが EFF の\nWe must be sure that measures taken in the name of responding to COVID-19 are, in the language of international human rights law, “necessary and proportionate” to the needs of society in fighting the virus. Above all, we must make sure that these measures end and that the data collected for these purposes is not re-purposed for either governmental or commercial ends. via Protecting Openness, Security, and Civil Liberties  という一文には激しく同意するものである。 ついでに以下の tweet も挙げておくか。\nかつてThe Economistは、「テロ対策と称して国家統制を許し、自由を捨てるな。テロで人が死ぬ。それがどうした」と言い放つ強さを持っていたけれど、いまコロナを前にして「国家統制を認めて自由を捨てるな。コロナで人が死ぬ。それがどうした」と言うだけの勇気はないらしい。でもそう言うべきだ。\n\u0026mdash; Hiroo Yamagata (@hiyori13) March 20, 2020  現代の人々にとって「健康」とは呪 (のろ) いのようなものかもしれない。\nリスク評価には「科学的リスク」と「政治的リスク」がある。 「政治的リスク」で重要なのは「その後」についてきちんと目配せできているかどうかである。 いくら危機的状況であっても「その後」に配慮しないその場しのぎの政策執行は悪手だ。\n リスクは事前と事後をセットで考える  そういう観点で是非とも議論していただきたいものである。 まぁ，私は（そういうのに巻き込まれたくないので）今年も政治的無関心を貫くけどね。 政治がどうこう言うような精神的余裕はない。\nそろそろ本格的に\u0026hellip; せっかく時間があり余ってるので，色々遊んでみたい。 プログラミング関連では\n Go Rust Haskell  の優先順位で 勉強 もとい遊んでみようかな，と。\nGo と Rust は同じ制御系言語なのに思想が真逆で実に面白い。\nGo は典型的な手続き型言語で並列処理やメモリ管理を隠蔽することでシンプルな記述を可能にしている。 Rust は並列処理やメモリ管理については剥き出しだが，その分（標準ライブラリを含めて）豊かな語彙を持っている。\nあと Rust を勉強し始めて痛感したが，やっぱ関数型プログラミング言語についてきちんと学ばないとダメだわ。 そういう意味で Haskell をもう一度勉強し直そうかと思っている。\n次の仕事が得られるまでどのくらい時間がかかるか分からないが，あり余る時間を趣味に没頭していく所存である（笑）\nブックマーク  クーリエ連載；エコノミスト紹介、自由のためなら人が死んでもいい（この中で紹介されている「自由の本当のコスト」の原文） 専門家会議の「クラスター対策」の解説　――新型コロナウイルスに対処する最後の希望｜吉峯 耕平｜note ある医師がエンジニアに寄せた“コロナにまつわる現場の本音” (1/10) - EE Times Japan    詳しくは Facebook の私の記述を参考にどうぞ。「友人」以外は読めないようにしてるけど（笑） \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "CommonMark と Hugo 0.68",
      "section": "remark",
      "description": "てっきり yuin/goldmark パーサのバグだと思っていたのだが，どうやら CommonMark の仕様らしい。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/03/commonmark-and-hugo/",
      "published": "2020-03-29T06:04:41+00:00",
      "update": "2020-03-29T09:05:07+00:00",
      "content": "先日 Hugo 0.68.x がリリースされたのだが\n Minify config and more! | Hugo Hugo 0.68.1: 1 bug fix | Hugo Hugo 0.68.2: A couple of Bug Fixes | Hugo Hugo 0.68.3: A couple of Bug Fixes | Hugo  どうもまた markdown 周りの挙動が変わったようだ。 例えば\n[string] を [][rune] に変換する。 [string]: http://golang.org/ref/spec#String_types [rune]: http://blog.golang.org/strings \u0026#34;Strings, bytes, runes and characters in Go - The Go Blog\u0026#34; をレンダリングすると\n\u0026lt;a href=\u0026#34;http://golang.org/ref/spec#String_types\u0026#34;\u0026gt;string\u0026lt;/a\u0026gt; を \u0026lt;a href=\u0026#34;http://blog.golang.org/strings\u0026#34; title=\u0026#34;Strings, bytes, runes and characters in Go - The Go Blog\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; に変換する。   string を  に変換する。  てな感じに [] 記述がまるっと抜け落ちて \u0026lt;a\u0026gt; 要素の中身も空になってしまう。 てっきり yuin/goldmark パーサのバグだと思っていたのだが，どうやらこれは CommonMark の仕様のようだ。\n具体的には\n[foo][bar] [bar]: http://bar と記述すると\n\u0026lt;a href=\u0026#34;http://bar\u0026#34;\u0026gt;foo\u0026lt;/a\u0026gt; のように [bar] で生成される \u0026lt;a\u0026gt; 要素の中身を foo に置き換えるらしい。 じゃあ今までがバグだったってこと？\nこれを回避するには\n\\[foo][bar]  [bar]: http://bar とエスケープすれば\n[foo]\u0026lt;a href=\u0026#34;http://bar\u0026#34;\u0026gt;bar\u0026lt;/a\u0026gt;   [foo]bar  と意図通りにレンダリングしてくれる。 なので最初の記述も\n[string] を \\[][rune] に変換する。  [string]: http://golang.org/ref/spec#String_types [rune]: http://blog.golang.org/strings \u0026#34;Strings, bytes, runes and characters in Go - The Go Blog\u0026#34; とすれば\n\u0026lt;a href=\u0026#34;http://golang.org/ref/spec#String_types\u0026#34;\u0026gt;string\u0026lt;/a\u0026gt; を []\u0026lt;a href=\u0026#34;http://blog.golang.org/strings\u0026#34; title=\u0026#34;Strings, bytes, runes and characters in Go - The Go Blog\u0026#34;\u0026gt;rune\u0026lt;/a\u0026gt; に変換する。   string を []rune に変換する。  とできた。\n私のブログでは影響が出たのが（結果的には）一箇所のみだったので直すのは簡単だったが，特に Go 言語では [] はスライスを意味する記述なので，今後は気をつけないとなぁ。 まぁ \u0026lt;code\u0026gt; 要素（`...`）で囲むのが無難か。\n改めて CommonMark の仕様を眺めてみたが，不可思議な記述が沢山ある。 たとえば\n[bar][] [bar]: http://bar と書くと\n\u0026lt;a href=\u0026#34;http://bar\u0026#34;\u0026gt;bar\u0026lt;/a\u0026gt; てな感じに，これまた [] が吸い込まれる。 しかも\n[bar][foo] [bar]: http://bar とすると，今度は \u0026lt;a\u0026gt; 要素が外れてただの\n[bar][foo] となる。 なんだよそれ orz\n雑すぎんだろ！ 一度ちゃんと文法を整理したほうがいいんじゃないのか？\n"
    },
    {
      "title": "Writers パッケージを作ってみた",
      "section": "golang",
      "description": "言語的に面白いトピックはないし，手遊びということで。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/writers-package/",
      "published": "2020-03-28T11:40:05+00:00",
      "update": "2020-03-29T03:01:38+00:00",
      "content": "Twitter で\nできればLogレベルでファイル分割したいところですが、Goの情報はなかなか見つからなかった...。\nTrace/Debug/Info/Warning\nError/Fatal\nとかいう好きな単位でログファイルを切り替えられれば、別ツイのtail -f時のノイズ削減になりそう。https://t.co/MTyoOqyvgQ\n(分割について記載なすび)\n\u0026mdash; SIG (@sig_246) March 26, 2020  というのを見かけたので，試しに作ってみた。\n spiegel-im-spiegel/writers: Filtering Writer  いや tee および grep コマンドを組み合わせれば出力の分割はできるんだけどね1。 まぁ，言語的に面白いトピックはないし，手遊びということで。\nたとえば，拙作の logf パッケージを使ってこんなログ出力を考えてみる。\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/logf\u0026#34; ) func main() { logf.SetOutput(os.Stdout) for i := 0; i \u0026lt; 6; i++ { logf.SetMinLevel(logf.TRACE + logf.Level(i)) logf.Tracef(\u0026#34;Traceing: No. %d\\n\u0026#34;, i+1) logf.Debugf(\u0026#34;Debugging: No. %d\\n\u0026#34;, i+1) logf.Printf(\u0026#34;Information: No. %d\\n\u0026#34;, i+1) logf.Warnf(\u0026#34;Warning: No. %d\\n\u0026#34;, i+1) logf.Errorf(\u0026#34;Erroring: No. %d\\n\u0026#34;, i+1) logf.Fatalf(\u0026#34;Fatal Erroring: No. %d\\n\u0026#34;, i+1) } } これを実行すると，こんな感じになる。\n$ go run sample.go 2020/03/28 14:44:44 [TRACE] Traceing: No. 1 2020/03/28 14:44:44 [DEBUG] Debugging: No. 1 2020/03/28 14:44:44 [INFO] Information: No. 1 2020/03/28 14:44:44 [WARN] Warning: No. 1 2020/03/28 14:44:44 [ERROR] Erroring: No. 1 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 1 2020/03/28 14:44:44 [DEBUG] Debugging: No. 2 2020/03/28 14:44:44 [INFO] Information: No. 2 2020/03/28 14:44:44 [WARN] Warning: No. 2 2020/03/28 14:44:44 [ERROR] Erroring: No. 2 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 2 2020/03/28 14:44:44 [INFO] Information: No. 3 2020/03/28 14:44:44 [WARN] Warning: No. 3 2020/03/28 14:44:44 [ERROR] Erroring: No. 3 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 3 2020/03/28 14:44:44 [WARN] Warning: No. 4 2020/03/28 14:44:44 [ERROR] Erroring: No. 4 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 4 2020/03/28 14:44:44 [ERROR] Erroring: No. 5 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 5 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 6 これを出発点とする。\n出力を多重化するには io.MultiWriter() 関数を使うとよい。 こんな感じ。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34;  \u0026#34;os\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/logf\u0026#34; ) func main() { file, err := os.Create(\u0026#34;log.txt\u0026#34;) if err != nil { fmt.Printf(\u0026#34;%#v\\n\u0026#34;, err) return } defer file.Close() ws := io.MultiWriter( file, os.Stdout, )  logf.SetOutput(ws) for i := 0; i \u0026lt; 6; i++ { logf.SetMinLevel(logf.TRACE + logf.Level(i)) logf.Tracef(\u0026#34;Traceing: No. %d\\n\u0026#34;, i+1) logf.Debugf(\u0026#34;Debugging: No. %d\\n\u0026#34;, i+1) logf.Printf(\u0026#34;Information: No. %d\\n\u0026#34;, i+1) logf.Warnf(\u0026#34;Warning: No. %d\\n\u0026#34;, i+1) logf.Errorf(\u0026#34;Erroring: No. %d\\n\u0026#34;, i+1) logf.Fatalf(\u0026#34;Fatal Erroring: No. %d\\n\u0026#34;, i+1) } } これで標準出力と log.txt ファイルに全く同じ内容が出力される。\n次に，標準出力には [ERROR] と [FATAL] のログのみ出力したい。 そこでこんな型を考える。\npackage writers //FilterWriter type is Writer with filter type FilterWriter struct { word []byte writer io.Writer } この型に対して以下の Write() メソッド\n//Write function writes bytes data. func (w *FilterWriter) Write(b []byte) (int, error) { if w.match(b) { return w.writer.Write(b) } return len(b), nil } func (w *FilterWriter) match(b []byte) bool { if len(b) == 0 { return false } if w.word == nil { return true } return bytes.Contains(b, w.word) } を組み込めば，設定したキーワードを含んでいる場合のみ書き込みを行うようになる。\nwriters.FilterWriter を使って先程のコードを書き換えてみよう。 こんな感じ。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/logf\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/writers\u0026#34; ) func main() { file, err := os.Create(\u0026#34;log.txt\u0026#34;) if err != nil { fmt.Printf(\u0026#34;%#v\\n\u0026#34;, err) return } defer file.Close() ws := io.MultiWriter( file, writers.Filter(os.Stdout, []byte(\u0026#34;[ERROR]\u0026#34;)), writers.Filter(os.Stdout, []byte(\u0026#34;[FATAL]\u0026#34;)), )  logf.SetOutput(ws) for i := 0; i \u0026lt; 6; i++ { logf.SetMinLevel(logf.TRACE + logf.Level(i)) logf.Tracef(\u0026#34;Traceing: No. %d\\n\u0026#34;, i+1) logf.Debugf(\u0026#34;Debugging: No. %d\\n\u0026#34;, i+1) logf.Printf(\u0026#34;Information: No. %d\\n\u0026#34;, i+1) logf.Warnf(\u0026#34;Warning: No. %d\\n\u0026#34;, i+1) logf.Errorf(\u0026#34;Erroring: No. %d\\n\u0026#34;, i+1) logf.Fatalf(\u0026#34;Fatal Erroring: No. %d\\n\u0026#34;, i+1) } } これで標準出力が\n$ go run sample.go 2020/03/28 14:44:44 [ERROR] Erroring: No. 1 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 1 2020/03/28 14:44:44 [ERROR] Erroring: No. 2 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 2 2020/03/28 14:44:44 [ERROR] Erroring: No. 3 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 3 2020/03/28 14:44:44 [ERROR] Erroring: No. 4 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 4 2020/03/28 14:44:44 [ERROR] Erroring: No. 5 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 5 2020/03/28 14:44:44 [FATAL] Fatal Erroring: No. 6 となった。\n単純な比較のみだと複雑なパターンを構成し辛いので，正規表現バージョンも作ってみた。\n//RegexpWriter type is Writer with regular expression filter type RegexpWriter struct { re *regexp.Regexp writer io.Writer } //WriteString function writes string. func (w *RegexpWriter) Write(b []byte) (int, error) { if w.match(b) { return w.writer.Write(b) } return len(b), nil } func (w *RegexpWriter) match(b []byte) bool { if len(b) == 0 { return false } if w.re == nil { return true } return w.re.Match(b) } これを使えば，先程のコードはこんな感じにできる。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;regexp\u0026#34;  \u0026#34;github.com/spiegel-im-spiegel/logf\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/writers\u0026#34; ) func main() { file, err := os.Create(\u0026#34;log.txt\u0026#34;) if err != nil { fmt.Printf(\u0026#34;%#v\\n\u0026#34;, err) return } defer file.Close() ws := io.MultiWriter( file, writers.FilterRegexp(os.Stdout, regexp.MustCompile(`\\[(ERROR|FATAL)\\]`)), )  logf.SetOutput(ws) for i := 0; i \u0026lt; 6; i++ { logf.SetMinLevel(logf.TRACE + logf.Level(i)) logf.Tracef(\u0026#34;Traceing: No. %d\\n\u0026#34;, i+1) logf.Debugf(\u0026#34;Debugging: No. %d\\n\u0026#34;, i+1) logf.Printf(\u0026#34;Information: No. %d\\n\u0026#34;, i+1) logf.Warnf(\u0026#34;Warning: No. %d\\n\u0026#34;, i+1) logf.Errorf(\u0026#34;Erroring: No. %d\\n\u0026#34;, i+1) logf.Fatalf(\u0026#34;Fatal Erroring: No. %d\\n\u0026#34;, i+1) } } これで同じ結果が得られる。\n今回はベースの Writer に出力多重化やらフィルタやらの機能を被せているだけなので，色々と応用が効くだろう。 効くといいな（笑）\nブックマーク  Log パッケージで遊ぶ 正規表現に関する戯れ言  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n   ちなみに Go の標準パッケージにも io.TeeReader() 関数ってのがあって tee コマンドと同等のことができる。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Font Awesome 5.13 に COVID-19 関連アイコンが登場",
      "section": "remark",
      "description": "covid-19 タグで検索すると色々と見つかるので，参考にどうぞ",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/03/covid-19-icons-in-font-awesome/",
      "published": "2020-03-25T02:00:26+00:00",
      "update": "2020-04-01T22:55:17+00:00",
      "content": "先日リリースされた Font Awesome 5.13 には SARS-CoV-2，世間で言うところの COVID-19 関連のアイコンが追加されたそうな1。 たとえばこんな感じ。\n   アイコン コード      \u0026lt;i class=\u0026quot;fas fa-virus\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;    \u0026lt;i class=\u0026quot;fas fa-viruses\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;    \u0026lt;i class=\u0026quot;fas fa-virus-slash\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;    ウイルスのイメージって今後はこれで定着するのかねぇ。 私はバクテリオファージのインパクトが強すぎて，ウイルスといえば\n File:Tevenphage.png - Wikimedia Commons  これなんだけど（笑）\ncovid-19 タグで検索すると既存のアイコンも併せて医療関係のアイコンを見つけることができる。 参考にどうぞ。 個人的には\n   アイコン コード      \u0026lt;i class=\u0026quot;fas fa-toilet-paper-slash\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;    \u0026lt;i class=\u0026quot;fas fa-plane-slash\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;    に笑ってしまった。 世相を反映してるというか\u0026hellip;\n  SARS-CoV-2 はウイルスの分類名， COVID-19 は WHO が定義した SARS-CoV-2 によって引き起こされる病状等を指すIDコード，らしい。日本では今だに「新型コロナ（ウイルス）」という暫定名が流通しているが，それ以外では何故か COVID-19 の ID コードがよく使われている。私は面倒くさいので SARS 2 と呼んでいる。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Java 14 がリリースされた",
      "section": "release",
      "description": "まぁ，私は PlantUML が問題なく動けばいいので（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/03/java-14-is-released/",
      "published": "2020-03-22T07:29:03+00:00",
      "update": "2020-03-29T00:57:08+00:00",
      "content": "ちょっと前に予定通り Java 14 がリリースされた。 OpenJDK および同系列の Java のみのショート・サイクルのバージョンアップである。\n JDK 14 JDK 14 GA Release JDK 14 Release Notes  まぁ，私は PlantUML が問題なく動けばいいので1（笑）\nOpenJDK を APT で管理するメリットはないので，実行バイナリをリリースページから直接ダウンロードして配置する。\n$ cd /usr/local/src $ sudo curl \u0026#34;https://download.java.net/java/GA/jdk14/076bab302c7b4508975440c56f6cc26a/36/GPL/openjdk-14_linux-x64_bin.tar.gz\u0026#34; -O $ cd .. $ sudo unlink java # 以前のバージョンの Java 環境がある場合 $ sudo tar xvf src/openjdk-14_linux-x64_bin.tar.gz $ sudo ln -s jdk-14 java $ java -version # すでに PATH が通っている場合 openjdk version \u0026#34;14\u0026#34; 2020-03-17 OpenJDK Runtime Environment (build 14+36-1461) OpenJDK 64-Bit Server VM (build 14+36-1461, mixed mode, sharing) PlantUML のほうも試してみるかな。\n Factory Method Pattern  よーし，うむうむ，よーし。\nブックマーク  Java 14正式版が登場。テキストブロック、インストーラー作成ツールなど新機能。Solaris/SPARC版はついに引退 － Publickey Java 14新機能まとめ - Qiita 真面目に PlantUML  参考図書  Java言語で学ぶリファクタリング入門 結城 浩 (著) SBクリエイティブ 2007-01-26 (Release 2014-03-12) Kindle版 B00I8AT1EU (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  結城浩さんによる「リファクタリング本」の Kindle 版。意外にも Java 以外でも応用できる優れもの。\nreviewed by Spiegel on 2018-12-11 (powered by PA-APIv5)\n  増補改訂版 Java言語で学ぶデザインパターン入門 結城 浩 (著) SBクリエイティブ 2004-06-18 (Release 2014-03-12) Kindle版 B00I8ATHGW (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  結城浩さんによる通称「デザパタ本」。 Java 以外でも使える優れもの。\nreviewed by Spiegel on 2016-01-05 (powered by PA-APIv5)\n  増補改訂版 Java言語で学ぶデザインパターン入門 マルチスレッド編 結城 浩 (著) SBクリエイティブ 2004-06-18 (Release 2014-03-12) Kindle版 B00I8AT1BS (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  結城浩さんによる通称「デザパタ本」の Kindle 版。意外にも Java 以外でも応用できる優れもの。\nreviewed by Spiegel on 2018-12-07 (powered by PA-APIv5)\n   2020-03-19 に PlantUML V1.2020.5 がリリースされている。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2020-03-22 のブックマーク",
      "section": "bookmarks",
      "description": "「GitHubがJavaScriptのパッケージマネージャー「npm」を買収」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2020/03/22-bookmarks/",
      "published": "2020-03-22T04:59:05+00:00",
      "update": "2020-03-22T04:59:21+00:00",
      "content": "リリース情報  Hugo 0.67.0: Custom HTTP headers | Hugo Release 1.45.0 · atom/atom · GitHub Announcing Rust 1.42.0 | Rust Blog Hugo 0.67.1: A couple of Bug Fixes | Hugo JDK 14 GA Release  JDK 14 JDK 14 Release Notes Java 14正式版が登場。テキストブロック、インストーラー作成ツールなど新機能。Solaris/SPARC版はついに引退 － Publickey   LibreOffice 6.4.2 available for download - The Document Foundation Blog Minify config and more! | Hugo : Hugo 0.68  セキュリティ＆プライバシー関連  Ransomware getting more fearsome, but there\u0026rsquo;s reason for optimism - Help Net Security ハッカーがデバイス攻撃時に最初に試すパスワードとは - ZDNet Japan グーグルの認証アプリ「Authenticator」、ワンタイムパスワードが盗まれるおそれ - ZDNet Japan AMD製CPUが2つの新しい攻撃に対して脆弱 ～グラーツ工科大学などのセキュリティ研究者が指摘 - 窓の杜 私は暗号解読バックドア法案に反対する | TechCrunch Japan ソフトパッチによる対策が困難なCPU脆弱性“LVI” ～ルーバンKUなどの研究者が発表 - 窓の杜  インテルCPUに脆弱性、「LVI」攻撃について研究者が明らかに - ZDNet Japan   流出NEMの不正交換事案についてまとめてみた - piyolog The Whisper Secret-Sharing App Exposed Locations - Schneier on Security Microsoft SMBv3 の脆弱性 (CVE-2020-0796) に関する注意喚起  定例外で修正されたSMBv3の脆弱性（CVE-2020-0796）についてまとめてみた - piyolog   The EARN-IT Act - Schneier on Security 新型コロナで揺れるプリンセス・クルーズが過去のデータ漏洩を認める | TechCrunch Japan 「Docker for Visual Studio Code」が正式版に、Visual Studio Codeの拡張機能。WSL 2環境のDockerコンテナに対応 － Publickey New tricks: simulating adversary tactics in modern, macOS environments | F-Secure WordPress and Apache Struts account for 55% of all weaponized vulnerabilities | ZDNet SANS Security Awareness Work-from-Home Deployment Kit | SANS Security Awareness  Work-from-Home Security Advice - Schneier on Security   Work-from-Home Security Advice - Schneier on Security  ブログ: 在宅勤務のセキュリティに関するアドバイス   テキサス法科大学教授ロバート・チェスニーの電子書籍「サイバーセキュリティの法律、政策、制度」バージョン3.0が公開されている - YAMDAS現更新履歴 Emergency Surveillance During COVID-19 Crisis - Schneier on Security  天文関連  [2002.10463] Betelgeuse Just Isn\u0026rsquo;t That Cool: Effective Temperature Alone Cannot Explain the Recent Dimming of Betelgeuse Dimming Betelgeuse likely isn\u0026rsquo;t cold, just dusty, new study shows 2020年3月17日ニュース「日本最古の天文記録、正体はオーロラだった 極地研などが見解」 | SciencePortal ニュース - 新型コロナウイルスに関連したアルマ望遠鏡の対応について - アルマ望遠鏡  知財関連  MIT Tech Review: 人工知能は特許法の 「発明者」になれるのか？ The Unicode Standard Now Includes CC License Symbols - Creative Commons Announcing the CC Catalog API, Version 1.0 - Creative Commons 将棋ユーチューバー「棋譜使わせて」と連盟に直訴　ツイートもできず、ファン悲鳴 - 弁護士ドットコム  その他  DuckDuckGo is good enough for regular use | www.bitlog.com  ブログ: DuckDuckGoは通常使用には十分だ   2020年3月9日ニュース「世界の感染国・地域は100を、感染者は10万人を超えさらに増加 新型コロナでWHO集計」 | SciencePortal サービスメッシュのIstio、機能拡張にWebAssemblyを採用。EnvoyにV8エンジンのWebAssemblyランタイムを統合 － Publickey Flatten the curve | These guidelines are intended to help Flatten the Curve with the COVID19 outbreak, to help limit spread and reduce the load on hospitals and other healthcare.  ブログ: コロナウイルス(COVID-19)へのアドバイス   AWS、コンテナに最適化したLinuxベースのOS「Bottlerocket」をオープンソースで公開 － Publickey グーグルが英ユーザーのデータ管轄を米国に移す意味とその影響 - ZDNet Japan GitHubが宿題の自動採点やインラインフィードバックなどが可能な教師向け新ツールを公開 | TechCrunch Japan 香川県条例：依存症の不安を煽って子どもからネットやゲームを奪ったうえに『親学』推進までされたんじゃたまったもんじゃない | P2Pとかその辺のお話R Rust 製スタティックサイトジェネレーター Zola をつかう | hiromasa.another :o) 2020年3月16日ニュース「厚労省が新型コロナの発生状況を周知するためにクラスターマップを作成」 | SciencePortal GitHubがnpmの買収を発表、JavaScriptのパッケージ管理サービス。将来的にはGitHubとnpmを統合へ － Publickey GitHubがJavaScriptのパッケージマネージャー「npm」を買収 | TechCrunch Japan docs.rs now allows you to choose your build targets | Rust Blog  ブログ: 失効 (リボケーション)   イラン革命体制の高齢化した指導層は新型コロナに脆弱か：池内恵 | 池内恵の中東通信 | 新潮社　Foresight(フォーサイト) | 会員制国際情報サイト 早期に米国からの入国を止めたイスラエルの「先見の明」：池内恵 | 池内恵の中東通信 | 新潮社　Foresight(フォーサイト) | 会員制国際情報サイト 「GitHub」モバイルアプリがベータ版を卒業、一般提供が開始 - 窓の杜 EOF is not a character - Ruslan\u0026rsquo;s Blog  ブログ: EOFは文字ではない   マイクロソフト、次世代.NETフレームワーク「.NET 5」最初のプレビューリリース。.NET Framework、.NET Core、Xamarinの3つを統合 － Publickey  "
    },
    {
      "title": "GnuPG 2.2.20 がリリースされた",
      "section": "release",
      "description": "セキュリティ・アップデートはなし。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/03/gnupg-2_2_20-is-released/",
      "published": "2020-03-21T10:27:24+00:00",
      "update": "2020-03-21T10:27:39+00:00",
      "content": "GnuPG 2.2.20 がリリースされた。\n [Announce] GnuPG 2.2.20 released  メンテナンス・リリース。 セキュリティ・アップデートはなし。 詳細はこちら。\n Protect the error counter against overflow to guarantee that the tools can\u0026rsquo;t be tricked into returning success after an error. gpg: Make really sure that --verify-files always returns an error. gpg: Fix key listing --with-secret if a pattern is given. [#4061] gpg: Fix detection of certain keys used as default-key. [#4810] gpg: Fix default-key selection when a card is available. [#4850] gpg: Fix key expiration and key usage for keys created with a creation date of zero. [#4670] gpgsm: Fix import of some CR,LF terminated certificates. [#4847] gpg: New options --include-key-block and --auto-key-import to allow encrypted replies after an initial signed message. [#4856] gpg: Allow the use of a fingerprint with --trusted-key. [#4855] gpg: New property \u0026quot;fpr\u0026quot; for use by --export-filter. scdaemon: Disable the pinpad if a KDF DO is used. [#4832] dirmngr: Improve finding OCSP certificates. [#4536] Avoid build problems with LTO or gcc-10. [#4831]  Release-info: https://dev.gnupg.org/T4860 via GnuPG 2.2.20 released  アップデートは計画的に。\n参考図書  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n "
    }
  ]
}
