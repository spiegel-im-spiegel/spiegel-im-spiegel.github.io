{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "TeX Live 2020 へのアップグレード",
      "section": "remark",
      "description": "手元の環境では973個ほど更新されたよ…",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/04/upgrade-texlive-2020/",
      "published": "2020-04-16T05:33:22+00:00",
      "update": "2020-04-16T07:53:47+00:00",
      "content": "どうやら TeX Live 2020 がリリースされたようだ。 今年は早かったな（笑）\nTeX Live 2020 is available over the Internet and (after production) on DVD. It was released on 10 April 2020, and ongoing updates are available. via TeX Live - TeX Users Group  ちうわけで，今年も TeX Live のアップグレードを行おう。 あっ，念のために言うと，今回のアップグレードは APT を使わず install-tl でインストールされていることが前提ね。\n TeX Live を Ubuntu に（APT を使わずに）導入する  前準備 まず tlmgr path add コマンドでパス設定をしている場合は\n$ sudo tlmgr path remove で設定を消しておく。\n次に 2019 の環境を 2020 へコピーする。\n$ cd /usr/local/texlive $ sudo cp -a 2019 2020 $ sudo rm 2020/tlpkg/backups/* update-tlmgr を使ってアップグレードを行う際に権限のコントロールが上手くないみたいなので 2020/ フォルダ以下のオーナーを一時的に自ユーザに書き換えておく。\n$ sudo chown -R username:username 2020 ~/.texlive2019/ ディレクトリも ~/.texlive2020/ にコピっとけばいいかな。\n$ cd ~ $ cp -a .texlive2019 .texlive2020 最後に環境変数 PATH や MANPATH 等を設定している場合はその設定を変更しておく。 たとえば /etc/profile.d/ ディレクトリに以下の内容を書いたファイル texlive-paths.sh を置いている場合\n# shellcheck shell=sh # Expand $PATH to include the directory where TeX Live applications go. texlive_path=\u0026#34;/usr/local/texlive/2019\u0026#34; texlive_bin_path=\u0026#34;${texlive_path}/bin/x86_64-linux\u0026#34; if [ -n \u0026#34;${PATH##*${texlive_bin_path}}\u0026#34; -a -n \u0026#34;${PATH##*${texlive_bin_path}:*}\u0026#34; ]; then export MANPATH=${MANPATH}:${texlive_path}/texmf-dist/doc/man export INFOPATH=${INFOPATH}:${texlive_path}/texmf-dist/doc/info export PATH=${PATH}:${texlive_bin_path} fi 2019 の部分を 2020 に置き換える。\n# shellcheck shell=sh # Expand $PATH to include the directory where TeX Live applications go. texlive_path=\u0026#34;/usr/local/texlive/2020\u0026#34; texlive_bin_path=\u0026#34;${texlive_path}/bin/x86_64-linux\u0026#34; if [ -n \u0026#34;${PATH##*${texlive_bin_path}}\u0026#34; -a -n \u0026#34;${PATH##*${texlive_bin_path}:*}\u0026#34; ]; then export MANPATH=${MANPATH}:${texlive_path}/texmf-dist/doc/man export INFOPATH=${INFOPATH}:${texlive_path}/texmf-dist/doc/info export PATH=${PATH}:${texlive_bin_path} fi 2020年版へのアップグレード ほいじゃまぁ，アップグレードしますかね。 まずは update-tlmgr による tlmgr のアップグレードから。\n$ cd /usr/local/texlive/2020 $ wget http://mirror.ctan.org/systems/texlive/tlnet/update-tlmgr-latest.sh $ sh update-tlmgr-latest.sh -- --upgrade tlmgr の動作確認をしておこう。\n$ tlmgr version tlmgr revision 54446 (2020-03-21 17:45:22 +0100) tlmgr using installation: /usr/local/texlive/2020 TeX Live (https://tug.org/texlive) version 2020 よしよし。\n次はアップグレードした tlmgr でアップデートを行う。\n$ tlmgr option repository http://mirror.ctan.org/systems/texlive/tlnet tlmgr: setting default package repository to http://mirror.ctan.org/systems/texlive/tlnet tlmgr: updating /usr/local/texlive/2020/tlpkg/texlive.tlpdb $ tlmgr update --self --all tlmgr: package repository http://ftp.yz.yamagata-u.ac.jp/pub/CTAN/systems/texlive/tlnet (verified) tlmgr: saving backups to /usr/local/texlive/2020/tlpkg/backups ... さて，お茶の時間にするか。\n\u0026hellip;手元の環境では973個ほど更新されたよ\u0026hellip;\n$\\mathrm{Lua\\TeX}$ を使う場合はフォントキャッシュのアップデートも忘れずに。\n$ luaotfload-tool -fu 最後に /usr/local/texlive/2020 ディレクトリ以下のオーナーを root に戻す。\n$ cd /usr/local/texlive $ sudo chown -R root:root 2020 更にパス設定（/usr/local/bin/ 等へシンボリック・リンクを張る）を行うなら\n$ sudo /usr/local/texlive/2020/bin/x86_64-linux/tlmgr path add とする。\n動作確認 ちょろんと動作確認しておこう。 $\\mathrm{Lua\\LaTeX}$ でね。\n$ lualatex -v This is LuaHBTeX, Version 1.12.0 (TeX Live 2020) Execute \u0026#39;luahbtex --credits\u0026#39; for credits and version details. There is NO warranty. Redistribution of this software is covered by the terms of the GNU General Public License, version 2 or (at your option) any later version. For more information about these matters, see the file named COPYING and the LuaTeX source. LuaTeX is Copyright 2020 Taco Hoekwater and the LuaTeX Team. うお！ $\\mathrm{LuaHB\\TeX}$ ベースになってる。 どうやら $\\mathrm{Lua\\LaTeX}$ では $\\mathrm{LuaHB\\TeX}$ ベースになる模様。 $\\mathrm{Lua\\TeX}$ 自体はあるようで\n$ luatex -v This is LuaTeX, Version 1.12.0 (TeX Live 2020) Execute \u0026#39;luatex --credits\u0026#39; for credits and version details. There is NO warranty. Redistribution of this software is covered by the terms of the GNU General Public License, version 2 or (at your option) any later version. For more information about these matters, see the file named COPYING and the LuaTeX source. LuaTeX is Copyright 2020 Taco Hoekwater and the LuaTeX Team. となる。\n以下のタイプセットも試してみるか。\n LuaLaTeX でコードを書いてみる  結果はこんな感じ。\n よーし，うむうむ，よーし。\nブックマーク  TeX Live 2020 released | There and back again trueroad/HaranoAjiFonts: 原ノ味フォント : TeX Live 2020 に組み込まれたそうな  参考図書  [改訂第7版]LaTeX2ε美文書作成入門 奥村 晴彦 (著), 黒木 裕介 (著) 技術評論社 2017-01-24 大型本 4774187054 (ASIN), 9784774187051 (EAN), 4774187054 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  ついに第7版が登場。紙の本で買って常に側に置いておくのが吉。\nreviewed by Spiegel on 2017-09-27 (powered by PA-APIv5)\n "
    },
    {
      "title": "OpenJDK 14.0.1 のリリース【セキュリティ・アップデート】",
      "section": "release",
      "description": "深刻度が高いセキュリティ・アップデートも含まれているので必ず対応すること。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/04/openjdk-14_0_1-is-released/",
      "published": "2020-04-16T03:21:08+00:00",
      "update": "2020-04-16T03:50:45+00:00",
      "content": "予定通り Java 14 および LTS である Java 11 のマイナー・バージョンアップが行われた。 深刻度が高い脆弱性も含まれているので必ず対応すること。\n OpenJDK Vulnerability Advisory: 2020/04/14  以下に脆弱性の一覧を挙げておく。\n  CVE ID Component CVSSv3\nScore Affects ...   7 8 11 13 14   CVE-2020-2803 core-libs/java.nio 8.3 \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226;   CVE-2020-2805 core-libs/java.io 8.3 \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226;   CVE-2020-2816 security-libs/javax.net.ssl 7.5 \u0026nbsp; \u0026nbsp; \u0026#8226; \u0026#8226; \u0026#8226;   CVE-2020-2781 security-libs/java.security 5.3 \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226;   CVE-2020-2830 core-libs/java.util 5.3 \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226;   CVE-2020-2767 security-libs/javax.net.ssl 4.8 \u0026nbsp; \u0026nbsp; \u0026#8226; \u0026#8226; \u0026#8226;   CVE-2020-2800 core-libs/java.net 4.8 \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226;   CVE-2020-2778 security-libs/javax.net.ssl 3.7 \u0026nbsp; \u0026nbsp; \u0026#8226; \u0026#8226; \u0026#8226;   CVE-2020-2754 core-libs/javax.script 3.7 \u0026nbsp; \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226;   CVE-2020-2755 core-libs/javax.script 3.7 \u0026nbsp; \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226;   CVE-2020-2773 security-libs/javax.xml.crypto 3.7 \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226;   CVE-2020-2756 core-libs/java.io:serialization 3.7 \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226;   CVE-2020-2757 core-libs/java.io:serialization 3.7 \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226; \u0026#8226;   CVE-2020-18197 javafx/web 8.1 \u0026nbsp; \u0026#8226; \u0026#8226; \u0026nbsp; \u0026#8226;    via OpenJDK Vulnerability Advisory: 2020/04/14  Java 10 以下 および 12, 13 は基本的にサポート期間が切れてる。 Java 11 または 14 へアップグレードするか Amazon Corretto のようなディストリビューションを利用すること。\nOpenJDK を APT で管理するメリットはないので，実行バイナリをリリースページから直接ダウンロードして配置する。\n$ cd /usr/local/src $ sudo curl \u0026#34;https://download.java.net/java/GA/jdk14.0.1/664493ef4a6946b186ff29eb326336a2/7/GPL/openjdk-14.0.1_linux-x64_bin.tar.gz\u0026#34; -O $ cd .. $ sudo unlink java # 以前のバージョンの Java 環境がある場合 $ sudo tar xvf src/openjdk-14.0.1_linux-x64_bin.tar.gz $ sudo ln -s jdk-14.0.1 java $ java -version # すでに PATH が通っている場合 openjdk 14.0.1 2020-04-14 OpenJDK Runtime Environment (build 14.0.1+7) OpenJDK 64-Bit Server VM (build 14.0.1+7, mixed mode, sharing) 私としては PlantUML が動けばいいので，試しておく1。\n Factory Method Pattern  うむうむ。 ちゃんと動くな。\nブックマーク  Oracle Critical Patch Update Advisory - April 2020  Oracle Java の脆弱性対策について(CVE-2020-2803等)：IPA 独立行政法人 情報処理推進機構 2020年4月 Oracle 製品のクリティカルパッチアップデートに関する注意喚起   Java 環境のリリースとサポートに関する覚え書き  参考図書  Java言語で学ぶリファクタリング入門 結城 浩 (著) SBクリエイティブ 2007-01-26 (Release 2014-03-12) Kindle版 B00I8AT1EU (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  結城浩さんによる「リファクタリング本」の Kindle 版。意外にも Java 以外でも応用できる優れもの。\nreviewed by Spiegel on 2018-12-11 (powered by PA-APIv5)\n  増補改訂版 Java言語で学ぶデザインパターン入門 結城 浩 (著) SBクリエイティブ 2004-06-18 (Release 2014-03-12) Kindle版 B00I8ATHGW (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  結城浩さんによる通称「デザパタ本」。 Java 以外でも使える優れもの。\nreviewed by Spiegel on 2016-01-05 (powered by PA-APIv5)\n  増補改訂版 Java言語で学ぶデザインパターン入門 マルチスレッド編 結城 浩 (著) SBクリエイティブ 2004-06-18 (Release 2014-03-12) Kindle版 B00I8AT1BS (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  結城浩さんによる通称「デザパタ本」の Kindle 版。意外にも Java 以外でも応用できる優れもの。\nreviewed by Spiegel on 2018-12-07 (powered by PA-APIv5)\n   2020-04-05 に PlantUML V1.2020.6 がリリースされている。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "ハロワとコロナ",
      "section": "remark",
      "description": "この時期にお金の心配をしないで引きこもれるとか。 運がいいのか悪いのか（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/04/hello-unemployed/",
      "published": "2020-04-15T09:46:10+00:00",
      "update": "2020-04-15T10:44:06+00:00",
      "content": "さて，「天下無敵のプー太郎」としては何はともあれ年金\u0026amp;健康保険の切り替えと失業認定を受けるための諸々の手続きをしないといけないわけで，お役所巡りしましたよ。 つっかれた！\n窓口がどこも透明ビニールシートで仕切られてて，まずそこで笑っちゃったよ。 いや，笑いごっちゃないけどね。 ホンマ，このご時世に対面で働かされるお役所の職員さんには頭が下がるよ。\nちなみに待ち合いのシートも間隔があけられていて，詰め詰めにならないように調整されていた。\n今回の退職は所謂「会社都合」なのでタイムラグなしで給付が受けられる。 しかも件の感染症流行のせいで対象者への説明会も失くなったので，何にもしないで1回目の給付認定を受けられることになってしまった（通常は説明会に参加することで1回目の求職活動実績と見なされる）。\n他にも個人的な都合で色々と優遇措置を受けられることになった。 この時期にお金の心配をしないで引きこもれるとか。 運がいいのか悪いのか。 人間万事塞翁が丙午（違う）\nレッツ！ 引きこもり\nそうそう。 今回の一連の手続きでハンコは一切使いませんでした。 ハンコなんて飾りですよ，偉い人には分からんのです（笑） マイナンバーカードがあれば顔写真の提出も不要（そのためのマイナンバーカードだからね）。\nあと（昨年末のインフルエンザ流行時に買い置きしておいた）マスクの在庫が尽きそう。 まぁ，マスクこそ「健康劇場」だけどね。 マスクより手洗い励行。 タブレット共有で接触感染とか笑えん。\n"
    },
    {
      "title": "Git v2.26.1 のリリース【セキュリティ・アップデート】",
      "section": "release",
      "description": "対象となるのは 2.17.x から 2.26.x までの各マイナーバージョン (CVE-2020-5260)",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/04/git-2_26_1-is-released/",
      "published": "2020-04-15T01:18:03+00:00",
      "update": "2020-04-15T02:12:21+00:00",
      "content": "Git v2.26.1 を含む複数のバージョンがリリースされた。\n [Announce] Git v2.26.1 and others  対象となるのは 2.17.x から 2.26.x までの各マイナーバージョン。 今回はセキュリティ・アップデートを含むため必ず対応すること。\nThese releases address the security issue CVE-2020-5260, which allowed a crafted URL to trick a Git client to send credential information for a wrong host to the attacker\u0026rsquo;s site. via Git v2.26.1 and others  Ubuntu の APT の標準リポジトリは最新版を提供してないが， USN-4329-1 によると各バージョンの git でアップデートを行っているようだ。 なお PPA 版リポジトリでは既に v2.26.1 がリリースされている。\nCVE-2020-5260 Affected versions of Git have a vulnerability whereby Git can be tricked into sending private credentials to a host controlled by an attacker. Git uses external \u0026ldquo;credential helper\u0026rdquo; programs to store and retrieve passwords or other credentials from secure storage provided by the operating system. Specially-crafted URLs that contain an encoded newline can inject unintended values into the credential helper protocol stream, causing the credential helper to retrieve the password for one server (e.g., good.example.com) for an HTTP request being made to another server (e.g., evil.example.com), resulting in credentials for the former being sent to the latter. There are no restrictions on the relationship between the two, meaning that an attacker can craft a URL that will present stored credentials for any host to a host of their choosing. The vulnerability can be triggered by feeding a malicious URL to git clone. However, the affected URLs look rather suspicious; the likely vector would be through systems which automatically clone URLs not visible to the user, such as Git submodules, or package systems built around Git. via CVE-2020-5260  説明がなげーよ orz\n要するに an attacker can craft a URL that will present stored credentials for any host to a host of their choosing ってところが重要。\n CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N (GitHub, Inc.) 深刻度: 緊急 (9.3)     基本評価基準 評価値     攻撃元区分 ネットワーク   攻撃条件の複雑さ 低   必要な特権レベル 不要   ユーザ関与レベル 要   スコープ 変更あり   機密性への影響 高   完全性への影響 高   可用性への影響 なし    Git Credential Helper ちなみに credential helper のひとつ GNOME/libsecret だが， Ubuntu 19.10 で用意されている APT 最新版は\n$ sudo apt show libsecret-1-dev Package: libsecret-1-dev Version: 0.18.8-2 Priority: optional Section: libdevel Source: libsecret Origin: Ubuntu ... だった。 ちょっと古いっぽい（？）気もするが\u0026hellip; Linux 系独特の意味不明な backport patch はどうにかならないのだろうか。\nまぁ，いいや。 以前も書いたがインストール手順は以下の通り（/usr/share/... 以下を汚したくなかったので）。\n$ sudo apt install libsecret-1-dev $ mkdir ~/work $ cp -r /usr/share/doc/git/contrib/credential/libsecret ~/work $ cd ~/work/libsecret $ make gcc -g -O2 -Wall -pthread -I/usr/include/libsecret-1 -I/usr/include/libmount -I/usr/include/blkid -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include -o git-credential-libsecret.o -c git-credential-libsecret.c gcc -o git-credential-libsecret git-credential-libsecret.o -lsecret-1 -lgio-2.0 -lgobject-2.0 -lglib-2.0 これでビルドした git-credential-libsecret を $PATH の通ったディレクトリに放り込んでおけばよい。 確認は以下の通り。\n$ git help -a | grep credential- credential-cache Helper to temporarily store passwords in memory credential-store Helper to store credentials on disk credential-libsecret よーし，うむうむ，よーし。\nGit 設定は以下の通り。\n$ git config --global credential.helper libsecret アップデートは\u0026hellip; アップデートは計画的に。\nブックマーク  malicious URLs may cause Git to present stored credentials to the wrong server · Advisory · git/git · GitHub PPA から Git をインストールする  "
    },
    {
      "title": "2020-04-12 のブックマーク",
      "section": "bookmarks",
      "description": "「MathJax v3.0.5 now available」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2020/04/12-bookmarks/",
      "published": "2020-04-12T00:28:03+00:00",
      "update": "2020-04-12T00:30:26+00:00",
      "content": "リリース情報  Release Release 2.5.4 · keepassxreboot/keepassxc · GitHub Release v0.69.0 · gohugoio/hugo · GitHub MathJax v3.0.5 now available | MathJax  バベルのインターネット  Cloudflareが無料の新DNSサービス「1.1.1.1 for Families」発表。DNSのレベルでアダルトコンテンツやマルウェアをブロック － Publickey 中国提案\u0026quot;New IP\u0026quot;をIETFが蹴る、インターネット分断を懸念〜インターネットと人権｜星 暁雄｜note  セキュリティ＆プライバシー関連  マイクロソフト、「Emotet」感染による顧客ネットワークの停止事例を公開 - ZDNet Japan 「Firefox」のキャッシュからTwitterデータが漏洩 ～MozillaはTwitterの非標準実装を批難 - 窓の杜 危機的状況にこそ「政府への批判」が必要である | P2Pとかその辺のお話R How to Protect Privacy When Aggregating Location Data to Fight COVID-19 | Electronic Frontier Foundation Twitterアカウントの名前が意図せずメールアドレスになる理由について調べてみた - piyolog Google Cloudの主要サービスが10時間ものあいだ障害発生。原因は分散アクセスコントロールへの大量の変更要求が引き起こしたメモリ不足 － Publickey Attack matrix for Kubernetes  Kubernetes Security - Schneier on Security    天文関連  2020年4月7日ニュース「持ち運べる光格子時計を開発、性能初確認 スカイツリーで高低差計測 東京大学など」 | SciencePortal  知財関連  Piracy and File-Sharing Traffic Surges Amidst Covid-19 Crisis * TorrentFreak  その他  We\u0026rsquo;re in for 2 months - foobuzz  ブログ: 私たちには2ヶ月必要です   Mathematical proof that rocked number theory will be published  ブログ: 数論を揺り動かす数学的証明が出版へ   Mysterious Heart Damage, Not Just Lung Troubles, Befalling COVID-19 Patients | Kaiser Health News  ブログ: COVID-19患者に降りかかる不思議な心臓の損傷   プログラミングなしで業務自動化を実現するTonkeanが約26億円調達 | TechCrunch Japan ラズパイ4にはやっぱりメタル調ケースが発熱低くて安心  "
    },
    {
      "title": "それは Duck Typing ぢゃない（らしい）",
      "section": "remark",
      "description": "今回は Go と Rust との比較をちょっとポエミーに語ってみる（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/04/subtyping/",
      "published": "2020-04-10T10:37:23+00:00",
      "update": "2020-04-10T10:55:30+00:00",
      "content": "今回は Go と Rust との比較をちょっとポエミーに語ってみる（笑）\nそもそも duck typing は Ruby のような動的型付け言語における型推論の手法（のひとつ）である。 その由来は duck test から来ていて\nIf it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck. via Duck test - Wikipedia  というフレーズに集約されている。\n静的型付け言語である Go や Rust における抽象型を使った型推論を duck typing と呼ぶのは厳密には正しくない，らしい。 Go や Rust における interface や trait といった抽象型を用いた型推論は「部分型付け（subtyping）」と呼ばれる。 ただし Go と Rust では全く異なる戦略をとる。\nCat コマンドもどき（Go 版） ここで簡単なプログラムを書いてみよう。 UNIX 系のプラットフォームではおなじみの cat コマンドの「もどき」を書いてみる。\n本来の cat コマンドは複数の入力を結合（concatenate）して出力するものだが，真面目な実装をし始めるとキリがないので，今回は以下の2つの機能のみ実装する。\n コマンドライン引数で指定したファイルを1つのみ標準出力に出力する ファイルの指定がない場合は標準入力をそのまま標準出力に出力する  ぶっちゃけ，ただの「土管」である（笑） これを Go で書いたのが以下のコードだ。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func concatenate(w io.Writer, r io.Reader) error { _, err := io.Copy(w, r) return err } func main() { if len(os.Args) \u0026gt; 1 { file, err := os.Open(os.Args[1]) if err != nil { fmt.Fprintln(os.Stderr, err) return } defer file.Close() if err := concatenate(os.Stdout, file); err != nil { fmt.Fprintln(os.Stderr, err) return } } else { if err := concatenate(os.Stdout, os.Stdin); err != nil { fmt.Fprintln(os.Stderr, err) return } } } concatenate() 関数がメインのロジックで，引数の io.Writer, io.Reader および返り値の error は全て interface 型である。 まぁ concatenate() 関数を括り出す必然性は全くないのだが，後述の Rust のコードと比較しやすいよう敢えて分けている。\nconcatenate() 関数の呼び出しで，最初の\nif err := concatenate(os.Stdout, file); err != nil { fmt.Fprintln(os.Stderr, err) return } と次の\nif err := concatenate(os.Stdout, os.Stdin); err != nil { fmt.Fprintln(os.Stderr, err) return } は（当然ながら）同じ関数で，引数や返り値にどのようなインスタンスが入るかは実行時に決まる。 コンパイル時に決まるのは注入するインスタンスの構造が受け入れる interface 型の構造と合致していることだけだ（合致しなければコンパイル・エラー）。\nすンごい簡単に書かれているけど，これは「依存の注入（depencency injection）」の典型例であり「Go では duck typing ができる」とか言われる所以である。\nでは，これをリファレンスとして，今度は Rust を使って書いてみる。\nCat コマンドもどき（Rust 版，総称型編） とりあえず，えいやっで書いたコードがこちら。\nfn concatenate\u0026lt;W,R\u0026gt;(w: \u0026amp;mutW,r: \u0026amp;mutR)-\u0026gt; Result\u0026lt;(),std::io::Error\u0026gt;whereW: std::io::Write,R: std::io::Read,{letmutbuf=Vec::new();r.read_to_end(\u0026amp;mutbuf)?;w.write_all(\u0026amp;buf)?;Ok(())}fn main()-\u0026gt; Result\u0026lt;(),std::io::Error\u0026gt;{letargs=std::env::args();ifargs.len()\u0026gt;1{forsinargs.skip(1).take(1){concatenate(\u0026amp;mutstd::io::stdout(),\u0026amp;mutstd::io::BufReader::new(std::fs::File::open(s)?),)?;}}else{concatenate(\u0026amp;mutstd::io::stdout(),\u0026amp;mutstd::io::stdin())?;}Ok(())}std::io::Write と std::io::Read が trait 型なのだが，各 trait は総称型 W, R の制約条件として書かれているだけで実行時に機能するわけではない。 つまり最初の\nconcatenate(\u0026amp;mutstd::io::stdout(),\u0026amp;mutstd::io::BufReader::new(std::fs::File::open(s)?),)?;と次の\nconcatenate(\u0026amp;mutstd::io::stdout(),\u0026amp;mutstd::io::stdin())?;はコンパイル時に別の関数として展開される1。 これを（多態化（polymorphization）に対する）単態化（monomorphization）と呼ぶ。\nじゃあ Rust では依存の注入は書けないのかというと，勿論そんなことはない。\nCat コマンドもどき（Rust 版，依存注入編） 依存の注入ができるように書き換えたバージョンがこれ。\nfn concatenate(w: \u0026amp;mutBox\u0026lt;dynstd::io::Write\u0026gt;,r: \u0026amp;mutBox\u0026lt;dynstd::io::Read\u0026gt;,)-\u0026gt; Result\u0026lt;(),Box\u0026lt;dynstd::error::Error\u0026gt;\u0026gt;{letmutbuf=Vec::new();r.read_to_end(\u0026amp;mutbuf)?;w.write_all(\u0026amp;buf)?;Ok(())}fn main()-\u0026gt; Result\u0026lt;(),Box\u0026lt;dynstd::error::Error\u0026gt;\u0026gt;{letargs=std::env::args();letmutr: Box\u0026lt;dynstd::io::Read\u0026gt;=ifargs.len()\u0026gt;1{letfnam=matchargs.skip(1).next(){Some(s)=\u0026gt;s,_=\u0026gt;\u0026#34;\u0026#34;.to_string(),};Box::new(std::io::BufReader::new(std::fs::File::open(fnam)?))}else{Box::new(std::io::stdin())};letmutw: Box\u0026lt;dynstd::io::Write\u0026gt;=Box::new(std::io::stdout());concatenate(\u0026amp;mutw,\u0026amp;mutr)?;Ok(())}concatenate() 関数が同一のものであることを強調するために呼び出しをひとつに纏めているので少しまだるこしい書き方になっているが，ご容赦。 このように Rust では trait 型を Box\u0026lt;dyn Trait\u0026gt; の形式に落とし込むことで実行時の動的ディスパッチを可能にしている。\nAccept Interfaces, Return Structs Go の設計指針で有名な言葉に accept interfaces, return structs というのがある。 私自身は必ずしもこれに賛同しないが（システム内部のコンテキスト境界は interface にすべき），この指針は Go の特徴をよく表している。\nたとえば io.Reader と os.File は同じ Read() 関数を持つという点で関連しているけど，両者の間に明示された記述は存在しない。 それでも，その関係を以って io.Reader に os.File インスタンスを注入可能である。 Go プログラマは息をするように依存を注入するのだ。\nこのような関係を構造型の部分型付け（structural subtyping）と呼ぶそうな。\n構造型と公称型 Go の interface 型が構造型の部分型付けであるのに対し Rust の trait 型は公称型の部分型付け（nominal subtyping）に分類されるだろう。 たとえば std::io::Read と std::fs::File との間にはコード上で明示された関係がある。 その「明示された関係」がなければ，たとえ同じ構造を持っていたとしても，両者の間に関係があるとは見なされないのだ。\nRust の言語仕様がこのような制約を構成しているのには，勿論ちゃんとした理由がある。\nGo においてはメモリ管理や並列処理2 をランタイム・モジュールに「丸投げ」している。 なので，プログラマは富豪的な記述に専念できるが，バイナリは肥大化してしまうしコンパイル時の最適化にも限度がある3。\nRust はリソース管理等についてプログラマ側でかなり面倒を見なければならないが（それでも C/C++ などに比べれば全然楽だし安全），言い換えればコード上でのコントロールがし易くコンパイル時の最適化についてもかなり期待できる。 上述の cat コマンドもどきでも，コンパイル時の単態化を避けるコードをわざわざ書く理由はないだろう。\nこれはプログラム設計時の重要なトレードオフとなる。 まぁ「Go か Rust か」みたいな究極の選択をする状況はないと思うが，複数のプログラミング言語からどれかを選ぶ際にはこういったことも考慮していくべきだ（選ぶ余裕もない事案のほうが多いだろうけどw）。\n前にも書いたが，「それができる」ことと「そのように作られている」ことには天と地ほどの違いがある。 どうせ「書く」なら無茶せず楽しく書きたいものである。\nブックマーク   Rustでファイルの入出力 - Qiita\n  RustのファイルI/OにはBufReader, BufWriterを使いましょう、という話 - Qiita\n  Go言語のInterfaceの考え方、Accept interfaces,return structs - Qiita\n  継承できないなら注入すればいいじゃない！ : Go のイベント用に作ったスライド\n  参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n  Go言語による並行処理 Katherine Cox-Buday (著), 山口 能迪 (翻訳) オライリージャパン 2018-10-26 単行本（ソフトカバー） 4873118468 (ASIN), 9784873118468 (EAN), 4873118468 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版もある。感想はこちら。 Go 言語で並行処理を書くならこの本は必読書になるだろう。\nreviewed by Spiegel on 2020-01-13 (powered by PA-APIv5)\n   余談だが Rust では「ファイルを閉じる」操作は変数の生存期間満了時に暗黙的に行われるようだ。明示的に閉じるには drop 関数を使う。 \u0026#x21a9;\u0026#xfe0e;\n Go における並行処理と並列処理の違いについては『Go言語による並行処理』を読むことを強くおすすめする。 \u0026#x21a9;\u0026#xfe0e;\n 近年，特に組込み用途で注目されている TinyGo は LLVM 上で動作することを前提としていて，本家 Go に比べてかなり小さい実行バイナリを吐けるらしい。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "RSA-250 解読完了！",
      "section": "remark",
      "description": "実際には何万ものマシンを使って数ヶ月で解読したらしい。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/04/rsa-250-factored/",
      "published": "2020-04-09T01:45:03+00:00",
      "update": "2020-04-09T02:09:57+00:00",
      "content": "2月末の話で申し訳ないが（Bruce Schneier 先生の記事でさっき知ったのだ）， RSA-250 鍵が因数分解され解読完了したらしい。\n [Cado-nfs-discuss] Factorization of RSA-250 RSA-250 Factored - Schneier on Security  The total computation time was roughly 2700 core-years, using Intel Xeon Gold 6130 CPUs as a reference (2.1GHz):\nRSA-250 sieving: 2450 physical core-years RSA-250 matrix: 250 physical core-years  via Factorization of RSA-250  実際には何万ものマシンを使って数ヶ月で解読したらしい。\nThe computation involved tens of thousands of machines worldwide, and was completed in a few months. via RSA-250 Factored  RSA-240 が解けたのって，つい昨年末なんだけどねぇ（笑） RSA は近い将来，量子コンピュータの一般化を待たずにお払い箱になるんだろうね。\n参考図書  暗号化 プライバシーを救った反乱者たち スティーブン・レビー (著), 斉藤 隆央 (翻訳) 紀伊國屋書店 2002-02-16 単行本 4314009071 (ASIN), 9784314009072 (EAN), 4314009071 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  20世紀末，暗号技術の世界で何があったのか。知りたかったらこちらを読むべし！\nreviewed by Spiegel on 2015-03-09 (powered by PA-APIv5)\n  暗号技術入門 第3版　秘密の国のアリス 結城 浩 (著) SBクリエイティブ 2015-08-25 (Release 2015-09-17) Kindle版 B015643CPE (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。\nreviewed by Spiegel on 2015-09-20 (powered by PA-APIv5)\n "
    },
    {
      "title": "Go 1.14.2 がリリースされた",
      "section": "release",
      "description": "セキュリティ・アップデートはなし，でいいかな。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/04/go-1_14_2-is-released/",
      "published": "2020-04-09T01:34:18+00:00",
      "update": "2020-04-09T01:36:29+00:00",
      "content": "Go 1.14.2 がリリースされた。\n Go 1.14.2 and Go 1.13.10 are released - Google group  セキュリティ・アップデートはなし，でいいかな。\ngo1.14.2 (released 2020/04/08) includes fixes to cgo, the go command, the runtime, os/exec, and testing packages. See the Go 1.14.2 milestone on our issue tracker for details. via Release History - The Go Programming Language  例によって Ubuntu の APT で管理している Go コンパイラは古いので，ダウンロードページからバイナリ（go1.14.2.linux-amd64.tar.gz）を取ってきて手動でインストールすることを強く推奨する。\n$ cd /usr/local/src $ sudo curl \u0026#34;https://dl.google.com/go/go1.14.2.linux-amd64.tar.gz\u0026#34; -O $ cd .. $ sudo unlink go # 以前の Go が入っている場合 $ sudo tar xvf src/go1.14.2.linux-amd64.tar.gz $ sudo mv go go1.14.2 $ sudo ln -s go1.14.2 go $ go version # /usr/local/go/bin にパスが通っている場合 go version go1.14.2 linux/amd64 アップデートは計画的に。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "Rust の型に関する覚え書き",
      "section": "rust-lang",
      "description": "思いつくまま脈絡なく随時更新予定。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/types/",
      "published": "2020-04-08T07:33:06+00:00",
      "update": "2020-04-09T07:33:39+00:00",
      "content": "この記事では Rust の型（type）に関することを思いつくまま脈絡なく書き記しておく。 随時更新予定。\n 組み込みデータ型 型エイリアス 構造体 列挙型 総称型  組み込みデータ型 組み込みデータ型には大きく分けてスカラ型と複合型がある。\nスカラ型 スカラ型はスカラ値を有する型である。 型によって値のサイズが決まっていて，受け渡しは copy semantics で行われる。\nスカラ型に分類される型は以下の通り。\n1. 整数型    サイズ 符号あり 符号なし 既定     8 bits i8 u8    16 bits i16 u16    32 bits i32 u32    64 bits i64 u64    — isize usize     isize/usize のサイズはアーキテクチャに依存する1。 また，リテラル表記時等での型推測の既定は i32 型となる2。\nletx=123;//type i32 ただしリテラル表記の後ろに型名を付けることで型を指定することが可能。\nletx=123i64;//type i64 もちろん変数に型注釈を付けて明示することも可能。\nletx: u8 =123;//type u8 2. 浮動小数点数型    サイズ 型名 既定     32 bits (仮数部 23 bits) f32    64 bits (仮数部 52 bits) f64     型の推定・評価は整数型と同じで，リテラル表記時等での型推測の既定は f64 型となる3。\nletx=1.23;//type f64 3. 文字型 文字型 char は Unicode 符号点を示す。 リテラル表記はこんな感じ。\nletc=\u0026#39;♡\u0026#39;;Rust における文字列と文字の関係については「Rust の文字列操作（1）」を参照のこと。\n4. 論理値型 論理値型 bool は true と false の2値のみ取り得る。\n複合型 複合型は複数の要素を組み合わせた型で，タプル型と配列型がある。\n複合型は定義毎に型と要素数が決まっている。 要素の型が全てスカラ型であれば copy semantics で値の受け渡しが可能。\n1. タプル型 タプル型は（名前の通り）複数の型を組み合わせた型で，こんな感じに記述できる。\nfn main(){lettup=(500,6.4,1u8);println!(\u0026#34;tup = {:?}\u0026#34;,tup);//Output: tup = (500, 6.4, 1) }2. 配列型 配列型は，単一の型で構成される複数要素の型で4，こんな感じに記述できる。\nfn main(){letary=[1,2,3];println!(\u0026#34;ary = {:?}\u0026#34;,ary);//Output: ary = [1, 2, 3] }型エイリアス 型の別名定義。 名前は変わっても機能は変わらない。 総称型と組み合わせると吉？\ntype Strings=Vec\u0026lt;String\u0026gt;;fn main(){letplanets: Strings=vec![\u0026#34;Mercury\u0026#34;.to_string(),\u0026#34;Venus\u0026#34;.to_string(),\u0026#34;Earth\u0026#34;.to_string(),\u0026#34;Mars\u0026#34;.to_string(),];planets.iter().for_each(|p|{println!(\u0026#34;{}\u0026#34;,p);});}構造体  0個以上のフィールド（型と名前）を含むデータ構造 構造体に紐づく関連関数およびメソッドを実装可能 トレイトからの実現（realization）が可能。構造体間の継承（inheritance）は不可  struct Planet{name: String,mass: f64,distance: f64,}構造体のインスタンス化 リテラル表現を使ったインスタンス化。\n#[derive(Debug)]struct Planet{name: String,mass: f64,distance: f64,}fn main(){letp=Planet{name: \u0026#34;Earth\u0026#34;.to_string(),mass: 1.0,distance: 1.0,};println!(\u0026#34;{:?}\u0026#34;,p);//Output: Planet { name: \u0026#34;Earth\u0026#34;, mass: 1.0, distance: 1.0 } }インスタンス化関数を実装してみる。\n#[derive(Debug)]struct Planet{name: String,mass: f64,distance: f64,}implPlanet{fn new(s: \u0026amp;str,mass: f64,distance: f64)-\u0026gt; Planet{Planet{name: s.to_string(),mass,distance,}}}fn main(){letp=Planet::new(\u0026#34;Earth\u0026#34;,1.0,1.0);println!(\u0026#34;{:?}\u0026#34;,p);//Output: Planet { name: \u0026#34;Earth\u0026#34;, mass: 1.0, distance: 1.0 } }構造体のコピー コピー用のメソッドを書いてみた。\nimplPlanet{fn copy(\u0026amp;self)-\u0026gt; Planet{Planet{name: self.name.clone(),..*self}}}あるいは derive 構文を使って Clone トレイトから clone() メソッドを自動生成する。\n#[derive(Debug, Clone)]struct Planet{name: String,mass: f64,distance: f64,}fn main(){letp=Planet::new(\u0026#34;Earth\u0026#34;,1.0,1.0);letcpy=p.clone();println!(\u0026#34;{:?}\u0026#34;,p);//Output: Planet { name: \u0026#34;Earth\u0026#34;, mass: 1.0, distance: 1.0 } println!(\u0026#34;{:?}\u0026#34;,cpy);//Output: Planet { name: \u0026#34;Earth\u0026#34;, mass: 1.0, distance: 1.0 } }なお String 等の Copy トレイトを実装できないフィールドを含む構造体は Copy トレイトを実装できないため，代入構文で値のコピーが発生しない。 この場合は move semantics により所有権が移動する。\nタプル構造体 構造体の特殊なパターンで，名前のないフィールドを定義する。 フィールドがタプルで定義される以外は通常の構造体と同じ。 関連関数およびメソッドも実装可能。\n#[derive(Debug, Copy, Clone)]struct Point(i64,i64);implPoint{fn new(x: i64,y: i64)-\u0026gt; Point{Point(x,y)}}fn main(){letp1=Point(1,2);letp2=Point::new(3,4);letp3=p1;//copy semantics println!(\u0026#34;{:?}\u0026#34;,p1);//Output: PPoint(1, 2) println!(\u0026#34;{:?}\u0026#34;,p2);//Output: PPoint(3, 4) println!(\u0026#34;{:?}\u0026#34;,p3);//Output: PPoint(1, 2) }列挙型 Rust の列挙型 enum はどちらかというと関数型プログラミング言語の影響を強く受けているらしい。\nenum VariantType{Int(i32),Float(f64),Text(String),}列挙型の評価には match 式を用いる。\nfn main(){letlist: Vec\u0026lt;VariantType\u0026gt;=vec![VariantType::Int(123),VariantType::Float(1.23),VariantType::Text(\u0026#34;hello\u0026#34;.to_string()),];list.iter().for_each(|e|{matche{VariantType::Int(v)=\u0026gt;println!(\u0026#34;{:#x}\u0026#34;,v),//Output: 0x7b VariantType::Float(v)=\u0026gt;println!(\u0026#34;{:e}\u0026#34;,v),//Output: 1.23e0 VariantType::Text(v)=\u0026gt;println!(\u0026#34;{:?}\u0026#34;,v),//Output: \u0026#34;hello\u0026#34; };});}列挙型も構造体と同じく関連関数やメソッドを実装できる。\nimplVariantType{fn is_integer(\u0026amp;self)-\u0026gt; bool {matchself{VariantType::Int(_)=\u0026gt;true,_=\u0026gt;false,//others }}}fn main(){letlist=vec![VariantType::Int(123),VariantType::Float(1.23),VariantType::Text(\u0026#34;hello\u0026#34;.to_string()),];list.iter().for_each(|e|{println!(\u0026#34;Is {:?} an integer?: {}\u0026#34;,e,e.is_integer());});}総称型 Rust ではオブジェクトの抽象化の手段として総称型をサポートしている。\n関数における総称型 以下の max() 関数で使われる型 T が総称型と呼ばれているもの。\nfn max\u0026lt;T: std::cmp::PartialOrd\u0026gt;(left: T,right: T)-\u0026gt; T{ifleft\u0026gt;=right{left}else{right}}fn main(){letx=1;lety=2;println!(\u0026#34;max({}, {}) = {}\u0026#34;,x,y,max(x,y));//Output: max(1, 2) = 2 }\u0026lt;T: std::cmp::PartialOrd\u0026gt; の表現は型 T の制約条件を示すもので std::cmp::PartialOrd トレイトを実装する型のみ max() 関数が有効になる。 このようなトレイトを使った制約の定義を「トレイト境界（trait bound）」と呼ぶらしい。\nトレイト境界は where 節を使って記述することもできる。\nfn max\u0026lt;T\u0026gt;(left: T,right: T)-\u0026gt; TwhereT: std::cmp::PartialOrd,{ifleft\u0026gt;=right{left}else{right}}トレイト境界の記述は煩雑になりがちなので，これで多少はスッキリするだろう。\nちなみに std::cmp::PartialOrd トレイトは \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;= の順序比較演算子を使うためのもので，少なくとも組み込みデータ型は全て std::cmp::PartialOrd トレイトを実装している。\nたとえば比較可能でない構造体\n#[derive(Debug)]struct Person{age: u32,name: String,}に max() 関数を使おうとしても\nfn max\u0026lt;\u0026#39;a,T: std::cmp::PartialOrd\u0026gt;(left: \u0026amp;\u0026#39;aT,right: \u0026amp;\u0026#39;aT)-\u0026gt; \u0026amp;\u0026#39;aT{ifleft\u0026gt;=right{left}else{right}}fn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};letp2=Person{age: 24,name: \u0026#34;Bob\u0026#34;.to_string(),};println!(\u0026#34;max({:?}, {:?}) = {:?}\u0026#34;,p1,p2,max(\u0026amp;p1,\u0026amp;p2));//Error: can\u0026#39;t compare `Person` with `Person` }コンパイルエラーになる。\n構造体における総称型 構造体のフィールドやメソッドも総称型で記述することができる。\nstruct Point\u0026lt;T\u0026gt;{x: T,y: T,}impl\u0026lt;T\u0026gt;Point\u0026lt;T\u0026gt;{fn new(x: T,y: T)-\u0026gt; Self{Self{x,y}}}impl\u0026lt;T: std::ops::Add\u0026lt;Output=T\u0026gt;+Copy\u0026gt;Point\u0026lt;T\u0026gt;{fn add(\u0026amp;self,p: \u0026amp;Self)-\u0026gt; Self{Self::new(self.x+p.x,self.y+p.y)}}impl\u0026lt;T: std::fmt::Display\u0026gt;std::fmt::DisplayforPoint\u0026lt;T\u0026gt;{fn fmt(\u0026amp;self,dest: \u0026amp;mutstd::fmt::Formatter)-\u0026gt; std::fmt::Result{write!(dest,\u0026#34;\u0026lt;{}, {}\u0026gt;\u0026#34;,self.x,self.y)}}fn main(){letp1=Point::new(1,2);letp2=Point::new(3,4);println!(\u0026#34;{} + {} = {}\u0026#34;,p1,p2,p1.add(\u0026amp;p2));//Output: \u0026lt;1, 2\u0026gt; }上述のように impl 構文毎に個別にトレイト境界を設定できる。\n列挙型における総称型 列挙型も構造体と同じように総称型が使える。 列挙型と総称型の組み合わせでもっとも有名なのが Result 型だろう。\nenum Result\u0026lt;T,E\u0026gt;{Ok(T),Err(E),}参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n  プログラミングRust Jim Blandy (著), Jason Orendorff (著), 中田 秀基 (翻訳) オライリージャパン 2018-08-10 単行本（ソフトカバー） 4873118557 (ASIN), 9784873118550 (EAN), 4873118557 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版あり。公式ドキュメントよりも系統的に書かれているので痒いところに手が届く感じ。ただし量が多いので，一度斜め読みしたらあとは傍らに置いて必要に応じてつまみ食いしていくのがいいだろう。\nreviewed by Spiegel on 2020-03-08 (powered by PA-APIv5)\n   isize/usize は C 言語等でいう int と同じと思って構わない。まぁ，どちらかと言うと size_t みたいな感じかもしれないけど。 \u0026#x21a9;\u0026#xfe0e;\n 現在のアーキテクチャの主流が 64 bits にも関わらず整数型の既定が i32 なのは， 32 bits アクセスのほうが「速い」かららしい。 \u0026#x21a9;\u0026#xfe0e;\n 浮動小数点数型の場合，単精度（f32）と倍精度（f64）の間でパフォーマンス上の違いは殆どないそうだ。それならサイズが大きい方を既定にすればいいよね，ってことらしい。 \u0026#x21a9;\u0026#xfe0e;\n 配列型でも列挙型（enum）と組み合わせることで複数の型に対応させることは可能。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "関数閉包で遊ぶ",
      "section": "rust-lang",
      "description": "関数閉包の記述では fn 構文は使えない。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/closure-and-currying/",
      "published": "2020-04-07T09:55:33+00:00",
      "update": "2020-04-08T07:33:29+00:00",
      "content": "今回は小ネタとして関数閉包（closure）で遊んでみる。 起点となるコードはこれにしよう。\nfn add(x: i32,y: i32)-\u0026gt; i32 {x+y}fn main(){letx=1;lety=2;println!(\u0026#34;{} + {} = {}\u0026#34;,x,y,add(x,y));//Output: 1 + 2 = 3 }add() 関数は見ての通り整数の足し算。 この関数を関数閉包で表してみたい。\n関数閉包で記述する 関数閉包の記述では fn 構文は使えない。 こんな感じに書く。\nfn main(){letadd=|x,y|{x+y};letx=1;lety=2;println!(\u0026#34;{} + {} = {}\u0026#34;,x,y,add(x,y));//Output: 1 + 2 = 3 }|...| で囲まれている部分で引数を定義し {...} で囲まれている部分が関数本体になる。 ちなみに，上のような記述であれば波括弧は省略できる。 ていうか rustfmt コマンドで整形すると問答無用で消される（笑）\nletadd=|x,y|x+y;引数や返り値の型は推論可能であれば省略できるが，型注釈で明示することもできる。\nletadd=|x: i32,y: i32|-\u0026gt; i32 {x+y};この関数閉包をもう少し弄ってみよう。\nスマートポインタ 関数閉包はスマートポインタを表すトレイト Box\u0026lt;T\u0026gt; で囲むことができる。\nfn main(){letadd=Box::new(|x,y|x+y);letx=1;lety=2;println!(\u0026#34;{} + {} = {}\u0026#34;,x,y,add(x,y));//Output: 1 + 2 = 3 }敢えて add に型注釈を付けるとこんな感じになる。\nletadd: Box\u0026lt;dynFn(i32,i32)-\u0026gt; i32\u0026gt;=Box::new(|x,y|x+y);ちなみに Fn は関数閉包を表すトレイトである。\nこれだけでは何も面白くないが，実は「高階関数（higher-order function）」で威力を発揮する。 高階関数の定番といえばアレだよね。 そう「カリー化（currying）」である1。\nカリー化と所有権 では早速 add() 関数をカリー化してみよう。 こんな感じ。\nfn add(x: i32)-\u0026gt; Box\u0026lt;dynFn(i32)-\u0026gt; i32\u0026gt;{Box::new(move|y|x+y)}fn main(){letx=1;lety=2;println!(\u0026#34;{} + {} = {}\u0026#34;,x,y,add(x)(y));//Output: 1 + 2 = 3 letincrement=add(x);//partial application println!(\u0026#34;add({}) -\u0026gt; increment({}) = {}\u0026#34;,x,y,increment(y));//Output: add(1) -\u0026gt; increment(2) = 3 }move キーワードを使って関数閉包内の変数 x の所有権を明示的に移動してる点に注意。 move を付けないと借用とみなされるが add() 関数を抜けるとスコープから外れるためコンパイルエラーになる。\nちなみに関数等のスコープ内であれば，もっと簡単に記述できる。 こんな感じ。\nfn main(){letadd=|x|move|y|x+y;letx=1;lety=2;println!(\u0026#34;{} + {} = {}\u0026#34;,x,y,add(x)(y));//Output: 1 + 2 = 3 letincrement=add(x);//partial application println!(\u0026#34;add({}) -\u0026gt; increment({}) = {}\u0026#34;,x,y,increment(y));//Output: add(1) -\u0026gt; increment(2) = 3 }よーし，うむうむ，よーし。\n参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n  プログラミングRust Jim Blandy (著), Jason Orendorff (著), 中田 秀基 (翻訳) オライリージャパン 2018-08-10 単行本（ソフトカバー） 4873118557 (ASIN), 9784873118550 (EAN), 4873118557 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版あり。公式ドキュメントよりも系統的に書かれているので痒いところに手が届く感じ。ただし量が多いので，一度斜め読みしたらあとは傍らに置いて必要に応じてつまみ食いしていくのがいいだろう。\nreviewed by Spiegel on 2020-03-08 (powered by PA-APIv5)\n   カリー化については拙文「カリー化に関する覚え書き」を参考にどうぞ。 \u0026#x21a9;\u0026#xfe0e;\n   "
    }
  ]
}
