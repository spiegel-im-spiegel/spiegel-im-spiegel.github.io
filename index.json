{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "本当は怖い Blockchain",
      "section": "remark",
      "description": "Blockchain による不正と腐敗",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/10/blockchain-horror/",
      "published": "2020-10-04T01:21:50+00:00",
      "update": "2020-10-04T01:28:01+00:00",
      "content": "なんか Twitter の TL を眺めていると不穏な話ばかり流れてくるのだが，そもそも「デジタル庁」なるものは最初の1フィートで間違えている印象である。 その中でも気になるのが Blockchain が云々とかいう話で，老婆心ながらこの記事でも言及しておく。\nそもそも Blockchain は「通貨」の性質を持つデジタル・トークンの「取引」を扱うための仕組みで，本来は他に転用できない。 トークンが「通貨」の性質を持つことに意味があるからだ。\nでは，それ以外の部分で Blockchain の特徴と言えるものをいくつか挙げると\n 追記型データベースで，追記されたデータについて完全性（integrity）を保証する PoW (Proof-of-Work) によって追記するデータが正しい（誤りがない）ことを保証する1  PoW の対価として「通貨」の性質を持つデジタル・トークンを振り出す（または手数料を払う） PoW の結果の正しさは多数決で保証する   非中央集権型（decentralization）かつ peer-to-peer なシステム構成を前提とする 不特定多数が参加することを前提とする データベースのコピーは自由だが分岐（fork）は無用 公開鍵を ID としてそのまま用い，鍵の証明（certification）を行わない  といったところだろうか。\nなお，3番目から5番目までは2番目の PoW を達成するための要件である点に注意。 まぁ Blockchain 本家である Bitcoin は既に3番目と5番目の要件が瓦解しているのだが（笑）\n6番目についてもう少し詳しく書くと Blockchain は ID となる公開鍵が誰に帰属するかについて全く関知しない。 Blockchain が気にするのは取引履歴の一貫性と無矛盾性であり，この要件が達成されているなら取引を行ったのが「誰か」なんてどうでもいいのだ2。\nしかし実際には取引の主体となる「誰か」という情報は最重要であると言っていい。 したがって ID と「誰か」を関連付ける別の仕掛けが必要となる。 たとえば「ウォレット・サービス」とか「交換所」とか。\nBlockchain で「取引」を追記するためには当事者の秘密鍵で電子署名する必要があり，もし「交換所」等でそれを肩代わりしてもらうなら秘密鍵を預けなければならない（key escrow）。 まぁ銀行に通帳とキャッシュカードを預けるみたいなもんだね。 鬼畜（笑）\nさて，ここで問題。\n 中央集権的またはアクターが構造化されたシステム 特定の「誰か」のみシステム内部にコミットできる データの分岐（fork）を許容する  という3条件のいずれかの下で Blockchain を応用したシステムを導入したら何が起きるか。\n\u0026hellip;\u0026hellip;\n正解は「不正」と「腐敗（不正の常態化）」。 何故なら PoW 達成要件を満たさないから。\n行政システムなんてまさに上の3条件に当てはまるよね。 それで Blockchain を導入するとか，システムとして「不正」と「腐敗」を許容する，と言っているに等しい。\nあー，コワイコワイ。\nブックマーク  “Blockchain and Trust” by Bruce Schneier    PoW の代替となる PoS (Proof-of-Stake) というのもあるが，ここでは割愛する。 PoS をザクッと説明すると「金持ち（の行動）は信用できる」とする仕組みだ。その通貨システムの「金持ち」なら不正をしてまで信用を破壊しないだろうという，ある意味で性善説（笑） \u0026#x21a9;\u0026#xfe0e;\n Bitcoin/Blockchain の「公開鍵が誰に帰属するかについては全く関知しない」という特徴を以って，これを匿名的なサービスと言っていた人も昔はいたが， Blockchain の外側で ID (＝公開鍵) とそれが帰属する「誰か」を紐付けることができるなら， Blockchain を解析してその「誰か」がしたことは分かるわけだ。実際にそういう調査を行う会社とかも存在する。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "バイト列の同値性（『プログラミング言語 Go』読書会より）",
      "section": "golang",
      "description": "色んな方法で比較してみる",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/equality-of-byte-arrays/",
      "published": "2020-10-03T10:27:34+00:00",
      "update": "2020-10-03T10:30:51+00:00",
      "content": "「第5回『プログラミング言語Go』オンライン読書会」に参加してみたです。\n以前 Discord で某エベントに参加したことがあったけど，やっぱオンラインイベントはしんどい。 それでもメインで喋る人が決まってるから，今回は楽なほうだったかな。 Discord にしろ Zoom にしろ，オンラインでフリートーク・イベントはかなり難しいと思うのだが，みんなどうしてるんだろう。\n閑話休題 (それはさておき) 。\n今回，のっけから面白い話を聞いた。 『プログラミング言語 Go』4.2章「スライス」に書かれている\n 配列と異なりスライスは比較可能ではありませんので，二つのスライスが同じ要素で構成されているかを検査するために == は使えません。標準ライブラリは二つのバイトスライス（[]byte）を比較するために高度に最適化された bytes.Equal 関数を提供しています。しかし… プログラミング言語 Goより  という部分（強調は私がやりました）。 実際にコードを見てみると\n// Equal reports whether a and b // are the same length and contain the same bytes. // A nil argument is equivalent to an empty slice. func Equal(a, b []byte) bool { // Neither cmd/compile nor gccgo allocates for these string conversions. \treturn string(a) == string(b) } てなことになっている。 で，「これのどこが『高度に最適化』なん？」という話があったらしい。\nバージョンを遡ってみると 1.12.7 までは\n// Equal returns a boolean reporting whether a and b // are the same length and contain the same bytes. // A nil argument is equivalent to an empty slice. func Equal(a, b []byte) bool { return bytealg.Equal(a, b) } となっていた。 ちなみに internal/bytealg は内部パッケージで，中身はほぼ（アーキテクチャ毎に）アセンブラで記述されている。 実は Go 1.13 では string 周りが大幅に強化されていて，その辺の影響が出ているのかもしれない。\nそれなら，どの程度のパフォーマンスか気になるよね。 というわけで，こんなコードを用意してみた1。\npackage eq import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; ) var ( hello1 = \u0026#34;I could tell you my pass phrase, but then I would have to kill you.\u0026#34; hello2 = \u0026#34;I could tell you my pass phrase, but then I would have to kill you.\u0026#34; helloA1 = [67]byte{0x49, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6d, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x49, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x2e} helloA2 = [67]byte{0x49, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6d, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x49, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x2e} helloS1 = []byte{0x49, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6d, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x49, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x2e} helloS2 = []byte{0x49, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6d, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x49, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x2e} ) func BenchmarkByteEqual1(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if hello1 != hello2 { fmt.Printf(\u0026#34;false\u0026#34;) } } } func BenchmarkByteEqual2(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if !bytes.Equal([]byte(hello1), []byte(hello2)) { fmt.Printf(\u0026#34;false\u0026#34;) } } } func BenchmarkByteEqual3(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if helloA1 != helloA2 { fmt.Printf(\u0026#34;false\u0026#34;) } } } func BenchmarkByteEqual4(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if string(helloA1[:]) != string(helloA2[:]) { fmt.Printf(\u0026#34;false\u0026#34;) } } } func BenchmarkByteEqual5(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if !bytes.Equal(helloA1[:], helloA2[:]) { fmt.Printf(\u0026#34;false\u0026#34;) } } } func BenchmarkByteEqual6(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if string(helloS1) != string(helloS2) { fmt.Printf(\u0026#34;false\u0026#34;) } } } func BenchmarkByteEqual7(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if !bytes.Equal(helloS1, helloS2) { fmt.Printf(\u0026#34;false\u0026#34;) } } } hello1, hello2 は string 型，helloA1, helloA2 は byte 配列，helloS1, helloS2 は []byte 型で中身はみんな同じ。 これらを使って同値性（equallity）をチェックするのだが，内訳はこんな感じ。\n   関数名 比較手順     BenchmarkByteEqual1 string == string   BenchmarkByteEqual2 bytes.Equal([]byte(string), []byte(string))   BenchmarkByteEqual3 \u0026lt;byte array\u0026gt; == \u0026lt;byte array\u0026gt;   BenchmarkByteEqual4 string(\u0026lt;array\u0026gt;[:]) == string(\u0026lt;array\u0026gt;[:])   BenchmarkByteEqual5 bytes.Equal(\u0026lt;array\u0026gt;[:], \u0026lt;array\u0026gt;[:])   BenchmarkByteEqual6 string([]byte) == string([]byte)   BenchmarkByteEqual7 bytes.Equal([]byte, []byte)    では，実際に動かしてみようか。\n$ go test -bench ByteEqual -benchmem goos: linux goarch: amd64 pkg: sample BenchmarkByteEqual1-4 301173402\t4.04 ns/op\t0 B/op\t0 allocs/op BenchmarkByteEqual2-4 8552673\t122 ns/op\t160 B/op\t2 allocs/op BenchmarkByteEqual3-4 182939372\t6.27 ns/op\t0 B/op\t0 allocs/op BenchmarkByteEqual4-4 191359716\t6.29 ns/op\t0 B/op\t0 allocs/op BenchmarkByteEqual5-4 191511163\t6.27 ns/op\t0 B/op\t0 allocs/op BenchmarkByteEqual6-4 168382664\t7.16 ns/op\t0 B/op\t0 allocs/op BenchmarkByteEqual7-4 167058468\t7.06 ns/op\t0 B/op\t0 allocs/op PASS ok sample\t12.140s 分かりやすく表にしておく。\n   比較手順 処理時間 (ns/op) Alloc 回数     string == string 4.04 0   bytes.Equal([]byte(string), []byte(string)) 122.00 2   \u0026lt;byte array\u0026gt; == \u0026lt;byte array\u0026gt; 6.27 0   string(\u0026lt;array\u0026gt;[:]) == string(array\u0026gt;[:]) 6.29 0   bytes.Equal(array\u0026gt;[:], \u0026lt;array\u0026gt;[:]) 6.27 0   string([]byte) == string([]byte) 7.16 0   bytes.Equal([]byte, []byte) 7.06 0    string → []byte へのキャスト時にアロケーションが発生している点に注意。\nつか string 同士の比較処理が速いな！ 配列と slice で若干差が出るのは仕方ないが，元が同じ型なら殆ど差がないようだ。 まぁ，これなら確かに\nfunc Equal(a, b []byte) bool { return string(a) == string(b) } でもいっか，って気になるよな。\nブックマーク  【改訂版】文字列連結はどれが速い？  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n   ちなみに “I could tell you my pass phrase, but then I would have to kill you.” という物騒なフレーズは Simson Garfinkel 氏の『PGP』に載っていたパスフレーズの事例である（笑） \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Go 製のツールとパッケージをまとめてアップデートした",
      "section": "release",
      "description": "Update gpgpdump, books-data, gnkf, pa-api, aozora-api, openbd-api, gocli, and errs packages",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/10/released-tools-and-packages-by-golang/",
      "published": "2020-10-02T07:40:54+00:00",
      "update": "2020-10-02T07:43:41+00:00",
      "content": "GitHub リポジトリにある Go 言語製のツールやパッケージについて GitHub Actions で CI (Continuous Integration) を回す目処が立ったので，設定を変更しリリースし直すことにした。 今回リリースしたツール・パッケージのうち主なものは以下の通り。\n Release v0.9.1 · spiegel-im-spiegel/gpgpdump · GitHub Release v0.5.8 · spiegel-im-spiegel/books-data · GitHub Release v0.1.3 · spiegel-im-spiegel/gnkf · GitHub Release v0.7.2 · spiegel-im-spiegel/pa-api · GitHub Release v0.2.6 · spiegel-im-spiegel/aozora-api · GitHub Release v0.2.6 · spiegel-im-spiegel/openbd-api · GitHub Release v0.10.3 · spiegel-im-spiegel/gocli · GitHub Release v1.0.2 · spiegel-im-spiegel/errs · GitHub  若干 lint に叱られたり軽微なバグを指摘されたりしたものもあるが，機能上の追加・変更はない。\nそれじゃあ，次のステージに行きましょう♪\nブックマーク   OpenPGP パケットを可視化する gpgpdump\n  書籍データ取得ツール books-data\n  GNKF: Network Kanji Filter by Golang\n  Go 言語用 PA-API v5 クライアント・パッケージ\n  Go 言語用青空文庫 API クライアント・パッケージ\n  Go 言語用 openBD クライアント・パッケージ\n  Go 言語用 CLI プログラミング支援パッケージ\n  Go 言語用エラーハンドリング・パッケージ\n  golangci-lint を GitHub Actions で使う\n  Go 依存パッケージの脆弱性検査\n  GitHub Actions でクロス・コンパイル（GoReleaser 編）\n  Go のコードでも GitHub Code Scanning が使えるらしい\n  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n  射手座☆午後九時Don\u0026#39;t be late シェリル・ノーム starring May\u0026#39;n (メインアーティスト) FlyingDog 2008-05-08 (Release 2017-01-16) MP3 ダウンロード B01MZ8UA8O (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  移動中に聴くとノリノリになれる（笑）\nreviewed by Spiegel on 2020-10-02 (powered by PA-APIv5)\n "
    },
    {
      "title": "Go のコードでも GitHub Code Scanning が使えるらしい",
      "section": "remark",
      "description": "うん。簡単！",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/10/github-code-scanning-with-golang/",
      "published": "2020-10-01T09:03:46+00:00",
      "update": "2020-10-01T09:20:19+00:00",
      "content": "GitHub の Code Scanning 機能が全ユーザで有効になった。\n Code scanning is now available! - The GitHub Blog GitHub、コードの脆弱性を検出する「Code Scanning」を全ユーザーに提供 - ZDNet Japan  「えー。どうせ Go 言語では使えないんでしょ？」と思ったが， C/C++, C#, Go, Java, JavaScript/TypeScript, Python で有効らしい。 というわけで，とりあえず手持ちの Go パッケージのリポジトリで試してみた。\nCode Scanning は各リポジトリの “Security” で設定できる。\n 一番下の “Code scanning alerts” の [Set up code scanning] ボタンを押す。 次に表示される以下の画面で\n [Set up this workflow] ボタンを押す。\nすると GitHub Actions 用の YAML ファイル編集画面が表示される。 今回は Go コードのリポジトリなので，こんな感じの内容になった。\n# For most projects, this workflow file will not need changing; you simply need# to commit it to your repository.## You may wish to alter this file to override the set of languages analyzed,# or to provide custom queries or build logic.name:\u0026#34;CodeQL\u0026#34;on:push:branches:[master]pull_request:# The branches below must be a subset of the branches abovebranches:[master]schedule:- cron:\u0026#39;0 6 * * 4\u0026#39;jobs:analyze:name:Analyzeruns-on:ubuntu-lateststrategy:fail-fast:falsematrix:# Override automatic language detection by changing the below list# Supported options are [\u0026#39;csharp\u0026#39;, \u0026#39;cpp\u0026#39;, \u0026#39;go\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;javascript\u0026#39;, \u0026#39;python\u0026#39;]language:[\u0026#39;go\u0026#39;]# Learn more...# https://docs.github.com/en/github/finding-security-vulnerabilities-and-errors-in-your-code/configuring-code-scanning#overriding-automatic-language-detectionsteps:- name:Checkout repositoryuses:actions/checkout@v2with:# We must fetch at least the immediate parents so that if this is# a pull request then we can checkout the head.fetch-depth:2# If this run was triggered by a pull request event, then checkout# the head of the pull request instead of the merge commit.- run:git checkout HEAD^2if:${{ github.event_name == \u0026#39;pull_request\u0026#39; }}# Initializes the CodeQL tools for scanning.- name:Initialize CodeQLuses:github/codeql-action/init@v1with:languages:${{ matrix.language }}# If you wish to specify custom queries, you can do so here or in a config file.# By default, queries listed here will override any specified in a config file. # Prefix the list here with \u0026#34;+\u0026#34; to use these queries and those in the config file.# queries: ./path/to/local/query, your-org/your-repo/queries@main# Autobuild attempts to build any compiled languages (C/C++, C#, or Java).# If this step fails, then you should remove it and run the build manually (see below)- name:Autobuilduses:github/codeql-action/autobuild@v1# ℹ️ Command-line programs to run using the OS shell.# 📚 https://git.io/JvXDl# ✏️ If the Autobuild fails above, remove it and uncomment the following three lines# and modify them (or add more) to build your code if your project# uses a compiled language#- run: |# make bootstrap# make release- name:Perform CodeQL Analysisuses:github/codeql-action/analyze@v1Go コードの検査だけならこのままコミットしてしまって構わない。 ちなみにコミットする場合は master ブランチ1 に対してではなく pull request 用のブランチを作ってそこにコミットしたほうがよい。 そうすれば PR 時に上記設定の action が走るので動作確認になるだろう。\nうん。 簡単！\nブックマーク  Github Code Scanning Workflow syntax for GitHub Actions - GitHub Docs Go 依存パッケージの脆弱性検査    2020年10月から GitHub の新規リポジトリの既定ブランチ名が main になるらしい。ご注意を。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "国勢調査の思ひ出",
      "section": "remark",
      "description": "まだ回答してない人でネット回答可能であれば，ネットのほうが断然楽。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/10/census/",
      "published": "2020-10-01T03:09:11+00:00",
      "update": "2020-10-01T05:00:06+00:00",
      "content": "知り合いのブログ記事で\n 国勢調査オンライン - 電気ウナギ的○○  というのがあって「そういや前回はネットで回答したな」と思い出して作業用リポジトリに grep かけて探してみたらやっぱり書いてた。\n 国勢調査を片付けた  なんでも記事にしておくものである。 5年前の私 good work!\nあの会社は今 当時は「国勢調査オンライン」のサイト証明書は Symantec 社が発行していて，ページにデカデカとロゴが貼り付けてあって苦笑したものだが，当の Symantec 社は CA 事業の不祥事で Web ブラウザのベンダ企業から信用されなくなり，2017年に事業を手放している。\n Symantec→DigiCertでSSL/TLS証明書はどうなる？　日本国内にも認証局構築へ、IoT機器市場も見据え - INTERNET Watch  今回はどうしてるんだろうと見てみたら DigiCert 社だったよ。 何も変わってないな（笑）\nそういや DigiCert 社のルート CA 証明書は RSA/2048 鍵で2031年まで有効なんだよな。 ちなみに RSA/2048 鍵が acceptable なのは2030年までだ。 まぁ鼻の先は問題ないが，政府調達品でこの程度の認識しかない企業を使うのはどうなんだろう。\n【追記】 Facebook で教えてもらったが DigiCert 社の CA 証明書はよりサイクルの短いものに順次切り替えていくそうだ。 Web 用のサーバ証明書は長くても1年程度のサイクルになる筈だし，数年かけて切り替えていくイメージだろうか。 なりすましと本人確認 そういや5年前はうっかり Phishing サイトを作って怒られた輩がいて話題になった。\n 国勢調査の“偽サイト”作った意図は？　総務省から削除依頼……「騒ぎになり深く反省」と制作者 (1/3) - ITmedia ニュース  最近の「ドコモロ系事案」を引くまでもなく，なりすましや本人確認は古くて新しい問題であり続ける。 このご時世に「オンライン推奨」とか現政権は勇気あるな（皮肉）\n国勢調査が面白いのは，基本的に「戸」単位であり，その枠組みの中で識別できていれば「本人確認」は必ずしも必要条件ではないということだ。 そして，その「戸」単位の確認を行うのが「国勢調査員」である。 これは紙でもネットでも同じこと。 ネットで回答するにしても，そのアカウント情報は国勢調査員から貰わなければならない。\nそもそも路上生活者とかにも国勢調査員が出向いて聞き取り調査するんだよ。 日本語が通じない人達だって相当数いるだろうに，ホンマ国勢調査員のご苦労は察するにあまりある。\n故に「『コロナ』だからオンライン推奨」というのは全く以って詭弁である。 ちなみに，今回うちで国勢調査の回答をしたのは親父殿だが，パソコンもスマホも持ってないので紙で回答したらしい。 私？ 私はただの居候ですから（笑）\n「国勢調査オンライン」はダサいか どうも「国勢調査オンライン」のサイトをダサいとか文句を言ってる人がいるらしい。 まぁ今風ではないな（笑）\n今回は私は回答してないのでどうだったかは知らないが，前回ネットで回答してめっさ楽だったのは覚えている。 ぶっちゃけて言うが\n政府系サイトに SEO (屁のつっぱり)  は要らんですよ そもそも Web アクセシビリティってそんな簡単じゃない。 うちのサイトもそうだけど，本当に不特定に見易い使い易いサイトなんか無理である。 このブログサイトをダークモードにしてるのは，主に「私」のためだ。\nできるだけ多くの人に対応しようとして結果として今風じゃないデザインになったとしても，利用者が文句を言う筋合いじゃないのだ。 機能要件やセキュリティ要件を満たしていない部分があるのなら，文句を言って然るべきだけど（笑）\nというわけで，まだ回答してない人でネット回答可能であれば，ネットのほうが断然楽なので，お試しあれ。\nいまさら思い出したが\u0026hellip; このブログサイト，正式オープンから5周年だわ。 何も考えてなかった。\nまぁ，この前買ったタブレットがご褒美ということで（笑）\nブックマーク  NIST SP 800-207: “Zero Trust Architecture” Authenticator と AAL  "
    },
    {
      "title": "GitHub Actions でクロス・コンパイル（GoReleaser 編）",
      "section": "golang",
      "description": "公式の GitHub Action があるので，それを使えばよい。簡単！",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/cross-compiling-in-github-actions-with-goreleaser/",
      "published": "2020-09-30T06:14:35+00:00",
      "update": "2020-09-30T07:22:49+00:00",
      "content": "以前（3年前だ！）に Travis CI と GoReleaser でクロス・コンパイル\u0026amp;デプロイを行う方法を紹介したが，今回は GitHub Actions を使う方法を紹介する。 なお GoReleaser 自体の説明については（だいぶ内容が古いが）以下の記事を参考にどうぞ。\n Travis CI でクロス・コンパイル（GoReleaser 編）  紹介と言っても公式の GitHub Action があるので，それを使えばよい。\n goreleaser/goreleaser-action: GitHub Action for GoReleaser  リポジトリの .github/workflows/ ディレクトリに YAML ファイル（例えば build.yml）を置き，以下のように記述する。\nname:buildon:push:tags:- v*jobs:goreleaser:runs-on:ubuntu-lateststeps:- name:Checkoutuses:actions/checkout@v2with:fetch-depth:0- name:Set up Gouses:actions/setup-go@v2with:go-version:1.15- name:Run GoReleaseruses:goreleaser/goreleaser-action@v2with:version:latestargs:release --rm-distenv:GITHUB_TOKEN:${{ secrets.GITHUB_TOKEN }}これでバージョンタグを打った際に GoReleaser によるクロス・コンパイルとデプロイが走る。 簡単！\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "Go 依存パッケージの脆弱性検査",
      "section": "golang",
      "description": "nancy を使うのがよさげである。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/check-for-vulns-in-golang-dependencies/",
      "published": "2020-09-30T03:49:21+00:00",
      "update": "2020-09-30T06:15:03+00:00",
      "content": "どの言語でも同じだけど，インポートする外部パッケージが安全かどうかを調べるのはけっこう大変である。 で， Go 言語の場合は nancy を使うのがよさげである。\n sonatype-nexus-community/nancy: A tool to check for vulnerabilities in your Golang dependencies, powered by Sonatype OSS Index  nancy は “Sonatype OSS Index” の情報を使って依存パッケージ／モジュールの検査をしてくれる。 ツール自体は Apache-2.0 でライセンスされている。 提供されているデータについては\nOSS Index and the associated tools are and always will be free to the community. The data we gather is derived from public sources, and does not include human curated intelligence nor expert remediation guidance. via Sonatype OSS Index  とあるので，オープンな場で使うなら問題ないかな。\n使い方は簡単で，開発中のパッケージのリポジトリ上で\n$ go list -json -m all | nancy sleuth とすればよい。 問題なければ\n$ go list -json -m all | nancy sleuth -n ┏━━━━━━━━━━━━━━━┓ ┃ Summary ┃ ┣━━━━━━━━━━━━━┳━┫ ┃ Audited Dependencies ┃ 9┃ ┣━━━━━━━━━━━━━╋━┫ ┃ Vulnerable Dependencies ┃ 0┃ ┗━━━━━━━━━━━━━┻━┛  みたいな感じで結果を返してくれる。 問題のあるパッケージ／モジュールを含んでると，ものすごい勢いで叱られるけど（笑）\nGitHub Actions でも使える nancy には GitHub Actions も用意されている。 ありがたや。\n sonatype-nexus-community/nancy-github-action: Sonatype Nancy for GitHub Actions  設定は簡単。 リポジトリの .github/workflows/ ディレクトリに YAML ファイル（例えば vulns.yml）を置き，以下のように記述する。\nname:vulnson:push:tags:- v*branches:- masterpull_request:jobs:vulns:name:Vulnerability scannerruns-on:ubuntu-lateststeps:- uses:actions/checkout@v2- uses:actions/setup-go@v2with:go-version:^1.13- name:WriteGoListrun:go list -json -m all \u0026gt; go.list- name:Nancyuses:sonatype-nexus-community/nancy-github-action@mainこれで pull request 時， master ブランチ1 への push 時，およびバージョンタグを打った際に脆弱性検査が走る。\n依存の依存パッケージに脆弱性がある 直接インポートするパッケージに脆弱性があるなら無害なバージョンに差し替えればいいけど，依存パッケージが依存しているパッケージに脆弱性がある場合はどうするか。\nとりあえず，そのパッケージ宛てには issue を投げておくとして，それまでの継ぎとしては go.mod ファイルの replace ディレクティブを使って凌ぐことができそうだ。\nたとえば，依存パッケージが github.com/coreos/etcd v3.3.13 に依存してるんだけど v3.3.13 に脆弱性がある場合，\nreplace ( github.com/coreos/etcd v3.3.13+incompatible =\u0026gt; github.com/coreos/etcd v3.3.25+incompatible ) などとして無害なバージョンに差し替えできる。\nrequire ディレクティブで\nrequire ( github.com/coreos/etcd v3.3.25+incompatible ) とか書いても同じ効果があるけど，名目だけの依存関係で実際にはインポートしないパッケージは go mod tidy コマンドで記述が削除されちゃうのでオススメできない。\ngo list -m all って，実際にはリンクしない名目上の依存関係も全部拾ってリストアップしちゃうので，凄い面倒くさいんだよねぇ。 実際にリンクするパッケージだけリストアップしてくれないものだろうか\u0026hellip;\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n   2020年10月から GitHub の新規リポジトリの既定ブランチ名が main になるらしい。ご注意を。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2020年10月の暦",
      "section": "remark",
      "description": "どっかの馬鹿な国際スポーツ大会のせいで今年の10月の祝日はなくなりました orz",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/09/ephemeris-202010/",
      "published": "2020-09-30T01:49:54+00:00",
      "update": "2020-09-30T01:53:56+00:00",
      "content": "2020年10月も spiegel-im-spiegel/koyomi パッケージを作って暦を浚ってみる。 なお spiegel-im-spiegel/koyomi パッケージは v0.1.5 をリリースしている。 今回も外部パッケージのバージョンを上げただけだけど。\n国立天文台のデータを使っているため，暦象の基準が日本の暦になっている点に注意。\n   日付 内容     2020-10-02 望(満月)   2020-10-02 水星が東方最大離角   2020-10-06 火星が地球最近   2020-10-08 寒露   2020-10-10 下弦   2020-10-14 火星が衝   2020-10-14 水星が留   2020-10-17 朔(新月)   2020-10-20 土用の入り   2020-10-23 上弦   2020-10-23 霜降   2020-10-26 水星が内合   2020-10-31 望(満月)    そうそう。 どっかの馬鹿な国際スポーツ大会のせいで今年の10月の祝日はなくなりました orz\n天象 各用語の意味は以下の通り。\n   天象 - 国立天文台暦計算室より  「留」とは「惑星の地心視赤経の時間変化が0、すなわち赤経方向の動きが止まる瞬間」，もっと簡単に言うと天球上の（見かけの）惑星の動きが反転する瞬間を指す。\n火星が最接近 既に十分見頃だが火星が 2020-10-06 に最接近となる。 つっても中接近くらいだけど。\n中秋の名月とブルームーン 今年は 2020-10-01 が中秋の名月で，翌2日が望（満月）である。 そんで，10月最終日の日付が変わる直前（23:49）に2回目の望となる。 いわゆる「ブルームーン」である。\n実は「月内2回目の満月」をブルームーンと呼ぶのは天文雑誌 “Sky \u0026amp; Telescope” による誤解なのだが，けっこう定着しちゃってる感がある（笑） 元々は “Once in a blue moon” といって「ありえないこと」とか「滅多にないこと」を指す慣用句で，世界各地に逸話や伝説があるらしい。\n土用の入り 「土用の入り」は雑節のひとつで，元々は「五行説」の考えから来たものである。\n四季を「五行説」に当てはめようとするとひとつ足らなくなるので，各季節の終わりの1/5ずつを集めて土の季節つまり「土用」としたそうな。 無理やりですねぇ（笑）\n現在の定義では太陽黄経が 27°, 117°, 207°, 297° となる日が「土用の入り」となる。\nコード 今回使用したコードは以下の通り。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/koyomi\u0026#34; ) func main() { start, _ := koyomi.DateFrom(\u0026#34;2020-10-01\u0026#34;) end, _ := koyomi.DateFrom(\u0026#34;2020-10-31\u0026#34;) k, err := koyomi.NewSource( koyomi.WithCalendarID( koyomi.Holiday, koyomi.MoonPhase, koyomi.SolarTerm, koyomi.Eclipse, koyomi.Planet, ), koyomi.WithStartDate(start), koyomi.WithEndDate(end), ).Get() if err != nil { fmt.Fprintln(os.Stderr, err) return } fmt.Println(\u0026#34;| 日付 | 内容 |\u0026#34;) fmt.Println(\u0026#34;| ---- | ---- |\u0026#34;) for _, e := range k.Events() { fmt.Printf(\u0026#34;| %v | %v |\\n\u0026#34;, e.Date, e.Title) } } ブックマーク   暦Wiki/季節/雑節とは？ - 国立天文台暦計算室\n  火星最接近2020 | 国立天文台(NAOJ)\n  2020年の主な暦象\n  日本の暦情報を取得するパッケージを作ってみた\n  参考図書  天文年鑑 2020年版 天文年鑑 編集委員会 (編集) 誠文堂新光社 2019-11-20 単行本 4416719485 (ASIN), 9784416719480 (EAN), 4416719485 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  天文ファン必携。2020年版。\nreviewed by Spiegel on 2019-11-23 (powered by PA-APIv5)\n "
    },
    {
      "title": "golangci-lint を GitHub Actions で使う",
      "section": "golang",
      "description": "これで pull request 時に golangci-lint が走る。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/using-golangci-lint-action/",
      "published": "2020-09-29T02:20:19+00:00",
      "update": "2020-09-30T07:22:49+00:00",
      "content": "golangci-lint は go vet をはじめ複数の lint を集約して結果を表示してくれる優れものである。 かつては GolangCI.com で GitHub と連携できていたのだが，2020年4月でサービスが停止してしまい，寂しい限り。\nと思っていたのだが，いつの間にか公式の GitHub Actions が用意されていた。 気付かなんだよ。 不覚。\n golangci/golangci-lint-action: Official GitHub action for golangci-lint from it\u0026rsquo;s authors  使い方は簡単。 リポジトリの .github/workflows/ ディレクトリに YAML ファイル（例えば lint.yml）を置き，以下のように記述する。\nname:golangci-linton:push:tags:- v*branches:- masterpull_request:jobs:golangci:strategy:matrix:go-version:[1.15.x]os:[ubuntu-latest, macos-latest, windows-latest]name:lintruns-on:${{ matrix.os }}steps:- uses:actions/checkout@v2- name:golangci-lintuses:golangci/golangci-lint-action@v2with:# Required: the version of golangci-lint is required and must be specified without patch version: we always use the latest patch version.version:v1.31# Optional: working directory, useful for monorepos# working-directory: somedir# Optional: golangci-lint command line arguments.# args: --issues-exit-code=0# Optional: show only new issues if it\u0026#39;s a pull request. The default value is `false`.# only-new-issues: trueまた，リポジトリ直下の .gitattributes ファイルに以下の記述を追加する。\n*.go text eol=lf これで pull request 時， master ブランチ1 への push 時，およびバージョンタグを打った際に golangci-lint が走る。 golangci-lint は matrix の組み合わせで並列処理されるようだ。\n よーし，うむうむ，よーし。\nまぁ，プラットフォーム依存のコードでもない限り Go 最新バージョンの ubuntu-latest だけでいいと思うけどね。\nブックマーク  golangci/golangci-lint: Fast linters Runner for Go golangci-lint に叱られる  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n   2020年10月から GitHub の新規リポジトリの既定ブランチ名が main になるらしい。ご注意を。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Authenticator と AAL",
      "section": "remark",
      "description": "どうも日本の金融界は「リスク感度が鈍い」そうなので，自衛のためにも2017年にリリースされた NIST SP 800-63-3 をベースに少しお勉強しておく。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/09/authenticator-and-aal/",
      "published": "2020-09-27T10:45:38+00:00",
      "update": "2020-09-27T11:01:38+00:00",
      "content": "どうも日本の金融界は「リスク感度が鈍い」そうなので，自衛のためにも2017年にリリースされた NIST SP 800-63-3 をベースに少しお勉強しておく。\n NIST Special Publication 800-63-3: Digital Identity Guidelines NIST Special Publication 800-63A: Enrollment and Identity Proofing NIST Special Publication 800-63B: Authentication and Lifecycle Management NIST Special Publication 800-63C: Federation and Assertions  SP 800-63-3 といえばパスワード運用で当時は話題になった。\n 「パスワードのベストプラクティス」が変わる  このパスワード話が出てくるのが SP 800-63B だが，このドキュメントでは Authenticator 全体について色々と書かれている。\nAuthenticator Authenticator について適切な日本語が見当たらないが，強いて言うなら「認証機能」あるいは「認証器」といったところだろうか。 たとえばパスワードも Authenticator だし，スマホにインストールした TOTP アプリも Authenticator だ。 Yubikey なんかの暗号デバイスも Authenticator に含まれる。\nSP 800-63B では Authenticator を以下の9つに分類している。\n   種別名 認証要素     Memorized Secrets\n記憶シークレット 知識   Look-Up Secrets\nルックアップ・シークレット 所有   Out-of-Band Devices\n経路外デバイス 所有   Single-Factor OTP Device\n単要素 OTP デバイス 所有   Multi-Factor OTP Devices\n多要素 OTP デバイス 所有＋知識／生体   Single-Factor Cryptographic Software\n単要素暗号ソフトウェア 所有   Single-Factor Cryptographic Devices\n単要素暗号デバイス 所有   Multi-Factor Cryptographic Software\n多要素暗号ソフトウェア 所有＋知識／生体   Multi-Factor Cryptographic Devices\n多要素暗号デバイス 所有＋知識／生体    また，各 Authenticator の例としては以下のものが挙げられる。\n   Authenticator 具体例     記憶シークレット パスワード，PINコード   ルックアップ・シークレット 乱数表，認証失敗時のリカバリコード   経路外デバイス SMS によるコード送信， QR コード（電子メールや VoIP は認められない）   単要素 OTP デバイス アクティベーションを必要としない OTP デバイスまたはソフトウェア   多要素 OTP デバイス アクティベーションを行った上で利用可能な OTP デバイスまたはソフトウェア   単要素暗号ソフトウェア セキュアなストレージ上で保護されている暗号鍵   単要素暗号デバイス FIDO U2F の USB ドングル   多要素暗号ソフトウェア 単要素暗号ソフトウェアに対して追加のアクティベーションを必要とするもの   多要素暗号デバイス 単要素暗号デバイスに対して追加のアクティベーションを必要とするもの    Authenticator Assurance Level さらに SP 800-63B では AAL (Authenticator Assurance Level) を定義している。 AAL は 1 〜 3 の3段階あり，それぞれ以下に示す Authenticator の組み合わせを許容している。\n AAL 1 では9種の Authenticator 全て許容され，単要素の認証で OK AAL 2 では以下に示す通り複数の認証要素による多要素認証が必要：  多要素 OTP デバイス 多要素暗号ソフトウェア 多要素暗号デバイス 記憶シークレット＋以下  ルックアップ・シークレット 経路外デバイス 単要素 OTP デバイス 単要素暗号ソフトウェア 単要素暗号デバイス     AAL 3 では以下に示す通り，暗号鍵の所持証明要素とハードウェア関与を含む複数の認証要素による多要素認証が必要：  多要素暗号デバイス 単要素暗号デバイス＋記憶シークレット 多要素OTPデバイス(SW/HW)＋単要素暗号デバイス 多要素OTPデバイス(HW)＋単要素暗号ソフトウェア 単要素OTPデバイス(HW)＋多要素暗号ソフトウェア 単要素OTPデバイス(HW)＋単暗号ソフトウェア＋記憶シークレット    AAL の各レベルごとに要求されるセキュリティ事項（一部）は以下の通り。\n   要求事項 AAL 1 AAL 2 AAL 3     中間者攻撃耐性 必須 必須 必須   Verifier なりすまし耐性 不要 不要 必須   Verifier 改ざん耐性 不要 不要 必須   リプレイ耐性 不要 必須 必須   認証意図（AuthN Inbtent） 不要 推奨 必須   レコード保持ポリシー 必須 必須 必須   プライバシー統制 必須 必須 必須    金融系サービスの subscriber 確認で乗っ取りやなりすましを防ぎたいなら AAL 3 で何らかの物理暗号デバイスが必要だと思うけどねー。\n格子型の乱数表は NG 現在は使ってるところはないだろうが，かつてネットバンキングでよく見られた格子型の乱数表はルックアップ・シークレットとしても NG だそうだ。 まぁ，当然だよな。\nSMS 認証は非推奨？ NIST は SMS によるコード送信について， SP 800-63-3 のドラフト段階では非推奨にするつもりだったらしい。\n SMSを使った二要素認証を非推奨〜禁止へ、米国立技術規格研究所NISTの新ガイダンス案 | TechCrunch Japan  しかしその後，激しい議論があったようで，最終的には “Restricted Authenticator” という位置づけまで緩和されたようだ。\nCurrently, authenticators leveraging the public switched telephone network, including phone- and Short Message Service (SMS)-based one-time passwords (OTPs) are restricted. Other authenticator types may be added as additional threats emerge. Note that, among other requirements, even when using phone- and SMS-based OTPs, the agency also has to verify that the OTP is being directed to a phone and not an IP address, such as with VoIP, as these accounts are not typically protected with multi-factor authentication. via NIST SP 800-63 Digital Identity Guidelines-FAQ  （スマホを含む）電話機に依存した認証は，プライバシーも絡めて考えると筋が悪い。 ぶっちゃけ SMS 認証を含む経路外デバイスを使った認証は排除するか（ルックアップ・シークレットのように）優先順位を下げて非常時のみ使えるようにするのがいいと思う。 もちろん電話番号を広告に流用するなど以っての外である。\n生体情報は Authenticator として使えるか Authenticator の分類を見れば分かるように，生体情報は単独では認証手段としては使えないという認識のようだ。 そもそも生体情報は秘密情報ではないのだから当たり前といえば当たり前かな。\nブックマーク  usnistgov/800-63-3: Home to public development of NIST Special Publication 800-63-3: Digital Authentication Guidelines NIST SP800-63-3翻訳版63-Bパートの紹介 認証にまつわるセキュリティの新常識  世界の電子認証基準が変わる：NIST SP800-63-3を読み解く – サポート − トラスト・ログイン byGMO【旧SKUID(スクイド)】 Phishing Resistant SMS Autofill - The GitHub Blog  参考図書  セキュリティはなぜやぶられたのか ブルース・シュナイアー (著), 井口 耕二 (翻訳) 日経BP 2007-02-15 単行本 4822283100 (ASIN), 9784822283100 (EAN), 4822283100 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  原書のタイトルが “Beyond Fear: Thinking Sensibly About Security in an Uncertain World” なのに対して日本語タイトルがどうしようもなくヘボいが中身は名著。とりあえず読んどきなはれ。ゼロ年代当時 9.11 およびその後の米国のセキュリティ政策と深く関連している内容なので，そのへんを加味して読むとよい。\nreviewed by Spiegel on 2019-02-11 (powered by PA-APIv5)\n  信頼と裏切りの社会 ブルース・シュナイアー (著), 山形 浩生 (翻訳) NTT出版 2013-12-24 単行本（ソフトカバー） 4757143044 (ASIN), 9784757143043 (EAN), 4757143044 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  社会における「信頼」とは。\nreviewed by Spiegel on 2015-11-28 (powered by PA-APIv5)\n "
    }
  ]
}
