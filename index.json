{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "OpenSSL 1.1.1k がリリースされた【セキュリティ・アップデート】",
      "section": "release",
      "description": "アップデートは計画的に",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/openssl-111k-is-released/",
      "published": "2021-03-26T10:10:57+00:00",
      "update": "2021-03-26T10:11:25+00:00",
      "content": "OpenSSL 1.1.1k がリリースされた。 2件の脆弱性の改修が行われている。\n OpenSSL Security Advisory [25 March 2021]  CVE-2021-3449 OpenSSL 側は “Severity: High” と評価している。\nAn OpenSSL TLS server may crash if sent a maliciously crafted renegotiation ClientHello message from a client. If a TLSv1.2 renegotiation ClientHello omits the signature_algorithms extension (where it was present in the initial ClientHello), but includes a signature_algorithms_cert extension then a NULL pointer dereference will result, leading to a crash and a denial of service attack. A server is only vulnerable if it has TLSv1.2 and renegotiation enabled (which is the default configuration). via CVE-2021-3449  （以下未稿）\nCVE-2021-3450 OpenSSL 側は “Severity: High” と評価している。\nThe X509_V_FLAG_X509_STRICT flag enables additional security checks of the certificates present in a certificate chain. It is not set by default. Starting from OpenSSL version 1.1.1h a check to disallow certificates in the chain that have explicitly encoded elliptic curve parameters was added as an additional strict check. An error in the implementation of this check meant that the result of a previous check to confirm that certificates in the chain are valid CA certificates was overwritten. This effectively bypasses the check that non-CA certificates must not be able to issue other certificates. via CVE-2021-3450  アップデートは計画的に Ubuntu は各バージョンごとにバックポートパッチを当てたバージョンを APT で配布している。\n USN-4891-1: OpenSSL vulnerability | Ubuntu security notices | Ubuntu  手動で更新するのであれば\n$ cd /usr/local/src/ $ sudo curl -L \u0026#34;https://www.openssl.org/source/openssl-1.1.1k.tar.gz\u0026#34; -O $ sudo curl -L \u0026#34;https://www.openssl.org/source/openssl-1.1.1k.tar.gz.asc\u0026#34; -O $ gpg -d openssl-1.1.1k.tar.gz.asc # 署名を確認する $ $ sudo tar xvf openssl-1.1.1k.tar.gz $ cd openssl-1.1.1k/ $ sudo ./config $ sudo make $ sudo make install $ sudo ldconfig # 念のため $ openssl version OpenSSL 1.1.1k 25 Mar 2021 などとする。\nアップデートは計画的に。\nブックマーク  OpenSSLの脆弱性（CVE-2021-3450、CVE-2021-3449）に関する注意喚起 Ubuntu に最新の OpenSSL を入れる  "
    },
    {
      "title": "Hugo Markdown でブロック要素にクラス属性を付与する",
      "section": "remark",
      "description": "お手軽装飾",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/add-attribute-in-hugo-markdown/",
      "published": "2021-03-22T08:14:37+00:00",
      "update": "2021-03-22T08:16:13+00:00",
      "content": "Hugo 0.81 からの機能らしいのだが， markdown テキスト中のブロック要素に対して class 属性を付けられるようだ（goldmark パーサを使う場合）。 これを有効にするには config.toml ファイルで\n[markup.goldmark.parser.attribute] block = true と指定する（既定値は false）。 YAML (config.yaml) で書くなら\nmarkup:goldmark:parser:attribute:block:trueてな感じかな。\nたとえば\n- One - Two - Three { .cloud .center } と箇条書きブロックの最後に { .cloud .center } とクラス名を付けると\n\u0026lt;ul class=\u0026#34;cloud center\u0026#34;\u0026gt; \u0026lt;li\u0026gt;One\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Two\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Three\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; という感じに展開してくれる。 ここで CSS 側を\nul.cloud { list-style: none; padding: 0 } ul.cloud \u0026gt; li { display: inline-block; margin: 0 0.5rem; } .center { text-align: center; } などと定義すれば\nOne Two Three   とできる。\nこれは HTML のブロック要素に相当するものであれば何でも適用できるみたいで，通常の段落でも\n*「人はなぜ大丈夫じゃないときに限って『大丈夫？』と訊くのだろう」* \u0026lt;br\u0026gt;（某ラノベ作品より） {.center} などと書けば\n「人はなぜ大丈夫じゃないときに限って『大丈夫？』と訊くのだろう」 （某ラノベ作品より） とできる。\n頻繁に使う表現なら shortcode を組んだほうがいいだろうが，ちょっとした装飾ならこちらのほうが手軽でいいかもしれない。\n"
    },
    {
      "title": "TinyGo で WASI 【失敗編】",
      "section": "golang",
      "description": "どうやったら動かせるのか。どなたか教えてください 🙇",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/wasi-with-tinygo/",
      "published": "2021-03-21T08:38:59+00:00",
      "update": "2021-03-22T11:15:31+00:00",
      "content": "前回は Go および TinyGo を使って WebAssembly コードを生成しブラウザ上で実行するところまでやった。\nしかし，クライアント側のブラウザ上で動かすだけではあまり面白くないよね。 そこで WASI (WebAssembly System Interface) という POSIX 風の標準規格があるそうな。 WASI に則った WebAssembly コードと，それを駆動するランタイム環境を用意することで “Write Once, Run Anywhere” の夢よもう一度，というわけ1（笑）\n実は本家 Go の wasm アーキテクチャは WASI に対応していない。 ただし TinyGo のほうはイケるみたいなので，今回は TinyGo オンリーでお送りする。\nWASI ランタイム スタンドアロンで動く WASI ランタイムには色々あるようで\n Lucet Wasmtime Wasmer WAVM SSVM  といった実装があるらしい。\nただ TinyGo のターゲット定義が\n{ \u0026#34;llvm-target\u0026#34;: \u0026#34;wasm32--wasi\u0026#34;, \u0026#34;build-tags\u0026#34;: [\u0026#34;wasm\u0026#34;, \u0026#34;wasi\u0026#34;], \u0026#34;goos\u0026#34;: \u0026#34;linux\u0026#34;, \u0026#34;goarch\u0026#34;: \u0026#34;arm\u0026#34;, \u0026#34;compiler\u0026#34;: \u0026#34;clang\u0026#34;, \u0026#34;linker\u0026#34;: \u0026#34;wasm-ld\u0026#34;, \u0026#34;libc\u0026#34;: \u0026#34;wasi-libc\u0026#34;, \u0026#34;cflags\u0026#34;: [ \u0026#34;--target=wasm32--wasi\u0026#34;, \u0026#34;--sysroot={root}/lib/wasi-libc/sysroot\u0026#34;, \u0026#34;-Oz\u0026#34; ], \u0026#34;ldflags\u0026#34;: [ \u0026#34;--allow-undefined\u0026#34;, \u0026#34;--stack-first\u0026#34;, \u0026#34;--export-dynamic\u0026#34;, \u0026#34;--no-demangle\u0026#34; ], \u0026#34;emulator\u0026#34;: [\u0026#34;wasmtime\u0026#34;],  \u0026#34;wasm-abi\u0026#34;: \u0026#34;generic\u0026#34; } と Wasmtime をリファレンスとしているみたいなので，今回はこれを使う。\nWasmtime の導入 Wasmtime のリポジトリでバイナリがリリースされているので，これを取ってきて PATH の通ったディレクトリに放り込んでおけばよい。\nあるいは\n$ curl https://wasmtime.dev/install.sh -sSf | bash とすれば $HOME/.wasmtime/bin/ ディレクトリを掘って入れてくれる。 さらに PATH を通すために $HOME/.bashrc ファイルを書き換えてくれやがるので，ご注意を。\nなお Wasmtime 自体のビルドには Rust と C++ (多分 GCC の g++) のビルド環境が必要らしい。 時代は Rust なんだねぇ。\n以下，動作確認。\n$ wasmtime --help wasmtime 0.25.0 Wasmtime WebAssembly Runtime USAGE: wasmtime \u0026lt;SUBCOMMAND\u0026gt; FLAGS: -h, --help Prints help information -V, --version Prints version information SUBCOMMANDS: config Controls Wasmtime configuration settings help Prints this message or the help of the given subcommand(s) run Runs a WebAssembly module wasm2obj Translates a WebAssembly module to native object file wast Runs a WebAssembly test script file If a subcommand is not provided, the `run` subcommand will be used. Usage examples: Running a WebAssembly module with a start function: wasmtime example.wasm Passing command line arguments to a WebAssembly module: wasmtime example.wasm arg1 arg2 arg3 Invoking a specific function (e.g. `add`) in a WebAssembly module: wasmtime example.wasm --invoke add 1 2 みんな大好き Hello World 何はともあれ，コードを用意しないとね。 いつものように，みんな大好き Hello World で。\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } これを TinyGo で処理する。\n$ tinygo build -o hello.wasm -target wasi ./hello.go ターゲットが wasi になっている点に注意。\nWasmtime で WASI コードを動かす んではビルドした hello.wasm ファイルを実行してみる。\n$ wasmtime run hello.wasm Hello, World! よーし，うむうむ，よーし。\nwasmtime-go で WASI ランタイムを組み込む【失敗編】 bytecodealliance/wasmtime-go を使うと Wasmtime のランタイム機能を Go のコードとして埋め込めるらしい（要 cgo）。 こんな感じかな。\npackage main import ( _ \u0026#34;embed\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/bytecodealliance/wasmtime-go\u0026#34; ) //go:embed hello.wasm var wasm []byte func main() { store := wasmtime.NewStore(wasmtime.NewEngine()) wasiConfig := wasmtime.NewWasiConfig() wasiConfig.InheritStdout() wasi, err := wasmtime.NewWasiInstance(store, wasiConfig, \u0026#34;wasi_snapshot_preview1\u0026#34;) if err != nil { fmt.Fprintln(os.Stderr, fmt.Errorf(\u0026#34;error in wasmtime.NewWasiInstance() : %w\u0026#34;, err)) return } linker := wasmtime.NewLinker(store) if err := linker.DefineWasi(wasi); err != nil { fmt.Fprintln(os.Stderr, fmt.Errorf(\u0026#34;error in wasmtime.Linker.DefineWasi() : %w\u0026#34;, err)) return } if err := wasmtime.ModuleValidate(store, wasm); err != nil { fmt.Fprintln(os.Stderr, fmt.Errorf(\u0026#34;error in wasmtime.ModuleValidate() : %w\u0026#34;, err)) return } module, err := wasmtime.NewModule(store.Engine, wasm) if err != nil { fmt.Fprintln(os.Stderr, fmt.Errorf(\u0026#34;error in wasmtime.NewModule() : %w\u0026#34;, err)) return } instance, err := linker.Instantiate(module) if err != nil { fmt.Fprintln(os.Stderr, fmt.Errorf(\u0026#34;error in wasmtime.Linker.Instantiate() : %w\u0026#34;, err)) return } if _, err := instance.GetExport(\u0026#34;_start\u0026#34;).Func().Call(); err != nil { fmt.Fprintln(os.Stderr, fmt.Errorf(\u0026#34;error in \\\u0026#34;_start\\\u0026#34; : %w\u0026#34;, err)) return } } では，これを動かしてみよう。\n$ go run sample.go error in wasmtime.Linker.Instantiate() : unknown import: `wasi_unstable::fd_write` has not been defined おうふ。 なんか足らんと言っている。\nTinyGo 側でなにか不備があるのかと思って以下のサンプル・コードもそのまま動かしてみたが\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;github.com/bytecodealliance/wasmtime-go\u0026#34; ) const TextWat = `(module ;; Import the required fd_write WASI function which will write the given io vectors to stdout ;; The function signature for fd_write is: ;; (File Descriptor, *iovs, iovs_len, nwritten) -\u0026gt; Returns number of bytes written (import \u0026#34;wasi_unstable\u0026#34; \u0026#34;fd_write\u0026#34; (func $fd_write (param i32 i32 i32 i32) (result i32))) (memory 1) (export \u0026#34;memory\u0026#34; (memory 0)) ;; Write \u0026#39;hello world\\n\u0026#39; to memory at an offset of 8 bytes ;; Note the trailing newline which is required for the text to appear (data (i32.const 8) \u0026#34;hello world\\n\u0026#34;) (func $main (export \u0026#34;_start\u0026#34;) ;; Creating a new io vector within linear memory (i32.store (i32.const 0) (i32.const 8)) ;; iov.iov_base - This is a pointer to the start of the \u0026#39;hello world\\n\u0026#39; string (i32.store (i32.const 4) (i32.const 12)) ;; iov.iov_len - The length of the \u0026#39;hello world\\n\u0026#39; string (call $fd_write (i32.const 1) ;; file_descriptor - 1 for stdout (i32.const 0) ;; *iovs - The pointer to the iov array, which is stored at memory location 0 (i32.const 1) ;; iovs_len - We\u0026#39;re printing 1 string stored in an iov - so one. (i32.const 20) ;; nwritten - A place in memory to store the number of bytes written ) drop ;; Discard the number of bytes written from the top of the stack ) )` func check(e error) { if e != nil { panic(e) } } func main() { dir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;out\u0026#34;) check(err) defer os.RemoveAll(dir) stdoutPath := filepath.Join(dir, \u0026#34;stdout\u0026#34;) engine := wasmtime.NewEngine() store := wasmtime.NewStore(engine) linker := wasmtime.NewLinker(store) // Configure WASI imports to write stdout into a file.  wasiConfig := wasmtime.NewWasiConfig() wasiConfig.SetStdoutFile(stdoutPath) // Set the version to the same as in the WAT.  wasi, err := wasmtime.NewWasiInstance(store, wasiConfig, \u0026#34;wasi_snapshot_preview1\u0026#34;) check(err) // Link WASI  err = linker.DefineWasi(wasi) check(err) // Create our module  wasm, err := wasmtime.Wat2Wasm(TextWat) check(err) module, err := wasmtime.NewModule(store.Engine, wasm) check(err) instance, err := linker.Instantiate(module) check(err) // Run the function  nom := instance.GetExport(\u0026#34;_start\u0026#34;).Func() _, err = nom.Call() check(err) // Print WASM stdout  out, err := ioutil.ReadFile(stdoutPath) check(err) fmt.Print(string(out)) } 結果は同じで wasi_unstable::fd_write なんぞ知らんと言ってくさる。 えっ？ みんなこのサンプルコード動かせるの？ どうやんだ？ 多分ランタイム側で何か足らないんだろうけど，よく分からん。 wasmtime-c-api を組み込めばいいのかなと思ったが，違うよなぁ？\nというところで挫折した orz どなたか教えてください \u0026#x1f647;\n【2021-03-22 追記】 Twitter で教えていただきました。 感謝！\nどうも TinyGo と wasmtime-go との間で WASI Application ABI (Application Binary Interface) が マッチしていない模様。 たしかに $TINYGOROOT/src/runtime/runtime_wasm.go に\n//go:wasm-module wasi_unstable //export fd_write func fd_write(id uint32, iovs *__wasi_iovec_t, iovs_len uint, nwritten *uint) (errno uint) って記述があるわ。 ふむむー。 //go:wasm-module ディレクティブをキーに調べてみればいいのかな。 参考になった。\nちなみに，アドバイスを参考に\nwasi, err := wasmtime.NewWasiInstance(store, wasiConfig, \u0026#34;wasi_snapshot_preview1\u0026#34;) の部分を\nwasi, err := wasmtime.NewWasiInstance(store, wasiConfig, \u0026#34;wasi_unstable\u0026#34;) に差し替えたら動き出した。 なるほどねー。\nTinyGo 側の PR は受理されてマージされているようなので，次のバージョンでは wasi_snapshot_preview1 で行けるだろう。\n【おまけ】 Node.js で WASI を動かす Node.js は v13 から WASI に対応しているらしい。\n$ npm i wasi でパッケージを組み込めば使えるようだ。 で，こんな感じのコードを書いて\n\u0026#39;use strict\u0026#39;; const fs = require(\u0026#39;fs\u0026#39;); const { WASI } = require(\u0026#39;wasi\u0026#39;); const wasi = new WASI({ args: process.argv, env: process.env, preopens: { } }); const importObject = { wasi_unstable: wasi.wasiImport }; // const importObject = { wasi_snapshot_preview1: wasi.wasiImport };  (async () =\u0026gt; { try { const wasm = await WebAssembly.compile(fs.readFileSync(\u0026#39;./hello.wasm\u0026#39;)); const instance = await WebAssembly.instantiate(wasm, importObject); wasi.start(instance); } catch (e) { console.error(e) } })(); 動かしてみると\n$ node --experimental-wasi-unstable-preview1 --experimental-wasm-bigint wasi.js (node:210549) ExperimentalWarning: WASI is an experimental feature. This feature could change at any time (Use `node --trace-warnings ...` to show where the warning was created) Hello, World! おー，動いた動いた。 これで Go のコードを WSAI 経由で JavaScript コードに埋め込めるわけだ。\nブックマーク  WASI - WebAssembly System Interface with Wasmtime - DEV Community コンテナ技術を捨て、 WASIを試す. こんにちは、NTTの藤田です。 | by FUJITA Tomonori | nttlabs | Medium  参考図書  ソフトウェアデザイン 2021年3月号 谷本 心 (著), 水島 宏太 (著), 増田 亨 (著), 山本 悠滋 (著), 折原 レオナルド賢 (著), 米田 武 (著), 清水 洋治 (著), 結城 浩 (著), 刀根 諒 (著), 大串 肇 (著), 松本 直人 (著), クラスメソッド 木村(作) (著), エクスデザイン ninnzinn(画) (著), くつなりょうすけ (著), 広木 大地 (著), 中島 明日香 (著), 金谷 拓哉 (著), 高橋 永成 (著), 平岡 正寿 (著), 梶原 直人(監修) (著), 平櫛 貴章 (著), 星川 真麻 (著), けんちょん(大槻 兼資) (著), 大嶋 健容 (著), 職業「戸倉彩」 (著), mattn (著), 小野 輝也 (著), 濱田 康貴 (著), 森若 和雄 (著), 古川 菜摘 (著), 嘉山 陽一 (著), 平野 尚志 (著), 杉山 貴章 (著), Software Design編集部 (編集) 技術評論社 2021-02-18 (Release 2021-02-18) 雑誌 B08T7D2LFR (ASIN), 4910058270316 (EAN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  第2特集が「WebAssembly 入門」近年の動向を把握するには丁度いいだろう。\nreviewed by Spiegel on 2021-03-21 (powered by PA-APIv5)\n  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n   “Write Once, Run Anywhere” は初期の Java のキャッチフレーズだった。当時は UNIX 機のハードウェア非互換の問題が酷くて，なんとかバイナリ互換を確保する方法がないかみんな頭を悩ませていた。そこに登場したのが Sun Microsystems の Java だったわけ。でも実際にはプラットフォーム間の差異が微妙に残ってしまい，むしろ “Write Once, Debug Everywhere” などと揶揄されることもあった。それでも Virtual Machine 上で標準化されたバイトコードを駆動させるというアイデアは秀逸だったので Java 以外の処理系でも応用され，特に組み込み用途では重宝されている。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2021-03-20 のブックマーク",
      "section": "bookmarks",
      "description": "「Microsoft Exchange Server の脆弱性対策について」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2021/03/20-bookmarks/",
      "published": "2021-03-20T03:19:24+00:00",
      "update": "2021-03-20T03:20:09+00:00",
      "content": "リリース情報  Release v1.38.0 · golangci/golangci-lint · GitHub LibreOffice 7.1.1 Community available for download - The Document Foundation Blog Release February 2021 · microsoft/vscode · GitHub- Release February 2021 Recovery · microsoft/vscode · GitHub Release 4.4.9_4 · zetamatta/nyagos · GitHub Release 1.55.0 · atom/atom · GitHub Release v1.0.16 · sonatype-nexus-community/nancy · GitHub Release February 2021 Recovery 2 · microsoft/vscode · GitHub Release February 2021 Recovery 3 · microsoft/vscode · GitHub Release gopls/v0.6.7 · golang/tools · GitHub Release v1.0.17 · sonatype-nexus-community/nancy · GitHub Release gopls/v0.6.8 · golang/tools · GitHub Release gopls/v0.6.9 · golang/tools · GitHub  バベルのインターネット  「インターネットの表現の自由を守る原則」を守らねばならない | P2Pとかその辺のお話R 中国で人気上昇中の暗号化チャットアプリ「Signal」が禁止に | TechCrunch Japan Twitterの全面遮断を予告したロシア、ブロッキング回避を阻止するためにVPN遮断も示唆 | P2Pとかその辺のお話R  セキュリティ＆プライバシー関連  【注意喚起】VMware vCenter Serverの脆弱性（CVE-2021-21972）、早急な対策を | セキュリティ対策のラック データ移行で発生したみずほ銀行のシステム障害についてまとめてみた - piyolog Finding Evil Go Packages | Michael Henriksen - Security engineer \u0026amp; builder of tools レンタルサーバー運営会社に不正利用を通報したときの窓口と、各社の対応をまとめた。 - Qiita Goで書かれたマルウェアが増加傾向\u0026ndash;APTと犯罪グループの両方が利用 - ZDNet Japan : 犯罪者も Go を選ぶw Linuxカーネルのセキュリティ強化へ\u0026ndash;グーグルがフルタイムのメンテナーを支援する理由 - ZDNet Japan 更新：Microsoft Exchange Server の脆弱性対策について(CVE-2021-26855等)：IPA 独立行政法人 情報処理推進機構  Microsoft Exchange Serverの複数の脆弱性に関する注意喚起 Researcher Publishes Code to Exploit Microsoft Exchange Vulnerabilities on Github Chinese Hackers Stole an NSA Windows Exploit in 2014 - Schneier on Security 攻撃発生中のExchange Serverの脆弱性 ProxyLogonなどについてまとめてみた - piyolog 中国の国家ハッカーがExchange Serverの脆弱性をゼロデイ攻撃、マイクロソフトが警告 | TechCrunch Japan   ミッコ・ヒッポネン氏が警鐘を鳴らす2021年のセキュリティトピックとは (1/3)：EnterpriseZine（エンタープライズジン）  ヒッポネンの法則：『スマート』は脆弱の証 - F-Secure : ウケた   Googleに騙されてはいけない：FLoCは邪悪なアイデアである | P2Pとかその辺のお話R  グーグルが「Cookie廃止後、それに代わる他のユーザー追跡技術を採用するつもりはない」と発言 | TechCrunch Japan   GitHub security update: A bug related to handling of authenticated sessions - The GitHub Blog  “github.com”にセキュリティ問題、ユーザーの強制ログアウトを実施 - 窓の杜   iPhone用通話録音アプリのバグで数千件の通話記録が流出 | TechCrunch Japan 「Linux 5.12 rc1に厄介なバグ」、トーバルズ氏が警告 - ZDNet Japan : 正式リリースでは解消済み バイデン政権は暗号化政策の方針を転換せよ | P2Pとかその辺のお話R 暗号化と表現の自由を脅かす米EARN IT法案とは何か？ | P2Pとかその辺のお話R Red Hat、企業におけるオープンソースの調査レポート「The State of Enterprise Open Source」公開。87％がオープンソースはプロプライエタリと同等かそれ以上にセキュアと － Publickey サイバー犯罪のエコシステムは今\u0026ndash;CrowdStrikeの脅威レポートにみる - ZDNet Japan EU：エンド・ツー・エンド暗号化の解体に向けたタイムテーブル | P2Pとかその辺のお話R ブルース・シュナイアーと語る「暗号戦争」と「暗号化を守んなきゃいけない理由」 | P2Pとかその辺のお話R 「Google Chrome 89」にゼロデイ脆弱性 ～v89.0.4389.90への更新を - 窓の杜  「Microsoft Edge 89」の最新版が公開 ～「Blink」のゼロデイ脆弱性に対処 - 窓の杜   Security Analysis of Apple’s “Find My…” Protocol - Schneier on Security Metadata Left in Security Agency PDFs - Schneier on Security Fast Random Bit Generation - Schneier on Security 3月15日よりセキュリティの警告が出てWebサイトへアクセスできなくなったお客様へ – さくらのサポート情報 GoogleアプリがiOSで収集している個人情報の詳細が判明、あまりの多さに「隠したがっていたのも無理はない」との声 - GIGAZINE Dropbox、無料プランでもパスワード管理ツール「Dropbox Passwords」を提供へ - ZDNet Japan : 「パスワードを任意の相手とセキュアな方法で共有する機能」という発想がそもそも間違っていると思うが\u0026hellip; 管理不備と報じられたLINEの問題についてまとめてみた - piyolog : 行政側が慌ててるのが笑かすw E2EE を開発していて思うこと. ここ数ヶ月は自社製品向けの End to End (Media)… | by V | Medium : 「今後 E2EE は安全すぎるために解析できないと困る部分で脅威」ってのはいかにもサービス提供者側の論理だよな A Hacker Got All My Texts for $16    Easy SMS Hijacking - Schneier on Security     Exploiting Spectre Over the Internet - Schneier on Security  知財関連  GitHub Wants to Get Rid Of the DMCA\u0026rsquo;s Anti-Circumvention FUD * TorrentFreak Overbroad DMCA Takedown Campaign Almost Wipes Dictionary Entries From Google * TorrentFreak EU High Court: Embedding Protected Images Can Breach Copyright Law * TorrentFreak  Linux または Ubuntu に関する話題  Ubuntu 21.10 その2 - 新しいUbuntu Desktopインストーラーのデザイン公開と協力の呼びかけ - kledgeb  Windows に関する話題  「Windows Terminal 1.7」プレビュー、GUI設定画面が既定に。JSONスニペットの共有でカスタマイズも簡単 - 窓の杜 Windows, 共有リソースへの別ユーザー名でのアクセスについて - プログラマーのメモ書き 「Windows 10」次期機能アップデート「21H1」はどうなる？ - ZDNet Japan  Go 言語関連  Complete Golang Microservice example | by Suraj Batuwana | Medium bimg (libvips Goバインディング) でサムネイル画像作成を高速化する - Quipper Product Team Blog Go 1.16で追加されたiotest.ErrReaderを使ってio.Readerの異常系をテストする 【Golang】Exit, panic, Goexitの違い | SharpKnock golang.jp ブログ: golang.jpのドメインを譲渡頂きました Goのリトライ処理で考慮すること GitHub - piprate/json-gold: A JSON-LD processor for Go Go言語における式の評価文脈を理解する Goエラーハンドリング戦略 go:embed を使った場合に GitHub Actions をどうするか : 機微情報を実行バイナリに埋め込むのは感心せんけどねー。まぁ，そういうやり方もあるよってことで VSCodeでbeegoをデバッグする - Qiita : VS Code で Go コードのデバッグ 【Golang】go-i18n/v2 の動作サンプル（2021年03月版）【国際化対応】 - Qiita : gettext みたいなやつ？ yaml.v3 - gopkg.in/yaml.v3 : v3 になってた Self Contained Blog Server with Go 1.16 Go Developer Survey 2020 Results - The Go Blog Manage PostgreSQL JSON data with Go(golang) | by Jorge Quitério | iostrap | Mar, 2021 | Medium Go と prisma と lit-html と ky で作るモダンな TODO アプリ How fast can you Go?. Today I will explore how profiling… | by Aymeric Augustin | Fractal Ideas | Feb, 2021 | Medium JWT を Go で処理するためのパッケージ - Qiita Go言語で複数のシェルスクリプトを実行するcliツールを作ってみた : goroutine リークの解析など参考になる Twitter APIの使い方まとめ（認証情報の種類・Goサンプル実装） Goアセンブリの書き方 - Plan 9とGo言語のブログ RaspberryPi-PicoをTinyGoでLチカする方法 - 144Labグループ開発者ブログ GitHub - google/go-licenses: Reports on the licenses used by a Go package and its dependencies. GitHub - jwalton/gchalk: Terminal string styling for go done right, with full and painless Windows 10 support. : ターミナルエミュレータに表示する文字に装飾できる。 Windows 10 対応？  Rust 言語関連  Rust入門 Building a shared vision for Async Rust | Rust Blog  その他  「Red Hat OpenShift 4.7」正式リリース。既存の仮想マシンをKubernetes管理下へ移行するツール提供、vSphere上のWinowsコンテナをサポート － Publickey マイクロソフト、マルチプラットフォームUIを実現する「.NET Multi-platform App UI」（MAUI）を実際にデモ。単一コードからWebとWindowsアプリを生成 － Publickey Google、Kubernetesを自動運用してくれる「GKE Autopilot」正式リリース。ノードのプロビジョニング、マルチゾーン展開、スケーリングなど自動的に最適実行 － Publickey ［速報］「AWS大阪リージョン」正式オープン。大阪ローカルリージョンを拡張し3つのアベイラビリティゾーンから構成、事前申し込みなど不要に － Publickey Excelの数式をベースにしたプログラミング言語「Microsoft Power Fx」登場。オープンソースで公開予定。Microsoft Ignite 2021 － Publickey GraphQL入門 scoop bucket を作成する - enjoy struggling マイクロソフトが会議で文字起こしや翻訳を行うアプリ「Group Transcribe」を発表 | TechCrunch Japan Flash対応を廃止。「Electron 12」が正式リリース ～SSE3命令が必須に - 窓の杜 マイクロソフト、RPA機能を「Windows 10」ユーザーに無償提供 - ZDNet Japan The lessons of Fukushima - Nuclear power must be well regulated, not ditched | Leaders | The Economist 「Windows Server 2022」プレビュー版が登場、安全なブートなどセキュリティ強化。Microsoft Ignite 2021 － Publickey マイクロソフト、「Universal Print」正式リリースを発表。プリンタサーバをクラウド化し、プリンタドライバを不要に。Microsoft Ignite 2021 － Publickey グーグルがChromeのリリースサイクルを6週から4週に短縮 | TechCrunch Japan  「Microsoft Edge」のリリース間隔も4週間へ短縮 ～「Edge 94」から実施 - 窓の杜   Splitting the ping  ブログ: pingを分割する   The Third Age of JavaScript 図解 CSR, SSR, SSG, ISR Google発の画像圧縮ツール「Squoosh」を使ってみた : これ，クラウドで処理してる？ Javaでもう一度学び直すオブジェクト指向プログラミングを関数型プログラミングで考え直す 〜第1章〜 理研のスーパーコンピューター「富岳」が完成、共用を開始 - ZDNet Japan OrbitDB : Peer-to-Peer Databases for the Decentralized Web Raspberry PiとJetson Nano(2GB)のUSBポートのデバイスを物理的に抜き差しせず、ソフトウェアで制御する 住所オープンデータ提供Web APIの使い方 「GitHub Discussions」がプライベートリポジトリでも利用可能に。電子掲示板を用いたコミュニティ機能を追加 － Publickey チームにdockerを布教することになったので、布教の教材を作ってみた。 「Wireshark」v3.4.4が公開 ～脆弱性を1件修正 - 窓の杜 Slack社はSlackをどう使っているのか - Slack利用ガイドラインの話 - Qiita ハネウェル、量子コンピューター「System Model H1」の性能を4倍に - ZDNet Japan Dart言語のフレームワーク「Flutter 2」公開。単一コードでiOS/Android/Web/Win/Mac/Linuxのネイティブアプリ実現。WebAssemblyによるレンダリングエンジン搭載 － Publickey グローバルIP無しのセキュアなリモート開発環境を構築 by VSCode Remote Development x GCP x IAP AWS、わざとクラウド障害を起こす新サービス「AWS Fault Injection Simulator」提供開始。カオスエンジニアリングをマネージドサービスで － Publickey フリーのお手軽PDF編集ツール「CubePDF Utility」がベータ版を卒業、v1.0.0に - 窓の杜 「Geekbench 5.4」がLinux/ARMとLinux/RISC-Vにプレビュー対応 ～シングルボードなどでも利用可能に - 窓の杜 Windowsで環境を極力汚さずにPythonを動かす方法 (Scoop編) - Qiita Google Colabで日本語要約してみた Improving large monorepo performance on GitHub - The GitHub Blog  マイクロサービスの部分で Go への置き換えが始まっているらしい GitHub における大規模なモノリポのパフォーマンスの向上 - GitHubブログ   デジタル・デトックスでは幸福にもならないし、充実した社会生活が送れるわけでもない - 井出草平の研究ノート NotionのようなUIのTrelloっぽいKanbanツールのOSSの Focalboard を触ってみた : オンプレミスで構築できる オラクルがOracle Autonomous Data Warehouseを強化。SQLを知らないビジネスユーザーでもデータ分析を容易にする自動化とUIなど追加 － Publickey Unreal Build: Automotive 2021 - Unreal Engine Pythonでmathライブラリ使わずlog計算をしたくて、math.log()関数を自作してみた。  "
    },
    {
      "title": "Java のサポート期限ってどうなってるんだっけ？",
      "section": "release",
      "description": "アップデートは計画的に。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/java-support-roadmap/",
      "published": "2021-03-19T11:25:53+00:00",
      "update": "2021-03-19T22:41:30+00:00",
      "content": "ぶっちゃけ PlantUML を動かす程度の利用なら最新の OpenJDK だけ気にしていればよかったんだけど，仕事で Java を使うとなればそういうわけにもいかない。 けど，今の Java のサポート期限ってどうなってるんだっけ？\nまずは Oracle Java。 これははっきりしている。\n Oracle Java SE Support Roadmap  これによると\n   Release GA Date Premier Support Extended Support     7 2011-07 2019-07 2022-07   8 2014-03 2022-03 2030-12   9 2017-09 2018-03 -   10 2018-03 2018-09 -   11 (LTS) 2018-09 2023-09 2026-09   12 2019-03 2019-09 -   13 2019-09 2020-03 -   14 2020-03 2020-09 -   15 2020-09 2021-03 -   16 2021-03 2021-09 -   17 (LTS) 2021-09 2026-09 2029-03    ということらしい1（どのバージョンでも Sustaining Support は無期限で受けれるため省いた）。 つまり Premier Support を受けれるバージョンは現時点（2021-03）で 8, 11, 15/16 が対象となる（15 は 2021-03 まで）。 Extended Support なら 7 も含まれる（Java 7 なら費用は免除）。\n一方 OpenJDK はよく分からない。\nJava 10 以降なら（リリースサイクルが半年毎というだけで）特にサポート期限というものはないみたい。 向こうが「やーめた」と言うまではアップデートを出し続けるのかな？ 7u と 8u については記述がなかったが，四半期ごとのマイナーアップデートの対象になってるみたいなので，一応はサポートしていると思われる。 まぁ， Oracle Java や AdoptOpenJDK, OpenJ9 などからフィードバックがあるのかもしれない。\nちなみに AdoptOpenJDK のサポート期限は\n Support | AdoptOpenJDK - Open source, prebuilt OpenJDK binaries  によると\n   バージョン First Availability End of Availability     8 (LTS) 2014-03 at least 2022-05   9 2017-09 2018-03   10 2018-03 2018-09   11 (LTS) 2018-09 2024-10   12 2019-03 2019-09   13 2019-09 2020-03   14 2020-03 2020-09   15 2020-09 2021-03   16 2021-03 2021-09   17 (LTS) 2021-09 (TBC)    となっていた。 現時点（2021-03）では 8, 11, 15/16 がサポート対象だ（15 は 2021-03 まで）。\n今はクラウドサービスごとに独自のディストリビューションを提供してたりするので， 11 以降ならあまり気にする必要はないのかな。 今だに 8/8u を使ってるサービス（行政サービスとか多そうだw）は，そろそろ未来について（Java を捨てる選択肢も含めて）議論したほうがいいだろう。\nなお，年間のリリース・イベントは以下の通り。\n   月 バージョンアップ・イベント     1月 マイナー・バージョンアップ   2月    3月 メジャー・バージョンアップ   4月 マイナー・バージョンアップ   5月    6月    7月 マイナー・バージョンアップ   8月    9月 メジャー・バージョンアップ   10月 マイナー・バージョンアップ   11月    12月     アップデートは計画的に。\nブックマーク  Eclipse Adoptium | projects.eclipse.org  AdoptOpenJDKプロジェクトがEclipse Foundationへの合流を発表。合流後の新プロジェクト名は「Eclipse Adoptium」に － Publickey   AWS、「Java 8」を2026年まで、「Java 11」は2027年まで、現行より3年サポート期間延長を発表。独自JavaディストリビューションのCorretto 8とCorretto 11で － Publickey OpenJDKと各種JDKディストリビューションの情報源まとめ  参考図書  Effective Java 第3版 Joshua Bloch (著), 柴田 芳樹 (翻訳) 丸善出版 2018-10-30 単行本（ソフトカバー） 4621303252 (ASIN), 9784621303252 (EAN), 4621303252 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  再勉強中。 Kindle 版のほうがちょっと安いが，勤務先でも使いたかったので紙の本にした。\nreviewed by Spiegel on 2021-03-17 (powered by PA-APIv5)\n   Oracle Java 8 はクライアント側での利用と開発目的での利用のみ許可されている。サーバ側での運用は別途有償契約が必要（の筈）。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Go を褒め殺ししてみる",
      "section": "remark",
      "description": "はやく作って はやく改す",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/awesome-golang/",
      "published": "2021-03-18T11:16:13+00:00",
      "update": "2021-03-18T11:17:55+00:00",
      "content": "母国語としてのプログラム言語 以前紹介したのだが，結城浩さんの過去の連ツイに\n プログラミング言語との付き合い方というのはいろいろあってですね。自分の母国語という言語はある。それから現在学んでいる最中の言語というのもある。そして、仕事用の言語やら、他の人とのコミュニケーション用言語というのもある。そのあたりは、自然言語とちょっと似ている。\nITな業界で仕事をしているひとというのは、だいたいそういう感じでプログラミング言語とつきあっていると思っている。たった一つしかプログラミング言語ができないという人は少なくて、二つくらいは読み書きできる。三つ四つくらいはなんとなく読むのはできる。五つ六つくらいは何のソースか言える。\n 考えてみると結城はC, Perl, Javaの本は書いたけれど...より  という記述がある。\nまぁ「仕事用の言語」や「コミュニケーション用言語」ってのは独りで選ぶものではないので今回は除外するとして，「母国語」というのは上手い比喩だ。 自然言語と同じで「母国語」として定着しているプログラミング言語があればロジックや制御への理解も速いし，他言語を習得する際にも有利になる。\nでも最初から「◯◯言語を母国語として習得するぞ」とかいう人はいないだろう。 使い込んで手に馴染んでいって初めて「母国語」になり得る。 問題は「どの言語か」ではなく「手に馴染むまで使い込むほどの動機があるか」だと思う。\n「これからプログラミングを始めるならどの言語にすればいいか」という問いは今の季節の風物詩みたいなものだが，この問いだけでは「始める」動機が見えないし，その人が既に「母国語」と言えるものを持っているか否かで話も変わってくる。\n先日見かけた\n これから勉強するならGolangとRustのどちらがいいでしょうか？難易度も含めて推奨お願いします。 - Quora  という記事も似たような印象を受けたが，回答に挙がっている Rust と Go の比較はなかなか興味深く，また大いに共感した。 ただ，回答された方は Rust 寄りみたいなので，対抗して私は Go を褒め殺ししてみる（笑）\nなお，あらかじめ予防線を張っておくと，私は言語オタクでも文房具オタクでもないし，その手の宗教論争に巻き込まれたくないので，異論反論（当然あると思うけど）には反応しないのであしからず。\n（前説おわり）\nはやく作って はやく改（なお）す1 昔は「はやく作る」というのはスクリプト言語の独壇場だった。 近年のバズワードだった「AI」技術において Python が大きな牽引力として機能しているのは Python が「はやく作る」ことに特化した言語であることも大きいだろう。\nしかし Go がこの状況を変えていく。\nGo はコンパイル言語には珍しく（と言っていいのか分からないが）「はやく作る」ことに特化した言語と言っていい。 「はやく作る」というのは事前学習量やコンパイル速度やコード記述量を指しているのではなく「考えたことをそのまま書いて安全に組めるか」ということだ。 Go の言語仕様に組み込まれた簡便さも制約もこの目的のためにあると言ってよい。\nたとえば Go は Java などの伝統的オブジェクト指向プログラミング言語とよく比較されるが，例外処理や継承など「考えたことをそのまま書く」ことにおいてノイズにしかならないギミックをあっさり捨て去っている。 Goroutine 間に優先順位が存在しないのも sync.Mutex が再入不可なのもちゃんと理由があるのだ（Generics は結局組み込むみたいだけどw）。\nちなみに「はやく作る」ことは「雑に作る」ことではない。 近年の流行語である「技術的負債」の本来の意図は「はやく作る」ことと引き換えにしているものを金融用語の「負債」に喩えたことだそうだ。つまり技術的負債の「返済」とは，システムやプログラムを「直す」ことではなく「改（なお）す」つまりリファクタリングを指している。\nもうひとつの Go の特徴は，このリファクタリングに厚い言語であるということだ。 シンプルな言語仕様故に手を入れやすいし， interface 型による「構造型の部分型付け（structural subtyping）」によってオブジェクト間の関係を「疎」にできるため，再利用性の高い機能を別パッケージとして切り離したり，なんなら「出来のよくないパッケージを丸ごと入れ替える」なんてことも比較的容易だったりする。\n一言で言うなら「はやく作って はやく改せる」のが Go 最大のメリットである。 道具に耽溺するのでなく振り回されるのでなく，自らのアイデアを「いい感じ」に実装する手段としてプログラミング言語を求めるのなら Go を選択するのは悪くない，と言っておこう。\n「文」の制約 Go の言語仕様を読むところまで慣れた方なら気づいてると思うけど， Go は文（statement）の制約が強い言語である。 文の制約を強くすることで全体の言語仕様をシンプルにしている，とも言えるが。\nたとえば if, switch, for といった制御文や = などの代入文は式（expression）として評価できないため，式の一部または全部として組み込めない。 分かりやすい例としては C/C++ などでは悪名高いインクリメント2 “x++” は代入構文のバリエーションとして評価されるため，式の一部として組み込めない，とかいったことがある。\ny := ary[x++] // syntax error あるいはもっと簡単に\na = b = c = 1 // syntax error とかも無理。\nこういった制約は，特に関数型プログラミング言語から来た人には大きな不満となるだろう。 この理由で Go に馴染めないというのであれば Rust のほうをお勧めする（笑）\n富豪的プログラミングの代償 並列処理とメモリ管理はどんな言語でも悩ましい問題である。 特に両者が組み合わさると非常に厄介と言える。\nたとえばスクリプト言語や Virtual Machine 上の動作を前提とした処理系ではスクリプト・エンジンや VM が並列処理やメモリ管理の厄介な部分を引き受けてくれるが， Go ではこれらを実行モジュールに組み込むことで高いパフォーマンス（とシングル・バイナリでのデプロイ）を可能としている。\n富豪的プログラミングの観点からは，これらの仕組みはプログラマに有利に働く。 最初の節で紹介した Q\u0026amp;A の回答でも\n 言語仕様が小さくて、コンパイルがとても速く、GC (Garbage Collector)を採用してメモリ管理の煩わしさをなくすとともに、並列実行を容易にしています。\nその分、単体での実行速度については妥協していますが、速度を求めるのなら処理を並列化しつつマシン側（実行環境）を増強すれば良い、というクラウド時代の解決策をとっています。つまり、コードのちまちまとした最適化で悩んでいる暇があるなら札束で殴ってさっさと解決しろ、ということですね。とても効率的な考え方です。\n これから勉強するならGolangとRustのどちらがいいでしょうか？難易度も含めて推奨お願いします。 - Quoraより  と解説されている。まさに富豪的（笑）\nしかし，これと引き換えに「小さなシステム」に対しては無視できない代償を支払っている。 これは並列処理やメモリ管理を実行バイナリに埋め込むために POSIX への依存度が高くなっているためだ。\n小さなシステムやシビアなリアルタイム処理3 には Go は向かないだろう。ましてやデバイスドライバや pure Go な OS カーネルなど夢のまた夢である。 そういうものに興味があるのであれば Rust のほうがお勧めだ。\nなお，個人的に興味を持っている TinyGo なら LLVM ベースの小さいバイナリを生成することができる。組み込み用途であればこういった選択肢はありだと思う。\n本当は WebAssembly に興味があるのだが，少なくとも Go 側が WASI (WebAssembly System Interface) をサポートしてくれないと無理かなぁ。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n  プログラミングRust Jim Blandy (著), Jason Orendorff (著), 中田 秀基 (翻訳) オライリージャパン 2018-08-10 単行本（ソフトカバー） 4873118557 (ASIN), 9784873118550 (EAN), 4873118557 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版あり。公式ドキュメントよりも系統的に書かれているので痒いところに手が届く感じ。ただし量が多いので，一度斜め読みしたらあとは傍らに置いて必要に応じてつまみ食いしていくのがいいだろう。\nreviewed by Spiegel on 2020-03-08 (powered by PA-APIv5)\n  Effective Java 第3版 Joshua Bloch (著), 柴田 芳樹 (翻訳) 丸善出版 2018-10-30 単行本（ソフトカバー） 4621303252 (ASIN), 9784621303252 (EAN), 4621303252 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  再勉強中。 Kindle 版のほうがちょっと安いが，勤務先でも使いたかったので紙の本にした。\nreviewed by Spiegel on 2021-03-17 (powered by PA-APIv5)\n   「改す」を「なおす」と読むのは辞書的に正しい日本語ではありません。念のため（笑） \u0026#x21a9;\u0026#xfe0e;\n C/C++ ではインクリメント/デクリメント演算子は前置（++x）と後置（x++）があって機能が異なる。これに起因する不具合も多く，コーディング・ルールで「インクリメント/デクリメントの後置は禁止」とするところが多いらしい。 \u0026#x21a9;\u0026#xfe0e;\n ここでいうリアルタイム処理とは「分割されたジョブを決められたタイミングで決められた期間内に完了すること」を指す。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Java 16 がリリースされた",
      "section": "release",
      "description": "OpenJDK および同系列 Java のショート・サイクルのバージョンアップ",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/java-16-is-released/",
      "published": "2021-03-17T10:32:20+00:00",
      "update": "2021-03-20T03:20:09+00:00",
      "content": "予定通り Java 16 がリリースされた。 OpenJDK および同系列 Java におけるショート・サイクルのバージョンアップである。\n JDK 16 JDK 16 GA Release JDK 16 Release Notes  OpenJDK を APT で管理するメリットはないので，実行バイナリをリリースページから直接ダウンロードして配置する。 以下は完全手動でのインストール（笑）\n$ cd /usr/local/src $ sudo curl -L \u0026#34;https://download.java.net/java/GA/jdk16/7863447f0ab643c585b9bdebf67c69db/36/GPL/openjdk-16_linux-x64_bin.tar.gz\u0026#34; -O $ cd .. $ sudo unlink java # 以前のバージョンの Java 環境がある場合 $ sudo tar xvf src/openjdk-16_linux-x64_bin.tar.gz $ sudo ln -s jdk-16 java $ java -version # すでに PATH が通っている場合 openjdk version \u0026#34;16\u0026#34; 2021-03-16 OpenJDK Runtime Environment (build 16+36-2231) OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing) 私としては PlantUML が動けばいいので，試しておく1。\nFactory Method Pattern  うむうむ。 ちゃんと動くな。\nScoop で OpenJDK 16 を入れる Windows 環境では Scoop を使って OpenJDK を入れているのだが，なかなかアップデートされない。 そこでバケットの中を見てみたのだが\n$ scoop search openjdk \u0026#39;java\u0026#39; bucket: adoptopenjdk-hotspot-jre (15.0.2-7) adoptopenjdk-hotspot (15.0.2-7) adoptopenjdk-lts-hotspot-jre (11.0.10-9) adoptopenjdk-lts-hotspot (11.0.10-9) adoptopenjdk-lts-openj9-jre (11.0.10-9-0.24.0) adoptopenjdk-lts-openj9-xl-jre (11.0.10-9-0.24.0) adoptopenjdk-lts-openj9-xl (11.0.10-9-0.24.0) adoptopenjdk-lts-openj9 (11.0.10-9-0.24.0) adoptopenjdk-lts-upstream-jre (11.0.10-9) adoptopenjdk-lts-upstream (11.0.10-9) adoptopenjdk-openj9-jre (16-36-0.25.0) adoptopenjdk-openj9-xl-jre (15.0.2-7-0.24.0) adoptopenjdk-openj9-xl (15.0.2-7-0.24.0) adoptopenjdk-openj9 (16-36-0.25.0) openjdk-ea (16-36) openjdk (15.0.2-7) openjdk10 (10.0.2-13) openjdk11 (11.0.2-9) openjdk12 (12.0.2-10) openjdk13 (13.0.2-8) openjdk14 (14.0.2-12) openjdk15 (15.0.2-7) openjdk16 (16-36) openjdk7-unofficial (7u80-b32) openjdk8-redhat-jre (8u282-b08) openjdk8-redhat (8u282-b08) openjdk9 (9.0.4-12) んー。 openjdk だと 16 に上がらないのか。 どうやら openjdk16 のようにバージョンを指定したほうがいいようだ。\nというわけで\n$ scoop install openjdk16 Installing \u0026#39;openjdk16\u0026#39; (16-36) [64bit] openjdk-16_windows-x64_bin.zip (175.1 MB) [===================================================================] 100% Checking hash of openjdk-16_windows-x64_bin.zip ... ok. Extracting openjdk-16_windows-x64_bin.zip ... done. Linking ~\\scoop\\apps\\openjdk16\\current =\u0026gt; ~\\scoop\\apps\\openjdk16\\16-36 $ scoop uninstall openjdk Uninstalling \u0026#39;openjdk\u0026#39; (15.0.2-7). Unlinking ~\\scoop\\apps\\openjdk\\current Removing ~\\scoop\\apps\\openjdk\\current\\bin from your path. Removing older version (15.0.1-9). \u0026#39;openjdk\u0026#39; was uninstalled. という感じに入れ換えた。 Windows Terminal を起動し直して\n$ java -version openjdk version \u0026#34;16\u0026#34; 2021-03-16 OpenJDK Runtime Environment (build 16+36-2231) OpenJDK 64-Bit Server VM (build 16+36-2231, mixed mode, sharing) よしよし，ちゃんと 16 になったな。 ちなみに各パッケージの旧バージョンを削除する場合は\n$ scoop cleanup openjdk16 などとすれば，最新バージョン以外は削除される。\nブックマーク  JDK 16 Security Enhancements Java 16正式リリース。JavaアプリをWin/Mac/Linuxのインストール形式にするパッケージャ登場、OpenJDKソースコードがGitHubへ移行 － Publickey Oracle、「Java 16」を発表 ～パターンマッチングinstanceofとrecord型が正式機能に - 窓の杜  参考図書  Effective Java 第3版 Joshua Bloch (著), 柴田 芳樹 (翻訳) 丸善出版 2018-10-30 単行本（ソフトカバー） 4621303252 (ASIN), 9784621303252 (EAN), 4621303252 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  再勉強中。 Kindle 版のほうがちょっと安いが，勤務先でも使いたかったので紙の本にした。\nreviewed by Spiegel on 2021-03-17 (powered by PA-APIv5)\n   2021-03-07 に PlantUML Version 1.2021.2 がリリースされている。 PlantUML の使い方等については拙文「真面目に PlantUML」シリーズを参考にどうぞ。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "『再発見の発想法』は非エンジニアこそ読んで欲しい",
      "section": "remark",
      "description": "3月14日は「円周率の日」で「数学の日」でアインシュタイン博士の誕生日である。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2021/03/the-essence-of-programming/",
      "published": "2021-03-13T22:31:13+00:00",
      "update": "2021-03-13T22:31:32+00:00",
      "content": "3月14日は「円周率の日」で「数学の日」でアインシュタイン博士の誕生日である。 世界の数学者と理学者と工学者は今日というめでたい日を盛大に祝うんだ！\nというわけで，今回は結城浩さん著作の『再発見の発想法』の感想文なんぞを書いてみる。 読書感想文は久しぶりだな（笑）\nソフトウェエア・エンジニアというのは不思議な職業で，それ単体では成立し得ない。 何故ならソフトウェアを使う人の多くはソフトウェエア・エンジニア以外の人たちだからだ。\nたとえば工場 (こうば) の工員さんやコールセンターの中の人，役場のお役人様やタクシーや長距離トラックの運ちゃん，そういった人たちのために私達エンジニアは日々頭を悩ませている。\n特に悩ましいのは業種や職場によって独自の用語や隠語があることだ。 だから私達はシステムを作る際にはまず「用語集」を作る。\n『再発見の発想法』6.2章に出てくる「ベンチマーク（benchmark）」という単語なんかが典型的だが，同じ言葉なのに業種によって少しずつ意味が異なることがある。 そうした言葉の背後にある差異に気づかず設計を推し進めると，後でとんでもないしっぺ返しを食らったりするのだ。\nでも，最初の段階でお互いに言葉をすり合わせて「用語集」を作っておくと，以後のコミュニケーションがスムーズになる。 特に考え方や手段といった目に見えないものに「名前」を付けることは重要で，名前を付けることで議論のアンカーもしくは原点として機能し始める。 私は名前の「正しさ」というものを全く信用していない不遜な人間だが，当事者がお互いに同じ言葉を同じ意味で話すことの重要性は理解しているつもりである。\nとはいえ，私達エンジニアが普段どんな言葉を喋ってどんな思考のもとに設計しコードを組み立てていくか知ってほしいというのも本音だ。\nそこで，いよいよ『再発見の発想法』の登場である。\nこの本は結城浩さんによる「Software Design」誌上の同名連載をまとめたものだそうで，さまざまな「技術用語」について解説したものだ。 しかし，内容は技術系雑誌に掲載されていたとは思えないほど平易な言葉で書かれている。\n用語の意味とその背後にある考え方と日常生活になぞらえた例示が絶妙なバランスで配置されていて，この辺のさじ加減の上手さは流石結城浩さんと言うしかない。 やはり《例示は理解の試金石》（by 数学ガール）なんだねぇ。\nソフトウェア・エンジニアリングの有名な格言（？）に「推測するな，計測せよ」というのがある。 『再発見の発想法』に出てくる技術用語の選択は，まさに 計測→評価→改修 というエンジニアリングの基本サイクルを意識している印象がある。\n技術系雑誌の連載が出自だし「再発見」というタイトルには私達エンジニアが普段使っている言葉を見直すという意味が含まれているのだろうが，私としてはこの本は非エンジニアの方々あるいはエンジニアを目指す若い方々にこそ読んで欲しい。 そして，本に出てくる言葉をエンジニアがつぶやいているときは「こういう風に考えてるんだなぁ」と感じていただければ幸いである。\nさて，積ん読状態の「数学ガール」シリーズも読み進めないとなぁ。 ようやく「本を読む」余裕が出てきたよ。\n参考図書  再発見の発想法 結城 浩 (著) SBクリエイティブ 2021-02-19 (Release 2021-02-20) Kindle版 B08S2LY9VG (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  「Software Design」誌の同名連載の書籍化。「技術用語」の解説書だが，平易な内容で読みやすい。\nreviewed by Spiegel on 2021-03-14 (powered by PA-APIv5)\n  プログラマの数学 第2版 結城 浩 (著) SBクリエイティブ 2018-01-16 (Release 2018-02-08) Kindle版 B079JLW5YN (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  タイトル通りプログラマ必読書。第2版では機械学習に関する章が付録に追加された。\nreviewed by Spiegel on 2018-03-19 (powered by PA-APIv5)\n  イミテーション・ゲーム／エニグマと天才数学者の秘密(字幕版) ベネディクト・カンバーバッチ (出演), キーラ・ナイトレイ (出演), マシュー・グード (出演), ロリー・キニア (出演), モルテン・ティルドゥム (監督), グラハム・ムーア (Writer)  (Release 2015-10-02) Prime Video B015SAFU42 (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  主人公であるアラン・チューリングは今もなお「天才」と称される数学者であり，「コンピュータの父」と呼ばれるほどの偉人である。そしてチューリングの偉業のひとつが，旧ナチス・ドイツの暗号機械「エニグマ」の解読である。作品はそのエニグマの解読を主軸に物語を展開していく。感想はこちら。\nreviewed by Spiegel on 2015-04-19 (powered by PA-APIv5)\n "
    },
    {
      "title": "Go 1.16.2 がリリースされた",
      "section": "release",
      "description": "セキュリティ・アップデートはなし。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2021/03/go-1_16_2-is-released/",
      "published": "2021-03-11T23:27:46+00:00",
      "update": "2021-03-11T23:30:23+00:00",
      "content": "Go 1.16.2 がリリースされた。\n Go 1.16.2 and Go 1.15.10 are released  セキュリティ・アップデートはなし。 一度に出せよ orz\ngo1.16.2 (released 2021/03/11) includes fixes to cgo, the compiler, linker, the go command, and the syscall and time packages. See the Go 1.16.2 milestone on our issue tracker for details. via Release History - The Go Programming Language  例によって Ubuntu の APT で管理している Go コンパイラは古いので，ダウンロードページからバイナリ（go1.16.2.linux-amd64.tar.gz）を取ってきて手動でインストールすることを強く推奨する。 以下は手動での作業例。\n$ cd /usr/local/src $ sudo curl -L \u0026#34;https://golang.org/dl/go1.16.2.linux-amd64.tar.gz\u0026#34; -O $ cd .. $ sudo unlink go # 以前の Go が入っている場合 $ sudo tar xvf src/go1.16.2.linux-amd64.tar.gz $ sudo mv go go1.16.2 $ sudo ln -s go1.16.2 go $ go version # /usr/local/go/bin にパスが通っている場合 go version go1.16.2 linux/amd64 アップデートは計画的に。\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "TinyGo で WebAssembly",
      "section": "golang",
      "description": "Go および TinyGo を使って WebAssembly へのコンパイルを行い Web ブラウザ上で動作させるところまでやってみる",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/webassembly-with-tinygo/",
      "published": "2021-03-11T12:01:29+00:00",
      "update": "2021-03-21T08:39:36+00:00",
      "content": "TinyGo は本家 Go のサブセットと言えるもので LLVM を使った組み込み用途特化のコンパイラである。 しかも LLVM が WebAssembly バイナリを直接出力できるということもあって TinyGo と WebAssembly の相性は本家 Go 以上と言える。\nというわけで今回は， Go および TinyGo を使って WebAssembly へのコンパイルを行い， Web ブラウザ上で動作させるところまでやってみることにする。\nTinyGo のインストール TinyGo が動作するためには，あらかじめ本家 Go のツールチェーンが導入済みであることが前提となる。 この記事では Go は導入済みであるとして話を進める。\nTinyGo は以下のリポジトリから最新版をダウンロード\u0026amp;インストールする。\n tinygo-org/tinygo: Go compiler for small places. Microcontrollers, WebAssembly, and command-line tools. Based on LLVM.  2021-03-11 時点での最新版は 0.17.0 である。 Go 1.16 以降が推奨らしい。\nUbuntu の場合 Ubuntu の APT や Snap の公式リポジトリにはないので， deb ファイルをダウンロードし，手動でインストールする。\n$ curl -L https://github.com/tinygo-org/tinygo/releases/download/v0.17.0/tinygo_0.17.0_amd64.deb -O $ sudo dpkg -i tinygo_0.17.0_amd64.deb $ tinygo version tinygo version 0.17.0 linux/amd64 (using go version go1.16.1 and LLVM version 11.0.0) ちなみに WSL/WSL2 上の Ubuntu にもインストール可能だそうだ。\nWindows の場合 Windows なら Scoop を使うのが最も簡単である。 Scoop なら本家 Go も簡単にインストールできるし TinyGo 用の周辺ツールも Scoop で簡単に導入できる。\n$ scoop install tinygo $ tinygo version tinygo version 0.17.0 windows/amd64 (using go version go1.16.1 and LLVM version 11.0.0) Docker の場合 Docker 環境も用意されているそうだ。 詳しくはこちら。\n Docker :: TinyGo - Go on Microcontrollers and WASM  ファイル構成 今回のファイル構成はこんな感じ。\n$ tree . . ├── hello │ ├── hello.go │ ├── index.html │ ├── wasm.js │ └── wasm_exec.js └── main.go main.go は簡易サーバのコードで，こんな感じになっている。\npackage main import ( \u0026#34;embed\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/fs\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) //go:embed hello var assets embed.FS func main() { addr := \u0026#34;localhost:3000\u0026#34; fmt.Printf(\u0026#34;Open http://%s/\\n\u0026#34;, addr) fmt.Println(\u0026#34;Press ctrl+c to stop\u0026#34;) root, _ := fs.Sub(assets, \u0026#34;hello\u0026#34;) fs := http.FileServer(http.FS(root)) http.Handle(\u0026#34;/\u0026#34;, http.FileServer(http.FS(root))) if err := http.ListenAndServe(addr, http.HandlerFunc(func(resp http.ResponseWriter, req *http.Request) { resp.Header().Add(\u0026#34;Cache-Control\u0026#34;, \u0026#34;no-cache\u0026#34;) if strings.HasSuffix(req.URL.Path, \u0026#34;.wasm\u0026#34;) { resp.Header().Set(\u0026#34;content-type\u0026#34;, \u0026#34;application/wasm\u0026#34;) } fs.ServeHTTP(resp, req) })); err != nil { fmt.Fprintln(os.Stderr, err) } } embed パッケージと //go:embed ディレクティブが便利！ 簡易サーバのコードについては拙文「紙芝居用の簡易サーバを書く【Go 1.16 版】 」を参照のこと。 今回用の設定としては *.wasm ファイルの Content-Type を application/wasm にすることくらいかな。 あとは no-cache の設定ね。\nwasm_exec.js ファイルは Go および TinyGo が用意しているファイルで，以下からコピってそのまま使えばよい。\n   処理系 パス     Go $GOROOT/misc/wasm/wasm_exec.js   TinyGo $TINYGOROOT/targets/wasm_exec.js    $GOROOT および $TINYGOROOT の値は，以下のコマンドで取得できる。\n$ tinygo env GOOS=\u0026#34;linux\u0026#34; GOARCH=\u0026#34;amd64\u0026#34; GOROOT=\u0026#34;/usr/local/go1.16.1\u0026#34; GOPATH=\u0026#34;/home/username/go\u0026#34; GOCACHE=\u0026#34;/home/username/.cache/tinygo\u0026#34; CGO_ENABLED=\u0026#34;1\u0026#34; TINYGOROOT=\u0026#34;/usr/local/lib/tinygo\u0026#34; みんな大好き Hello World さて hello/hello.go ファイルの中身だが，まずはこんな感じで。\n// +build js,wasm  package main import \u0026#34;syscall/js\u0026#34; func main() { ch := make(chan struct{}) js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, \u0026#34;hello\u0026#34;).Set(\u0026#34;innerHTML\u0026#34;, \u0026#34;Hello, World!\u0026#34;) \u0026lt;-ch // Code must not finish } JavaScript の DOM 構造に慣れている人ならそんなに難しくないだろう。 ID 名 hello の要素に文字列 Hello, World! を突っ込むだけの簡単なお仕事（笑）\nこれを Go および TinyGo の各コンパイラでコンパイルしてみる。\n$ GOOS=js GOARCH=wasm go build -o hello1.wasm -trimpath $ tinygo build -o hello2.wasm -target wasm ./hello.go 前者が本家 Go によるコンパイルで，後者が TinyGo によるコンパイルだ。 コンパイル結果は以下の通り。\n$ ll *.wasm -rwxrwxr-x 1 username username 1364695 3月 10 23:59 hello1.wasm* -rwxrwxr-x 1 username username 67375 3月 10 23:59 hello2.wasm* おうふ。 こんなに違うのか。\n本家 Go のコードが大きいのは，良くも悪くも POSIX 互換環境への依存度が高く組み込み用途に使うには余計なコードを抱え込んでしまうという事情がある。\n一方 TinyGo は LLVM の制約を受けるため，ガベージコレクションや並行処理などで本家 Go とは異なる挙動になる（他にもいくつかの標準パッケージが使えない場合があるらしい）。\nたとえば先ほどの\nfunc main() { ch := make(chan struct{}) js.Global().Get(\u0026#34;document\u0026#34;).Call(\u0026#34;getElementById\u0026#34;, \u0026#34;hello\u0026#34;).Set(\u0026#34;innerHTML\u0026#34;, \u0026#34;Hello, World!\u0026#34;) \u0026lt;-ch // Code must not finish } の最後を見ると，チャネル受信状態で処理が止まっているが（というか止めるためにわざわざこのように書いているのだが），これがないと TinyGo コンパイラがエラーを吐く場合があるようだ。\nWebAssembly コードのバインド hello/wasm.js ファイルは生成した WebAssembly コードを JavaScript 側にバインドするものである。 今回は以下のように書いてみた。\nfunction initWASM(url) { const go = new Go(); if (\u0026#39;instantiateStreaming\u0026#39; in WebAssembly) { WebAssembly.instantiateStreaming(fetch(url), go.importObject).then(function (obj) { go.run(obj.instance); }) } else { fetch(WASM_URL).then(resp =\u0026gt; resp.arrayBuffer() ).then(bytes =\u0026gt; WebAssembly.instantiate(bytes, go.importObject).then(function (obj) { go.run(obj.instance); }) ) } } これで\ninitWASM(\u0026#39;hello2.wasm\u0026#39;); という感じに任意の WebAssembly ファイルを取り込める。\nHTML の内容 以上を踏まえて hello/index.html ファイルの内容は以下のようにした。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;wasm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p id=\u0026#34;hello\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; initWASM(\u0026#34;hello2.wasm\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 実行結果 では，いよいよ動かしてみよう。\n$ go run main.go Open http://localhost:3000/ Press ctrl+c to stop 該当の URL を開くと\nHello  よーし，ちゃんと表示されているな。 ここまでは楽勝。\nWebAssembly の機能を JavaScript から呼び出す 以上のコードは WebAssembly 側から HTML 要素に値をセットしていたが，これではあまり応用できないだろう。 なので，今度は JavaScript 側から WebAssembly の機能を呼び出すことを考える。\nまずは hello/hello.go ファイルの内容を以下のように変更する。\n// +build js,wasm  package main import ( \u0026#34;strings\u0026#34; \u0026#34;syscall/js\u0026#34; ) func say(this js.Value, args []js.Value) interface{} { ss := []string{} for _, jss := range args { if s := jsString(jss); s != \u0026#34;\u0026#34; { ss = append(ss, s) } } return js.ValueOf(\u0026#34;Hello, \u0026#34; + strings.Join(ss, \u0026#34;, \u0026#34;)) } func jsString(j js.Value) string { if j.IsUndefined() || j.IsNull() { return \u0026#34;\u0026#34; } return j.String() } func main() { ch := make(chan struct{}) js.Global().Set(\u0026#34;say\u0026#34;, js.FuncOf(say)) \u0026lt;-ch // Code must not finish } JavaScript から呼び出す関数は\nfunc(this js.Value, args []js.Value) interface{} の関数型にする決まりのようだ。 また返り値は js.Value 型にして返すのだが，実際の Go の型と JavaScript の型の対応は以下のようになっているらしい。\n   Go JavaScript     js.Value [its value]   js.Func function   nil null   bool boolean   integers and floats number   string string   []interface{} new array   map[string]interface{} new object     via js - The Go Programming Language  さらに main() 関数内の\njs.Global().Set(\u0026#34;say\u0026#34;, js.FuncOf(say)) によって Go の say() 関数は JavaScript の global.say() 関数に紐付けられる。\nhello/wasm.js ファイルはそのままでOK。 hello/index.html ファイルの内容を以下のように書き換える。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;wasm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;Hello\u0026lt;/button\u0026gt; \u0026lt;p id=\u0026#34;hello\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; initWASM(\u0026#39;hello2.wasm\u0026#39;); document.querySelector(\u0026#39;button\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, event =\u0026gt; { document.getElementById(\u0026#34;hello\u0026#34;).innerHTML = global.say(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Chris\u0026#34;); }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; これで [Hello] ボタン押下で global.say() 関数が発火するはずである。 実行してみよう。\n$ go run main.go Open http://localhost:3000/ Press ctrl+c to stop この状態で画面を表示すると\nHello Button (1)  さらにボタンを押下すると\nHello Button (2)  よーし，うむうむ，よーし。\nこれなら応用が効きそうかな。 今回はここまで。\nブックマーク  WebAssembly · golang/go Wiki · GitHub Wasmer Go embedding 1.0 lift-off  GitHub - wasmerio/wasmer-go: 🐹🕸️ WebAssembly runtime for Go   Wasm By Example Go 製 WebAssembly ホスト環境パッケージ wax のご紹介 - bearmini\u0026rsquo;s blog Go × WebAssemblyで電卓のWebアプリを作ってみた - Sansan Builders Blog WASI (WebAssembly system interface) を Wasmtime と Node.js で試す - Qiita  参考図書  ソフトウェアデザイン 2021年3月号 谷本 心 (著), 水島 宏太 (著), 増田 亨 (著), 山本 悠滋 (著), 折原 レオナルド賢 (著), 米田 武 (著), 清水 洋治 (著), 結城 浩 (著), 刀根 諒 (著), 大串 肇 (著), 松本 直人 (著), クラスメソッド 木村(作) (著), エクスデザイン ninnzinn(画) (著), くつなりょうすけ (著), 広木 大地 (著), 中島 明日香 (著), 金谷 拓哉 (著), 高橋 永成 (著), 平岡 正寿 (著), 梶原 直人(監修) (著), 平櫛 貴章 (著), 星川 真麻 (著), けんちょん(大槻 兼資) (著), 大嶋 健容 (著), 職業「戸倉彩」 (著), mattn (著), 小野 輝也 (著), 濱田 康貴 (著), 森若 和雄 (著), 古川 菜摘 (著), 嘉山 陽一 (著), 平野 尚志 (著), 杉山 貴章 (著), Software Design編集部 (編集) 技術評論社 2021-02-18 (Release 2021-02-18) 雑誌 B08T7D2LFR (ASIN), 4910058270316 (EAN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  第2特集が「WebAssembly 入門」近年の動向を把握するには丁度いいだろう。\nreviewed by Spiegel on 2021-03-21 (powered by PA-APIv5)\n  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    }
  ]
}
