{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "カリー化に関する覚え書き",
      "section": "remark",
      "description": "関数型プログラミング言語への馴染みが薄いせいですぐ忘れちゃうのよ。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/03/currying/",
      "published": "2020-03-20T05:30:42+00:00",
      "update": "2020-03-20T09:09:06+00:00",
      "content": "どこぞの某ウイルスのせいでメチャメチャ忙しい。 しかもここ1ヶ月くらいですっかり脅威扇動型ビジネス・モデルへと変貌したようで，ホンマにいい迷惑である。 もはやため息しか出ない。 ので，この件は無視することに決めた。\nと，まぁ近況はこれくらいにして，今回は「カリー化」の話。 いや，関数型プログラミング言語への馴染みが薄いせいですぐ忘れちゃうのよ。\nというわけで，覚え書きとして記しておく。\nカリーは 飲みもの 動詞 Wikipedia によると「カリー化（currying）」とは\n 複数の引数をとる関数を、引数が「もとの関数の最初の引数」で戻り値が「もとの関数の残りの引数を取り結果を返す関数」であるような関数にすること via カリー化 - Wikipedia  とある。 「カリー」は偉い数学者である Haskell B. Curry の名前から拝借したものらしい。 名前が動詞化しちゃってるのね（笑）\n詳しくは近所の数学オタクに訊きなはれ。\n関数型言語におけるカリー化 ガチの関数型プログラミング言語 Haskell ではカリー化は言語仕様に組み込まれていて，たとえば関数 add の定義\nadd x y = x + y は実際にはカリー化表現\nadd = \\x -\u0026gt; \\y -\u0026gt; x + y の糖衣構文となっている1。\nカリー化のメリットは関数の部分適用（partial application）が作れることで，たとえば\nincrement = add 1 とすれば add を実引数 1 で部分適用とした新しい関数 increment をシンプルに記述できる。 もちろん，わざわざ名前を付けなくても無名関数として使えばいいのだが。\n関数型じゃなくてもカリー化はできる ガチの関数型プログラミング言語じゃなくても第一級関数（first-class function）をサポートするプログラミング言語であればカリー化の記述自体は可能である。\nたとえば Go 言語なら\npackage main import \u0026#34;fmt\u0026#34; func add(x int) func(int) int { return func(y int) int { return x + y } }  func main() { fmt.Println(add(1)(2)) //Output: 3 \tincrement := add(1) //partial application \tfmt.Println(increment(2)) //Output: 3 } のように書ける。 JavaScript でも\nfunction add(x) { return function(y) { return x + y; }; }  console.log(add(1)(2)); //Output: 3 let increment = add(1); //partial application console.log(increment(2)); //Output: 3 と書くことができる。 JavaScript ではアロー関数式が使えるので，関数 add の定義を\nconst add = x =\u0026gt; y =\u0026gt; x + y; などと書くことも可能である。 ここまでくると，だいぶ関数型っぽいよね。\n「それができる」ことと「そのように作られている」ことには天と地ほどの違いがある この記事を書いて思い出したが，随分前に脊髄反射で\nそんなこと言ってたら Go でだって関数型モドキな記述はできる。「それができる」ことと「そのように作られている」ことには天と地ほどの違いがある。何言ってるんだ、こいつw https://t.co/6YsZ0ouDQY\n\u0026mdash; Der Spiegel im Spiegel (@spiegel_2007) February 20, 2020  と呟いた。 今回の話はまさにそれ。\nまぁ，そもそも Go 言語の場合はシンプルを旨とする思想な上に構文（statement）の制約が強いため，関数型っぽい記述には（書けるとしても）向いてない。\nJavaScript は ES5 以降から関数型の要素を大幅に取り込んでいるが， Haskell と比較すれば分かるとおり，「関数」に対する考え方の根本が異なっている。\nこれは良し悪しの問題ではない。 まさに「制約は構造を生む」で，そうして生み出される構造と実装するシステムとの間で無理なくバランスし続けることがシステムを上手に運用するコツで，それこそが言語を選択する最重要ポイントだと思う（仕事ならね）。\n 公理によって与えられる暗黙の制約。この制約が集合の要素同士をしっかり結びつける。単純にしばるのではない、相互に秩序ある関係を結ぶ。言い換えれば――公理によって与えられる制約が構造を生み出しているのだ via 数学ガール／フェルマーの最終定理  システムを維持するために遺産や負債を抱え続けなければならない場合もあるが（それでも限度というか寿命はあるけど），そうでないならわざわざレガシーを選択する必然性は微塵もない。\nブックマーク  Haskell 超入門 - Qiita カリー化と部分適用（JavaScriptとHaskell） - Qiita    Haskell でカリー化を避けるなら add (x, y) = x + y のように引数をタプルにすればよい。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Rust の文字列操作（2）",
      "section": "rust-lang",
      "description": "文字列と他の型の値との相互変換について。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/character-string-2/",
      "published": "2020-03-11T11:24:35+00:00",
      "update": "2020-03-11T12:07:44+00:00",
      "content": "前回の続き。 Rust の文字列操作についてオベンキョ中です。\n他の型の値を文字列に変換する ある型が ToString トレイトを実装していれば to_string() メソッドを使って文字列に変換できる。 整数や浮動小数点数などの基本型は ToString トレイトを実装している。 以下のようにリテラル表現に対して直接 to_string() メソッドを起動することもできる。\nfn main(){println!(\u0026#34;{}\u0026#34;,(123).to_string());//Output: 123 println!(\u0026#34;{}\u0026#34;,(1.23).to_string());//Output: 1.23 println!(\u0026#34;{}\u0026#34;,(true).to_string());//Output: true println!(\u0026#34;{}\u0026#34;,(\u0026#39;あ\u0026#39;).to_string());//Output: あ }同じ基本型でもタプルや配列は ToString トレイトを実装していないため to_string() メソッドは使えない。\nfn main(){println!(\u0026#34;{}\u0026#34;,([1,2,3]).to_string());//Error: no method named `to_string` found for type `[{integer}; 3]` in the current scope }変換する文字列を整形する 今までさんざん出てきたので今更だが， format! 等のマクロを使えば他の型の値を変換する際の文字列を整形できる。\n   マクロ名 機能     format! 文字列を整形して String として出力する   print!, println! 文字列を整形して標準出力に出力する   write!, writeln! 文字列を整形して指定したストリームに出力する   panic! 文字列を整形して panic 出力に付加する    たとえば，こんな感じ。\nfn main(){println!(\u0026#34;{{{} = {num:#04x} = {num:#010b}}}\u0026#34;,num=15);//Output: {15 = 0x0f = 0b00001111} }プレースホルダ {which:how} の中身の how の部分が C/C++ や Go の printf 文の書式（%d など）に相当する。 意味もだいたい同じ。\n   書式 意味     なし 既定のテキスト   b 2進数   o 8進数   x 16進数（小文字）   X 16進数（大文字）   e 浮動小数点数科学技術記法（小文字）   E 浮動小数点数科学技術記法（大文字）   ? デバッグ出力   p ポインタ値    実はこれらの書式には対応するトレイトがあって，独自に作成した型でもトレイトを実装することで書式に対応できる。\n   書式 トレイト     なし std::fmt::Display   b std::fmt::Binary   o std::fmt::Octal   x std::fmt::LowerHex   X std::fmt::UpperHex   e std::fmt::LowerExp   E std::fmt::UpperExp   ? std::fmt::Debug   p std::fmt::Pointer    たとえば，以下の構造体 Person に対して\nstruct Person{age: u32,name: String,}std::fmt::Display トレイトを実装してみる。 こんな感じ。\nusestd::fmt;struct Person{age: u32,name: String,}implfmt::DisplayforPerson{fn fmt(\u0026amp;self,dest: \u0026amp;mutfmt::Formatter)-\u0026gt; fmt::Result{write!(dest,\u0026#34;{} ({})\u0026#34;,self.name,self.age)}}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};println!(\u0026#34;p1 = {}\u0026#34;,p1);//Output: p1 = alice (24) println!(\u0026#34;p1 = {}\u0026#34;,p1.to_string());//Output: p1 = alice (24) }std::fmt::Display トレイトを実装すると ToString トレイトもセットで実装される。 便利！\nstd::fmt::Debug トレイトの実装はもっと簡単で， derive 構文を使って\n#[derive(Debug)]struct Person{age: u32,name: String,}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};println!(\u0026#34;p1 = {:?}\u0026#34;,p1);//Output: p1 = Person { age: 24, name: \u0026#34;alice\u0026#34; } }とすればよい。\nちなみに全ての組み込み型と標準ライブラリで定義される型は std::fmt::Debug トレイトを実装済みなので，さきほど to_string() メソッドが使えないと書いたタプルや配列でも\nfn main(){println!(\u0026#34;{:?}\u0026#34;,(123,1.13));//Output: (123, 1.13) println!(\u0026#34;{:?}\u0026#34;,[1,2,3]);//Output: [1, 2, 3] }のようにできる。\n文字列から他の型の値を取得する std::str::FromStr トレイトを実装している型であれば文字列からその型の値を取得できる。\npubtraitFromStr: Sized {type Err;fn from_str(s: \u0026amp;str)-\u0026gt; Result\u0026lt;Self,Self::Err\u0026gt;;}整数や浮動小数点数などの基本型は std::str::FromStr トレイトを実装している。 返り値は Result 型なので何らかのエラーハンドリングが必要だが，以下のコードでは端折っている。 ゴメンペコン。\nusestd::str::FromStr;fn main(){println!(\u0026#34;{:?}\u0026#34;,i64::from_str(\u0026#34;123\u0026#34;));//Output: Ok(123) println!(\u0026#34;{:?}\u0026#34;,f64::from_str(\u0026#34;1.23\u0026#34;));//Output: Ok(1.23) println!(\u0026#34;{:?}\u0026#34;,bool::from_str(\u0026#34;true\u0026#34;));//Output: Ok(true) }ちなみに大文字の \u0026quot;TRUE\u0026quot; はダメらしい（笑）\nusestd::str::FromStr;fn main(){println!(\u0026#34;{:?}\u0026#34;,bool::from_str(\u0026#34;TRUE\u0026#34;));//Output: Err(ParseBoolError { _priv: () }) }小文字に変換すればいいかな。\nusestd::str::FromStr;fn main(){println!(\u0026#34;{:?}\u0026#34;,bool::from_str(\u0026amp;\u0026#34;TRUE\u0026#34;.to_lowercase()));//Output: Ok(true) }文字列に対して parse() メソッドを使う方法もある。 parse() メソッド内部で from_str() を呼び出しているらしい。\nfn main(){println!(\u0026#34;{:?}\u0026#34;,\u0026#34;123\u0026#34;.parse::\u0026lt;i64\u0026gt;());//Output: Ok(123) println!(\u0026#34;{:?}\u0026#34;,\u0026#34;TRUE\u0026#34;.to_lowercase().parse::\u0026lt;bool\u0026gt;());//Output: Ok(true) }記述としてはどっちもどっちだな。\n参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n  プログラミングRust Jim Blandy (著), Jason Orendorff (著), 中田 秀基 (翻訳) オライリージャパン 2018-08-10 単行本（ソフトカバー） 4873118557 (ASIN), 9784873118550 (EAN), 4873118557 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版あり。公式ドキュメントよりも系統的に書かれているので痒いところに手が届く感じ。ただし量が多いので，一度斜め読みしたらあとは傍らに置いて必要に応じてつまみ食いしていくのがいいだろう。\nreviewed by Spiegel on 2020-03-08 (powered by PA-APIv5)\n "
    },
    {
      "title": "Rust の文字列操作（1）",
      "section": "rust-lang",
      "description": " Rust では「文字列」としての操作対象を Unicode/UTF-8 に限定している。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/character-string-1/",
      "published": "2020-03-08T14:08:47+00:00",
      "update": "2020-03-10T12:45:26+00:00",
      "content": "さて，所有権について何とな〜く分かったところで，目先を変えて文字・文字列・文字列操作について調べていこう。\nRust の「文字列」は Unicode/UTF-8 限定 文字列操作で何が面倒かって複数の文字セットと文字エンコーディングが混在している点である。 そこで今どきのプログラミング言語は「文字列」としての操作対象を Unicode/UTF-8 に限定していることが多い。 Rust もそうした言語のひとつである。\nこんにちは，世界！ まずは，以下のコードを書いてみる。\nfn main(){println!(\u0026#34;こんにちは，世界！\u0026#34;);}ここで \u0026quot;こんにちは，世界！\u0026quot; はリテラル文字列で，実行すると\n$ cargo run こんにちは，世界！ と表示される。 println! マクロ引数のリテラル文字列も出力される文字列も UTF-8 エンコーディングである。\nここでリテラル文字列の \u0026quot;こんにちは，世界！\u0026quot; を強引に Shift-JIS に書き換えて実行するとどうなるか。\n$ pushd src/ $ cp main.rs main.rs.utf8.txt $ gonkf conv -s utf8 -d sjis main.rs.utf8.txt \u0026gt; main.rs $ popd $ cargo run error: couldn\u0026#39;t read src/main.rs: stream did not contain valid UTF-8 というわけでコンパイルに失敗しました（笑）\nRust における文字と文字列 Rust では Unicode/UTF-8 文字および文字列を扱うために以下の3つの型が存在する。\n   型名 内部表現 内容     char u32 文字（Unicode 符号点）   String Vec\u0026lt;u8\u0026gt; 可変長文字列（UTF-8）   str [u8] 文字列への参照（UTF-8）    char および str は組み込み型， String は標準ライブラリで定義される型である。\nstr 型は文字列に対するスライスで，それ自体は所有権を持たず（値を持たないため）範囲指定付きビューとして機能する。 通常は \u0026amp;str と参照の形で使う。\nString と str の関係はこんな感じ。\nfn main(){lets: String =\u0026#34;Hello World\u0026#34;.to_string();lethw: \u0026amp;str =s.as_str();letw: \u0026amp;str =\u0026amp;s[6..11];println!(\u0026#34;{}\u0026#34;,s);//Output: Hello World println!(\u0026#34;{}\u0026#34;,hw);//Output: Hello World println!(\u0026#34;{}\u0026#34;,w);//Output: World }図にするとこんな感じだろうか。\n \u0026quot;Hello World\u0026quot; などのリテラル文字列は型としては \u0026amp;'static str と表現できる。 ちなみに 'static はライフタイム注釈の特殊な表現で，生存期間がプログラム全域に及ぶという恐ろしいものである（笑）\nリテラル文字列の後ろの to_string() メソッドは文字列のコピーを返す。 リテラル文字列そのものがセットされているわけではない。\n文字列から文字を抽出する Rust の文字列の中身は UTF-8 バイト列なので，文字列から文字（厳密には Unicode 符号点1）を抽出するのは単純ではない。 そもそも\nfn main(){lets=\u0026#34;日本語\u0026#34;;println!(\u0026#34;{}\u0026#34;,s[0]);//Error: the type `str` cannot be indexed by `{integer}` }とかやってもコンパイル・エラーになるだけである。\n文字列から文字を抽出するには，例えばこんな感じに書ける。\nfn main(){lets1=\u0026#34;日本語\u0026#34;;println!(\u0026#34;{:?}\u0026#34;,s1.chars().nth(0));//Output: Some(\u0026#39;日\u0026#39;) lets2=s1.to_string();println!(\u0026#34;{:?}\u0026#34;,s2.chars().nth(1));//Output: Some(\u0026#39;本\u0026#39;) }まず chars() メソッドで文字列を文字単位のイテレータ Chars に変換し，更に nth() メソッドで任意の位置の文字を抽出している。 nth() メソッドは Option 型の値を返すので本来は何らかのエラー・ハンドリングが必要だが，今回は横着している2。 ゴメンペコン。\nあるいはもっと簡単に collect() メソッドを使って Chars から配列 Vec\u0026lt;char\u0026gt; に変換して\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;letchs=nihongo.chars().collect::\u0026lt;Vec\u0026lt;char\u0026gt;\u0026gt;();println!(\u0026#34;{}\u0026#34;,chs[0]);//Output: 日 }てな感じにも記述できる。\n「文字」列から「文字列」を生成する 1文字ではなく，先頭の2文字を抽出して文字列を生成してみる。 まずは素朴にこんな感じだろうか。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;letmutnippon=String::new();for(i,c)innihongo.chars().enumerate(){nippon.push(c);ifi\u0026gt;0{break;}}println!(\u0026#34;{}\u0026#34;,nippon);//Output: 日本 }うーん，微妙。 たとえば take() メソッドを使えば先頭から指定した数だけ要素を有効にできる。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;letmutnippon=String::new();forcinnihongo.chars().take(2){nippon.push(c);}println!(\u0026#34;{}\u0026#34;,nippon);//Output: 日本 }いや，そもそも for 文で回すってのがダサいというか\u0026hellip; ふむむー，そっか。 fold() メソッドを使えばいいのか。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;letnippon=nihongo.chars().take(2).fold(String::new(),|muts,c|{s.push(c);s});println!(\u0026#34;{}\u0026#34;,nippon);//Output: 日本 }でも「先頭の2文字を抽出する」だけなのに，コードが大袈裟すぎないか？ と思ってたら，ゴメン。 collect() メソッドを使えば一発で String に変換できたわ。\nfn main(){letnihongo=\u0026#34;日本語\u0026#34;;letnippon=nihongo.chars().take(2).collect::\u0026lt;String\u0026gt;();println!(\u0026#34;{}\u0026#34;,nippon);//Output: 日本 }なんだ，簡単ぢゃん orz\nブックマーク   Stringとstr入門 - Qiita\n  文字列操作 with Rust - Qiita\n  Rustで文字列の先頭文字や部分文字列を取得する - Qiita\n  spiegel-im-spiegel/charset_document: 「文字コードとその実装」 upLaTeX ドキュメント : 大昔に書いたドキュメントで内容が古いため，取り扱いには注意\n  spiegel-im-spiegel/text: Encoding/Decoding Text Package by Golang : gonkf コマンドはここで公開しています\n  参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n  プログラミングRust Jim Blandy (著), Jason Orendorff (著), 中田 秀基 (翻訳) オライリージャパン 2018-08-10 単行本（ソフトカバー） 4873118557 (ASIN), 9784873118550 (EAN), 4873118557 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版あり。公式ドキュメントよりも系統的に書かれているので痒いところに手が届く感じ。ただし量が多いので，一度斜め読みしたらあとは傍らに置いて必要に応じてつまみ食いしていくのがいいだろう。\nreviewed by Spiegel on 2020-03-08 (powered by PA-APIv5)\n   Unicode ではひとつの符号点がひとつの文字を表すとは限らない点に注意。これに関して以前に「Go 言語と Unicode 正規化」という記事を書いたので参考にどうぞ。 \u0026#x21a9;\u0026#xfe0e;\n エラー・ハンドリングについてはいつかどこかでやる予定。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "SETI@home 20年間の区切り",
      "section": "remark",
      "description": "とはいえ SETI@home プロジェクト自体は閉鎖されず，サイトとユーザ・アカウントは保持される。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/03/setiathome-hibernation/",
      "published": "2020-03-08T03:56:44+00:00",
      "update": "2020-03-08T03:56:56+00:00",
      "content": "SETI@home が休眠するらしい。\n SETI@home hibernation  休眠する最大の理由はあらかたのデータ解析が終わったからのようだ。\nWe\u0026rsquo;re doing this for two reasons:\n Scientifically, we\u0026rsquo;re at the point of diminishing returns; basically, we\u0026rsquo;ve analyzed all the data we need for now. It\u0026rsquo;s a lot of work for us to manage the distributed processing of data. We need to focus on completing the back-end analysis of the results we already have, and writing this up in a scientific journal paper.  via SETI@home hibernation  とはいえ SETI@home プロジェクト自体は閉鎖されず，サイトとユーザ・アカウントは保持される。\nHowever, SETI@home is not disappearing. The web site and the message boards will continue to operate. We hope that other UC Berkeley astronomers will find uses for the huge computing capabilities of SETI@home for SETI or related areas like cosmology and pulsar research. If this happens, SETI@home will start distributing work again. We’ll keep you posted about this. via SETI@home hibernation  科学的学術研究テーマとしての SETI (Search for Extra-Terrestrial Intelligence; 地球外知的生命探査) は広範囲かつ長期間の観測が要求される割に実りが少なく，分の悪い賭けといえる。\nボランティアとして参加する私達一般ユーザはともかく，プロジェクトを統括・運営するプロの研究者達は無償というわけにはいかない。 また（プロなのだから）区切られた期間できちんと結果を出さなければならない。 もちろんシステムを維持するためのコストもある（最初の頃はサーバや回線の確保が大変だった）。\nもともと SETI@home は2年間の期限付きプロジェクトだった。 それが世界中で予想以上の反響を巻き起こし3年4年と延長され，ついには BOINC なる汎用プラットフォームを生み出した1。\nBOINC 移行後は当時の熱狂も収まり（資金難に陥ることも度々あったが）ボランティア・ユーザが淡々と解析を行うスタイルで継続し，なんだかんだと正式稼働から20年も続いたわけだ。 天文学関連の学術プロジェクトで20年というのはさして長いわけではないだろうが（太陽観測なら2周期分に満たないw），このテーマでよくもこれだけもったというのが正直な感想である。\n現在の SETI@home は純粋に宇宙人探しをしているわけではなく AstroPulse2 などの関連プロジェクトに相乗りする形で運営されている。 したがって，今後 SETI@home と相乗り可能なプロジェクトが興れば再開される可能性がある。 あるいは全く違うアプローチのプロジェクトになるか。\nWe’re extremely grateful to all of our volunteers for supporting us in many ways during the past 20 years. Without you there would be no SETI@home. We’re excited to finish up our original science project, and we look forward to what comes next. via SETI@home hibernation  SETI@home の次回作にご期待ください，といったところか（笑）\nなお，私が参加している天文学関連の BOINC プロジェクトは（SETI@home 以外では）以下の通り。\n Einstein@Home Asteroids@home  BOINC では複数のプロジェクトを掛け持ちして効率よく回すのがコツである。 「計算機による信号傍受と解析は人類のためにこそ使いましょう」。\nHappy analyzing !!\nブックマーク   地球外知的生命体探査プロジェクト“SETI@home”が3月31日で一旦休止 - 窓の杜\n  Club-HUAA サポートページ\n  参考図書  ファースト・コンタクト―地球外知性体と出会う日 (文春新書) 金子 隆一 (著) 文藝春秋 1998-10-01 新書 4166600044 (ASIN), 9784166600045 (EAN), 4166600044 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  地球外文明探査の歴史を俯瞰する良書。\nreviewed by Spiegel on 2016-01-30 (powered by PA-APIv5)\n  SETI@homeファンブック―おうちのパソコンで宇宙人探し 野尻 抱介 (著) ローカス 2000-01-01 単行本 4898140866 (ASIN), 9784898140864 (EAN), 4898140866 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  内容は古いけど当時の「熱」を伝えた名著だと思うけどなぁ。著者の方が自己出版で Kindle で出してくれたらいいのに。\nreviewed by Spiegel on 2019-03-28 (powered by PA-APIv5)\n   もともと BOINC は “Berkeley Open Infrastructure for Network Computing” の略称だったが，現在は単に “BOINC” と呼ばれているようだ。 \u0026#x21a9;\u0026#xfe0e;\n AstroPulse は全天で特徴的なパルスを放つ天体を捜索するプロジェクトで SETI@home と相性がよかった。 AstroPulse で発見された連星パルサーが Einstein@Home の観測対象になったこともある。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2020-03-08 のブックマーク",
      "section": "bookmarks",
      "description": "「Let’s Encrypt discovers CAA bug, must revoke customer certificates」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2020/03/08-bookmarks/",
      "published": "2020-03-08T02:17:03+00:00",
      "update": "2020-03-08T02:17:16+00:00",
      "content": "リリース情報  Hugo 0.66.0: PostCSS Edition | Hugo Release Release v5.8.5 · mattn/jvgrep · GitHub : バイナリもリリース  セキュリティ＆プライバシー関連  Citrix脆弱性悪用と窃取データ公開が行われたランサムウェア被害事例についてまとめてみた - piyolog No, Facebook is not telling you everything | PI  Facebook\u0026rsquo;s Download-Your-Data Tool Is Incomplete - Schneier on Security   A Flaw in Billions of Wi-Fi Chips Let Attackers Decrypt Data | WIRED  Wi-Fi Chip Vulnerability - Schneier on Security   DNSSEC Validation (Revisited)  ブログ: DNSSECの検証(再検討)   Millions of websites face \u0026lsquo;insecure\u0026rsquo; warnings - BBC News  Let’s Encrypt discovers CAA bug, must revoke customer certificates | Ars Technica Let\u0026rsquo;s Encrypt Vulnerability - Schneier on Security Let\u0026rsquo;s Encryptが証明書300万件を失効処理、ソフトウェアの不具合で - ZDNet Japan   国立感染症研究所旧公式サーバーへの不正アクセスについてまとめてみた - piyolog  国立感染症研究所に不正アクセス、20年前のPerlプログラムが想定外の動作 | 日経クロステック（xTECH）   Security of Health Information - Schneier on Security  ブログ: 保健関連情報のセキュリティ   More on Crypto AG - Schneier on Security Intel製CPUの「修正済み」脆弱性が実は修正不可能であったことが判明、特権によるコード実行やDRMの回避などが可能 - GIGAZINE ブログ: EARN IT法は暗号化に対する攻撃である  天文関連  SETI@home hibernation  地球外知的生命体探査プロジェクト“SETI@home”が3月31日で一旦休止 - 窓の杜   \u0026ldquo;Cosmic String\u0026rdquo; Gravitational Waves Could Solve Antimatter Mystery - Scientific American  ブログ: 「宇宙ひも」の重力波が反物質の謎を解決するかも知れない   臨終間近の老星が変身する瞬間をアルマ望遠鏡が捉えた | 国立天文台(NAOJ)  知財関連  「Twitterはクソ」だけでは済まないDMCA悪用の問題 | P2Pとかその辺のお話R  Linux または Ubuntu に関する話題  Ubuntu 20.04 その15 - デフォルトの壁紙が決まる - kledgeb  その他  テック系ジャーナリストの大御所スティーブン・レヴィがFacebookに切り込む最後の（？）渾身作が刊行された - YAMDAS現更新履歴 Cloudflare、新サーバ群にAMD EPYC第二世代プロセッサを全面採用。サーバ市場で存在感を取り戻しつつあるAMD － Publickey A new Go API for Protocol Buffers - The Go Blog Webブラウザから利用可能な「Visual Studio Online」がDockerコンテナサポートなど機能強化、パブリックプレビュー版として － Publickey 「Kubeflow 1.0」正式版リリース。あらゆるKubernetes上にJupyter notebookなど機械学習の開発、トレーニング、デプロイ機能を構築 － Publickey rust - Rustの\u0026quot;unwrap()\u0026ldquo;は何をするものですか？ - スタック・オーバーフロー  "
    },
    {
      "title": "参照と借用",
      "section": "rust-lang",
      "description": "ちょっとした数理パズルだと思えばいい（笑）",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/references-and-borrowing/",
      "published": "2020-03-07T15:51:00+00:00",
      "update": "2020-03-08T00:33:08+00:00",
      "content": "前回の続きで，所有権に絡む話。\n参照と借用 まずはこのコードを出発点にしよう。\nstruct Person{age: u32,name: String,}fn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};println!(\u0026#34;{} ({})\u0026#34;,p1.name1,p.age);//Output: Alice (24) }毎回 println! マクロで出力を整形するのはかったるいので，整形を行う関数を考えてみる。 こんな感じ。\nstruct Person{age: u32,name: String,}fn display_person(p: Person)-\u0026gt; String {letmuts=p.name;s.push_str(\u0026#34; (\u0026#34;);s.push_str(\u0026amp;p.age.to_string());s.push_str(\u0026#34;)\u0026#34;);s}fn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};println!(\u0026#34;{}\u0026#34;,display_person(p1));//Output: Alice (24) }一見うまく行っているようだが，次の1行を足すとコンパイル・エラーになる。\nfn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};println!(\u0026#34;{}\u0026#34;,display_person(p1));println!(\u0026#34;{}\u0026#34;,p1.name);//Error: borrow of moved value: `p1` }これは 変数の p1 の値の所有権が display_person() 関数の引数 p に移動したからである。\n変数を引数にセットするたびに所有権が移るのは鬱陶しいので，変数の「参照」を引数にセットする。 こんな感じに書き換えてみよう。\nfn display_person(p: \u0026amp;Person)-\u0026gt; String {letmuts=p.name.clone();s.push_str(\u0026#34; (\u0026#34;);s.push_str(\u0026amp;p.age.to_string());s.push_str(\u0026#34;)\u0026#34;);s}2行目の宣言文も変わってることに注意。 実は2行目を\nfn display_person(p: \u0026amp;Person)-\u0026gt; String {letmuts=p.name;//Error: cannot move out of `p.name` which is behind a shared reference s.push_str(\u0026#34; (\u0026#34;);s.push_str(\u0026amp;p.age.to_string());s.push_str(\u0026#34;)\u0026#34;);s}のままにするとコンパイル・エラーになる。 引数 p は元の変数の値を「借用」しているに過ぎないので，所有権の移動はできないのである。 ていうか，最初の display_person() 関数は引数の値を壊してたのか。 コワイコワイ（笑）\n全体のコードは以下の通り。\nstruct Person{age: u32,name: String,}fn display_person(p: \u0026amp;Person)-\u0026gt; String {letmuts=p.name.clone();s.push_str(\u0026#34; (\u0026#34;);s.push_str(\u0026amp;p.age.to_string());s.push_str(\u0026#34;)\u0026#34;);s}fn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};println!(\u0026#34;{}\u0026#34;,display_person(\u0026amp;p1));//Output: Alice (24) println!(\u0026#34;{}\u0026#34;,p1.name);//Output: Alice }変数と参照の関係を図式化するとこんな感じだろうか。\n display_person() 関数の引数である参照変数 p は，値を直接参照しているのではなく，値の所有権を持つ変数 p1 を参照している点がポイントである。 このことを示す例を挙げてみよう。\n参照されている変数の値の所有権は移動できない 先程の main() 関数を少し弄って\nfn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};letp2=\u0026amp;p1;letp3=p1;//Error: cannot move out of `p1` because it is borrowed println!(\u0026#34;{}\u0026#34;,display_person(p2));println!(\u0026#34;{}\u0026#34;,p3.name);}とするとコンパイル・エラーになる。 参照されている変数の値の所有権は移動できないようだ。 まぁ，当たり前か。\nただし println! マクロの位置を少し変えると\nfn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};letp2=\u0026amp;p1;println!(\u0026#34;{}\u0026#34;,display_person(p2));//Output: Alice (24) letp3=p1;println!(\u0026#34;{}\u0026#34;,p3.name);//Output: Alice }問題なく動く。 これは参照変数 p2 のライフタイム（lifetime）が display_person() 関数実行完了をもって満了しているため。 その後の let p3 = p1; 宣言文では p1 を参照している変数はないので問題なく所有権を移動できる。\n変数のライフタイムを超えた参照はできない ちょっとへんてこりんなコードだが\nfn main(){letlong_p;{letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};long_p=\u0026amp;p1;//Error: `p1` does not live long enough println!(\u0026#34;{}\u0026#34;,p1.name);}println!(\u0026#34;{}\u0026#34;,display_person(long_p));}これもコンパイル・エラーになる。\n変数 p1 のライフタイムは\nfn main(){letlong_p;{letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};long_p=\u0026amp;p1;//Error: `p1` does not live long enough println!(\u0026#34;{}\u0026#34;,p1.name);}println!(\u0026#34;{}\u0026#34;,display_person(long_p));}このスコープだが，参照変数 long_p のライフタイムは main() 関数全域に及ぶため，最後の\nfn main(){letlong_p;{letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};long_p=\u0026amp;p1;//Error: `p1` does not live long enough println!(\u0026#34;{}\u0026#34;,p1.name);}println!(\u0026#34;{}\u0026#34;,display_person(long_p));}println! マクロ実行時で，元の変数 p1 のライフタイムは満了しているのに参照変数 long_p はまだ生きているという不整合が発生しているわけだ。\nコンパイル・エラーのメッセージだけ見ても分かりにくいかもしれないが，変数のライフタイムを頭に入れながら考えれば分かりやすいだろう。 ちょっとした数理パズルだと思えばいい（笑）\nライフタイム注釈 ここでもうひとつ関数を考えてみる。\n欲しいのは2つの Person インスタンスの age が小さい方を選択する関数である。 とりあえず何も考えずに書いてみよう。\nfn younger(l: \u0026amp;Person,r: \u0026amp;Person)-\u0026gt; \u0026amp;Person{//Error: missing lifetime specifier ifl.age\u0026lt;r.age{l}else{r}}残念。 コンパイルエラーになってしまった。\nこの関数では参照変数 l と r のうちどちらかを返すが，どちらを返すかは実行時にしか分からない。 したがって，以下の main() 関数内で\nfn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};letp2=Person{age: 18,name: \u0026#34;Bob\u0026#34;.to_string(),};letp3=younger(\u0026amp;p1,\u0026amp;p2);println!(\u0026#34;{}\u0026#34;,display_person(p3));}参照変数 p3 が参照しているのが p1 なのか p2 なのか（コンパイル時に）決定できないためライフタイムも決まらないのである。\nこういうときは younger() 関数に「ライフタイム注釈（lifetime annotation）」を付けるとよい。 こんな感じ。\nfn younger\u0026lt;\u0026#39;a\u0026gt;(l: \u0026amp;\u0026#39;aPerson,r: \u0026amp;\u0026#39;aPerson)-\u0026gt; \u0026amp;\u0026#39;aPerson{ifl.age\u0026lt;r.age{l}else{r}}ここでは 'a がライフタイム注釈に相当する。 アポストロフィ（'）から続く文字列で構成されている。 新しい younger() 関数では引数と返り値の \u0026amp;Person 参照変数が同じライフタイムであることをコンパイラに知らせている。\n全体のコードはこんな感じ。\nstruct Person{age: u32,name: String,}fn display_person(p: \u0026amp;Person)-\u0026gt; String {letmuts=p.name.clone();s.push_str(\u0026#34; (\u0026#34;);s.push_str(\u0026amp;p.age.to_string());s.push_str(\u0026#34;)\u0026#34;);s}fn younger\u0026lt;\u0026#39;a\u0026gt;(l: \u0026amp;\u0026#39;aPerson,r: \u0026amp;\u0026#39;aPerson)-\u0026gt; \u0026amp;\u0026#39;aPerson{ifl.age\u0026lt;r.age{l}else{r}}fn main(){letp1=Person{age: 24,name: \u0026#34;Alice\u0026#34;.to_string(),};letp2=Person{age: 18,name: \u0026#34;Bob\u0026#34;.to_string(),};println!(\u0026#34;{}\u0026#34;,display_person(younger(\u0026amp;p1,\u0026amp;p2)));//Output: Bob (18) }よーし，うむうむ，よーし。\n参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n "
    },
    {
      "title": "変数束縛",
      "section": "rust-lang",
      "description": "「値」は所有者である「変数」に束縛される。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/rust-lang/variable-bindings/",
      "published": "2020-03-01T12:08:53+00:00",
      "update": "2020-03-11T07:05:42+00:00",
      "content": "Rust の所有権（ownership）のルールは以下の3つ。\n Each value in Rust has a variable that’s called its owner (Rustの各値は、所有者と呼ばれる変数と対応している) There can only be one owner at a time (いかなる時も所有者は一つである) When the owner goes out of scope, the value will be dropped (所有者がスコープから外れたら、値は破棄される)  「値」は所有者である「変数」に束縛される。 これを「変数束縛（variable bindings）」と呼ぶ。\n実際に変数束縛がどのように機能しているかを見てみよう。\nCopy Semantics Rust において組み込みで定義されるデータ型は以下の通り。\n スカラー型  整数 (i8, u8, \u0026hellip;, isize, usize) 浮動小数点型（f32, f64） 論理値型（bool） 文字型（char）: Unicode 符号点   複合型  タプル型 配列型    タプル型はこんな感じで記述できる。\nfn main(){lettup=(500,6.4,1);println!(\u0026#34;tup = {:?}\u0026#34;,tup);//Output: tup = (500, 6.4, 1) }配列はこんな感じ。\nfn main(){letary=[1,2,3];println!(\u0026#34;ary = {:?}\u0026#34;,ary);//Output: ary = [1, 2, 3] }これらのデータ型は値と変数が一体になっていて（値が直接スタックに積まれるため），代入時に値のコピーが発生する。\nfn main(){letmutary1=[1,2,3];letary2=ary1;ary1[0]*=100;println!(\u0026#34;ary1 = {:?}\u0026#34;,ary1);//Output: ary1 = [100, 2, 3] println!(\u0026#34;ary2 = {:?}\u0026#34;,ary2);//Output: ary2 = [1, 2, 3] }イメージとしてはこんな感じ。\n このようにデータ型では値をコピーすることによって変数束縛を担保している。\nちなみに mut は変数が可変（mutable）であることを示す。 Rust では，全ての変数は宣言時に mut キーワードを付けない限り不変（immutable）である。\nMove Semantics Rust には上述のデータ型以外にもいくつかの型が存在する。 以下に主なものを挙げる。\n 構造体（struct） コレクション  文字列（String） ベクタ（Vec\u0026lt;T\u0026gt;） ハッシュマップ（HashMap\u0026lt;K, V\u0026gt;）    たとえば構造体なら\nstruct Person{age: u32,name: String,}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};println!(\u0026#34;p1 = {} ({})\u0026#34;,p1.name,p1.age);//Output: p1 = alice (24) }てな感じに書ける。\n組み込みのデータ型との違いは，変数で示しているものが，値そのものではなく，値への参照（のようなもの1）という点である。\n 今度は変数 p1 の値を別の変数に代入してみよう。\nstruct Person{age: u32,name: String,}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};println!(\u0026#34;p1 = {} ({})\u0026#34;,p1.name,p1.age);//Output: p1 = alice (24) letp2=p1;println!(\u0026#34;p2 = {} ({})\u0026#34;,p2.name,p2.age);//Output: p2 = alice (24) }一見うまく言っているようだが，println! マクロ2 の位置を変えると\nstruct Person{age: u32,name: String,}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};letp2=p1;println!(\u0026#34;p1 = {} ({})\u0026#34;,p1.name,p1.age);//Error: value borrowed here after move println!(\u0026#34;p2 = {} ({})\u0026#34;,p2.name,p2.age);}コンパイルエラーになる。\nこれは\nletp2=p1;の部分で値がコピーされず，所有権のみ移動してしまうため。\n 構造体やコレクションの各型の値はヒープ領域に置かれる。 ヒープ上の値に対して代入等を行うたびにコピーを行うのは高コストだし，かといって野放図に参照を増やすとヒープ管理が煩雑になってしまう。\nそこで所有権を「移動」することでヒープ管理の最適化を行うわけだ。\nCopy/Clone Trait じゃあ，構造体やコレクションのコピーはできないのかというと，ちゃんと救済措置はある。\nRust の標準ライブラリには Clone および Copy トレイトが用意されていてこれらを実装することで値のコピーが可能になる。\nちなみに「トレイト（trait）」とは，ここでは C++ や Java で言うところの interface クラスのようなものだと思っておけばよい。 トレイトに関しては多分その内ちゃんとした記事を書くと思う（笑）\nたとえば先程の Person 構造体に Clone トレイトを実装すると\nstruct Person{age: u32,name: String,}implCloneforPerson{fn clone(\u0026amp;self)-\u0026gt; Self{Person{age: self.age,name: self.name.clone(),}}}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};letp2=p1.clone();println!(\u0026#34;p1 = {} ({})\u0026#34;,p1.name,p1.age);//Output: p1 = alice (24) println!(\u0026#34;p2 = {} ({})\u0026#34;,p2.name,p2.age);//Output: p2 = alice (24) }のように clone() メソッドでコピーを生成できるようになる。 図にすると，こんな感じか。\n あるいは derive 構文3 を使えば\n#[derive(Clone)]struct Person{age: u32,name: String,}fn main(){letp1=Person{age: 24,name: \u0026#34;alice\u0026#34;.to_string(),};letp2=p1.clone();println!(\u0026#34;p1 = {} ({})\u0026#34;,p1.name,p1.age);//Output: p1 = alice (24) println!(\u0026#34;p2 = {} ({})\u0026#34;,p2.name,p2.age);//Output: p2 = alice (24) }のようにコンパイラが自動的に Clone トレイトを実装してくれる。\n実を言うと\n#[derive(Copy, Clone)]とすれば代入時に値をコピーできるようになるのだが， Person 構造体ではコンパイルエラーになってしまい上手く行かなかった。 色々試してみたが，どうも String 等のコレクションを含む構造体の Copy トレイトは実装できないようだ4。\n属性にコレクション型を含まないのであれば\n#[derive(Copy, Clone)]struct Complex{real: f64,image: f64,}fn main(){letc1=Complex{real: 1.23,image: 4.5,};letc2=c1;println!(\u0026#34;c1 = {} + {}i\u0026#34;,c1.real,c1.image);//Output: c1 = 1.23 + 4.5i println!(\u0026#34;c2 = {} + {}i\u0026#34;,c2.real,c2.image);//Output: c2 = 1.23 + 4.5i }てな感じに簡単に Copy トレイトを実装できる。\nふむむー。\nブックマーク  RustのコピーセマンティクスをCopyトレイトを実装して確認する ｜ Developers.IO  参考図書  プログラミング言語Rust 公式ガイド Steve Klabnik (著), Carol Nichols (著), 尾崎 亮太 (翻訳) KADOKAWA 2019-06-28 (Release 2019-06-28) 単行本 4048930702 (ASIN), 9784048930703 (EAN), 4048930702 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  公式ドキュメントの日本語版。索引がちゃんとしているので，紙の本を買っておいて手元に置いておくのが吉。\nreviewed by Spiegel on 2020-02-24 (powered by PA-APIv5)\n   厳密には Rust で「参照」は別のものを指すので，ここではユルく「のようなもの」という感じでご容赦を。 \u0026#x21a9;\u0026#xfe0e;\n println! って関数じゃなくてマクロなんですよ，奥さん。 \u0026#x21a9;\u0026#xfe0e;\n derive はマクロに似た拡張構文の一種。詳細については割愛する。ていうか，これから勉強する（笑） \u0026#x21a9;\u0026#xfe0e;\n derive 構文を使った Copy トレイトの実装はあくまでも bitwise なもので，たとえ String 等で Copy トレイトを実装してもスタック上のポインタ値等がコピーされるだけなので意味がないそうな。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2020-03-01 のブックマーク",
      "section": "bookmarks",
      "description": "「GraphQLの開発を単純化するHasuraが約10億円調達」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2020/03/01-bookmarks/",
      "published": "2020-03-01T03:06:25+00:00",
      "update": "2020-03-08T02:11:29+00:00",
      "content": "リリース情報  Go 1.14 is released - The Go Blog The Document Foundation announces LibreOffice 6.4.1 - The Document Foundation Blog Announcing Rust 1.41.1 | Rust Blog  バベルのインターネット  MIT Tech Review: ツイッター、「ブルームバーグ支持」アカウントを大量停止  セキュリティ＆プライバシー関連  マスクの注文確認を装った返信狙いスパムメールについてまとめてみた - piyolog マイクロソフト、Linux用のマルウェア対策ソフト「Microsoft Defender ATP for Linux」パブリックプレビュー － Publickey Apache Tomcat における脆弱性（CVE-2020-1938）について：IPA 独立行政法人 情報処理推進機構  Apache Tomcat の脆弱性 (CVE-2020-1938) に関する注意喚起   Firefox Enables DNS over HTTPS - Schneier on Security セキュリティに関する情報源を整理してみた 2020年版 - トリコロールな猫/セキュリティ Newly Declassified Study Demonstrates Uselessness of NSA\u0026rsquo;s Phone Metadata Program - Schneier on Security Securing the Internet of Things through Class-Action Lawsuits - Schneier on Security 全国初のダークウェブ一斉摘発キャンペーンについてまとめてみた - piyolog  天文関連  大型低温重力波望遠鏡KAGRA観測開始 | 国立天文台(NAOJ) MITの研究者が「小惑星の地球衝突を回避する方法」を考案 - sorae 宇宙へのポータルサイト ESA - The most powerful black hole eruption in the Universe : へびつかい座銀河団に天の川銀河が15個ぐらい入るサイズの空洞を発見。光速まで加速された電子で満たされており、超巨大ブラックホールが引き起こした爆発で作られたらしい  MIT Tech Review: 宇宙史上最大の爆発、へびつかい座銀河団で観測 ブログ: 「ビッグバン以来最大の爆発」を発見    知財関連  YouTube Fair Use: Documentary Makers Defeat Gaye, Thicke, Bee Gees \u0026amp; Jackson - TorrentFreak Copyright Troll Now Has its Own Piracy Tracking Tool - TorrentFreak 侵害コンテンツのダウンロード違法範囲拡大は、どういう目的で導入されようとし、どういう制度になろうとしているのか？ | HON.jp News Blog  その他  ブログ: ローコードとノーコードプラットフォームはプログラミングに革命をもたらすか? どこまで実現できるか\u0026ndash;「Raspberry Pi」をデータセンターで活用 - ZDNet Japan Google、Active Directoryのマネージドサービスを正式サービスとして開始 － Publickey 日米合意でMIDI 2.0が正式規格としてリリース。MIDI 2.0で変わる新たな電子楽器の世界 | | 藤本健の \u0026ldquo;DTMステーション\u0026rdquo; 2020年2月25日ニュース「地域で増えた患者は一般医療機関でも対応、と政府が基本方針 専門家会議は『この1～2週が急速拡大か瀬戸際』」 | SciencePortal ブログ: Fuchsiaのプログラミング言語ポリシー Coming soon: A new site for fully free collaboration — Free Software Foundation — working together for free software 「さくらのレンタルサーバ/マネージドサーバ」および「さくらのメールボックス」一部機能提供終了のお知らせ（2020年2月27日11：45修正） | さくらインターネット 1200人以上の全社員がリモートワーク。GitLabが公開する「リモートワークマニフェスト」は何を教えているか？ － Publickey GraphQLの開発を単純化するHasuraが約10億円調達 | TechCrunch Japan Raspberry Pi 4が価格据え置きでメモリー容量を2GBに倍増 | TechCrunch Japan 実装言語を「Go」から「Rust」に変更、ゲーマー向けチャットアプリ「Discord」の課題とは：Rustで処理速度を改善 - ＠IT さようなら、TypeScript enum | Kabuku Developers Blog  "
    },
    {
      "title": "LibreOffice 6.4 へのアップグレード",
      "section": "release",
      "description": "前回と同じく今回も公式サイトからファイルを取ってきてインストールした。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/03/upgrade-libreoffice-6_4/",
      "published": "2020-03-01T01:46:04+00:00",
      "update": "2020-03-01T01:48:45+00:00",
      "content": "LibreOffice 6.4 がリリースされた。\n Performance-focused LibreOffice 6.4 is available for download - The Document Foundation Blog The Document Foundation announces LibreOffice 6.4.1 - The Document Foundation Blog  Ubuntu で LibreOffice を導入する方法はいくつかあるが，前回と同じく今回も公式サイトから *.deb ファイルを取ってきてインストールした。 細かくチェックしたわけではないが 6.4 でも OpenPGP 鍵で暗号化したファイルが開けたので，まぁ問題なかろう。\n6.3 系と 6.4 系はパソコン上で共存できてしまうので 6.4 系のみを使うのであれば以前の 6.3 系は削除する。\n$ sudo apt remove libreoffice6.3* libobasis6.3* 6.4 系を削除する場合も\n$ sudo apt remove libreoffice6.4* libobasis6.4* でよい。\nブックマーク  Ubuntu に LibreOffice をインストールする3つの方法  "
    },
    {
      "title": "Go 1.14 がリリースされた",
      "section": "release",
      "description": "アップデートは計画的に。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/02/go-1_14-is-released/",
      "published": "2020-02-26T03:28:32+00:00",
      "update": "2020-02-26T03:31:05+00:00",
      "content": "Go 1.14 がリリースされた。 今回は2月中にリリースできてよかったね（笑）\n Go 1.14 is released - Google group Go 1.14 is released - The Go Blog Go 1.14 Release Notes - The Go Programming Language  主な変更点は以下の通り。\n Module support in the go command is now ready for production use. We encourage all users to migrate to go modules for dependency management. Embedding interfaces with overlapping method sets Improved defer performance Goroutines are asynchronously preemptible The page allocator is more efficient Internal timers are more efficient  via Go 1.14 is released - The Go Blog  個人的に気になっている点は以前「Go 1.14 リリース候補版」に書いているので，参考にどうぞ。\n例によって Ubuntu の APT で管理している Go コンパイラは古いので，ダウンロードページからバイナリ（go1.14.linux-amd64.tar.gz）を取ってきて手動でインストールすることを強く推奨する。\n$ cd /usr/local/src $ sudo curl \u0026#34;https://dl.google.com/go/go1.14.linux-amd64.tar.gz\u0026#34; -O $ cd .. $ sudo unlink go # 以前の Go が入っている場合 $ sudo tar xvf src/go1.14.linux-amd64.tar.gz $ sudo mv go go1.14 $ sudo ln -s go1.14 go $ go version # /usr/local/go/bin にパスが通っている場合 go version go1.14 linux/amd64 アップデートは計画的に。\nブックマーク  Changes to interfaces in Go1.14 - Dylan Meeus - Medium A Go Module Testbed « null program Inlined defers in Go · Go, the unwritten parts Go1.14で来るGo Modules関連の変更を見てみる - Qiita Go 1.14 リリースノート 日本語訳 - Qiita Go1.14のcontextは何が変わるのか - Qiita What\u0026rsquo;s new Go 1.14?  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n  Go言語による並行処理 Katherine Cox-Buday (著), 山口 能迪 (翻訳) オライリージャパン 2018-10-26 単行本（ソフトカバー） 4873118468 (ASIN), 9784873118468 (EAN), 4873118468 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  Eブック版もある。感想はこちら。 Go 言語で並行処理を書くならこの本は必読書になるだろう。\nreviewed by Spiegel on 2020-01-13 (powered by PA-APIv5)\n "
    }
  ]
}
