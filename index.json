{
  "title": "text.Baldanders.info",
  "url": "https://text.baldanders.info/",
  "feed": "https://text.baldanders.info/index.xml",
  "description": "帰ってきた「しっぽのさきっちょ」",
  "entry": [
    {
      "title": "AI はコピペ・プログラマを救うか",
      "section": "remark",
      "description": "2年前に「AI 時代に真っ先に駆逐される職業は（コピペ）プログラマなんじゃないだろうか」と書いたが，考え直すべき時かもしれない。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/10/programming-with-artificial-intelligence/",
      "published": "2020-10-05T06:39:17+00:00",
      "update": "2020-10-05T06:40:41+00:00",
      "content": "ガートナーが発表するハイプ・サイクルによると日本でも「人工知能」そのものはとっくに幻滅期に入っているわけだが，最近いくつか面白い記事を見かけたので，覚え書きとしてちょろんと書いておく。\n「AI がしたこと」の責任は誰が取るのか まずはこれ。\n リツイートしただけで著作者人格権を侵害し得るという判決が最高裁で確定(栗原潔) - 個人 - Yahoo!ニュース  微妙に釣りタイトルだが（笑），かいつまんで書くとこんな感じ。\n 「無断転載」の写真を無断で tweet した馬鹿がいた さらにその「無断 tweet」を retweet した人がいた（意図は不明） Retweet のプレビューは自動でトリミング表示され写真端のクレジット表記が隠される 写真の著作者側は，プレビューのトリミング表示は著作者人格権の侵害である，として retweet したユーザの情報開示を Twitter に求める Twitter 側は「プレビューのトリミングは表示上だけの問題だからいんじゃね？」と拒否したため訴訟に発展 知財高裁で Twitter 側が負けたので最高裁へ上告 最高裁は「プレビューのトリミング表示でも著作者人格権の侵害になりうる」と判断し上告を棄却  実際に侵害となるかどうかは別の事案になるだろう。\n日本における強すぎる著作者人格権や最高裁の判断については色々思うところがあるだろうが，それについては今は置いておいて，この結果 Twitter 側がどうしたか，である。 それがおそらくこの記事になるんだと思う。\n Twitterは投稿時の画像プレビューのトリミング方法をユーザーに委ねる方針へ | TechCrunch Japan  元が米国の記事なので人種差別に絡めて書いてあるが，日本人から見れば上の判決の直後だけに，この影響がないとは思わないだろう（笑）\nまぁ人種差別に絡めた話でも同じ結論だと思うが，要するに「『AI がしたこと』の責任は誰が取るのか」ってことだよね。\nAI に「製造物責任」は取れないんだから，その「責任」の所在は人間側にシフトせざるを得ない。 でもサービス・プロバイダはそんな「責任」は取りたくないので「じゃあユーザに押し付けちゃえばいいぢゃん」となる，当然ながら。\nその結果「プレビューのトリミングは君らが決めてくれ」となったわけだ。 その判断のフィードバックは当然行うんだろうけど。 監視資本主義社会だからね（笑）\n実に分かりやすい。\n「AI が書いたコード」の責任は誰が取るのか 同じことはプログラム・コードにも言えるだろう。\nライセンスでコード自体を「無保証」としても，そのコードで損害が発生したら誰かがそのペナルティを払わなくちゃいけない。 「AI が書いたコード」だから誰もペナルティを払わなくていい，とはならないはずだ。\nであれば，現在および現在の延長線上の未来において「AI がコードを書く」ことはないんじゃないだろうか。 技術的な可能性の有無は別として。\nAI はコピペ・プログラマを救うか というわけで次の記事。\n Pair Programming with AI – O’Reilly AIとのペアプログラミングは可能だろうか？ - YAMDAS現更新履歴  この中の以下の部分（引用の引用でゴメンペコン）\n そのソリューションはおそらく IDE に組み込まれるだろう。プログラマがやりたいことを、不正確で曖昧な英語でざっと記述することで始める。AI はその解決策がどんなものになるか、おそらくは疑似コードみたいなスケッチでそれに応える。それを受けてプログラマは、豊富なコード補完機能（つまりそう、GitHub とかそうしたものにあるすべてのコードを学習したモデルに基づく）を使って実際のコードを埋めて書き継ぐわけだ。 AIとのペアプログラミングは可能だろうか？より  を見て「それなんてエキスパートシステム？」って思ってしまったのだが（笑）\nもう少し踏み込んで考えると，現在でも「インプットしたコードに対して何らかの回答を返す」しくみはあるわけだ。 それこそ上の記事でも紹介されている Visual Studio IntelliCode とか，最近話題の GitHub Code Scanning の中核である CodeQL も確か AI ベースである。\nしかし，今だに「コードでないところからコードを生み出す」ことはできてない。 「ノーコード」だって「ロジックの表現がコードではない」というだけで，ロジック自体は人間が考えなきゃならないし，そのロジックを動かすためのコードは（別の）人間が書かなきゃならない。\n「プログラマがやりたいことを、不正確で曖昧な英語でざっと記述」したものを AI がコードに「翻訳」してくれるとして，誰が一番得をするか考えたら，それはコピペ・プログラマじゃないだろうか。\nだってコピペ・プログラミングで一番苦労するのは「コピー元」を探すことだから。 それを AI が肩代わりしてくれるんだよ。 コピペ・コード同士の整合性も AI が指摘してくれるだろう。 スキルも不要。 何故ならスキルの蓄積は人間ではなく AI の仕事になるから。\nAI がコードを書くことは（主に人間側の都合で）ない。 だがプログラミングに必要な道具（ロジックやコード）や提案は AI が用意してくれる。\nこうなると「よいプログラマ」の条件は「AI への質問が上手い人」になるかもしれない。 件の記事は機械が人間に寄り添うことを期待しているようにも読めるが，相手に合わせるのが得意なのは人間のほうだからね（笑）\n2年前に「AI 時代に真っ先に駆逐される職業は（コピペ）プログラマなんじゃないだろうか」と書いたが，考え直すべき時かもしれない。\n参考図書  いかにして問題をとくか G. ポリア (著), Polya,G. (原著), 賢信, 柿内 (翻訳) 丸善 1975-04-01 単行本 4621045938 (ASIN), 9784621045930 (EAN), 4621045938 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  数学書。というか問いの立てかたやものの考え方についての指南書。のようなものかな。\nreviewed by Spiegel on 2014-09-26 (powered by PA-APIv5)\n "
    },
    {
      "title": "2020-10-05 のブックマーク",
      "section": "bookmarks",
      "description": "「Webアクション「部屋裏のバイテン」第６話」他",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/bookmarks/2020/10/05-bookmarks/",
      "published": "2020-10-05T02:29:20+00:00",
      "update": "2020-10-05T02:32:11+00:00",
      "content": "リリース情報  Release 8.8.1 · mermaid-js/mermaid · GitHub OpenSSH 8.4 was released on 2020-09-27 Release August 2020 Recovery 3 · microsoft/vscode · GitHub  バベルのインターネット  アップルが中国App StoreからRSSリーダーのReederとFiery Feedsを削除 | TechCrunch Japan Facebookは米国選挙結果の「非合法性を主張する」広告を受け付けない | TechCrunch Japan  セキュリティ＆プライバシー関連  耐量子コンピュータ暗号の概要 | Zenn TwitterのAPIキーが漏えいした可能性\u0026ndash;開発者に警告 - ZDNet Japan 米警察当局はアマゾンの顧客データを情報要求ポータルから入手している | TechCrunch Japan When coffee makers are demanding a ransom, you know IoT is screwed | Ars Technica  Hacking a Coffee Maker - Schneier on Security Wi-Fi接続対応のコーヒーメーカーは「ランサムウェアに感染して身代金を要求される」可能性がある - GIGAZINE   GPSとGPS信号に対する攻撃｜ラック・セキュリティごった煮ブログ編集部｜note Negotiating with Ransomware Gangs - Schneier on Security 旧「Microsoft Edge」「Internet Explorer」の「TLS 1.0/1.1」対応は来年春にも削除へ - 窓の杜 2020年10月に発生した東京証券取引所のシステム障害についてまとめてみた - piyolog マイナンバーカードのセキュリティ向上へ　生体認証追加し多要素化検討 - ITmedia NEWS : セキュリティ劇場 Intezer - IPStorm Now Has a Linux Malware : Go のせいで malware がマルチプラットフォーム対応になったという言いがかり（笑） Paper Backup - KeePassXC : KeePassXC データベースの内容を紙に打ち出す方法 ある日突然、自社ドメインが乗っ取られた――“原因も手口も不明”の攻撃に、セキュリティチームはどう立ち向かったか - ITmedia エンタープライズ Microsoft 365の大規模障害、原因は未検証アップデートがデプロイシステムのバグにより通常のプロセスをバイパスして本番環境へ直接デプロイされたこと － Publickey  天文関連  長周期彗星が作るもう一つの黄道面 | 国立天文台(NAOJ) MIT Tech Review: 火星の南極に新たな地下湖、生命体が見つかる可能性も 火星最接近2020 | 国立天文台(NAOJ)  火星が地球に最接近（2020年10月） | 国立天文台(NAOJ)   JAXA | 過酷な月の宇宙放射線被ばく線量を縦孔利用で月表面の10%以下に Join Planet Patrol and Help TESS Hunt Exoplanets | SETI Institute サイエンスクリップ「8億年前、地球に起きた天体衝突に迫る 手がかりは月のクレーター」| SciencePortal ニュース - アルマ望遠鏡の運用再開に向けた準備について - アルマ望遠鏡 ニュース - アルマ望遠鏡、最期を迎える星が噴き出すガスを克明にとらえる - アルマ望遠鏡  知財関連  リツイートしただけで著作者人格権を侵害し得るという判決が最高裁で確定(栗原潔) - 個人 - Yahoo!ニュース 「アマビエ」の商標登録出願に拒絶理由通知(栗原潔) - 個人 - Yahoo!ニュース  Linux または Ubuntu に関する話題  電子辞書は組み込みLinuxの夢を見るか？ - Zopfcode Linux その71 - GNOME 40のリリーススケジュール（ドラフト） - kledgeb Ubuntu 20.04 その195 - Dellから第11世代のIntel CPUを搭載した新XPS 13 Developer Edition登場 - kledgeb Ubuntu 20.10 その9 - Ubuntu 20.10 β版がリリースされました・ディスクイメージのダウンロード - kledgeb  Go 言語関連  Amazon CloudWatch Agentのソースコードが公開されたのでナナメ読み - @netmarkjp GitHub - mercari/testdeck: Testdeck is a framework for integration, end-to-end (E2E), and security testing of gRPC microservices written in Golang. elsaland/elsa: ❄️ Elsa is a minimal, fast and secure runtime for Javascript and Typescript written in Go Microservices Deserve Modern Programming Platforms: Java May Not be the Best Option | Hacker Noon シェルスクリプトで作る Twitter bot 作成入門 | Zenn : 中核部分を Go で書く slack-go/slack v0.7.0 をリリースしました | Zenn Go言語で非同期処理の結果を受け取る | Zenn Go: How Does a Program Recover?. Panics in Go are triggered when the… | by Vincent Blanchon | A Journey With Go | Oct, 2020 | Medium Go, WebAssembly, HTTP requests and Promises | With Blue Ink Golang Weekly GitHub - cockroachdb/apd: Arbitrary-precision decimals for Go : いわゆる Decimal 型  Rust 言語関連  Rust ではじめる Twitter API | Zenn  その他  【連載】計算の歴史学とジェンダー―誰が計算をしていたのか？（前山和喜） - 文学通信 レッシグ新刊で知ったアメリカ政治二極化の力学 - 山形浩生の「経済のトリセツ」 C/C++言語のVisual Studio Code拡張機能がv1.0に到達、初の一般リリース - 窓の杜 PostgreSQL 13正式版リリース。B-Treeインデックスの重複排除、同一テーブル内でのVacuum並列処理など新機能 － Publickey Swift言語がWindowsのサポートを開始。コンパイラやライブラリなどWindows対応に － Publickey EUがアップルに対する1.5兆円超の罰金命令を棄却した判決を上訴 | TechCrunch Japan zenn-cli + reviewdog + textlint + GitHub Actions で執筆体験を最高にする | Zenn Androidデバイス上のウェブブラウザに向けたフォント設定を考える。 - freefielder.jp : だから Web フォントを OFF るとおかしいことになるのか Google、プロジェクト管理のための新ノーコードツール「Tables」発表。リスト／カンバン／チケット管理／マップなど柔軟なビュー、Botによる作業自動化など － Publickey  Googleのプロジェクト管理のためのノーコードツール「Tables」を使ってみた | Zenn   古いテレビの発するSHINE電波で村全体のネットがダウン | ギズモード・ジャパン How to Add a GitHub Actions Badge to Your Project - DEV 2020年9月29日ニュース「名大など、新型コロナの人工抗体を作製 治療や検査、感染防止薬に期待」 | SciencePortal ZennをRSSフィードで購読する | Zenn IBM Cloud大阪リージョンが稼働開始。東京リージョンと同じく3つのゾーンで構成。リージョン間の通信費無料 － Publickey ホテルのレビューで「星1」をつけた男性が逮捕され投獄される事態が発生 - GIGAZINE Raspberry Pi 4で仮想化ハイパーバイザが実行可能に。Xenハイパーバイザが移植完了を発表 － Publickey Token authentication requirements for API and Git operations - The GitHub Blog 「韓国民間人」射殺で文在寅「威信失墜」金正恩「謝罪」の波紋（上）：平井久志 | 記事 | 新潮社　Foresight(フォーサイト) | 会員制国際情報サイト  「韓国民間人」射殺で文在寅「威信失墜」金正恩「謝罪」の波紋（下）：平井久志 | 記事 | 新潮社　Foresight(フォーサイト) | 会員制国際情報サイト   2020年10月1日ニュース「高温ほど熱伝導率が大きくなる現象を観測 東大、窒化ケイ素薄膜で」 | SciencePortal Arm版「Windows 10」、x64エミュレーションに対応へ - ZDNet Japan Facebookの「監査審査会」に対抗し活動家による「真の監査審査会」が発足 | TechCrunch Japan Detecting Deep Fakes with a Heartbeat - Schneier on Security 7月に深刻なハッキングを受けたTwitterに新たな最高情報セキュリティ責任者が就任 | TechCrunch Japan 軽量か防水か遊び心か 『モバイルキーボード』スマホやタブレット用おすすめ5選｜TIME＆SPACE by KDDI BitTorrentを買収した中国の億万長者に対し元従業員たちが猛反発、一体何が起きているのか？ - GIGAZINE 郵便投票のデジタル申請は殆どの州でアクセシビリティーがない | TechCrunch Japan グーグルがDaydreamのサポートを打ち切りへ、VR白昼夢から完全覚醒か | TechCrunch Japan Webアクション「部屋裏のバイテン」第６話 : ぽじとろんの竹本泉観察記 COVID-19 and Acedia - Schneier on Security Twitterは投稿時の画像プレビューのトリミング方法をユーザーに委ねる方針へ | TechCrunch Japan インフラ構成図をReactで描けるツールを作った | Zenn Amazonの「沈黙で始まる会議」と「PowerPoint禁止」の密接な関係｜塚本 牧生｜note 『もうすぐ絶滅するという開かれたウェブについて 続・情報共有の未来』の（今度こそおそらく）最終版を公開 - YAMDAS現更新履歴 データ第一な世界を疑う技術を説く『Calling Bullshit』がタイムリーで面白そうだ - YAMDAS現更新履歴  "
    },
    {
      "title": "本当は怖い Blockchain",
      "section": "remark",
      "description": "Blockchain による不正と腐敗",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/10/blockchain-horror/",
      "published": "2020-10-04T01:21:50+00:00",
      "update": "2020-10-04T01:46:00+00:00",
      "content": "なんか Twitter の TL を眺めていると不穏な話ばかり流れてくるのだが，そもそも「デジタル庁」なるものは最初の1フィートで間違えている印象である。 その中でも気になるのが Blockchain が云々とかいう話で，老婆心ながらこの記事でも言及しておく。\nそもそも Blockchain は「通貨」の性質を持つデジタル・トークンの「取引」を扱うための仕組みで，本来は他に転用できない。 トークンが「通貨」の性質を持つことに意味があるからだ。\nでは，それ以外の部分で Blockchain の特徴と言えるものをいくつか挙げると\n 追記型データベースで，追記されたデータについて完全性（integrity）を保証する PoW (Proof-of-Work) によって追記するデータが正しい（誤りがない）ことを保証する1  PoW の対価として「通貨」の性質を持つデジタル・トークンを振り出す（または手数料を払う） PoW の結果の正しさは多数決で保証する   非中央集権型（decentralization）かつ peer-to-peer なシステム構成を前提とする 不特定多数が参加することを前提とする データベースのコピーは自由だが分岐（fork）は無用 公開鍵を ID としてそのまま用い，鍵の証明（certification）を行わない  といったところだろうか。\nなお，3番目から5番目までは2番目の PoW を達成するための要件である点に注意。 まぁ Blockchain 本家である Bitcoin は既に3番目と5番目の要件が瓦解しているのだが（笑）\n6番目についてもう少し詳しく書くと Blockchain は ID となる公開鍵が誰に帰属するかについて全く関知しない。 Blockchain が気にするのは取引履歴の一貫性と無矛盾性であり，この要件が達成されているなら取引を行ったのが「誰か」なんてどうでもいいのだ2。\nしかし実際には取引の主体となる「誰か」という情報は最重要であると言っていい。 したがって ID と「誰か」を関連付ける別の仕掛けが必要となる。 たとえば「ウォレット・サービス」とか「交換所」とか。\nBlockchain で「取引」を追記するためには当事者の秘密鍵で電子署名する必要があり，もし「交換所」等でそれを肩代わりしてもらうなら秘密鍵を預けなければならない（key escrow）。 まぁ銀行に通帳とキャッシュカードを預けるみたいなもんだね。 鬼畜（笑）\nさて，ここで問題。\n 中央集権的またはアクターが構造化されたシステム 特定の「誰か」のみシステム内部にコミットできる データの分岐（fork）を許容する  という3条件のいずれかの下で Blockchain を応用したシステムを導入したら何が起きるか。\n\u0026hellip;\u0026hellip;\n正解は「不正」と「腐敗（不正の常態化）」。 何故なら PoW 達成要件を満たさないから。\n行政システムなんてまさに上の3条件に当てはまるよね。 それで Blockchain を導入するとか，システムとして「不正」と「腐敗」を許容する，と言っているに等しい。\nあー，コワイコワイ。\nブックマーク  “Blockchain and Trust” by Bruce Schneier 公開鍵暗号の秘密鍵は絶対に渡してはならない（フリじゃないよ） | Zenn  参考図書  信頼と裏切りの社会 ブルース・シュナイアー (著), 山形 浩生 (翻訳) NTT出版 2013-12-24 単行本（ソフトカバー） 4757143044 (ASIN), 9784757143043 (EAN), 4757143044 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  社会における「信頼」とは。\nreviewed by Spiegel on 2015-11-28 (powered by PA-APIv5)\n   PoW の代替となる PoS (Proof-of-Stake) というのもあるが，ここでは割愛する。 PoS をザクッと説明すると「金持ち（の行動）は信用できる」とする仕組みだ。その通貨システムの「金持ち」なら不正をしてまで信用を破壊しないだろうという，ある意味で性善説（笑） \u0026#x21a9;\u0026#xfe0e;\n Bitcoin/Blockchain の「公開鍵が誰に帰属するかについては全く関知しない」という特徴を以って，これを匿名的なサービスと言っていた人も昔はいたが， Blockchain の外側で ID (＝公開鍵) とそれが帰属する「誰か」を紐付けることができるなら， Blockchain を解析してその「誰か」がしたことは分かるわけだ。実際にそういう調査を行う会社とかも存在する。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "バイト列の同値性（『プログラミング言語 Go』読書会より）",
      "section": "golang",
      "description": "色んな方法で比較してみる",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/equality-of-byte-arrays/",
      "published": "2020-10-03T10:27:34+00:00",
      "update": "2020-10-05T02:32:11+00:00",
      "content": "「第5回『プログラミング言語Go』オンライン読書会」に参加してみたです。\n以前 Discord で某エベントに参加したことがあったけど，やっぱオンラインイベントはしんどい。 それでもメインで喋る人が決まってるから，今回は楽なほうだったかな。 Discord にしろ Zoom にしろ，オンラインでフリートーク・イベントはかなり難しいと思うのだが，みんなどうしてるんだろう。\n閑話休題 (それはさておき) 。\n今回，のっけから面白い話を聞いた。 『プログラミング言語 Go』4.2章「スライス」に書かれている\n 配列と異なりスライスは比較可能ではありませんので，二つのスライスが同じ要素で構成されているかを検査するために == は使えません。標準ライブラリは二つのバイトスライス（[]byte）を比較するために高度に最適化された bytes.Equal 関数を提供しています。しかし… プログラミング言語 Goより  という部分（強調は私がやりました）。 実際にコードを見てみると\n// Equal reports whether a and b // are the same length and contain the same bytes. // A nil argument is equivalent to an empty slice. func Equal(a, b []byte) bool { // Neither cmd/compile nor gccgo allocates for these string conversions. \treturn string(a) == string(b) } てなことになっている。 で，「これのどこが『高度に最適化』なん？」という話があったらしい。\nバージョンを遡ってみると 1.12.7 までは\n// Equal returns a boolean reporting whether a and b // are the same length and contain the same bytes. // A nil argument is equivalent to an empty slice. func Equal(a, b []byte) bool { return bytealg.Equal(a, b) } となっていた。 ちなみに internal/bytealg は内部パッケージで，中身はほぼ（アーキテクチャ毎に）アセンブラで記述されている。 実は Go 1.13 では string 周りが大幅に強化されていて，その辺の影響が出ているのかもしれない。\nそれなら，どの程度のパフォーマンスか気になるよね。 というわけで，こんなコードを用意してみた1。\npackage eq import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; ) var ( hello1 = \u0026#34;I could tell you my pass phrase, but then I would have to kill you.\u0026#34; hello2 = \u0026#34;I could tell you my pass phrase, but then I would have to kill you.\u0026#34; helloA1 = [67]byte{0x49, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6d, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x49, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x2e} helloA2 = [67]byte{0x49, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6d, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x49, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x2e} helloS1 = []byte{0x49, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6d, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x49, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x2e} helloS2 = []byte{0x49, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6d, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x49, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x20, 0x79, 0x6f, 0x75, 0x2e} ) func BenchmarkByteEqual1(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if hello1 != hello2 { fmt.Printf(\u0026#34;false\u0026#34;) } } } func BenchmarkByteEqual2(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if !bytes.Equal([]byte(hello1), []byte(hello2)) { fmt.Printf(\u0026#34;false\u0026#34;) } } } func BenchmarkByteEqual3(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if helloA1 != helloA2 { fmt.Printf(\u0026#34;false\u0026#34;) } } } func BenchmarkByteEqual4(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if string(helloA1[:]) != string(helloA2[:]) { fmt.Printf(\u0026#34;false\u0026#34;) } } } func BenchmarkByteEqual5(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if !bytes.Equal(helloA1[:], helloA2[:]) { fmt.Printf(\u0026#34;false\u0026#34;) } } } func BenchmarkByteEqual6(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if string(helloS1) != string(helloS2) { fmt.Printf(\u0026#34;false\u0026#34;) } } } func BenchmarkByteEqual7(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { if !bytes.Equal(helloS1, helloS2) { fmt.Printf(\u0026#34;false\u0026#34;) } } } hello1, hello2 は string 型，helloA1, helloA2 は byte 配列，helloS1, helloS2 は []byte 型で中身はみんな同じ。 これらを使って同値性（equallity）をチェックするのだが，内訳はこんな感じ。\n   関数名 比較手順     BenchmarkByteEqual1 string == string   BenchmarkByteEqual2 bytes.Equal([]byte(string), []byte(string))   BenchmarkByteEqual3 \u0026lt;byte array\u0026gt; == \u0026lt;byte array\u0026gt;   BenchmarkByteEqual4 string(\u0026lt;array\u0026gt;[:]) == string(\u0026lt;array\u0026gt;[:])   BenchmarkByteEqual5 bytes.Equal(\u0026lt;array\u0026gt;[:], \u0026lt;array\u0026gt;[:])   BenchmarkByteEqual6 string([]byte) == string([]byte)   BenchmarkByteEqual7 bytes.Equal([]byte, []byte)    では，実際に動かしてみようか。\n$ go test -bench ByteEqual -benchmem goos: linux goarch: amd64 pkg: sample BenchmarkByteEqual1-4 301173402\t4.04 ns/op\t0 B/op\t0 allocs/op BenchmarkByteEqual2-4 8552673\t122 ns/op\t160 B/op\t2 allocs/op BenchmarkByteEqual3-4 182939372\t6.27 ns/op\t0 B/op\t0 allocs/op BenchmarkByteEqual4-4 191359716\t6.29 ns/op\t0 B/op\t0 allocs/op BenchmarkByteEqual5-4 191511163\t6.27 ns/op\t0 B/op\t0 allocs/op BenchmarkByteEqual6-4 168382664\t7.16 ns/op\t0 B/op\t0 allocs/op BenchmarkByteEqual7-4 167058468\t7.06 ns/op\t0 B/op\t0 allocs/op PASS ok sample\t12.140s 分かりやすく表にしておく。\n   比較手順 処理時間 (ns/op) Alloc 回数     string == string 4.04 0   bytes.Equal([]byte(string), []byte(string)) 122.00 2   \u0026lt;byte array\u0026gt; == \u0026lt;byte array\u0026gt; 6.27 0   string(\u0026lt;array\u0026gt;[:]) == string(array\u0026gt;[:]) 6.29 0   bytes.Equal(array\u0026gt;[:], \u0026lt;array\u0026gt;[:]) 6.27 0   string([]byte) == string([]byte) 7.16 0   bytes.Equal([]byte, []byte) 7.06 0    string → []byte へのキャスト時にアロケーションが発生している点に注意。\nつか string 同士の比較処理が速いな！ 配列と slice で若干差が出るのは仕方ないが，元が同じ型なら殆ど差がないようだ。 まぁ，これなら確かに\nfunc Equal(a, b []byte) bool { return string(a) == string(b) } でもいっか，って気になるよな。\nブックマーク   第５回「プログラミング言語Go」オンライン読書会 - Mikke\u0026rsquo;s blog\n  【改訂版】文字列連結はどれが速い？\n  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n   ちなみに “I could tell you my pass phrase, but then I would have to kill you.” という物騒なフレーズは Simson Garfinkel 氏の『PGP』に載っていたパスフレーズの事例である（笑） \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "Go 製のツールとパッケージをまとめてアップデートした",
      "section": "release",
      "description": "Update gpgpdump, books-data, gnkf, pa-api, aozora-api, openbd-api, gocli, and errs packages",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/release/2020/10/released-tools-and-packages-by-golang/",
      "published": "2020-10-02T07:40:54+00:00",
      "update": "2020-10-02T07:43:41+00:00",
      "content": "GitHub リポジトリにある Go 言語製のツールやパッケージについて GitHub Actions で CI (Continuous Integration) を回す目処が立ったので，設定を変更しリリースし直すことにした。 今回リリースしたツール・パッケージのうち主なものは以下の通り。\n Release v0.9.1 · spiegel-im-spiegel/gpgpdump · GitHub Release v0.5.8 · spiegel-im-spiegel/books-data · GitHub Release v0.1.3 · spiegel-im-spiegel/gnkf · GitHub Release v0.7.2 · spiegel-im-spiegel/pa-api · GitHub Release v0.2.6 · spiegel-im-spiegel/aozora-api · GitHub Release v0.2.6 · spiegel-im-spiegel/openbd-api · GitHub Release v0.10.3 · spiegel-im-spiegel/gocli · GitHub Release v1.0.2 · spiegel-im-spiegel/errs · GitHub  若干 lint に叱られたり軽微なバグを指摘されたりしたものもあるが，機能上の追加・変更はない。\nそれじゃあ，次のステージに行きましょう♪\nブックマーク   OpenPGP パケットを可視化する gpgpdump\n  書籍データ取得ツール books-data\n  GNKF: Network Kanji Filter by Golang\n  Go 言語用 PA-API v5 クライアント・パッケージ\n  Go 言語用青空文庫 API クライアント・パッケージ\n  Go 言語用 openBD クライアント・パッケージ\n  Go 言語用 CLI プログラミング支援パッケージ\n  Go 言語用エラーハンドリング・パッケージ\n  golangci-lint を GitHub Actions で使う\n  Go 依存パッケージの脆弱性検査\n  GitHub Actions でクロス・コンパイル（GoReleaser 編）\n  Go のコードでも GitHub Code Scanning が使えるらしい\n  参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n  射手座☆午後九時Don\u0026#39;t be late シェリル・ノーム starring May\u0026#39;n (メインアーティスト) FlyingDog 2008-05-08 (Release 2017-01-16) MP3 ダウンロード B01MZ8UA8O (ASIN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  移動中に聴くとノリノリになれる（笑）\nreviewed by Spiegel on 2020-10-02 (powered by PA-APIv5)\n "
    },
    {
      "title": "Go のコードでも GitHub Code Scanning が使えるらしい",
      "section": "remark",
      "description": "うん。簡単！",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/10/github-code-scanning-with-golang/",
      "published": "2020-10-01T09:03:46+00:00",
      "update": "2020-10-05T02:32:11+00:00",
      "content": "GitHub の Code Scanning 機能が全ユーザで有効になった。\n Github Code Scanning Code scanning is now available! - The GitHub Blog  「えー。どうせ Go 言語では使えないんでしょ？」と思ったが， C/C++, C#, Go, Java, JavaScript/TypeScript, Python で有効らしい。 というわけで，とりあえず手持ちの Go パッケージのリポジトリで試してみた。\nCode Scanning は各リポジトリの “Security” で設定できる。\n 一番下の “Code scanning alerts” の [Set up code scanning] ボタンを押す。 次に表示される以下の画面で\n [Set up this workflow] ボタンを押す。\nすると GitHub Actions 用の YAML ファイル編集画面が表示される。 今回は Go コードのリポジトリなので，こんな感じの内容になった。\n# For most projects, this workflow file will not need changing; you simply need# to commit it to your repository.## You may wish to alter this file to override the set of languages analyzed,# or to provide custom queries or build logic.name:\u0026#34;CodeQL\u0026#34;on:push:branches:[master]pull_request:# The branches below must be a subset of the branches abovebranches:[master]schedule:- cron:\u0026#39;0 6 * * 4\u0026#39;jobs:analyze:name:Analyzeruns-on:ubuntu-lateststrategy:fail-fast:falsematrix:# Override automatic language detection by changing the below list# Supported options are [\u0026#39;csharp\u0026#39;, \u0026#39;cpp\u0026#39;, \u0026#39;go\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;javascript\u0026#39;, \u0026#39;python\u0026#39;]language:[\u0026#39;go\u0026#39;]# Learn more...# https://docs.github.com/en/github/finding-security-vulnerabilities-and-errors-in-your-code/configuring-code-scanning#overriding-automatic-language-detectionsteps:- name:Checkout repositoryuses:actions/checkout@v2with:# We must fetch at least the immediate parents so that if this is# a pull request then we can checkout the head.fetch-depth:2# If this run was triggered by a pull request event, then checkout# the head of the pull request instead of the merge commit.- run:git checkout HEAD^2if:${{ github.event_name == \u0026#39;pull_request\u0026#39; }}# Initializes the CodeQL tools for scanning.- name:Initialize CodeQLuses:github/codeql-action/init@v1with:languages:${{ matrix.language }}# If you wish to specify custom queries, you can do so here or in a config file.# By default, queries listed here will override any specified in a config file. # Prefix the list here with \u0026#34;+\u0026#34; to use these queries and those in the config file.# queries: ./path/to/local/query, your-org/your-repo/queries@main# Autobuild attempts to build any compiled languages (C/C++, C#, or Java).# If this step fails, then you should remove it and run the build manually (see below)- name:Autobuilduses:github/codeql-action/autobuild@v1# ℹ️ Command-line programs to run using the OS shell.# 📚 https://git.io/JvXDl# ✏️ If the Autobuild fails above, remove it and uncomment the following three lines# and modify them (or add more) to build your code if your project# uses a compiled language#- run: |# make bootstrap# make release- name:Perform CodeQL Analysisuses:github/codeql-action/analyze@v1Go コードの検査だけならこのままコミットしてしまって構わない。 ちなみにコミットする場合は master ブランチ1 に対してではなく pull request 用のブランチを作ってそこにコミットしたほうがよい。 そうすれば PR 時に上記設定の action が走るので動作確認になるだろう。\nうん。 簡単！\nブックマーク  Workflow syntax for GitHub Actions - GitHub Docs GitHub、コードの脆弱性を検出する「Code Scanning」を全ユーザーに提供 - ZDNet Japan GitHub、コードの脆弱性などを発見してくれる「GitHub Code Scanning」正式版が提供開始。パブリックリポジトリには無料 － Publickey GitHub、開発者がセキュリティ脆弱性を発見するための支援機能「Code Scanning」 | マイナビニュース Go 依存パッケージの脆弱性検査    2020年10月から GitHub の新規リポジトリの既定ブランチ名が main になるらしい。ご注意を。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "国勢調査の思ひ出",
      "section": "remark",
      "description": "まだ回答してない人でネット回答可能であれば，ネットのほうが断然楽。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/10/census/",
      "published": "2020-10-01T03:09:11+00:00",
      "update": "2020-10-01T05:00:06+00:00",
      "content": "知り合いのブログ記事で\n 国勢調査オンライン - 電気ウナギ的○○  というのがあって「そういや前回はネットで回答したな」と思い出して作業用リポジトリに grep かけて探してみたらやっぱり書いてた。\n 国勢調査を片付けた  なんでも記事にしておくものである。 5年前の私 good work!\nあの会社は今 当時は「国勢調査オンライン」のサイト証明書は Symantec 社が発行していて，ページにデカデカとロゴが貼り付けてあって苦笑したものだが，当の Symantec 社は CA 事業の不祥事で Web ブラウザのベンダ企業から信用されなくなり，2017年に事業を手放している。\n Symantec→DigiCertでSSL/TLS証明書はどうなる？　日本国内にも認証局構築へ、IoT機器市場も見据え - INTERNET Watch  今回はどうしてるんだろうと見てみたら DigiCert 社だったよ。 何も変わってないな（笑）\nそういや DigiCert 社のルート CA 証明書は RSA/2048 鍵で2031年まで有効なんだよな。 ちなみに RSA/2048 鍵が acceptable なのは2030年までだ。 まぁ鼻の先は問題ないが，政府調達品でこの程度の認識しかない企業を使うのはどうなんだろう。\n【追記】 Facebook で教えてもらったが DigiCert 社の CA 証明書はよりサイクルの短いものに順次切り替えていくそうだ。 Web 用のサーバ証明書は長くても1年程度のサイクルになる筈だし，数年かけて切り替えていくイメージだろうか。 なりすましと本人確認 そういや5年前はうっかり Phishing サイトを作って怒られた輩がいて話題になった。\n 国勢調査の“偽サイト”作った意図は？　総務省から削除依頼……「騒ぎになり深く反省」と制作者 (1/3) - ITmedia ニュース  最近の「ドコモロ系事案」を引くまでもなく，なりすましや本人確認は古くて新しい問題であり続ける。 このご時世に「オンライン推奨」とか現政権は勇気あるな（皮肉）\n国勢調査が面白いのは，基本的に「戸」単位であり，その枠組みの中で識別できていれば「本人確認」は必ずしも必要条件ではないということだ。 そして，その「戸」単位の確認を行うのが「国勢調査員」である。 これは紙でもネットでも同じこと。 ネットで回答するにしても，そのアカウント情報は国勢調査員から貰わなければならない。\nそもそも路上生活者とかにも国勢調査員が出向いて聞き取り調査するんだよ。 日本語が通じない人達だって相当数いるだろうに，ホンマ国勢調査員のご苦労は察するにあまりある。\n故に「『コロナ』だからオンライン推奨」というのは全く以って詭弁である。 ちなみに，今回うちで国勢調査の回答をしたのは親父殿だが，パソコンもスマホも持ってないので紙で回答したらしい。 私？ 私はただの居候ですから（笑）\n「国勢調査オンライン」はダサいか どうも「国勢調査オンライン」のサイトをダサいとか文句を言ってる人がいるらしい。 まぁ今風ではないな（笑）\n今回は私は回答してないのでどうだったかは知らないが，前回ネットで回答してめっさ楽だったのは覚えている。 ぶっちゃけて言うが\n政府系サイトに SEO (屁のつっぱり)  は要らんですよ そもそも Web アクセシビリティってそんな簡単じゃない。 うちのサイトもそうだけど，本当に不特定に見易い使い易いサイトなんか無理である。 このブログサイトをダークモードにしてるのは，主に「私」のためだ。\nできるだけ多くの人に対応しようとして結果として今風じゃないデザインになったとしても，利用者が文句を言う筋合いじゃないのだ。 機能要件やセキュリティ要件を満たしていない部分があるのなら，文句を言って然るべきだけど（笑）\nというわけで，まだ回答してない人でネット回答可能であれば，ネットのほうが断然楽なので，お試しあれ。\nいまさら思い出したが\u0026hellip; このブログサイト，正式オープンから5周年だわ。 何も考えてなかった。\nまぁ，この前買ったタブレットがご褒美ということで（笑）\nブックマーク  NIST SP 800-207: “Zero Trust Architecture” Authenticator と AAL  "
    },
    {
      "title": "GitHub Actions でクロス・コンパイル（GoReleaser 編）",
      "section": "golang",
      "description": "公式の GitHub Action があるので，それを使えばよい。簡単！",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/cross-compiling-in-github-actions-with-goreleaser/",
      "published": "2020-09-30T06:14:35+00:00",
      "update": "2020-09-30T07:22:49+00:00",
      "content": "以前（3年前だ！）に Travis CI と GoReleaser でクロス・コンパイル\u0026amp;デプロイを行う方法を紹介したが，今回は GitHub Actions を使う方法を紹介する。 なお GoReleaser 自体の説明については（だいぶ内容が古いが）以下の記事を参考にどうぞ。\n Travis CI でクロス・コンパイル（GoReleaser 編）  紹介と言っても公式の GitHub Action があるので，それを使えばよい。\n goreleaser/goreleaser-action: GitHub Action for GoReleaser  リポジトリの .github/workflows/ ディレクトリに YAML ファイル（例えば build.yml）を置き，以下のように記述する。\nname:buildon:push:tags:- v*jobs:goreleaser:runs-on:ubuntu-lateststeps:- name:Checkoutuses:actions/checkout@v2with:fetch-depth:0- name:Set up Gouses:actions/setup-go@v2with:go-version:1.15- name:Run GoReleaseruses:goreleaser/goreleaser-action@v2with:version:latestargs:release --rm-distenv:GITHUB_TOKEN:${{ secrets.GITHUB_TOKEN }}これでバージョンタグを打った際に GoReleaser によるクロス・コンパイルとデプロイが走る。 簡単！\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n "
    },
    {
      "title": "Go 依存パッケージの脆弱性検査",
      "section": "golang",
      "description": "nancy を使うのがよさげである。",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/golang/check-for-vulns-in-golang-dependencies/",
      "published": "2020-09-30T03:49:21+00:00",
      "update": "2020-09-30T06:15:03+00:00",
      "content": "どの言語でも同じだけど，インポートする外部パッケージが安全かどうかを調べるのはけっこう大変である。 で， Go 言語の場合は nancy を使うのがよさげである。\n sonatype-nexus-community/nancy: A tool to check for vulnerabilities in your Golang dependencies, powered by Sonatype OSS Index  nancy は “Sonatype OSS Index” の情報を使って依存パッケージ／モジュールの検査をしてくれる。 ツール自体は Apache-2.0 でライセンスされている。 提供されているデータについては\nOSS Index and the associated tools are and always will be free to the community. The data we gather is derived from public sources, and does not include human curated intelligence nor expert remediation guidance. via Sonatype OSS Index  とあるので，オープンな場で使うなら問題ないかな。\n使い方は簡単で，開発中のパッケージのリポジトリ上で\n$ go list -json -m all | nancy sleuth とすればよい。 問題なければ\n$ go list -json -m all | nancy sleuth -n ┏━━━━━━━━━━━━━━━┓ ┃ Summary ┃ ┣━━━━━━━━━━━━━┳━┫ ┃ Audited Dependencies ┃ 9┃ ┣━━━━━━━━━━━━━╋━┫ ┃ Vulnerable Dependencies ┃ 0┃ ┗━━━━━━━━━━━━━┻━┛  みたいな感じで結果を返してくれる。 問題のあるパッケージ／モジュールを含んでると，ものすごい勢いで叱られるけど（笑）\nGitHub Actions でも使える nancy には GitHub Actions も用意されている。 ありがたや。\n sonatype-nexus-community/nancy-github-action: Sonatype Nancy for GitHub Actions  設定は簡単。 リポジトリの .github/workflows/ ディレクトリに YAML ファイル（例えば vulns.yml）を置き，以下のように記述する。\nname:vulnson:push:tags:- v*branches:- masterpull_request:jobs:vulns:name:Vulnerability scannerruns-on:ubuntu-lateststeps:- uses:actions/checkout@v2- uses:actions/setup-go@v2with:go-version:^1.13- name:WriteGoListrun:go list -json -m all \u0026gt; go.list- name:Nancyuses:sonatype-nexus-community/nancy-github-action@mainこれで pull request 時， master ブランチ1 への push 時，およびバージョンタグを打った際に脆弱性検査が走る。\n依存の依存パッケージに脆弱性がある 直接インポートするパッケージに脆弱性があるなら無害なバージョンに差し替えればいいけど，依存パッケージが依存しているパッケージに脆弱性がある場合はどうするか。\nとりあえず，そのパッケージ宛てには issue を投げておくとして，それまでの継ぎとしては go.mod ファイルの replace ディレクティブを使って凌ぐことができそうだ。\nたとえば，依存パッケージが github.com/coreos/etcd v3.3.13 に依存してるんだけど v3.3.13 に脆弱性がある場合，\nreplace ( github.com/coreos/etcd v3.3.13+incompatible =\u0026gt; github.com/coreos/etcd v3.3.25+incompatible ) などとして無害なバージョンに差し替えできる。\nrequire ディレクティブで\nrequire ( github.com/coreos/etcd v3.3.25+incompatible ) とか書いても同じ効果があるけど，名目だけの依存関係で実際にはインポートしないパッケージは go mod tidy コマンドで記述が削除されちゃうのでオススメできない。\ngo list -m all って，実際にはリンクしない名目上の依存関係も全部拾ってリストアップしちゃうので，凄い面倒くさいんだよねぇ。 実際にリンクするパッケージだけリストアップしてくれないものだろうか\u0026hellip;\n参考図書  プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES) Alan A.A. Donovan (著), Brian W. Kernighan (著), 柴田 芳樹 (翻訳) 丸善出版 2016-06-20 単行本（ソフトカバー） 4621300253 (ASIN), 9784621300251 (EAN), 4621300253 (ISBN), 9784621300251 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K\u0026amp;R” の K のほうである。この本は Go 言語の教科書と言ってもいいだろう。\nreviewed by Spiegel on 2016-07-13 (powered by PA-APIv5)\n   2020年10月から GitHub の新規リポジトリの既定ブランチ名が main になるらしい。ご注意を。 \u0026#x21a9;\u0026#xfe0e;\n   "
    },
    {
      "title": "2020年10月の暦",
      "section": "remark",
      "description": "どっかの馬鹿な国際スポーツ大会のせいで今年の10月の祝日はなくなりました orz",
      "author": "Spiegel",
      "license": "http://creativecommons.org/licenses/by-sa/4.0/",
      "url": "https://text.baldanders.info/remark/2020/09/ephemeris-202010/",
      "published": "2020-09-30T01:49:54+00:00",
      "update": "2020-10-05T02:32:11+00:00",
      "content": "2020年10月も spiegel-im-spiegel/koyomi パッケージを作って暦を浚ってみる。 なお spiegel-im-spiegel/koyomi パッケージは v0.1.5 をリリースしている。 今回も外部パッケージのバージョンを上げただけだけど。\n国立天文台のデータを使っているため，暦象の基準が日本の暦になっている点に注意。\n   日付 内容     2020-10-02 望(満月)   2020-10-02 水星が東方最大離角   2020-10-06 火星が地球最近   2020-10-08 寒露   2020-10-10 下弦   2020-10-14 火星が衝   2020-10-14 水星が留   2020-10-17 朔(新月)   2020-10-20 土用の入り   2020-10-23 上弦   2020-10-23 霜降   2020-10-26 水星が内合   2020-10-31 望(満月)    そうそう。 どっかの馬鹿な国際スポーツ大会のせいで今年の10月の祝日はなくなりました orz\n天象 各用語の意味は以下の通り。\n   天象 - 国立天文台暦計算室より  「留」とは「惑星の地心視赤経の時間変化が0、すなわち赤経方向の動きが止まる瞬間」，もっと簡単に言うと天球上の（見かけの）惑星の動きが反転する瞬間を指す。\n火星が最接近 既に十分見頃だが火星が 2020-10-06 に最接近となる。 つっても中接近くらいだけど。\n中秋の名月とブルームーン 今年は 2020-10-01 が中秋の名月で，翌2日が望（満月）である。 そんで，10月最終日の日付が変わる直前（23:49）に2回目の望となる。 いわゆる「ブルームーン」である。\n実は「月内2回目の満月」をブルームーンと呼ぶのは天文雑誌 “Sky \u0026amp; Telescope” による誤解なのだが，けっこう定着しちゃってる感がある（笑） 元々は “Once in a blue moon” といって「ありえないこと」とか「滅多にないこと」を指す慣用句で，世界各地に逸話や伝説があるらしい。\n土用の入り 「土用の入り」は雑節のひとつで，元々は「五行説」の考えから来たものである。\n四季を「五行説」に当てはめようとするとひとつ足らなくなるので，各季節の終わりの1/5ずつを集めて土の季節つまり「土用」としたそうな。 無理やりですねぇ（笑）\n現在の定義では太陽黄経が 27°, 117°, 207°, 297° となる日が「土用の入り」となる。\nコード 今回使用したコードは以下の通り。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/spiegel-im-spiegel/koyomi\u0026#34; ) func main() { start, _ := koyomi.DateFrom(\u0026#34;2020-10-01\u0026#34;) end, _ := koyomi.DateFrom(\u0026#34;2020-10-31\u0026#34;) k, err := koyomi.NewSource( koyomi.WithCalendarID( koyomi.Holiday, koyomi.MoonPhase, koyomi.SolarTerm, koyomi.Eclipse, koyomi.Planet, ), koyomi.WithStartDate(start), koyomi.WithEndDate(end), ).Get() if err != nil { fmt.Fprintln(os.Stderr, err) return } fmt.Println(\u0026#34;| 日付 | 内容 |\u0026#34;) fmt.Println(\u0026#34;| ---- | ---- |\u0026#34;) for _, e := range k.Events() { fmt.Printf(\u0026#34;| %v | %v |\\n\u0026#34;, e.Date, e.Title) } } ブックマーク   暦Wiki/季節/雑節とは？ - 国立天文台暦計算室\n  中秋の名月（2020年10月） | 国立天文台(NAOJ)\n  火星最接近2020 | 国立天文台(NAOJ)\n 火星が地球に最接近（2020年10月） | 国立天文台(NAOJ)    2020年の主な暦象\n  日本の暦情報を取得するパッケージを作ってみた\n  参考図書  天文年鑑 2020年版 天文年鑑 編集委員会 (編集) 誠文堂新光社 2019-11-20 単行本 4416719485 (ASIN), 9784416719480 (EAN), 4416719485 (ISBN) 評価\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;  天文ファン必携。2020年版。\nreviewed by Spiegel on 2019-11-23 (powered by PA-APIv5)\n "
    }
  ]
}
