<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:cc="http://web.resource.org/cc/">
	<title>Recursion - text.Baldanders.info</title>
	<link rel="alternate" type="text/html" href="http://text.baldanders.info/tags/recursion/" />
	<link rel="self" type="application/atom+xml" href="http://text.baldanders.info/tags/recursion/index.xml" />
	<id>tag:text.Baldanders.info,2017-09-23:/tags</id>
	<updated>2017-09-23T23:32:56+09:00</updated>
	<subtitle>帰ってきた「しっぽのさきっちょ」</subtitle>
	<icon>http://text.baldanders.info//images/avatar.jpg</icon>
	<logo>http://text.baldanders.info//images/avatar.jpg</logo>
	<generator uri="https://gohugo.io/">Hugo 0.28</generator>

	
	<entry>
		<title>最大公約数と関数型プログラミング - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/greatest-common-divisor/" />
		<id>tag:text.Baldanders.info,2017-09-23:/golang/greatest-common-divisor/</id>
		<published>2017-09-23T23:32:56+09:00</published>
		<updated>2017-09-24T11:54:57+09:00</updated>
		<summary>そうだ。最大公約数（greatest common divisor）の話をしよう。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/rsky/items/a39070208eaea38394c5&#34;&gt;配列の全ての要素の最大公約数を求める (Java 8, Python) - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この記事を見て思いついた。
そうだ。
最大公約数（greatest common divisor）の話をしよう。&lt;/p&gt;

&lt;h2 id=&#34;最大公約数を求める&#34;&gt;最大公約数を求める&lt;/h2&gt;

&lt;p&gt;まずは定義から。
最大公約数の定義は以下の通り。&lt;/p&gt;

&lt;figure&gt;
&lt;blockquote&gt;&lt;p&gt;2つ以上の正の整数に共通な約数（公約数）のうち最大のもの&lt;/p&gt;
&lt;/blockquote&gt;

&lt;/figure&gt;

&lt;p&gt;折角なので何か例題を立ててみよう。&lt;/p&gt;

&lt;figure&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;例題1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;20 と 32 の最大公約数を求めよ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;/figure&gt;

&lt;p&gt;簡単な数だし，まずは暗算で解いてみる。
それぞれの値を素因数分解すると以下のようになる。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;

\[
20 = 2^2 \times 5 \\
32 = 2^5
\]


&lt;/figure&gt;

&lt;p&gt;これにより最大公約数は $2^2 = 4$ だということが分かる。
簡単でよかったね。&lt;/p&gt;

&lt;h2 id=&#34;ユークリッドの互除法&#34;&gt;ユークリッドの互除法&lt;/h2&gt;

&lt;p&gt;さて，最大公約数を求める機械向けの計算方法としては「&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E3%81%AE%E4%BA%92%E9%99%A4%E6%B3%95&#34; title=&#34;ユークリッドの互除法 - Wikipedia&#34;&gt;ユークリッドの互除法&lt;/a&gt;」が有名である。
具体的な手順は以下の通り。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;32 を 20 で割った余りは 12&lt;/li&gt;
&lt;li&gt;20 を 12 で割った余りは 8&lt;/li&gt;
&lt;li&gt;12 を 8 で割った余りは 4&lt;/li&gt;
&lt;li&gt;8 を 4 で割った余りは 0&lt;/li&gt;
&lt;li&gt;したがって 32 と 20 の最大公約数は 4 である&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これを図形で表すとこんな感じになる。
（以下の&lt;a href=&#34;https://ja.wikipedia.org/wiki/File:GCM_Of_20_And_32.gif&#34; title=&#34;File_GCM Of 20 And 32.gif - Wikipedia&#34;&gt;図は Wikipedia のもの&lt;/a&gt;を拝借した。 &lt;a href=&#34;https://creativecommons.org/licenses/by-sa/3.0/&#34; title=&#34;Creative Commons — Attribution-ShareAlike 3.0 Unported — CC BY-SA 3.0&#34;&gt;CC-BY-SA-3.0&lt;/a&gt; で公開されている）&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;https://ja.wikipedia.org/wiki/File:GCM_Of_20_And_32.gif&#34;&gt;&lt;img srcset=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/1/1a/GCM_Of_20_And_32.gif/640px-GCM_Of_20_And_32.gif 640w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;From Wikipedia&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/File:GCM_Of_20_And_32.gif&#34;&gt;From Wikipedia&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;今回は&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E3%81%AE%E4%BA%92%E9%99%A4%E6%B3%95&#34; title=&#34;ユークリッドの互除法 - Wikipedia&#34;&gt;ユークリッドの互除法&lt;/a&gt;の証明は割愛するとして&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:pf1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:pf1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，上記の手順の 1 から 4 は再帰処理になっていることが分かる。
というわけで，こんな感じのコードを組んでみる。
（だいぶ端折ったコードでゴメン）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func gcd(a, b int) int {
    if b == 0 {
        return a
    }
    return gcd(b, a%b)
}

func main() {
	fmt.Println(gcd(32, 20)) // 4
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで実行結果は 4 になる。&lt;/p&gt;

&lt;p&gt;実は &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;にも最大公約数を求める関数が標準パッケージ &lt;a href=&#34;https://golang.org/pkg/math/big/&#34; title=&#34;big - The Go Programming Language&#34;&gt;&lt;code&gt;math/big&lt;/code&gt;&lt;/a&gt; に用意されている。
こんな感じで使える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/big&amp;quot;
)

func gcd(m, n uint64) uint64 {
	x := new(big.Int)
	y := new(big.Int)
	z := new(big.Int)
	a := new(big.Int).SetUint64(m)
	b := new(big.Int).SetUint64(n)
	return z.GCD(x, y, a, b).Uint64()
}

func main() {
	fmt.Println(gcd(20, 32)) // 4
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/math/big/&#34; title=&#34;big - The Go Programming Language&#34;&gt;&lt;code&gt;big&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Int.GCD()&lt;/code&gt; 関数も&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E3%81%AE%E4%BA%92%E9%99%A4%E6%B3%95&#34; title=&#34;ユークリッドの互除法 - Wikipedia&#34;&gt;ユークリッドの互除法&lt;/a&gt;の一種で，正の整数 $a$, $b$ に対する最大公約数を $gcd(a, b)$ とすると&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;

\[
gcd(a, b) = ax + by
\]


&lt;/figure&gt;

&lt;p&gt;となる $x$, $y$ の組み合わせを探すものだ。&lt;/p&gt;

&lt;h2 id=&#34;3つ以上の数の最大公約数&#34;&gt;3つ以上の数の最大公約数&lt;/h2&gt;

&lt;p&gt;では3つ以上の数の最大公約数を求めるにはどうすればいいか。
ちょっと考えれば分かるが，たとえば (a, b, c) の最大公約数を求めたいなら &lt;code&gt;gcd(gcd(a, b), c)&lt;/code&gt; とすればいい。&lt;/p&gt;

&lt;p&gt;では例題を立ててみよう。
これは「&lt;a href=&#34;https://qiita.com/rsky/items/a39070208eaea38394c5&#34;&gt;配列の全ての要素の最大公約数を求める&lt;/a&gt;」の設問と同等と言える。&lt;/p&gt;

&lt;figure&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;例題2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(290021904, 927964716, 826824516, 817140688) の最大公約数を求めよ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;/figure&gt;

&lt;p&gt;まずはベタに for 文を回してベタに解いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/big&amp;quot;
)

func gcd(m, n uint64) uint64 {
	x := new(big.Int)
	y := new(big.Int)
	z := new(big.Int)
	a := new(big.Int).SetUint64(m)
	b := new(big.Int).SetUint64(n)
	return z.GCD(x, y, a, b).Uint64()
}

func main() {
	values := []uint64{290021904, 927964716, 826824516, 817140688}

	z := values[0]
	for _, n := range values {
		z = gcd(n, z)
	}
	fmt.Println(z) // 92
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ふむふむ。
イケてそうだな&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:gcd1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:gcd1&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;go-で関数型プログラミング&#34;&gt;Go で関数型プログラミング&lt;/h2&gt;

&lt;p&gt;「&lt;a href=&#34;https://qiita.com/rsky/items/a39070208eaea38394c5&#34;&gt;配列の全ての要素の最大公約数を求める&lt;/a&gt;」で紹介されているコードは高階関数（higher-order function）である &lt;code&gt;reduce()&lt;/code&gt; による関数型プログラミングになっている。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の関数は第一級関数（first-class function）なので関数型っぽいプログラミングも可能なのだが&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fp1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fp1&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;， &lt;code&gt;reduce()&lt;/code&gt; のような関数は標準では用意されていない。
ただし，似たような機能を持つパッケージを公開しておられる人はいる。
わざわざ自作するのもナニなので今回は以下のパッケージを利用させてもらおう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/robpike/filter&#34;&gt;robpike/filter: Simple apply/filter/reduce package.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを使って先程の例題を以下のコードで解くことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/big&amp;quot;

	&amp;quot;github.com/robpike/filter&amp;quot;
)

func gcd(m, n uint64) uint64 {
	x := new(big.Int)
	y := new(big.Int)
	z := new(big.Int)
	a := new(big.Int).SetUint64(m)
	b := new(big.Int).SetUint64(n)
	return z.GCD(x, y, a, b).Uint64()
}

func main() {
	values := []uint64{290021904, 927964716, 826824516, 817140688}

	fmt.Println(filter.Reduce(values, gcd, 1).(uint64)) // 92
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もしくは &lt;code&gt;gcd()&lt;/code&gt; 関数自体を引数に組み込んで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/big&amp;quot;

	&amp;quot;github.com/robpike/filter&amp;quot;
)

func main() {
	values := []uint64{290021904, 927964716, 826824516, 817140688}

	fmt.Println(filter.Reduce(values,
		func(m, n uint64) uint64 {
			x := new(big.Int)
			y := new(big.Int)
			z := new(big.Int)
			a := new(big.Int).SetUint64(m)
			b := new(big.Int).SetUint64(n)
			return z.GCD(x, y, a, b).Uint64()
		},
		1).(uint64)) // 92
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてもよい。
ほら，これなら「実質的にワンライナー」と呼べないこともない（笑）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/robpike/filter&#34; title=&#34;robpike/filter: Simple apply/filter/reduce package.&#34;&gt;&lt;code&gt;robpike/filter&lt;/code&gt;&lt;/a&gt; パッケージの作者も書いておられるが&lt;/p&gt;

&lt;figure lang=&#34;en&#34;&gt;
&lt;blockquote&gt;
&lt;q&gt;I wanted to see how hard it was to implement this sort of thing in Go, with as nice an API as I could manage. It wasn&#39;t hard.&lt;br&gt;
&lt;br&gt;
Having written it a couple of years ago, I haven&#39;t had occasion to use it once. Instead, I just use &#34;for&#34; loops.&lt;br&gt;
&lt;br&gt;
You shouldn&#39;t use it either.&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;https://github.com/robpike/filter&#34;&gt;robpike/filter&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/robpike/filter&#34; title=&#34;robpike/filter: Simple apply/filter/reduce package.&#34;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Reduce()&lt;/code&gt; 関数を駆動するコストを考えれば&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:rf1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:rf1&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; 普通に for 文で回したほうが安上がりだよね。
イマドキっぽく関数型言語の利点をいくつか取り込んでいるとはいえ Haskell のようなガッツリした関数型言語とは役割が異なるので，無理に関数型にこだわらなくてもいいということである。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/tawatawa/items/408b872a7092be0d7b3c&#34;&gt;3つ以上の数の最大公約数と最小公倍数 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/taksatou@github/items/d721a62158f554b8e399&#34;&gt;Goで関数型プログラミング - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/yohhoy/items/d3c12361bb5eed3cbede&#34;&gt;Go言語では高階関数よりforループを使え(by Rob Pike氏) - Qiita&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://qiita.com/hiruberuto/items/26a813ab2b188ca39019&#34;&gt;関数型言語のウソとホント - Qiita&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/recursive-call-and-function-table/&#34;&gt;再帰呼び出しと関数テーブル&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/477418392X/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/61EL3Dc95dL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/477418392X/baldandersinf-22/&#34;&gt;みんなのGo言語【現場で使える実践テクニック】&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;松木雅幸 mattn 藤原俊一郎 中島大一 牧 大輔 鈴木健太 稲葉貴洋 &lt;/dd&gt;&lt;dd&gt;技術評論社 2016-09-09&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;4&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-4-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4774184322/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4774184322.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;WEB+DB PRESS Vol.95&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4621300253.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274219151/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274219151.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;プログラミングElixir&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798147400/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798147400.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;詳解MySQL 5.7 止まらぬ進化に乗り遅れないためのテクニカルガイド (NEXT ONE)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4774182869/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4774182869.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;WEB+DB PRESS Vol.94&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117763/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117763.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/477418361X/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/477418361X.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;オブジェクト指向設計実践ガイド ~Rubyでわかる 進化しつづける柔軟なアプリケーションの育て方&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4295000337/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4295000337.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;WebデベロッパーのためのReact開発入門 JavaScript UIライブラリの基本と活用&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;リファレンス本なのに索引が貧弱。これなら Kindle で買ってもよかったか。 1.7 への言及があるのはよかった。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-11-17&#34;&gt;2016-11-17&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMJ0/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/51-nVSeXaNL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMJ0/baldandersinf-22/&#34;&gt;数学ガールの秘密ノート／整数で遊ぼう&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;結城 浩 &lt;/dd&gt;&lt;dd&gt;SBクリエイティブ株式会社 2014-07-24&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMIQ/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00L0PDMIQ.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／式とグラフ&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMK4/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00L0PDMK4.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／ガロア理論&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00NAQA33A/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00NAQA33A.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの誕生 　理想の数学対話を求めて&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1FO/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1FO.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／乱択アルゴリズム&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1D6/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1D6.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／ゲーデルの不完全性定理&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34; &gt;&lt;a href=&#39;http://www.baldanders.info/spiegel/log2/000670.shtml&#39;&gt;小中学生にお薦め&lt;/a&gt;。小学生高学年くらいならギリで理解可能と思われ。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#34;#maker&#34; class=&#34;reviewer&#34;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2014-09-26&#34;&gt;2014/09/26&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34;&gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1CM/baldandersinf-22/&#34;&gt;&lt;img src=&#34;https://images-fe.ssl-images-amazon.com/images/I/41vT2D6sERL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1CM/baldandersinf-22/&#34;&gt;数学ガール／フェルマーの最終定理&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;結城 浩 &lt;/dd&gt;&lt;dd&gt;SBクリエイティブ 2008-07-29&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1D6/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1D6.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／ゲーデルの不完全性定理&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMK4/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00L0PDMK4.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／ガロア理論&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1FO/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1FO.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／乱択アルゴリズム&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B073F45B97/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B073F45B97.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／積分を見つめて&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00EYXMA9I/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00EYXMA9I.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00W6NCLL0/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00W6NCLL0.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／数列の広場&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMJ0/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00L0PDMJ0.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／整数で遊ぼう&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00W6NCLJM/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00W6NCLJM.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／丸い三角関数&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01EL08HVS/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01EL08HVS.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／場合の数&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00Y9EYOIW/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00Y9EYOIW.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／微分を追いかけて&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;「フェルマーの最終定理」というサブタイトルをみたとき「なんちう大風呂敷を広げるねん」と思ったものだが，実際に読んでみるとぐいぐい引き込まれる。ひっさびさに頭を使ったような気がする。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2017-09-23&#34;&gt;2017-09-23&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:pf1&#34;&gt;結城浩さんが連載しておられる「&lt;a href=&#34;https://cakes.mu/series/339&#34; title=&#34;数学ガールの秘密ノート｜結城浩｜cakes（ケイクス）&#34;&gt;数学ガールの秘密ノート&lt;/a&gt;」に&lt;a href=&#34;https://cakes.mu/posts/16292&#34; title=&#34;第195回　ユークリッドの互除法（前編）｜数学ガールの秘密ノート｜結城浩｜cakes（ケイクス）&#34;&gt;ユークリッドの互除法が出て来る&lt;/a&gt;。はやく本にならないかなぁ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:pf1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:gcd1&#34;&gt;繰り返し処理が1回余分に回っているが $gcd(a, a) = a$ で影響はないのでご容赦。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:gcd1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:fp1&#34;&gt;あくまでも「ぽい」である。たとえば &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では if 文や for 文などは関数でも演算子でもない単なる制御&lt;a href=&#34;http://text.baldanders.info/golang/operators-and-statements/&#34; title=&#34;演算子とステートメント&#34;&gt;構文（stateement）&lt;/a&gt;であり，直接ロジックにコンパイルされる。これまでの手続き型言語と関数型言語の利点を合わせたような言語は「マルチパラダイム・プログラミング言語（multiparadigm programming language）」などと呼ばれたりする。 Python や Swift といった近頃流行りの言語もマルチパラダイムの流れのひとつである。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fp1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:rf1&#34;&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;には総称型（Generics）がないため &lt;a href=&#34;https://github.com/robpike/filter&#34; title=&#34;robpike/filter: Simple apply/filter/reduce package.&#34;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Reduce()&lt;/code&gt; 関数内部で &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt; パッケージを駆使することになるが，その分はどうしてもパフォーマンスに影響を与えてしまう（参考： &lt;a href=&#34;http://text.baldanders.info/remark/2017/03/generics-vs-duck-typing/&#34;&gt;きみは Generics がとくいなフレンズなんだね，または「制約は構造を生む」&lt;/a&gt;）。しかし &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt; パッケージが悪というわけではなく，たとえば&lt;a href=&#34;http://text.baldanders.info/golang/sort/&#34; title=&#34;ソートを使う&#34;&gt;先日紹介&lt;/a&gt;した &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Slice()&lt;/code&gt; 関数は &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt; パッケージを効果的に使用した例といえる。高階関数は見た目はクールだが，それに惑わされることなく目的に適うコードを選ぶことが重要である。とはいえ，勉強のために &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で高階関数を組んでみようというのは悪くないと思う。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:rf1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>再帰呼び出しと関数テーブル - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/recursive-call-and-function-table/" />
		<id>tag:text.Baldanders.info,2016-01-18:/golang/recursive-call-and-function-table/</id>
		<published>2016-01-18T22:59:07+09:00</published>
		<updated>2017-01-19T11:35:44+09:00</updated>
		<summary>今回は再帰呼び出しの話。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回は再帰呼び出しの話。&lt;/p&gt;

&lt;p&gt;再帰呼び出しのサンプルとして典型的なのは&lt;a href=&#34;https://en.wikipedia.org/wiki/Fibonacci_number&#34; title=&#34;Fibonacci number - Wikipedia, the free encyclopedia&#34;&gt;フィボナッチ数&lt;/a&gt;かな。
&lt;a href=&#34;https://en.wikipedia.org/wiki/Fibonacci_number&#34; title=&#34;Fibonacci number - Wikipedia, the free encyclopedia&#34;&gt;フィボナッチ数&lt;/a&gt;の定義を愚直にコードにするとこんな感じになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func fibonacciNumber(n int) int {
	switch n {
	case 0:
		return 0
	case 1:
		return 1
	default:
		return fibonacciNumber(n-2) + fibonacciNumber(n-1)
	}
}

func main() {
	fmt.Println(fibonacciNumber(40))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般に手続き型言語は再帰呼び出しに弱いと言われている（関数型のほうが有利）。
特に &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の場合は &lt;a href=&#34;http://golang.org/ref/spec#Go_statements&#34;&gt;goroutine&lt;/a&gt; に最適化を割り振っている関係で，関数呼び出しやその戻り&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:r&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:r&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; のパフォーマンスが冷遇されているようだ。
したがって，再帰呼び出し部分のパフォーマンスを改善したければ，なるべく呼び出し回数を減らすようにするのがコツである。
たとえば上の&lt;a href=&#34;https://en.wikipedia.org/wiki/Fibonacci_number&#34; title=&#34;Fibonacci number - Wikipedia, the free encyclopedia&#34;&gt;フィボナッチ数&lt;/a&gt;の場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

var fibonacciNumbers = make(map[int]int)

func fibonacciNumber(n int) int {
	switch n {
	case 0:
		return 0
	case 1:
		return 1
	default:
		if fn, ok := fibonacciNumbers[n]; ok {
			return fn
		}
		fn := fibonacciNumber(n-2) + fibonacciNumber(n-1)
		fibonacciNumbers[n] = fn
		return fn
	}
}

func main() {
	fmt.Println(fibonacciNumber(40))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じに計算結果を保持っておくことでかなり改善する。&lt;/p&gt;

&lt;p&gt;ところで，再帰呼び出しで怖いのが無限呼び出しに陥るパターンである。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では関数値（function value）を介す場合であれば再帰呼び出しを禁止する。&lt;/p&gt;

&lt;p&gt;たとえば先ほどのコードを以下のように書き換えてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

var fibonacciNumbers = make(map[int]int)

func fibonacciNumber(n int) int {
	switch n {
	case 0:
		return 0
	case 1:
		return 1
	default:
		if fn, ok := fibonacciNumbers[n]; ok {
			return fn
		}
		fn := fib(n-2) + fib(n-1)
		fibonacciNumbers[n] = fn
		return fn
	}
}

type ff func(int) int

var fib ff = fibonacciNumber

func main() {
	fmt.Println(fib(40))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fibonacciNumber()&lt;/code&gt; を &lt;code&gt;fib()&lt;/code&gt; で別名定義しているだけだが，これを実行しようとすると以下のコンパイルエラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prog.go:25: initialization loop:
	prog.go:25 fib refers to
	prog.go:7 fibonacciNumber refers to
	prog.go:25 fib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数値 &lt;code&gt;fib&lt;/code&gt; の部分でエラーになっている点に注目してほしい。&lt;/p&gt;

&lt;p&gt;本当に「ついうっかり」再帰呼び出しになってしまう場合はエラーではじいてもらってありがたいのだが，そうでない場合もある。
あまり例示がうまくなくて申し訳ないのだが，以下の簡単なステート・マシンを考えてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func f0(evt int) int {
	fmt.Println(&amp;quot;processing f0&amp;quot;)
	return 1
}

func f1(evt int) int {
	fmt.Println(&amp;quot;processing f1&amp;quot;)
	return 2
}

func f2(evt int) int {
	fmt.Println(&amp;quot;processing f2&amp;quot;)
	return 3
}

func f3(evt int) int {
	fmt.Println(&amp;quot;processing f3&amp;quot;)
	return 0
}

type fn func(int) int

var fs = []fn{
	f0,
	f1,
	f2,
	f3,
}

func StateMachin(stat, evt int) int {
	return fs[stat](evt)
}

func main() {
	s := 0
	for e := 0; e &amp;lt; 10; e++ {
		s = StateMachin(s, e)
		if s == 0 {
			break
		}
	}
	fmt.Println(&amp;quot;end&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fs&lt;/code&gt; が関数テーブルになっていて，状態 &lt;code&gt;s&lt;/code&gt; とイベント &lt;code&gt;e&lt;/code&gt; に対する処理 &lt;code&gt;fs[s](e)&lt;/code&gt; を呼び出して処理後の状態を返してもらう。
一応 &lt;code&gt;StateMachine()&lt;/code&gt; 関数で詳細を隠蔽しているつもりである&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:b&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:b&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;ここで &lt;code&gt;StateMachine(3, evt)&lt;/code&gt; の処理に続けて &lt;code&gt;StateMachine(1, evt)&lt;/code&gt; の処理がしたくなり&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func f3(evt int) int {
    fmt.Println(&amp;quot;processing f3&amp;quot;)
    return StateMachin(1, evt)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと書いたらどうなるか。
もちろんこれもコンパイルエラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prog.go:32: initialization loop:
	prog.go:32 fs refers to
	prog.go:20 f3 refers to
	prog.go:34 StateMachin refers to
	prog.go:32 fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし実際には &lt;code&gt;f3&lt;/code&gt; を無限に呼び出しているわけではないので，このコンパイルエラーでは困ってしまう&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
このエラーを回避するには関数テーブル &lt;code&gt;fs&lt;/code&gt; を介さなければよい。
たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fs = []fn{
	f0,
	f1,
	f2,
	//f3,
}

func StateMachin(stat, evt int) int {
	if stat == 3 {
		return f3(evt)
	}
	return fs[stat](evt)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば，めでたく &lt;code&gt;f1&lt;/code&gt; → &lt;code&gt;f2&lt;/code&gt; → &lt;code&gt;f3&lt;/code&gt; → &lt;code&gt;f1&lt;/code&gt; とエンドレスにつながる。
ちなみにここでうっかり&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func f3(evt int) int {
	fmt.Println(&amp;quot;processing f3&amp;quot;)
	return StateMachin(3, evt)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと書くと，コンパイルエラーにもならず無限呼び出しが発生する。&lt;/p&gt;

&lt;p&gt;再帰呼び出しは計画的に。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ymotongpoo.hatenablog.com/entry/2015/02/23/165341&#34;&gt;Goで再帰使うと遅くなりますがそれが何だ - YAMAGUCHI::weblog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/zetamatta/items/cc0f29441b16d63472ed&#34;&gt;.\hoge.go:7: initialization loop - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/penguin_dream/items/f1bdeb4c621a3e8d8990&#34;&gt;Fibonacci exercise (go tour) - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:r&#34;&gt;再帰呼び出しが「末尾呼び出し（tail call）」の場合は，戻りの最適化でパフォーマンスの向上が期待できるが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のコンパイラはこの辺の最適化も行っていないらしい。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:r&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:b&#34;&gt;実際には別パッケージにしてちゃんとクラス設計すべきだろうけど色々端折っている。ゴメンペコン。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:b&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:a&#34;&gt;このコードに限れば &lt;code&gt;StateMachine(1, evt)&lt;/code&gt; ではなく &lt;code&gt;f1(evt)&lt;/code&gt; を呼び出せば済む話なのでこれは言いがかりであるが，「話の都合」ということで軽く流していただけるとありがたい。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
</feed>
