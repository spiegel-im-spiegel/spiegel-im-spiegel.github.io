<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:cc="http://web.resource.org/cc/">
	<title>Golang - text.Baldanders.info</title>
	<link rel="alternate" type="text/html" href="http://text.baldanders.info/tags/golang/index.xml" />
	<link rel="self" type="application/atom+xml" href="http://text.baldanders.info/tags/golang/index.xml/index.xml" />
	<id>tag:text.Baldanders.info,0001-01-01:/</id>
	<updated>0001-01-01T00:00:00+00:00</updated>
	<subtitle>帰ってきた「しっぽのさきっちょ」</subtitle>
	<icon>http://text.baldanders.info//images/avatar.jpg</icon>
	<logo>http://text.baldanders.info//images/avatar.jpg</logo>
	<generator uri="https://gohugo.io/">Hugo 0.19</generator>

	
	<entry>
		<title>インスタンスの生成と Functional Options パターン - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/functional-options-pattern/" />
		<id>tag:text.Baldanders.info,2017-04-04:/golang/functional-options-pattern/</id>
		<published>2017-04-04T01:01:59+09:00</published>
		<updated>2017-04-04T06:02:47+09:00</updated>
		<summary>今回も自分用の覚え書きとして書いておく。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;「&lt;a href=&#34;http://qiita.com/weloan/items/56f1c7792088b5ede136&#34;&gt;Go言語のFunctional Option Pattern - Qiita&lt;/a&gt;」を参考にして今回も自分用の覚え書きとして書いておく。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;には C++ や Java 等にある class 宣言がない。
つまりインスタンス（instance）生成時の構築子（constructor）もない。
ではどうやってインスタンスを生成するのか。&lt;/p&gt;

&lt;p&gt;たとえば以下のような型を考える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package ui

import (
	&amp;quot;io&amp;quot;
)

// UI is Command line user interface
type UI struct {
	reader      io.Reader
	writer      io.Writer
	errorWriter io.Writer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ui.UI&lt;/code&gt; 型のインスタンスを生成するにはいくつかの方法がある。&lt;/p&gt;

&lt;p&gt;まずは &lt;code&gt;new()&lt;/code&gt; 関数を使う方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;u := new(ui.UI)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;new()&lt;/code&gt; 関数でインスタンスを生成する場合は必ずゼロ値で初期化される。
&lt;code&gt;ui.UI&lt;/code&gt; の場合は &lt;code&gt;reader&lt;/code&gt;, &lt;code&gt;writer&lt;/code&gt;, &lt;code&gt;errorWriter&lt;/code&gt; の各フィールドには nil がセットされる。
しかし &lt;a href=&#34;https://golang.org/pkg/io/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Reader&lt;/code&gt; および &lt;a href=&#34;https://golang.org/pkg/io/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Writer&lt;/code&gt; は nil のまま使用すると panic になるため何らかの初期値を与える必要がある。&lt;/p&gt;

&lt;p&gt;2番目は複合リテラル（composite literals）で記述する方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;u := UI{reader: os.Stdin, writer: os.Stdout, errorWriter: os.Stderr}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この方法であれば各フィールドに初期値を与えることができる。
ただしフィールドがパッケージ &lt;code&gt;ui&lt;/code&gt; の外からは不可視の場合は（普通そうだよね）この手は使えない。&lt;/p&gt;

&lt;p&gt;そこで，3番目の方法として構築子に相当する関数を考える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package ui

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
)

// UI is Command line user interface
type UI struct {
	reader      io.Reader
	writer      io.Writer
	errorWriter io.Writer
}

// New returns a new UI instance
func New(r io.Reader, w, e io.Writer) *UI {
	if r == nil {
		r = ioutil.NopCloser(bytes.NewReader(nil))
	}
	if w == nil {
		w = ioutil.Discard
	}
	if e == nil {
		e = ioutil.Discard
	}
	return &amp;amp;UI{reader: r, writer: w, errorWriter: e}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;u := ui.New(os.Stdin, os.Stdout, os.Stderr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と記述することでパッケージ外でも初期化済みのインスタンスを生成できる。
また&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;u := ui.New(nil, nil, nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と無効な値（nil）を引数に指定した場合でもフィールドには（nil ではなく）安全な値がセットされる。&lt;/p&gt;

&lt;p&gt;この方法の問題点は引数に必ず何らかの値をセットしなければならないことだ。
たとえば &lt;code&gt;errorWriter&lt;/code&gt; は既定では使わないことが分かっていてもインスタンス生成時には&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;u := ui.New(os.Stdin, os.Stdout, nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとしなければならない。
また&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// NewWithoutErr returns a new UI instance
func NewWithoutErr(r io.Reader, w io.Writer) *UI {
	return New(r, w, nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと構築子を別途増やす手もあるが，それではフィールドの数が増えると関数の管理が煩雑になってしまう。&lt;/p&gt;

&lt;p&gt;そこで4番目の方法。
構築子の引数に初期値をセットするのではなく，初期化関数をセットするのである。
この初期化関数の型を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Option func(*UI)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義する。
すると構築子は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Option is function value of functional options
type Option func(*UI)

// New returns a new UI instance
func New(opts ...Option) *UI {
	u := &amp;amp;UI{reader: ioutil.NopCloser(bytes.NewReader(nil)), writer: ioutil.Discard, errorWriter: ioutil.Discard}
	for _, opt := range opts {
		opt(u)
	}
	return u
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と記述することができる。&lt;/p&gt;

&lt;p&gt;さらにフィールドごとに &lt;code&gt;Option&lt;/code&gt; 関数を返す関数も定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Reader returns function value of Option
func Reader(r io.Reader) Option {
    return func(u *UI) {
        if r != nil {
            u.reader = r
        }

    }
}

//Writer returns function value of Option
func Writer(w io.Writer) Option {
    return func(u *UI) {
        if w != nil {
            u.writer = w
        }
    }
}

//ErrorWriter returns function value of Option
func ErrorWriter(e io.Writer) Option {
    return func(u *UI) {
        if e != nil {
            u.errorWriter = e
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうしておけばインスタンス生成時の記述は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;u := ui.New(ui.Reader(os.Stdin), ui.Writer(os.Stdout))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと初期化の必要なフィールドのみ引数で指定することができる。
このような記述パターンを “Functional Options&amp;rdquo; と呼ぶようである。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://commandcenter.blogspot.jp/2014/01/self-referential-functions-and-design.html&#34;&gt;command center: Self-referential functions and the design of options&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis&#34;&gt;Functional options for friendly APIs | Dave Cheney&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>配列と Slice - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/array-and-slice/" />
		<id>tag:text.Baldanders.info,2017-03-15:/golang/array-and-slice/</id>
		<published>2017-03-15T00:31:48+09:00</published>
		<updated>2017-04-04T00:51:45+09:00</updated>
		<summary>配列と slice との関係について。あくまでも私のための覚え書きである。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;以下の記事を見て思わず膝を打った。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/seihmd/items/d9bc98a4f4f606ecaef7&#34;&gt;Goのarrayとsliceを理解するときがきた - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なるほど！ こういう風に説明すればいいのか。
というわけで，私も便乗してみる。
あくまでも私のための覚え書きである。&lt;/p&gt;

&lt;h2 id=&#34;配列は常に-値-である&#34;&gt;配列は常に「値」である&lt;/h2&gt;

&lt;p&gt;まずはこんなコードを書いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func main() {
	ary := Array4{0, 1, 2, 3}
	fmt.Printf(&amp;quot;ary = %p\n&amp;quot;, &amp;amp;ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;[4]int8&lt;/code&gt; が「型」であることを意識してもらうために敢えて &lt;code&gt;Array4&lt;/code&gt; という型を宣言している。
実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary = 0x1040a124
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まぁ分かりやすいよね。
今度はダンプ表示部分を別関数にしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dump(ary Array4) {
	fmt.Printf(&amp;quot;ary(dump) = %p\n&amp;quot;, &amp;amp;ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}

func main() {
	ary := Array4{0, 1, 2, 3}
	fmt.Printf(&amp;quot;ary(org) = %p\n&amp;quot;, &amp;amp;ary)
	dump(ary)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードの実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary(org) = 0x1040a124
ary(dump) = 0x1040a128
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;dump()&lt;/code&gt; 関数の引数として渡される配列がオリジナルのものと異なることが分かるだろう。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では関数の引数は原則として「値渡し（call by value）」であるため，配列を渡す場合でも配列のコピーを作って渡すことになる。
配列を値渡しではなく「参照渡し（call by reference）」にしたい場合はポインタを使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dump(ary *Array4) {
	fmt.Printf(&amp;quot;ary(dump) = %p\n&amp;quot;, ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}

func main() {
	ary := Array4{0, 1, 2, 3}
	fmt.Printf(&amp;quot;ary(org) = %p\n&amp;quot;, &amp;amp;ary)
	dump(&amp;amp;ary)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary(org) = 0x1040a124
ary(dump) = 0x1040a124
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;slice-は配列への参照である&#34;&gt;Slice は配列への参照である&lt;/h2&gt;

&lt;p&gt;次は配列を &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; に置き換えてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func dump(slc []int8) {
	fmt.Printf(&amp;quot;slc(dump) = %p\n&amp;quot;, slc)
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func main() {
	slc := []int8{0, 1, 2, 3}
	fmt.Printf(&amp;quot;slc(org) = %p\n&amp;quot;, slc)
	dump(slc)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配列の場合の記述の違いが分かるだろうか。
この場合 &lt;code&gt;slc&lt;/code&gt; には配列 &lt;code&gt;{0, 1, 2, 3}&lt;/code&gt; へのポインタがセットされる。
したがって &lt;code&gt;dump()&lt;/code&gt; 関数の引数には（見かけ上）配列 &lt;code&gt;{0, 1, 2, 3}&lt;/code&gt; への参照がセットされていることになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;slc(org) = 0x1040a124
slc(dump) = 0x1040a124
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では応用として今度はこんなコードを考えてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dumpA(ary Array4) {
	fmt.Printf(&amp;quot;ary(dumpA) = %p\n&amp;quot;, &amp;amp;ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}

func dumpS(slc []int8) {
	fmt.Printf(&amp;quot;slc(dumpS) = %p\n&amp;quot;, slc)
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func main() {
	ary := Array4{0, 1, 2, 3}
	fmt.Printf(&amp;quot;ary(org) = %p\n&amp;quot;, &amp;amp;ary)
	dumpA(ary)
	slc := ary[:]
	dumpS(slc)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;slc := ary[:]&lt;/code&gt; で配列 &lt;code&gt;ary&lt;/code&gt; が &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; &lt;code&gt;slc&lt;/code&gt; にキャストされているのがポイントである。
実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary(org) = 0x1040a124
ary(dumpA) = 0x1040a128
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
slc(dumpS) = 0x1040a124
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配列 &lt;code&gt;ary&lt;/code&gt; のオリジナルのポインタ値がそのまま &lt;code&gt;slc&lt;/code&gt; の値になっているのが分かると思う。
この「&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; は配列への参照である」ということを踏まえると，こんな面白いコードも書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dumpA(ary Array4) {
	fmt.Printf(&amp;quot;ary(dumpA) = %p\n&amp;quot;, &amp;amp;ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}

func dumpS(slc []int8) {
	fmt.Printf(&amp;quot;pointer(dumpS) = %p\n&amp;quot;, slc)
	fmt.Printf(&amp;quot;size(dumpS) = %v\n&amp;quot;, len(slc))
	fmt.Printf(&amp;quot;capacity(dumpS) = %v\n&amp;quot;, cap(slc))
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func main() {
	ary := Array4{0, 1, 2, 3}
	fmt.Printf(&amp;quot;ary(org) = %p\n&amp;quot;, &amp;amp;ary)
	dumpA(ary)
	slc1 := ary[0:2]
	dumpS(slc1)
	slc2 := slc1[0:4]
	dumpS(slc2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;サイズ 2 の &lt;code&gt;slc1&lt;/code&gt; からサイズ4の &lt;code&gt;slc2&lt;/code&gt; を取得しているのがポイント。
このコードの実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary(org) = 0x1040a124
ary(dumpA) = 0x1040a128
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
pointer(dumpS) = 0x1040a124
size(dumpS) = 2
capacity(dumpS) = 4
0x1040a124: 0
0x1040a125: 1
pointer(dumpS) = 0x1040a124
size(dumpS) = 4
capacity(dumpS) = 4
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; は配列に対してポインタとサイズと容量の3つの属性を持つオブジェクトである。
上述のコードでは配列 &lt;code&gt;ary&lt;/code&gt; を反映し， &lt;code&gt;slc1&lt;/code&gt; の容量が4となるため &lt;code&gt;slc2&lt;/code&gt; ではサイズ4の &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; が作れるわけだ。&lt;/p&gt;

&lt;p&gt;たとえば &lt;code&gt;slc1 := ary[2:4]&lt;/code&gt; と書き換えると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dumpA(ary Array4) {
	fmt.Printf(&amp;quot;ary(dumpA) = %p\n&amp;quot;, &amp;amp;ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}

func dumpS(slc []int8) {
	fmt.Printf(&amp;quot;pointer(dumpS) = %p\n&amp;quot;, slc)
	fmt.Printf(&amp;quot;size(dumpS) = %v\n&amp;quot;, len(slc))
	fmt.Printf(&amp;quot;capacity(dumpS) = %v\n&amp;quot;, cap(slc))
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func main() {
	ary := Array4{0, 1, 2, 3}
	fmt.Printf(&amp;quot;ary(org) = %p\n&amp;quot;, &amp;amp;ary)
	dumpA(ary)
	slc1 := ary[2:4]
	dumpS(slc1)
	slc2 := slc1[0:4]
	dumpS(slc2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;slc1&lt;/code&gt; の容量が変わるため，以下のように実行時 panic になる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary(org) = 0x1040a124
ary(dumpA) = 0x1040a128
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
pointer(dumpS) = 0x1040a126
size(dumpS) = 2
capacity(dumpS) = 2
0x1040a126: 2
0x1040a127: 3
panic: runtime error: slice bounds out of range
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように配列と &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; の関係が分かると &lt;code&gt;append()&lt;/code&gt; 関数の挙動も理解しやすくなる。&lt;/p&gt;

&lt;p&gt;ところで先ほど &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; は「ポインタとサイズと容量の3つの属性を持つオブジェクト」と書いた。
つまり厳密に言えば，関数の引数に &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; をセットするということは「ポインタとサイズと容量の3つの属性を持つオブジェクト」を値渡しでセットしているということになる。
たとえば以下のようなコードを考える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dumpS(slc []int8) {
	fmt.Printf(&amp;quot;pointer(dumpS) = %p\n&amp;quot;, slc)
	fmt.Printf(&amp;quot;size(dumpS) = %v\n&amp;quot;, len(slc))
	fmt.Printf(&amp;quot;capacity(dumpS) = %v\n&amp;quot;, cap(slc))
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func addS(slc []int8, e int8) {
	slc = append(slc, e)
	dumpS(slc)
}

func main() {
	slc := make([]int8, 4, 8)
	slc[0] = 0
	slc[1] = 1
	slc[2] = 2
	slc[3] = 3
	dumpS(slc)
	addS(slc, 4)
	dumpS(slc)
	slc2 := slc[0:5]
	dumpS(slc2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;杜撰なコードではあるが，サイズ4容量8の配列に5番目の要素を &lt;code&gt;append()&lt;/code&gt; しても内部の配列そのものは更新されないため動きとしては問題ないように見える。
しかし実際には以下のような実行結果になる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;pointer(dumpS) = 0x1040a128
size(dumpS) = 4
capacity(dumpS) = 8
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
pointer(dumpS) = 0x1040a128
size(dumpS) = 5
capacity(dumpS) = 8
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
0x1040a12c: 4
pointer(dumpS) = 0x1040a128
size(dumpS) = 4
capacity(dumpS) = 8
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
pointer(dumpS) = 0x1040a128
size(dumpS) = 5
capacity(dumpS) = 8
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
0x1040a12c: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり &lt;code&gt;addS()&lt;/code&gt; 関数に渡す &lt;code&gt;slc&lt;/code&gt; は値渡しなので &lt;code&gt;addS()&lt;/code&gt; 関数内で &lt;code&gt;slc&lt;/code&gt; のサイズが変わっても関数の呼び出し元には反映されないことになる（配列自体には値がセットされている）。
&lt;code&gt;append()&lt;/code&gt; 関数実行後は必ず状態が変わるため正しく &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; の「値」を更新する必要がある。&lt;/p&gt;

&lt;h2 id=&#34;配列の複製&#34;&gt;配列の複製&lt;/h2&gt;

&lt;p&gt;配列を明示的に複製して使いたい場合がある。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では配列の複製はとても簡単である。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dump(ary *Array4) {
	fmt.Printf(&amp;quot;ary(dump) = %p\n&amp;quot;, ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}

func main() {
	ary := Array4{0, 1, 2, 3}
	var ary2 Array4
	fmt.Printf(&amp;quot;ary(org) = %p\n&amp;quot;, &amp;amp;ary)
	dump(&amp;amp;ary)
	ary2 = ary
	dump(&amp;amp;ary2)
    if ary == ary2 {
		fmt.Println(&amp;quot;ary == ary2&amp;quot;)
	} else {
		fmt.Println(&amp;quot;ary != ary2&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary(org) = 0x1040a124
ary(dump) = 0x1040a124
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
ary(dump) = 0x1040a128
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
ary == ary2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ary&lt;/code&gt; と &lt;code&gt;ary2&lt;/code&gt; が同じ内容の異なるインスタンス（instance）であることが分かると思う。
また配列同士の比較も同じ型であれば単純である。
&lt;code&gt;[3]int8&lt;/code&gt; と &lt;code&gt;[4]int8&lt;/code&gt; は異なる型と見なされるため単純比較はできない。&lt;/p&gt;

&lt;p&gt;一方， &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; の複製が欲しい場合は &lt;code&gt;copy()&lt;/code&gt; 関数を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;reflect&amp;quot;
)

type Array4 [4]int8

func dumpS(slc []int8) {
	fmt.Printf(&amp;quot;pointer(dumpS) = %p\n&amp;quot;, slc)
	fmt.Printf(&amp;quot;size(dumpS) = %v\n&amp;quot;, len(slc))
	fmt.Printf(&amp;quot;capacity(dumpS) = %v\n&amp;quot;, cap(slc))
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func main() {
	slc1 := []int8{0, 1, 2, 3}
	dumpS(slc1)
	slc2 := make([]int8, len(slc1), cap(slc1))
	copy(slc2, slc1)
	dumpS(slc2)
	if reflect.DeepEqual(slc1, slc2) {
		fmt.Println(&amp;quot;slc1 == slc2&amp;quot;)
	} else {
		fmt.Println(&amp;quot;slc1 != slc2&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コピー先の &lt;code&gt;slc2&lt;/code&gt; について &lt;code&gt;make()&lt;/code&gt; 関数であらかじめサイズと容量を確保しておくのがポイント。
実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;pointer(dumpS) = 0x1040a124
size(dumpS) = 4
capacity(dumpS) = 4
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
pointer(dumpS) = 0x1040a144
size(dumpS) = 4
capacity(dumpS) = 4
0x1040a144: 0
0x1040a145: 1
0x1040a146: 2
0x1040a147: 3
slc1 == slc2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; 同士を比較するのも単純ではないが， &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;DeepEqual()&lt;/code&gt; 関数が使える。
ちなみに 宣言構文を使ってもっと単純に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;reflect&amp;quot;
)

type Array4 [4]int8

func dumpS(slc []int8) {
	fmt.Printf(&amp;quot;pointer(dumpS) = %p\n&amp;quot;, slc)
	fmt.Printf(&amp;quot;size(dumpS) = %v\n&amp;quot;, len(slc))
	fmt.Printf(&amp;quot;capacity(dumpS) = %v\n&amp;quot;, cap(slc))
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func main() {
	slc1 := []int8{0, 1, 2, 3}
	dumpS(slc1)
    slc2 := slc1
	dumpS(slc2)
	if reflect.DeepEqual(slc1, slc2) {
		fmt.Println(&amp;quot;slc1 == slc2&amp;quot;)
	} else {
		fmt.Println(&amp;quot;slc1 != slc2&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすればいいじゃない，と思われるかもしれないが，結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;pointer(dumpS) = 0x1040a124
size(dumpS) = 4
capacity(dumpS) = 4
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
pointer(dumpS) = 0x1040a124
size(dumpS) = 4
capacity(dumpS) = 4
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
slc1 == slc2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;slc1&lt;/code&gt; と &lt;code&gt;slc2&lt;/code&gt; の指す配列が同じになり複製できない。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/go-slices-usage-and-internals&#34;&gt;Go Slices: usage and internals - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/slices&#34;&gt;Arrays, slices (and strings): The mechanics of &amp;lsquo;append&amp;rsquo; - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/golang-slice-internals2&#34;&gt;Go のスライスでハマッたところ - Block Rockin’ Codes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/mattn/items/176459728ff4f854b165&#34;&gt;golang で string を []byte にキャストしてもメモリコピーが走らない方法を考えてみる - Qiita&lt;/a&gt; : ネタ記事&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/function-and-pointer/&#34;&gt;関数とポインタ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>きみは Generics がとくいなフレンズなんだね，または「制約は構造を生む」 - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2017/03/generics-vs-duck-typing/" />
		<id>tag:text.Baldanders.info,2017-03-11:/remark/2017/03/generics-vs-duck-typing/</id>
		<published>2017-03-11T14:55:06+09:00</published>
		<updated>2017-03-30T10:11:38+09:00</updated>
		<summary>これはどちらが正しいかという問題ではない。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;figure&gt;
&lt;blockquote&gt;
&lt;q&gt;公理によって与えられる暗黙の制約。この制約が集合の要素同士をしっかり結びつける。単純にしばるのではない、相互に秩序ある関係を結ぶ。言い換えれば――公理によって与えられる制約が構造を生み出しているのだ&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1CM/baldandersinf-22/&#34;&gt;数学ガール／フェルマーの最終定理&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;今回は戯れ言モードなので「&lt;a href=&#34;http://text.baldanders.info/golang/&#34;&gt;プログラミング言語 Go&lt;/a&gt;」ではなくこちらで書いてみる。
コードは1行も書かないのでご安心を（笑）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mattn.kaoriya.net/software/lang/go/20170309201506.htm&#34;&gt;Big Sky :: golang と Generics と私&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/yuroyoro/items/6bf33f3cd4bb35469e0b&#34;&gt;golang と Generics と吾 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/t2y/items/139c6a38173d7750ddfc&#34;&gt;Java の Generics にもの思い - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;私は出自が組込みエンジニアで（今は何でも屋），アセンブラや C/C++ から始まり Java などの制御に向いていると言われる言語を遍歴している（PHP を機器制御に使うとかいうこともやったが）。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;もその流れから興味を持っているが，あいにく私が住んでいる地方都市で &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の出番はまだない。&lt;/p&gt;

&lt;p&gt;そういう経歴を持つ私から見て &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;が特異だと思ったのは以下の2点である。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;例外処理がない&lt;/li&gt;
&lt;li&gt;明示的なクラス定義構文がない&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;私だけでなく C++ や Java などから来た人は大抵これで面食らうらしい。&lt;/p&gt;

&lt;p&gt;このうち1番目については「&lt;a href=&#34;http://text.baldanders.info/golang/&#34;&gt;プログラミング言語 Go&lt;/a&gt;」で&lt;a href=&#34;http://text.baldanders.info/golang/error-handling/&#34; title=&#34;エラー・ハンドリングについて&#34;&gt;記事にした&lt;/a&gt;ので割愛する。&lt;/p&gt;

&lt;p&gt;さて，2番目の「明示的なクラス定義構文がない」について。&lt;/p&gt;

&lt;p&gt;そもそも「クラス」とはなにか。
クラスとは以下の要素をひとまとめの「モノ（object）」として定義したものである。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;名前（必ず1個）&lt;/li&gt;
&lt;li&gt;属性（0個以上）&lt;/li&gt;
&lt;li&gt;操作（0個以上）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では明示的なクラス定義構文がない代わりに &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; と &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt;，およびメソッド・レシーバを組み合わせることでクラスの要素である名前，属性，操作を定義できる。&lt;/p&gt;

&lt;p&gt;そしてクラス定義で重要なのは「クラス間の関係」を定義することである。
クラス間の関係としては大雑把に以下の2つがある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;汎化・特化（継承 等）&lt;/li&gt;
&lt;li&gt;関連（集約，依存 等）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;このうち2番目の関連は定義しやすい。
あるクラスの属性として別のクラスを定義するか，操作によって関連付けるかすればいいからだ。
問題は1番目の汎化・特化をどうやって定義するかである。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の場合は &lt;a href=&#34;https://golang.org/ref/spec#Interface_types&#34; title=&#34;Interface types&#34;&gt;interface&lt;/a&gt; を使った &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:dt&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:dt&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; を採用した。
&lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; とはクラスの振る舞いに注目してクラス間の汎化・特化関係を帰納法的に定義することである。
例を挙げると，それが「にゃーん」と鳴くのなら机器猫だろうが猫耳メイドだろうがサーバルキャットだろうが全部「猫」である，ということだ。&lt;/p&gt;

&lt;p&gt;クラス間の関係を定義するのは意外に大変である。
皆さんは「クラス設計」をどのように行っているだろうか。
まずは具体的なクラスを列挙していき，それらの関係を考察していくのではないだろうか（「ユーザ」や「管理者」を定義するのに 動物→人間→&amp;hellip; と考えていく人はいないだろう）。
考察する過程で（クラスとクラスを繋ぐ）不可視のクラスを発見したり複数のクラスがひとつの概念で括れることに気づいたりすることもある。
つまり設計する過程では「具象→抽象」へと遡っていく。&lt;/p&gt;

&lt;p&gt;一方，実装する際には， C++ や Java では最初にテンプレート・クラスやインタフェース・クラスを作ってからインプリメント・クラスに落とし込む。&lt;/p&gt;

&lt;p&gt;たとえば，最初に「猫」という抽象クラスを作っておいて，それを継承する形で机器猫や猫耳メイドやサーバルキャットといった具体的なクラスを実装していく。
つまり「抽象→具象」へと作業していくわけだ。
そしてその過程において Generics&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:g1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:g1&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; は，ほとんど必須と言えるほど利用価値の高い機能と言える。&lt;/p&gt;

&lt;p&gt;これが &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;による実装ではひっくり返る。
たとえば，最初に机器猫や猫耳メイドやサーバルキャットといった具体的なクラスを作っていって「これってみんな『にゃーん』って鳴くじゃん」と気がつけば後付けで「猫」という抽象クラスを実装できるのである。&lt;/p&gt;

&lt;p&gt;どういうことかというと， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;においては設計と実装を同時進行で「具象→抽象」へと考察していくことができる，ということである。
このような思考過程においては Generics の有無はさして重要ではなくなる。
だって具象化されたオブジェクトから作り始めるのだから。&lt;/p&gt;

&lt;p&gt;「抽象→具象」へと実装する人にとっては Generics のない &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;はとてもまだるこしく見えるかもしれない。
「なんで Generics がねーんだよ。いちいち全部書かせる気か。このポンコツ言語が！」となること請け合いである。
しかし一度 &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; に慣れた人にとっては抽象クラスから書かなければならない C++ や Java こそが面倒くさい。
何故なら，脳内では「具象→抽象」で思考していくのに実際に書くときには「考え終わらないと書けない&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:cd1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:cd1&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;」からである。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;なら「考えながら書ける」のに。&lt;/p&gt;

&lt;p&gt;これはどちらが正しいかという問題ではない。&lt;/p&gt;

&lt;p&gt;たとえばウォータフォール型&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:wf&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:wf&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; の開発スタイルでは実装を開始するまでに設計が終わることが（建前上は）保証されているため「抽象→具象」へと書き進めることが容易な言語が向いている。
一方，要件が絶えず変わったり実験的な製品の場合は設計が終わるまで待っていられないため &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のような言語が向いてるかもしれない。
まぁ設計と実装を同時にやろうとするとリファクタリングが頻繁に発生するのでコピペ・プログラマにはキツい作業になるかもしれないが。&lt;/p&gt;

&lt;p&gt;個人的には「プログラマは要件定義の段階から参加してコードを書くべき」と思ってるので，これを容易にするであろう &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;には注目している。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;Why Everyone Hates Go · npf.io&#34;&gt;Why Everyone Hates Go · npf.io&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/hirokidaichi/items/adccebb41f77eaa6132f&#34;&gt;[翻訳]なんでGoってみんなに嫌われてるの？ - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dave.cheney.net/2017/03/20/why-go&#34;&gt;Why Go? | Dave Cheney&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/methane/items/b627f20457873a504638&#34;&gt;[翻訳] Why Go? - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jsstudy.hatenablog.com/entry/2017/03/29/214931&#34;&gt;JavaScriptで継承を使わないプログラミングスタイル - JavaScript勉強会&lt;/a&gt; : オブジェクト指向設計について上手くまとめている&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:dt&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; の由来は &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_test&#34; title=&#34;Duck test - Wikipedia&#34;&gt;duck test&lt;/a&gt; だそうで， &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_test&#34; title=&#34;Duck test - Wikipedia&#34;&gt;duck test&lt;/a&gt; とは “If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.” と帰納法的に対象を推測する手法を指すらしい。 &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; のメリットのひとつは多重継承で発生する様々な問題（名前の衝突や菱形継承など）を気にする必要がない点である。念のために言うと， &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; の概念自体は  &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;が初出というわけではない。オブジェクト指向プログラミングをサポートするスクリプト言語（Ruby など）では大抵 &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; な記述が可能である。またコンパイル言語でも Generics やそれに近い機能（C# の dynamic 型など）をサポートする場合は &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; な記述が可能な場合がある。  &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;が特異なのは（class キーワードなどを使った）古典的な継承関係の定義構文をざっくり捨て去ってる点にある。プログラミングの「考え方」を切り替える必要があるのだ。これは私たちプログラマが息をするように書いてきた継承（is-a）関係の実装について改めて考察する機会だと私は思う。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:dt&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:g1&#34;&gt;知らない人のために Generics について簡単に説明しておくと，変数の型あるいはインスタンス（instance）に対するクラス（class）に関係なく単一の記述で変数ないしインスタンスを扱うことのできる仕組みである。汎化の一種と考えてもよい。いわゆる多態性（polymorphism）とは異なり，継承関係の異なるクラスでも一緒くたに扱うことが可能なかなり強力な仕組みである。 Generics は特にコンテナ（container; オブジェクトの集まりを表現するデータ構造，配列など）操作で威力を発揮する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:g1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:cd1&#34;&gt;私はこれを「写経」と呼んでいる。はっきり言ってプログラミングでもっとも苦痛なのがコーディング＝写経だったりする。ちなみに一番好きなのはデバッグ。特に他人の書いたコードをデバッグするのは大好物。あれは極上の数理パズルである（締切さえなければね）。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:cd1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:wf&#34;&gt;「ウォータフォール型」とは滝の水が上から下へと落ちていくように 要件定義→設計→製造 と上流工程から下流工程へ順番にプロセスを進めていく開発スタイル。工程ごとにマイルストーンを設けてチェックを行い，各工程が完了しないと先に進めないようにする。まぁ実際にはスケジュールやらの関係でチェックを端折って先に進めてしまうことが多く，下流工程に入ってから致命的な欠陥に気づいて抜き差しならない状況に陥ることもしばしばある（笑）
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:wf&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>「プレミアムフライデー」を求めるパッケージを作ってみた - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/premium-friday/" />
		<id>tag:text.Baldanders.info,2017-03-04:/golang/premium-friday/</id>
		<published>2017-03-04T09:40:51+09:00</published>
		<updated>2017-03-07T09:38:50+09:00</updated>
		<summary>もちろん息抜きである。潤いは大事。でも実用性はないと思われ。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;そういえば先月の「プレミアムフライデー」，皆様はいかがお過ごしでしたか。
私は3時間も残業してしまいましたよ（笑）&lt;/p&gt;

&lt;p&gt;ちうわけで，以下を真似して「プレミアムフライデー」を求めるパッケージを考えてみる。
もちろん息抜きである。
潤いは大事。
でも実用性はないと思われ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/neko_the_shadow/items/4ebf94a8a6d9282e7207&#34;&gt;プレミアムフライデーを求めるメソッドを作った - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/deaf_tadashi/items/963a62072338f09f12a5&#34;&gt;プレミアムフライデーを求めるメソッドを作った（Java8版） - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まずはパッケージ分割しないでベタに書いてみる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:rf1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:rf1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;time&amp;quot;
)

//GetPremiumFriday returns day of premium friday
func GetPremiumFriday(y int, m time.Month) (int, error) {
	//引数のチェック
    if y &amp;lt; 2017 || m &amp;lt; time.January || m &amp;gt; time.December {
		return 0, os.ErrInvalid
	}
	if y == 2017 &amp;amp;&amp;amp; m &amp;lt; time.February { //2017年1月は実施前なのでエラー
		return 0, os.ErrInvalid
	}

	//指定月末（翌月0日）で初期化する
    tm := time.Date(y, m+1, 0, 0, 0, 0, 0, time.UTC) //時差は影響しないので，とりあえず UTC で

    w := tm.Weekday() - time.Friday
	if w &amp;lt; 0 {
		w += 7
	}
	return tm.Day() - (int)(w), nil
}

func main() {
	flag.Parse()
	argsStr := flag.Args()
	if len(argsStr) &amp;lt; 2 {
		fmt.Fprintln(os.Stderr, &amp;quot;年月を指定してください&amp;quot;)
		return
	}
	args := make([]int, 2)
	for i := 0; i &amp;lt; 2; i++ {
		num, err := strconv.Atoi(argsStr[i])
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			return
		}
		args[i] = num
	}
	d, err := GetPremiumFriday(args[0], time.Month(args[1]))
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	fmt.Println(d)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定月末を求めるのに「翌月0日」で初期化するのがポイント（つか，ここしかポイントになるものがない&lt;code&gt;w&lt;/code&gt;）。
実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run pf.go 2017 2
24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;期待通りの値が得られた。&lt;/p&gt;

&lt;p&gt;関数1個だけなんでパッケージにするのもどうかと思うけど折角なのでパッケージ化してみた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/pf&#34;&gt;spiegel-im-spiegel/pf: Premium Friday&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内容は &lt;code&gt;GetPremiumFriday()&lt;/code&gt; 関数を切り出しただけ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package pf

import (
	&amp;quot;os&amp;quot;
	&amp;quot;time&amp;quot;
)

//GetPremiumFriday returns day of premium friday
func GetPremiumFriday(y int, m time.Month) (int, error) {
	//引数のチェック
    if y &amp;lt; 2017 || m &amp;lt; time.January || m &amp;gt; time.December {
		return 0, os.ErrInvalid
	}
	if y == 2017 &amp;amp;&amp;amp; m &amp;lt; time.February { //2017年1月は実施前なのでエラー
		return 0, os.ErrInvalid
	}

	//指定月末（翌月0日）で初期化する
    tm := time.Date(y, m+1, 0, 0, 0, 0, 0, time.UTC) //時差は影響しないので，とりあえず UTC で

    w := tm.Weekday() - time.Friday
	if w &amp;lt; 0 {
		w += 7
	}
	return tm.Day() - (int)(w), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;したがって &lt;code&gt;main()&lt;/code&gt; 関数はこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/pf&amp;quot;
)

func main() {
	flag.Parse()
	argsStr := flag.Args()
	if len(argsStr) &amp;lt; 2 {
		fmt.Fprintln(os.Stderr, &amp;quot;年月を指定してください&amp;quot;)
		return
	}
	args := make([]int, 2)
	for i := 0; i &amp;lt; 2; i++ {
		num, err := strconv.Atoi(argsStr[i])
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			return
		}
		args[i] = num
	}
	d, err := pf.GetPremiumFriday(args[0], time.Month(args[1]))
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	fmt.Println(d)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まぁこんなもんかな。
遊んだ遊んだ。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/qube81/items/1e93c837c0a7e3d99a10&#34;&gt;Golangでプレミアムフライデーかどうか判定する - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:rf1&#34;&gt;元記事のコードがループさせてたんでこっちもついループさせちゃったけど，考えてみれば（いや考えるまでもなく）ループを回す必要はなかった。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:rf1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>演算子とステートメント - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/operators-and-statements/" />
		<id>tag:text.Baldanders.info,2017-02-20:/golang/operators-and-statements/</id>
		<published>2017-02-20T21:07:33+09:00</published>
		<updated>2017-02-21T11:44:15+09:00</updated>
		<summary>今回は「つまみ食い」的に演算子（operator）とステートメント（statement）について解説する。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（この記事は &lt;a href=&#34;http://qiita.com/&#34;&gt;Qiita&lt;/a&gt; に投稿した「&lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/2c6cf5ff44d816d1be7b&#34;&gt;Go 言語の &lt;code&gt;++&lt;/code&gt; や &lt;code&gt;--&lt;/code&gt; は演算子ではない - Qiita&lt;/a&gt;」を大幅に修正して再構成したものです）&lt;/p&gt;

&lt;p&gt;あるプログラミング言語を習得する際に最も早道なのは「たくさんの（他人の）コードを読むこと」であり「たくさんのコードを（コピペではなく自分で）書く」ことである。
これは間違いない。
しかし，その言語の仕様をきちんと把握してないとコードを読んでも間違って理解するかもしれないし，何より実際に自分でコードを書く際に躓く原因になる。&lt;/p&gt;

&lt;p&gt;というわけで，少なくとも学ぶ言語の言語仕様を一度は眺めておくことをお勧めする。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の場合は以下のページで言語仕様を見ることができる（“&lt;a href=&#34;https://tour.golang.org/&#34;&gt;A Tour of Go&lt;/a&gt;” の後で読むと頭に入りやすいかもしれない）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://golang.jp/go_spec&#34;&gt;Goプログラミング言語仕様 - golang.jp&lt;/a&gt; : 日本語だが内容が古いので注意&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回は「つまみ食い」的に演算子（operator）とステートメント（statement）&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:stmt&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:stmt&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; について軽く紹介してみる。&lt;/p&gt;

&lt;h2 id=&#34;stmnt&#34;&gt;ステートメント&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;においては「ステートメント」は以下のように定義されている。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Statement =
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;まぁ名前で何か大体わかると思う。
ここでは &lt;code&gt;SimpleStmt&lt;/code&gt; (simple statement) に絞って紹介しよう。&lt;/p&gt;

&lt;h3 id=&#34;empty-statements&#34;&gt;Empty Statements&lt;/h3&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;EmptyStmt = .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;文字通り空のステートメント。&lt;/p&gt;

&lt;h3 id=&#34;expression-statements&#34;&gt;Expression Statements&lt;/h3&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ExpressionStmt = Expression .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;式（expression）を表すステートメント。
関数呼び出しや受信操作のコンテキスト内に記述できる。&lt;/p&gt;

&lt;p&gt;さらに式は以下のように定義される。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = &amp;quot;||&amp;quot; | &amp;quot;&amp;amp;&amp;amp;&amp;quot; | rel_op | add_op | mul_op .
rel_op     = &amp;quot;==&amp;quot; | &amp;quot;!=&amp;quot; | &amp;quot;&amp;lt;&amp;quot; | &amp;quot;&amp;lt;=&amp;quot; | &amp;quot;&amp;gt;&amp;quot; | &amp;quot;&amp;gt;=&amp;quot; .
add_op     = &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;|&amp;quot; | &amp;quot;^&amp;quot; .
mul_op     = &amp;quot;*&amp;quot; | &amp;quot;/&amp;quot; | &amp;quot;%&amp;quot; | &amp;quot;&amp;lt;&amp;lt;&amp;quot; | &amp;quot;&amp;gt;&amp;gt;&amp;quot; | &amp;quot;&amp;amp;&amp;quot; | &amp;quot;&amp;amp;^&amp;quot; .

unary_op   = &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;!&amp;quot; | &amp;quot;^&amp;quot; | &amp;quot;*&amp;quot; | &amp;quot;&amp;amp;&amp;quot; | &amp;quot;&amp;lt;-&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;（&lt;code&gt;PrimaryExpr&lt;/code&gt; (primary expression) については割愛する。詳細は「&lt;a href=&#34;https://golang.org/ref/spec&#34; title=&#34;The Go Programming Language Specification - The Go Programming Language&#34;&gt;言語仕様&lt;/a&gt;」で確かめてみてください。ここでは &lt;code&gt;Expression&lt;/code&gt; を構成する要素にはステートメントが含まれないことに注目）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;binary_op&lt;/code&gt;, &lt;code&gt;rel_op&lt;/code&gt;, &lt;code&gt;add_op&lt;/code&gt;, &lt;code&gt;mul_op&lt;/code&gt;, &lt;code&gt;unary_op&lt;/code&gt; は演算子である。
演算子については&lt;a href=&#34;#op&#34;&gt;後述&lt;/a&gt;する。&lt;/p&gt;

&lt;h3 id=&#34;send-statements&#34;&gt;Send Statements&lt;/h3&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;SendStmt = Channel &amp;quot;&amp;lt;-&amp;quot; Expression .
Channel  = Expression .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; 送信のステートメント。&lt;/p&gt;

&lt;h3 id=&#34;incdec-statements&#34;&gt;IncDec Statements&lt;/h3&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;IncDecStmt = Expression ( &amp;quot;++&amp;quot; | &amp;quot;--&amp;quot; ) .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;インクリメント（increment）およびデクリメント（decrement）のステートメント。
C/C++ のように &lt;code&gt;++x&lt;/code&gt; みたいな記述はできないので注意。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;code&gt;IncDecStmt&lt;/code&gt; は次の代入ステートメントの以下の記述と同じである。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IncDec statement&lt;/th&gt;
&lt;th&gt;Assignment&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x++&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x += 1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x -= 1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;assignments&#34;&gt;Assignments&lt;/h3&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Assignment = ExpressionList assign_op ExpressionList .
assign_op = [ add_op | mul_op ] &amp;quot;=&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;代入。
&lt;code&gt;add_op&lt;/code&gt;, &lt;code&gt;mul_op&lt;/code&gt; は先ほど出た &lt;code&gt;Expression&lt;/code&gt; の演算子を指す。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;add_op     = &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;|&amp;quot; | &amp;quot;^&amp;quot; .
mul_op     = &amp;quot;*&amp;quot; | &amp;quot;/&amp;quot; | &amp;quot;%&amp;quot; | &amp;quot;&amp;lt;&amp;lt;&amp;quot; | &amp;quot;&amp;gt;&amp;gt;&amp;quot; | &amp;quot;&amp;amp;&amp;quot; | &amp;quot;&amp;amp;^&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;定義だと &lt;code&gt;assign_op&lt;/code&gt; は演算子っぽく見える。
そもそも代入を “assignment operation” と表記しているのだ。
どうなんだろう。
まぁ，いずれにしろ代入自体は間違いなくステートメントであり式の中には含められない。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;code&gt;ExpressionList&lt;/code&gt; は &lt;code&gt;Expression&lt;/code&gt; を列挙したものである。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ExpressionList = Expression { &amp;quot;,&amp;quot; Expression } .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;これにより代入の左辺・右辺を組（tuple）で記述できる。
たとえば2つの変数の値を入れ替える場合は以下のように記述する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x, y = y, x
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;short-variable-declarations&#34;&gt;Short Variable Declarations&lt;/h3&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ShortVarDecl = IdentifierList &amp;quot;:=&amp;quot; ExpressionList .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;変数宣言の短縮表現。
&lt;code&gt;var&lt;/code&gt; キーワードを使った以下の表現と同じ。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;&amp;quot;var&amp;quot; IdentifierList = ExpressionList .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;IdentifierList&lt;/code&gt; は &lt;code&gt;identifier&lt;/code&gt; を列挙したもので&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;IdentifierList = identifier { &amp;quot;,&amp;quot; identifier } .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;これにより &lt;code&gt;identifier&lt;/code&gt; で記述される複数の変数をまとめて宣言・初期化できる。
&lt;code&gt;identifier&lt;/code&gt; の定義は以下の通り&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;identifier = letter { letter | unicode_digit } .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;ちなみに変数名となる &lt;code&gt;identifier&lt;/code&gt; は全ての Unicode 文字を許容する。
なので日本語交じりでこんな書き方もできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    わーい := &amp;quot;わーい！ たのしー！&amp;quot;
    fmt.Println(わーい)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;op&#34;&gt;演算子&lt;/h2&gt;

&lt;p&gt;さて，式と演算子の定義を再び掲げる。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = &amp;quot;||&amp;quot; | &amp;quot;&amp;amp;&amp;amp;&amp;quot; | rel_op | add_op | mul_op .
rel_op     = &amp;quot;==&amp;quot; | &amp;quot;!=&amp;quot; | &amp;quot;&amp;lt;&amp;quot; | &amp;quot;&amp;lt;=&amp;quot; | &amp;quot;&amp;gt;&amp;quot; | &amp;quot;&amp;gt;=&amp;quot; .
add_op     = &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;|&amp;quot; | &amp;quot;^&amp;quot; .
mul_op     = &amp;quot;*&amp;quot; | &amp;quot;/&amp;quot; | &amp;quot;%&amp;quot; | &amp;quot;&amp;lt;&amp;lt;&amp;quot; | &amp;quot;&amp;gt;&amp;gt;&amp;quot; | &amp;quot;&amp;amp;&amp;quot; | &amp;quot;&amp;amp;^&amp;quot; .

unary_op   = &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;!&amp;quot; | &amp;quot;^&amp;quot; | &amp;quot;*&amp;quot; | &amp;quot;&amp;amp;&amp;quot; | &amp;quot;&amp;lt;-&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で式に使える演算子はここに挙げられているものが全てである。
このうち二項演算子（&lt;code&gt;binary_op&lt;/code&gt;）には優先順位が付けられている。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Precedence&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Operator&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;*  /  %  &amp;lt;&amp;lt;  &amp;gt;&amp;gt;  &amp;amp;  &amp;amp;^&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;+  -&lt;/code&gt;  |  &lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;==  !=  &amp;lt;  &amp;lt;=  &amp;gt;  &amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;||&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;なお単項演算子（&lt;code&gt;unary_op&lt;/code&gt;）は二項演算子よりも高い優先順位で機能する。
したがって全体としてはこんな感じだろうか。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Precedence&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Operator&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;unary_op&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;mul_op&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;add_op&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;rel_op&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;||&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;インクリメント-デクリメントは演算子ではない&#34;&gt;インクリメント／デクリメントは演算子ではない&lt;/h3&gt;

&lt;p&gt;たとえば &lt;a href=&#34;http://www.bohyoh.com/CandCPP/C/operator.html&#34; title=&#34;BohYoh.com【Ｃ言語講座】演算子一覧表&#34;&gt;C 言語の演算子&lt;/a&gt;と比較すると &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;ではインクリメント（&lt;code&gt;++&lt;/code&gt;）／デクリメント（&lt;code&gt;--&lt;/code&gt;）が演算子として扱われていないことに気付く&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:op&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:op&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;ではインクリメント／デクリメント（および代入）はステートメントである。&lt;/p&gt;

&lt;p&gt;これはどういうことかというと，たとえば C 言語のコードに似せて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	i := 1
	fmt.Println(i++)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書いてコンパイルしようとしても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;syntax error: unexpected ++, expecting comma or )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とコンパイルエラーになるということである（式を構成する要素にステートメントは含まれないことを思い出してほしい）。
これはコードを，以下のように，代入に置き換えたほうが直感的で分かりやすいかもしれない。
（この場合も「&lt;code&gt;syntax error: unexpected +=, expecting comma or )&lt;/code&gt;」でコンパイルエラーになる）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	i := 1
	fmt.Println(i+=1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私見で申し訳ないが，私は「式中の演算子は変数の状態を変えるべきではない」と考えている。
たとえば C/C++ では &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt; 演算子を前置にすべきか後置にすべきかというのでよく議論になる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:pp&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:pp&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
しかし，これはそもそも &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt; 演算子が式の中で対象の変数の状態を変えてしまうことに問題があるのだ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;ではインクリメントやデクリメント（あるいは代入）といった変数の状態を変える操作をステートメントとし，式の中に埋め込むことを禁止することでこの問題を回避しているように見える。
式の中で変数の状態が変わらないのであれば副作用を気にすることなく安全にコードを書くことができる。&lt;/p&gt;

&lt;p&gt;ただし例外がある。&lt;/p&gt;

&lt;h3 id=&#34;channel-操作&#34;&gt;&lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; 操作&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; 操作では，送信はステートメントだが受信は &lt;code&gt;&amp;lt;-&lt;/code&gt; 単項演算子を使う。
したがって，こんな記述もできる（意味があるかどうかはともかく）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch2 &amp;lt;- &amp;lt;-ch1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; 受信を含んだ式では &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; 変数の状態が変わる副作用（特に deadlock 関連）に注意を払う必要がある。&lt;/p&gt;

&lt;h2 id=&#34;とまぁ-こんな感じで&#34;&gt;とまぁ，こんな感じで&lt;/h2&gt;

&lt;p&gt;手を動かしながら「&lt;a href=&#34;https://golang.org/ref/spec&#34; title=&#34;The Go Programming Language Specification - The Go Programming Language&#34;&gt;言語仕様&lt;/a&gt;」を眺めていくと，いろいろ発見があって楽しいと思う。&lt;/p&gt;

&lt;p&gt;ではまた。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/tonkotsuboy_com/items/0adc5dac54e690fcf706&#34;&gt;web制作者にもわかる、Swift 3が++と&amp;ndash;を削除した理由 - Qiita&lt;/a&gt; : Swift 3 では &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt; 演算子を仕様から削除したらしい&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:stmt&#34;&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34; title=&#34;The Go Programming Language Specification - The Go Programming Language&#34;&gt;言語仕様&lt;/a&gt;における “statement” の適切な日本語訳が思いつかなかったので，今回はカタカナにのばして「ステートメント」と表記する。教えて，英語得手の人。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:stmt&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:op&#34;&gt;「&lt;a href=&#34;https://golang.org/ref/spec&#34; title=&#34;The Go Programming Language Specification - The Go Programming Language&#34;&gt;言語仕様&lt;/a&gt;」では文章上の表現として operator と記述しているところが幾つかあるが定義としては演算子として扱われていない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:op&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:pp&#34;&gt;C/C++ で &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt; 演算子を前置にするか後置にするかという問題は挙動の分かりにくさと実行時パフォーマンスの2つの論点がある。いずれにしろ前置に統一する方がよいと言われているが，&lt;a href=&#34;http://cpp.aquariuscode.com/preincriment-vs-postincriment&#34; title=&#34;前置インクリメント vs 後置インクリメント | 闇夜のC++&#34;&gt;パフォーマンスに関しては異論もある&lt;/a&gt;ようだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:pp&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Go 言語 1.8 がリリース - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2017/02/go-1_8-released/" />
		<id>tag:text.Baldanders.info,2017-02-19:/remark/2017/02/go-1_8-released/</id>
		<published>2017-02-19T15:45:53+09:00</published>
		<updated>2017-02-19T15:45:53+09:00</updated>
		<summary>Go 言語コンパイラのバージョン 1.8 がリリースされた。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;コンパイラのバージョン 1.8 がリリースされた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/go1.8&#34;&gt;Go 1.8 is released - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主な改善点を上げると&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;コンパイル時間の短縮&lt;/li&gt;
&lt;li&gt;ガベージコレクションの改善（通常で 100μsec 未満，しばしば 10μsec 未満）&lt;/li&gt;
&lt;li&gt;HTTP/2 Push の追加&lt;/li&gt;
&lt;li&gt;標準ライブラリの &lt;a href=&#34;https://golang.org/pkg/context/&#34; title=&#34;context - The Go Programming Language&#34;&gt;&lt;code&gt;context&lt;/code&gt;&lt;/a&gt; パッケージについてキャンセルとタイムアウトの仕組みを追加

&lt;ul&gt;
&lt;li&gt;HTTP サーバのシャットダウンの改善など&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;a href=&#34;https://golang.org/pkg/sort/#Slice&#34;&gt;&lt;code&gt;Slice&lt;/code&gt;&lt;/a&gt; 関数の追加。 &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; のソートが簡単になった&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;その他，詳しくは以下のリリースノートを参照のこと。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/go1.8&#34;&gt;Go 1.8 Release Notes - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;戯れ言&#34;&gt;戯れ言&lt;/h2&gt;

&lt;p&gt;2015年頃から（仕事以外でだが） &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で遊ぶようになって2年半近くが過ぎた。&lt;/p&gt;

&lt;p&gt;仕事においては，業務システムでは相変わらず Java への replace 仕事ばっかりだし（私のようなロートルエンジニアは過去の&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E6%8A%80%E8%A1%93%E7%9A%84%E8%B2%A0%E5%82%B5&#34;&gt;技術的負債&lt;/a&gt;の後始末をするのがお役目），組み込みでは C/C++ がメインなので， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;を使う機会がないのだが，恐ろしいことに私の中で &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;が「&lt;a href=&#34;http://text.baldanders.info/remark/2015/programming-language/&#34; title=&#34;プログラミング言語との付き合い方&#34;&gt;母国語&lt;/a&gt;」になりつつある。
つまり，あるロジックをプログラム・コードに「翻訳」する際に，まず &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のコードが思い浮かぶようになってきた。&lt;/p&gt;

&lt;p&gt;この業界に四半世紀以上も足を突っ込んでるが脳内の&lt;a href=&#34;http://text.baldanders.info/remark/2015/programming-language/&#34; title=&#34;プログラミング言語との付き合い方&#34;&gt;母国語&lt;/a&gt;が変わるという経験は初めてで，まるで転生物のラノベ作品を読むがごとく，年甲斐もなく「&lt;a href=&#34;https://nijipi.com/it-news/kemono-lang_ruby-brainfuck/&#34;&gt;わーい！ たのしー！&lt;/a&gt;」な気分でコードを眺める日々である。&lt;/p&gt;

&lt;p&gt;もっとも，有り余る計算資源を持つクラウド環境ならともかくリソースの限られた RTOS (Real-Time Operating System) 環境下では息を吸うようにヒープを使いまくる &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;での実装は向いてない気がするので，「これは言語のチョイスを間違えたかなぁ」とも思わないでもない。
まぁでもそれならそれで C/C++ を使えばいいので困ることでもないんだけどね。&lt;/p&gt;

&lt;p&gt;でも  &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;が&lt;a href=&#34;http://text.baldanders.info/remark/2015/programming-language/&#34; title=&#34;プログラミング言語との付き合い方&#34;&gt;母国語&lt;/a&gt;になると（アセンブラに近い C 言語はともかく） C++ って本当に面倒くさい言語だったんだなぁ，と涙が出ちゃう。
だってエンジニアだもん。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://postd.cc/why-go-is-not-good/&#34;&gt;Go言語がダメな理由 | プログラミング | POSTD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/&#34;&gt;プログラミング言語 Go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4320026926/baldandersinf-22/&#34;&gt;&lt;img src=&#34;https://images-fe.ssl-images-amazon.com/images/I/41W69WGATNL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4320026926/baldandersinf-22/&#34;&gt;プログラミング言語C 第2版 ANSI規格準拠&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;B.W. カーニハン D.M. リッチー 石田 晴久 &lt;/dd&gt;&lt;dd&gt;共立出版 1989-06-15&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4320027485/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4320027485.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;プログラミング言語Cアンサー・ブック 第2版&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4874084141/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4874084141.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;C言語による最新アルゴリズム事典 (ソフトウェアテクノロジー)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4774111422/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4774111422.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;C言語ポインタ完全制覇 (標準プログラマーズライブラリ)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4797304952/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4797304952.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;定本 Cプログラマのためのアルゴリズムとデータ構造 (SOFTBANK BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4900900648/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4900900648.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;C実践プログラミング 第3版&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4781908535/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4781908535.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;工科系の数学 (5)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4781908896/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4781908896.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;工科系の数学〈6〉関数論&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4756136494/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4756136494.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;プログラミング作法&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798030147/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798030147.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;苦しんで覚えるC言語&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798101036/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798101036.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Cの絵本―C言語が好きになる9つの扉&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;通称 “K&amp;amp;R”。その筋の人々には「バイブル」と呼ばれる名著。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2017-02-19&#34;&gt;2017-02-19&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Go 1.7.5 がリリース - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2017/01/go-1_7_5-released/" />
		<id>tag:text.Baldanders.info,2017-01-27:/remark/2017/01/go-1_7_5-released/</id>
		<published>2017-01-27T20:16:27+09:00</published>
		<updated>2017-01-27T20:16:27+09:00</updated>
		<summary>crypto/x509 および time パッケージを使っているプロジェクトは要対応である。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">&lt;p&gt;Go 1.7.5 がリリースされている。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/devel/release.html#go1.7.minor&#34;&gt;Release History&lt;/a&gt; によると&lt;/p&gt;

&lt;figure lang=&#34;en&#34;&gt;
&lt;blockquote&gt;
&lt;q&gt;go1.7.5 (released 2017/01/26) includes fixes to the compiler, runtime, and the &lt;code&gt;crypto/x509&lt;/code&gt; and &lt;code&gt;time&lt;/code&gt; packages. See the &lt;a href=&#34;https://github.com/golang/go/issues?q=milestone%3AGo1.7.5&#34;&gt;Go 1.7.5 milestone&lt;/a&gt; on our issue tracker for details. &lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;https://golang.org/doc/devel/release.html#go1.7.minor&#34;&gt;Release History&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;ということなので，該当するパッケージを使っているプロジェクトは要対応である。&lt;/p&gt;

&lt;p&gt;なお，併せて Go 1.8 RC3 もリリースされている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://beta.golang.org/doc/go1.8&#34;&gt;Go 1.8 Release Notes - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>1を1億回足して1億にならない場合 - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/loop-counter/" />
		<id>tag:text.Baldanders.info,2017-01-18:/golang/loop-counter/</id>
		<published>2017-01-18T21:45:30+09:00</published>
		<updated>2017-02-27T14:33:55+09:00</updated>
		<summary>浮動小数点数型の変数をループカウンタにするのは止めましょうね。約束だよ！</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（この記事は &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/74a49773413c62721189&#34; title=&#34;1を1億回足して1億にならない場合 - Qiita&#34;&gt;Qiita に投稿した記事&lt;/a&gt;の転載です）&lt;/p&gt;

&lt;p&gt;今回は軽めのネタで。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/7of9/items/438a43bf53d60eab59e3&#34;&gt;C &amp;gt; 浮動小数点型変数はループカウンタとして使用しない - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まぁ浮動小数点数型の仕様を知れば当たり前の話なのだが，面白そうなので「1を1億回足す」ってのを &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;でも書いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	var d float32 = 0.0
	for i := 0; i &amp;lt; 100000000; i++ {
		d += 1.0
	}
	fmt.Println(d)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は予想通り&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run loop1.go
1.6777216e+07
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:f32&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:f32&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
念のため &lt;code&gt;float64&lt;/code&gt; でも試してみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	var d float64 = 0.0
	for i := 0; i &amp;lt; 100000000; i++ {
		d += 1.0
	}
	fmt.Println(d)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run loop2.go
1e+08
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で，ちゃんと1億になる。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では基本型のサイズが厳密に決まってるので（int, uint, uintptr は除く），浮動小数点数型の計算誤差についてもきちんと見積もれるはずである。&lt;/p&gt;

&lt;p&gt;ちなみに&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	for d := 0.0; d &amp;lt; 1.0; d += 0.1 {
		fmt.Println(d)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:var&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:var&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run loop3.go
0
0.1
0.2
0.30000000000000004
0.4
0.5
0.6
0.7
0.7999999999999999
0.8999999999999999
0.9999999999999999
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ってなことになる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:r&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:r&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; ので浮動小数点数型の変数をループカウンタにするのは止めましょうね。
約束だよ！&lt;/p&gt;

&lt;h2 id=&#34;math-big-パッケージ-追記&#34;&gt;math/big パッケージ（追記）&lt;/h2&gt;

&lt;p&gt;浮動小数点数演算の「情報落ち」や「丸め誤差」等を緩和する方法として &lt;a href=&#34;https://golang.org/pkg/math/big/&#34; title=&#34;big - The Go Programming Language&#34;&gt;&lt;code&gt;math/big&lt;/code&gt;&lt;/a&gt; パッケージの &lt;a href=&#34;https://golang.org/pkg/math/big/#Float&#34;&gt;&lt;code&gt;Float&lt;/code&gt;&lt;/a&gt; 型を使う手がある。
&lt;a href=&#34;https://golang.org/pkg/math/big/#Float&#34;&gt;&lt;code&gt;Float&lt;/code&gt;&lt;/a&gt; 型では有効桁数を指定できる。
たとえば先程の 0.1 ずつカウントアップさせる処理ならこんなコードになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/big&amp;quot;
)

func main() {
	var x, y, z big.Float //zero initialize
	y.SetFloat64(0.1)     //53bit precision
	x.SetPrec(64)
	y.SetPrec(64)

	for i := 0; i &amp;lt; 10; i++ {
		z.Add(&amp;amp;x, &amp;amp;y)
		x.Set(&amp;amp;z)
		fmt.Printf(&amp;quot;x = %v (prec = %d bits)\n&amp;quot;, &amp;amp;x, x.Prec())
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードでは有効桁数を64ビットにそろえて計算している。
これを実行するとこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run big2.go
x = 0.10000000000000000555 (prec = 64 bits)
x = 0.2000000000000000111 (prec = 64 bits)
x = 0.30000000000000001665 (prec = 64 bits)
x = 0.4000000000000000222 (prec = 64 bits)
x = 0.50000000000000002776 (prec = 64 bits)
x = 0.6000000000000000333 (prec = 64 bits)
x = 0.70000000000000003886 (prec = 64 bits)
x = 0.8000000000000000444 (prec = 64 bits)
x = 0.90000000000000004996 (prec = 64 bits)
x = 1.0000000000000000555 (prec = 64 bits)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もうひとつ。
&lt;a href=&#34;https://golang.org/pkg/math/big/#Rat&#34;&gt;&lt;code&gt;Rat&lt;/code&gt;&lt;/a&gt; 型を使う手もある。
&lt;a href=&#34;https://golang.org/pkg/math/big/#Rat&#34;&gt;&lt;code&gt;Rat&lt;/code&gt;&lt;/a&gt; 型は有理数の内部表現で値を保持するため記述によっては誤差を小さくできる。
たとえばこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/big&amp;quot;
)

func main() {
	var x, y, z big.Rat //zero initialize
	var a, b big.Int
	a.SetInt64(1)
	b.SetInt64(10)
	y.SetFrac(&amp;amp;a, &amp;amp;b)

	for i := 0; i &amp;lt; 10; i++ {
		z.Add(&amp;amp;x, &amp;amp;y)
		x.Set(&amp;amp;z)
		fmt.Printf(&amp;quot;x = %s (%v)\n&amp;quot;, x.FloatString(20), &amp;amp;x)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run big3.go
x = 0.10000000000000000000 (1/10)
x = 0.20000000000000000000 (1/5)
x = 0.30000000000000000000 (3/10)
x = 0.40000000000000000000 (2/5)
x = 0.50000000000000000000 (1/2)
x = 0.60000000000000000000 (3/5)
x = 0.70000000000000000000 (7/10)
x = 0.80000000000000000000 (4/5)
x = 0.90000000000000000000 (9/10)
x = 1.00000000000000000000 (1/1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;decimal-型-追記&#34;&gt;Decimal 型（追記）&lt;/h2&gt;

&lt;p&gt;残念ながら &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の標準パッケージには Java で言うところの &lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&#34;&gt;BigDecimal&lt;/a&gt; に相当するものがない。
ただし似たパッケージを提供している人はいるようだ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/shopspring/decimal&#34; title=&#34;shopspring/decimal: Arbitrary-precision fixed-point decimal numbers in go&#34;&gt;shopspring/decimal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;たとえばこんな感じに記述する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/shopspring/decimal&amp;quot;
)

func main() {
	x := decimal.NewFromFloat(0)
	y, _ := decimal.NewFromString(&amp;quot;0.1&amp;quot;)

	for i := 0; i &amp;lt; 10; i++ {
		x = x.Add(y)
		fmt.Printf(&amp;quot;x = %s\n&amp;quot;, x.StringFixed(20))
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run big4.go
x = 0.10000000000000000000
x = 0.20000000000000000000
x = 0.30000000000000000000
x = 0.40000000000000000000
x = 0.50000000000000000000
x = 0.60000000000000000000
x = 0.70000000000000000000
x = 0.80000000000000000000
x = 0.90000000000000000000
x = 1.00000000000000000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;じゃあ試しに1を1億回足してみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/shopspring/decimal&amp;quot;
)

func main() {
	x := decimal.NewFromFloat(0)
	y, _ := decimal.NewFromString(&amp;quot;1.0&amp;quot;)

	for i := 0; i &amp;lt; 100000000; i++ {
		x = x.Add(y)
	}
	fmt.Printf(&amp;quot;x = %s\n&amp;quot;, x.StringFixed(20))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果はこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run big4b.go
z = 100000000.00000000000000000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結構な時間がかかった。
でも「情報落ち」もなく綺麗に1億になったようだ。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cc.kyoto-su.ac.jp/~yamada/programming/float.html&#34;&gt;浮動小数点数型と誤差&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tooljp.com/jyosho/docs/ketaochi-jyohoochi/ketaochi-jyohoochi.html&#34;&gt;情報落ち、桁落ち、丸め誤差、打切り誤差の違い&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:f32&#34;&gt;&lt;code&gt;float32&lt;/code&gt; は32ビットサイズの浮動小数点数型で，符号部1ビット，指数部8ビット，仮数部23ビット，という内訳になっている（仮数部は仮数の小数点以下を表す）。つまり有効桁数が24ビット（10進数で約7桁）しかない。したがって今回のような「1づつ加算する動作を繰り返す」処理では16,777,216（&lt;code&gt;=0xffffff+1&lt;/code&gt;）以降は「情報落ち」が発生する。ちなみに &lt;code&gt;float64&lt;/code&gt; は64ビットサイズで仮数部は52ビットあり，10進数にして約15桁の有効桁数になる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:f32&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:var&#34;&gt;“&lt;code&gt;d := 0.0&lt;/code&gt;” と記述した場合，変数 &lt;code&gt;d&lt;/code&gt; は &lt;code&gt;float64&lt;/code&gt; として宣言・初期化される。厳密には定数 “&lt;code&gt;0.0&lt;/code&gt;” は，いったん「型付けなし」の浮動小数点数として評価された後，変数宣言時に &lt;code&gt;float64&lt;/code&gt; に暗黙的に変換される。 &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;におけるこの定数の機能は何かと便利なので覚えておくとよいだろう。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:var&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:r&#34;&gt;このような結果になるのは &lt;code&gt;float32&lt;/code&gt;/&lt;code&gt;float64&lt;/code&gt; の浮動小数点数型の内部表現が2進数になっているため。たとえば 0.1 を2進数で表すと「0.000110011&amp;hellip;」と循環しキリのいい値にならない。このため 0.1 を加算していくと「丸め誤差」が蓄積していくのである。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:r&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>『数学ガールの秘密ノート／やさしい統計』で遊ぶ - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2016/12/math-girl-secret-note-statistics/" />
		<id>tag:text.Baldanders.info,2016-12-11:/remark/2016/12/math-girl-secret-note-statistics/</id>
		<published>2016-12-11T15:59:26+09:00</published>
		<updated>2016-12-11T15:59:26+09:00</updated>
		<summary>今回はテトラちゃん回かなぁ。1,2章のユーリちゃんとのやり取りも面白いけど，新しい用語が次々登場する状況で，言葉や名前に敏感なテトラちゃんがアワアワする感じがよかった。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">&lt;p&gt;（今回はネタバレをガッツリ含むので見たくない方は静かにページを閉じてください）&lt;/p&gt;

&lt;p&gt;本当は「この世界の片隅に」を観に行こうかと思っていたのだが，さすが地元広島は大人気のようで満席になっていた。
こりゃあ劇場で観るのは無理そうだな。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;https://www.flickr.com/photos/spiegel/31524625546/&#34;&gt;&lt;img srcset=&#34;https://c3.staticflickr.com/1/547/31524625546_7ecb84c98b.jpg 500w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;残念。こりゃあ劇場で見るのは無理そうだな。シネコンで見る気はないし。&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/31524625546/&#34;&gt;残念。こりゃあ劇場で見るのは無理そうだな。シネコンで見る気はないし。&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;ということで映画は諦めて，夕方の待ち合わせ時間まで喫茶店で積ん読状態だった『&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MSJMKMW/baldandersinf-22/&#34; title=&#34;Amazon.co.jp: 数学ガールの秘密ノート／やさしい統計 電子書籍: 結城 浩: Kindleストア&#34;&gt;数学ガールの秘密ノート／やさしい統計&lt;/a&gt;』を一気読みすることにした。&lt;/p&gt;

&lt;p&gt;ちなみに『&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MSJMKMW/baldandersinf-22/&#34; title=&#34;Amazon.co.jp: 数学ガールの秘密ノート／やさしい統計 電子書籍: 結城 浩: Kindleストア&#34;&gt;数学ガールの秘密ノート／やさしい統計&lt;/a&gt;』の詳しい解説は以下のページが参考になる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://id.fnshr.info/2016/11/05/secret-notebook-statistics/&#34;&gt;数学好きから統計好きに――『数学ガールの秘密ノート／やさしい統計』｜Colorless Green Ideas&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この記事によると最近の中高生は統計についてきちんと習うらしい（でも選択科目？）。
私は高校は理数科だったので一通り習ったはずなのだが，あまり憶えてなかったりする。
統計について強く意識するようになったのは大学で誤差論を習ってから。
だから純粋に数学って感じじゃなくて，あくまでもデータを解析するための道具・手段として捉えていた。
『&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MSJMKMW/baldandersinf-22/&#34; title=&#34;Amazon.co.jp: 数学ガールの秘密ノート／やさしい統計 電子書籍: 結城 浩: Kindleストア&#34;&gt;数学ガールの秘密ノート／やさしい統計&lt;/a&gt;』を通して統計の初歩について数学体系として学ぶのは多分初めての体験で（高校で習ったのはあくまでも受験用だったからね）とても面白かった。&lt;/p&gt;

&lt;p&gt;今回はテトラちゃん回かなぁ。
1,2章のユーリちゃんとのやり取りも面白いけど，新しい用語が次々登場する状況で，言葉や名前に敏感なテトラちゃんがアワアワする感じがよかった。&lt;/p&gt;

&lt;p&gt;今回の『&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MSJMKMW/baldandersinf-22/&#34; title=&#34;Amazon.co.jp: 数学ガールの秘密ノート／やさしい統計 電子書籍: 結城 浩: Kindleストア&#34;&gt;数学ガールの秘密ノート／やさしい統計&lt;/a&gt;』がいつもと毛色が違うなと感じたのは，次々と用語が登場して，その定義と意味についてユーリちゃんやテトラちゃんに延々と説明していく，という流れになっていたからだろうか。
実は最近新しいプロジェクトで要求分析をやっているところなので，それと脳内でシンクロする感じが楽しかった。&lt;/p&gt;

&lt;p&gt;要求分析で真っ先にやるのは「用語集」を作ることだ。
「用語集」を作る目的は2つある。
ひとつは顧客と「言葉」を合わせることで，もうひとつは「言葉」を厳密に定義することだ。
これを最初にやっておかないと顧客との間で齟齬が生じてしまう場合がある。
『&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MSJMKMW/baldandersinf-22/&#34; title=&#34;Amazon.co.jp: 数学ガールの秘密ノート／やさしい統計 電子書籍: 結城 浩: Kindleストア&#34;&gt;数学ガールの秘密ノート／やさしい統計&lt;/a&gt;』でやっていることは用語集の作成プロセスに似ている。&lt;/p&gt;

&lt;p&gt;さて，作中で登場した村木先生の《カード》&lt;/p&gt;

&lt;figure&gt;
&lt;blockquote&gt;
&lt;q&gt;コインを10回投げたとき、表は何回出るだろう。&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MSJMKMW/baldandersinf-22/&#34;&gt;『数学ガールの秘密ノート／やさしい統計』第4章&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;プログラマならこれを擬似乱数を使って試してみたいって思うよね。
このサイトの別セクションで，以前「&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi/&#34;&gt;モンテカルロ法を使って円周率を求める&lt;/a&gt;」というのをやったので，これを応用してコードを組んでみることにしよう。&lt;/p&gt;

&lt;p&gt;できあがりはこちら。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/cointoss&#34;&gt;spiegel-im-spiegel/cointoss: コインを10回投げたとき、表は何回出るだろう。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;パッケージ構成は概ねこんな感じ。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/ddd-cointoss.svg&#34;&gt;&lt;img srcset=&#34;http://text.baldanders.info/images/ddd-cointoss.svg 640w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;パッケージ構成&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;http://text.baldanders.info/images/ddd-cointoss.svg&#34;&gt;パッケージ構成&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;gen&lt;/code&gt; パッケージで擬似乱数を使ってコイントスを行う。
こんな感じのコード。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * These codes are licensed under CC0.
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package gen

import &amp;quot;math/rand&amp;quot;

//New returns generator of random number [0,2)
func New(s rand.Source, ct int64) &amp;lt;-chan int {
	ch := make(chan int)
	r := rand.New(s)

	go func(ct int64) {
		for i := int64(0); i &amp;lt; ct; i++ {
			ch &amp;lt;- r.Intn(2)
		}
		close(ch)
	}(ct)

	return ch
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コイントスを行った結果を入れる &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; を生成し，実際のコイントスは &lt;a href=&#34;http://golang.org/ref/spec#Go_statements&#34;&gt;goroutine&lt;/a&gt; の中で擬似乱数生成器を使い指定した回数だけ行っている。
1が出れば表である。
では実際にコインを10回投げてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go toss -t 10
0
0
1
0
0
0
0
0
1
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは10回中表になったのは3回。
さらに「コインを10回投げる」行為を10回行って統計値を取ってみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go repeat -t 10 -c 10
6
6
5
1
9
5
5
5
6
3
minimum value: 1
maximum value: 9
average value: 5.10000
standard deviation: 1.97231
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは表が出た回数の最小値が1，最大値が9，平均値が5.1，標準偏差が約1.97となった。
10回ではよくわからないので次はどどーんと1万回やってみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go repeat -t 10 -c 10000 &amp;gt; cointoss.dat
minimum value: 0
maximum value: 10
average value: 4.99690
standard deviation: 1.57477
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果データは &lt;code&gt;cointoss.dat&lt;/code&gt; ファイルに保存している。
ここでは表が出た回数の最小値が0，最大値が10，平均値が約5.0，標準偏差が約1.57となった。
では &lt;code&gt;cointoss.dat&lt;/code&gt; ファイルを &lt;a href=&#34;http://www.gnuplot.info/&#34; title=&#34;gnuplot homepage&#34;&gt;gnuplot&lt;/a&gt; に食わせてヒストグラムにしてみる（階級幅は1）&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:h&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:h&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;gnuplot&amp;gt; unset key
gnuplot&amp;gt; set xrange [-1:11]  
gnuplot&amp;gt; filter(x,y)=int(x/y)*y                                                              
gnuplot&amp;gt; plot &amp;quot;cointoss.dat&amp;quot;  u (filter($1,1)):(1) smooth frequency with boxes lc rgb &amp;quot;black&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果はこんな感じ。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/cointoss-hist.png&#34;&gt;&lt;img srcset=&#34;http://text.baldanders.info/images/cointoss-hist.png 750w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;ヒストグラム&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;http://text.baldanders.info/images/cointoss-hist.png&#34;&gt;ヒストグラム&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;おおっ。
きれいに正規分布っぽくなっている。
さて，『&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MSJMKMW/baldandersinf-22/&#34; title=&#34;Amazon.co.jp: 数学ガールの秘密ノート／やさしい統計 電子書籍: 結城 浩: Kindleストア&#34;&gt;数学ガールの秘密ノート／やさしい統計&lt;/a&gt;』4章で数学的に求めた値とどのくらい違うかな（笑） ちなみに $\sqrt{2.5} = 1.5811&amp;hellip;$ である。&lt;/p&gt;

&lt;p&gt;あー，遊んだ遊んだ。&lt;/p&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MSJMKMW/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/41-A4q7tckL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MSJMKMW/baldandersinf-22/&#34;&gt;数学ガールの秘密ノート／やさしい統計&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;結城 浩 &lt;/dd&gt;&lt;dd&gt;SBクリエイティブ 2016-10-28&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01EL08HVS/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01EL08HVS.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／場合の数&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B018VE46YW/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B018VE46YW.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／ベクトルの真実&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01NCIV1N7/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01NCIV1N7.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;はじめての深層学習（ディープラーニング）プログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01NA96U1T/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01NA96U1T.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;ポートとソケットがわかればインターネットがわかる――TCP/IP・ネットワーク技術を学びたいあなたのために&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00W6NCLL0/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00W6NCLL0.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／数列の広場&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00Y9EYOIW/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00Y9EYOIW.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／微分を追いかけて&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMJ0/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00L0PDMJ0.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／整数で遊ぼう&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00W6NCLJM/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00W6NCLJM.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／丸い三角関数&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01N66D7CV/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01N66D7CV.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;経済数学の直観的方法　確率・統計編 (ブルーバックス)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MXHLC6P/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01MXHLC6P.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;速習 Python 3 上: プログラミングの基礎編&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;統計の本当に基礎の部分から。学業成績でよく聞く「偏差値」とは何を表していて何を意味しているのか。なんてなあたりから。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-12-11&#34;&gt;2016-12-11&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:h&#34;&gt;「&lt;a href=&#34;http://qiita.com/iwiwi/items/4c7635d4c84bc785e47a&#34;&gt;gnuplot でヒストグラム（頻度分布図）を描画する - Qiita&lt;/a&gt;」を参考にした。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:h&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Security Release Go 1.7.4 and 1.6.4 - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2016/12/security-release-golang-1_7_4-and-1_6_4/" />
		<id>tag:text.Baldanders.info,2016-12-02:/remark/2016/12/security-release-golang-1_7_4-and-1_6_4/</id>
		<published>2016-12-02T20:32:33+09:00</published>
		<updated>2016-12-02T20:32:33+09:00</updated>
		<summary>数日前から予告されていたが， Go 言語の 1.7.4 と 1.6.4 がリリースされた。詳細が分かり次第，ここに追記する。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">&lt;p&gt;数日前から&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-announce/YOqTqcJtiJI&#34;&gt;予告&lt;/a&gt;されていたが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の 1.7.4 と 1.6.4 がリリースされた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-announce/2lP5z9i9ySY&#34;&gt;[security] Go 1.7.4 and Go 1.6.4 are released&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;セキュリティ脆弱性を含むので（特に Web 関連で &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;を使ってる方は）必ずアップデートすること。
なお，特に理由がない限り 1.7 系を使うことをお勧めする。&lt;/p&gt;

&lt;p&gt;ひとつは &lt;a href=&#34;https://golang.org/pkg/crypto/x509/&#34; title=&#34;x509 - The Go Programming Language&#34;&gt;&lt;code&gt;crypto/x509&lt;/code&gt;&lt;/a&gt; パケージに関するもの&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://go-review.googlesource.com/#/c/33721/&#34;&gt;Change If681c514: crypto/x509: read Darwin trust settings for root CAs | go-review.googlesource Code Review&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/issues/18141&#34;&gt;crypto/x509: honor OS X certificate trust settings · Issue #18141 · golang/go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もうひとつは &lt;a href=&#34;https://golang.org/pkg/net/http/&#34; title=&#34;http - The Go Programming Language&#34;&gt;&lt;code&gt;net/http&lt;/code&gt;&lt;/a&gt; パッケージに関するものだ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://go-review.googlesource.com/#/c/30410/&#34;&gt;Change Ib394655b: net/http: multipart ReadForm close file after copy | go-review.googlesource Code Review&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/issues/17965&#34;&gt;net/http: backport &amp;ldquo;multipart ReadForm close file after copy&amp;rdquo; to 1.7 · Issue #17965 · golang/go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CVE 番号とかはまだ付いてないのかな？
詳細が分かり次第，ここに追記する。&lt;/p&gt;

&lt;p&gt;そうそう。
1.8 ベータ版も登場している。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-announce/Wgv6NGcntlQ&#34;&gt;Go 1.8 Beta 1 is released&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://beta.golang.org/doc/go1.8&#34;&gt;Go 1.8 Release Notes - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;GOPATH&lt;/code&gt; 環境変数にデフォルト値ができたらしい。
あと &lt;code&gt;go bug&lt;/code&gt; コマンドってなんだ？&lt;/p&gt;
</content>
	</entry>
	
</feed>
