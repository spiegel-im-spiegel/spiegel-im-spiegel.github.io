<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:cc="http://web.resource.org/cc/">
	<title>Golang - text.Baldanders.info</title>
	<link rel="alternate" type="text/html" href="http://text.baldanders.info/tags/golang/" />
	<link rel="self" type="application/atom+xml" href="http://text.baldanders.info/tags/golang/index.xml" />
	<id>tag:text.Baldanders.info,2015-09-28T20:38:45+0900:/</id>
	<updated>2015-09-28T20:38:45+0900</updated>
	<subtitle>帰ってきた「しっぽのさきっちょ」 （プレ・オープン中）</subtitle>
	<icon>http://text.baldanders.info//images/avatar.jpg</icon>
	<logo>http://text.baldanders.info//images/avatar.jpg</logo>
	<generator uri="http://gohugo.io/">Hugo 0.15-DEV</generator>

	
	<entry>
		<title>プロジェクト・ベースの開発環境をつくる - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/project-based-development/" />
		<id>tag:text.Baldanders.info,2015-09-28T20:38:45+0900:/golang/project-based-development/</id>
		<published>2015-09-28T20:38:45+0900</published>
		
		<summary>今回は gb を使ってプロジェクト・ベースで Golang のコードを管理してみる。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/ef15a48542e043b32c99&#34;&gt;はじめての Go 言語 (on Windows) その9 - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;今回は &lt;a href=&#34;http://getgb.io/&#34; title=&#34;gb - A project based build tool for Go&#34;&gt;gb&lt;/a&gt; を使ってプロジェクト・ベースで Golang のコードを管理してみる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://getgb.io/&#34;&gt;gb - A project based build tool for Go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gb-の導入:6e131725c8916e09bb821f8d42f65641&#34;&gt;gb の導入&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://getgb.io/&#34; title=&#34;gb - A project based build tool for Go&#34;&gt;gb&lt;/a&gt; の導入は &lt;code&gt;go get&lt;/code&gt; でできる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:6e131725c8916e09bb821f8d42f65641:b&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:6e131725c8916e09bb821f8d42f65641:b&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go get -v github.com/constabulary/gb/...
github.com/constabulary/gb (download)
github.com/constabulary/gb/log
github.com/constabulary/gb
github.com/constabulary/gb/vendor
github.com/constabulary/gb/cmd
github.com/constabulary/gb/cmd/gb
github.com/constabulary/gb/cmd/gb-vendor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Windows の場合，環境変数 &lt;code&gt;GOPATH&lt;/code&gt; で指定するフォルダ配下の &lt;code&gt;bin&lt;/code&gt; フォルダに &lt;code&gt;gb.exe&lt;/code&gt; および &lt;code&gt;gb-vendor.exe&lt;/code&gt; が生成される。
このフォルダにパスを通しておく（またはパスの通っているフォルダに実行ファイルをコピーする）。&lt;/p&gt;

&lt;h2 id=&#34;プロジェクトの構築とビルド:6e131725c8916e09bb821f8d42f65641&#34;&gt;プロジェクトの構築とビルド&lt;/h2&gt;

&lt;p&gt;「&lt;a href=&#34;http://text.baldanders.info/golang/packaging/&#34;&gt;機能のパッケージ化&lt;/a&gt;」で最後に作ったコードを使って実際に &lt;a href=&#34;http://getgb.io/&#34; title=&#34;gb - A project based build tool for Go&#34;&gt;gb&lt;/a&gt; でプロジェクトを作成しビルドを行ってみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/astrocalc/modjulian&amp;quot;
)

func main() {
	//引数のチェック
	flag.Parse()
	argsStr := flag.Args()
	if len(argsStr) &amp;lt; 3 {
		fmt.Fprintln(os.Stderr, &amp;quot;年月日を指定してください&amp;quot;)
		return
	}
	args := make([]int, 3)
	for i := 0; i &amp;lt; 3; i++ {
		num, err := strconv.Atoi(argsStr[i])
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			return
		} else {
			args[i] = num
		}
	}
	tm := time.Date(args[0], time.Month(args[1]), args[2], 0, 0, 0, 0, time.UTC)
	fmt.Printf(&amp;quot;%v\n&amp;quot;, tm)
	fmt.Printf(&amp;quot;MJD = %d日\n&amp;quot;, modjulian.DayNumber(tm))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ソース-ファイルの配置:6e131725c8916e09bb821f8d42f65641&#34;&gt;ソース・ファイルの配置&lt;/h3&gt;

&lt;p&gt;プロジェクト・フォルダを &lt;code&gt;C:\workspace\gbdemo&lt;/code&gt; とし，ソース・ファイル用のフォルダ &lt;code&gt;src\julian-day&lt;/code&gt; を作成する。
このフォルダに上述のコードを記述したソース・ファイルを配置する。
フォルダ構成は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\gbdemo&amp;gt;tree /f .
C:\WORKSPACE\GBDEMO
└─src
    └─julian-day
            julian-day.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルドするには &lt;code&gt;gb build&lt;/code&gt; コマンドを実行すればいいのだが，このままでは &lt;code&gt;modjulian&lt;/code&gt; パッケージがないため失敗する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\gbdemo&amp;gt;gb build
FATAL command &amp;quot;build&amp;quot; failed: failed to resolve import path &amp;quot;julian-day&amp;quot;: cannot find package &amp;quot;github.com/spiegel-im-spiegel/astrocalc/modjulian&amp;quot; in any of:
        C:\Go\src\github.com\spiegel-im-spiegel\astrocalc\modjulian (from $GOROOT)
        C:\workspace\gbdemo\src\github.com\spiegel-im-spiegel\astrocalc\modjulian (from $GOPATH)
        C:\workspace\gbdemo\vendor\src\github.com\spiegel-im-spiegel\astrocalc\modjulian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プロジェクト・フォルダ以下を &lt;code&gt;GOPATH&lt;/code&gt; として &lt;code&gt;modjulian&lt;/code&gt; パッケージを探しているのがお分かりだろうか。
&lt;a href=&#34;http://getgb.io/&#34; title=&#34;gb - A project based build tool for Go&#34;&gt;gb&lt;/a&gt; では，実行時に既存の &lt;code&gt;GOPATH&lt;/code&gt; を上書きするようである。
またプロジェクト・フォルダ配下の &lt;code&gt;vendor&lt;/code&gt; フォルダを探しているのにも注目してほしい。&lt;/p&gt;

&lt;h3 id=&#34;外部パッケージの導入:6e131725c8916e09bb821f8d42f65641&#34;&gt;外部パッケージの導入&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://getgb.io/&#34; title=&#34;gb - A project based build tool for Go&#34;&gt;gb&lt;/a&gt; では外部パッケージを &lt;code&gt;gb vendor&lt;/code&gt; コマンドで管理できる。
外部パッケージの導入には &lt;code&gt;gb vendor fetch&lt;/code&gt; コマンドを使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\gbdemo&amp;gt;gb vendor fetch github.com/spiegel-im-spiegel/astrocalc/modjulian

C:\workspace\gbdemo&amp;gt;tree /f .
C:\WORKSPACE\GBDEMO
├─src
│  └─julian-day
│          julian-day.go
│
└─vendor
    │  manifest
    │
    └─src
        └─github.com
            └─spiegel-im-spiegel
                └─astrocalc
                    └─modjulian
                            example_test.go
                            LICENSE
                            modjulian.go
                            modjulian_test.go

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プロジェクト・フォルダ以下に &lt;code&gt;vendor&lt;/code&gt; フォルダが作成され，パッケージのソースファイルが展開されている。&lt;/p&gt;

&lt;p&gt;今回 &lt;code&gt;gb vendor fetch&lt;/code&gt; で取得したパッケージは &lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; のリポジトリから取ってきたものだが， &lt;code&gt;git clone&lt;/code&gt; ではなく，フォルダ・ファイル構成ごとコピーしてきたもののようである。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gb vendor fetch&lt;/code&gt; コマンドでは &lt;code&gt;-branch&lt;/code&gt; や &lt;code&gt;-tag&lt;/code&gt; や &lt;code&gt;-revision&lt;/code&gt; オプションでリポジトリのブランチやタグまたはリビジョンを指定できる。
このとき，導入したパッケージのリポジトリ情報は &lt;code&gt;vender\manifest&lt;/code&gt; ファイルに格納されている（中身は JSON 形式）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
	&amp;quot;version&amp;quot;: 0,
	&amp;quot;dependencies&amp;quot;: [
		{
			&amp;quot;importpath&amp;quot;: &amp;quot;github.com/spiegel-im-spiegel/astrocalc/modjulian&amp;quot;,
			&amp;quot;repository&amp;quot;: &amp;quot;https://github.com/spiegel-im-spiegel/astrocalc&amp;quot;,
			&amp;quot;revision&amp;quot;: &amp;quot;c9f5fb495e67b868a2b3f0e16c38282095fe5033&amp;quot;,
			&amp;quot;branch&amp;quot;: &amp;quot;master&amp;quot;,
			&amp;quot;path&amp;quot;: &amp;quot;/modjulian&amp;quot;
		}
	]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに外部パッケージをアップデートする場合は &lt;code&gt;gb vendor update&lt;/code&gt; コマンドを使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\gbdemo&amp;gt;gb vendor update github.com/spiegel-im-spiegel/astrocalc/modjulian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;または&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\gbdemo&amp;gt;gb vendor update -all
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;プロジェクトのビルド:6e131725c8916e09bb821f8d42f65641&#34;&gt;プロジェクトのビルド&lt;/h3&gt;

&lt;p&gt;では，この状態でもう一回ビルドしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\gbdemo&amp;gt;gb build
julian-day

C:\workspace\gbdemo&amp;gt;tree /f .
C:\WORKSPACE\GBDEMO
├─bin
│      julian-day.exe
│
├─pkg
│  └─windows-amd64
│      │  julian-day.a
│      │
│      └─github.com
│          └─spiegel-im-spiegel
│              └─astrocalc
│                      modjulian.a
│
├─src
│  └─julian-day
│          julian-day.go
│
└─vendor
    │  manifest
    │
    └─src
        └─github.com
            └─spiegel-im-spiegel
                └─astrocalc
                    └─modjulian
                            example_test.go
                            LICENSE
                            modjulian.go
                            modjulian_test.go

C:\workspace\gbdemo&amp;gt;bin\julian-day.exe 2015 1 1
2015-01-01 00:00:00 +0000 UTC
MJD = 57023日
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今度は上手くいったようだ。
&lt;code&gt;gb build&lt;/code&gt; コマンドのオプションは以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\gbdemo&amp;gt;gb help build
usage: gb build [build flags] [packages]

Build compiles the packages named by the import paths, along with their
dependencies.

Flags:

        -f
                ignore cached packages if present, new packages built will overwrite
                any cached packages. This effectively disables incremental
                compilation.
        -F
                do not cache packages, cached packages will still be used for
                incremental compilation. -f -F is advised to disable the package

                caching system.
        -q
                decreases verbosity, effectively raising the output level to ERROR.
                In a successful build, no output will be displayed.
        -P
                The number of build jobs to run in parallel, including test execution.
                By default this is the number of CPUs visible to gb.
        -R
                sets the base of the project root search path from the current working
                directory to the value supplied. Effectively gb changes working
                directory to this path before searching for the project root.
        -v
                increases verbosity, effectively lowering the output level from INFO
                to DEBUG.
        -dotfile
                if provided, gb will output a dot formatted file of the build steps to
                be performed.
        -ldflags &#39;flag list&#39;
                arguments to pass on each linker invocation.
        -gcflags &#39;arg list&#39;
                arguments to pass on each compile invocation.
        -tags &#39;tag list&#39;
                additional build tags.

The list flags accept a space-separated list of strings. To embed spaces in an
element in the list, surround it with either single or double quotes.

For more about specifying packages, see &#39;gb help packages&#39;. For more about
where packages and binaries are installed, run &#39;gb help project&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-ldflags&lt;/code&gt; や &lt;code&gt;-gcflags&lt;/code&gt; オプションが使えるのはありがたいかな。&lt;/p&gt;

&lt;h2 id=&#34;複数パッケージを含めたプロジェクト管理:6e131725c8916e09bb821f8d42f65641&#34;&gt;複数パッケージを含めたプロジェクト管理&lt;/h2&gt;

&lt;p&gt;複数のパッケージをまとめて管理したい場合もある。
例えば以下のような構成を考えてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\gbdemo&amp;gt;tree /f .
C:\WORKSPACE\GBDEMO
└─src
    └─julian-day
            julian-day.go

C:\workspace\gbdemo&amp;gt;pushd src

C:\workspace\gbdemo\src&amp;gt;git clone https://github.com/spiegel-im-spiegel/astrocalc.git github.com/spiegel-im-spiegel/astrocalc
Cloning into &#39;github.com/spiegel-im-spiegel/astrocalc&#39;...
remote: Counting objects: 43, done.
remote: Total 43 (delta 0), reused 0 (delta 0), pack-reused 43
Unpacking objects: 100% (43/43), done.
Checking connectivity... done.

C:\workspace\gbdemo\src&amp;gt;popd

C:\workspace\gbdemo&amp;gt;tree /f .
C:\WORKSPACE\GBDEMO
└─src
    ├─github.com
    │  └─spiegel-im-spiegel
    │      └─astrocalc
    │          │  .editorconfig
    │          │  .gitignore
    │          │  .travis.yml
    │          │  LICENSE
    │          │  README.md
    │          │
    │          └─modjulian
    │                  example_test.go
    │                  LICENSE
    │                  modjulian.go
    │                  modjulian_test.go
    │
    └─julian-day
            julian-day.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この状態でビルドを実行してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\gbdemo&amp;gt;gb build
github.com/spiegel-im-spiegel/astrocalc/modjulian
julian-day

C:\workspace\gbdemo&amp;gt;tree /f .
C:\WORKSPACE\GBDEMO
├─bin
│      julian-day.exe
│
├─pkg
│  └─windows-amd64
│      │  julian-day.a
│      │
│      └─github.com
│          └─spiegel-im-spiegel
│              └─astrocalc
│                      modjulian.a
│
└─src
    ├─github.com
    │  └─spiegel-im-spiegel
    │      └─astrocalc
    │          │  .editorconfig
    │          │  .gitignore
    │          │  .travis.yml
    │          │  LICENSE
    │          │  README.md
    │          │
    │          └─modjulian
    │                  example_test.go
    │                  LICENSE
    │                  modjulian.go
    │                  modjulian_test.go
    │
    └─julian-day
            julian-day.go

C:\workspace\gbdemo&amp;gt;bin\julian-day.exe 2015 1 1
2015-01-01 00:00:00 +0000 UTC
MJD = 57023日
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://getgb.io/&#34; title=&#34;gb - A project based build tool for Go&#34;&gt;gb&lt;/a&gt; ではプロジェクト・フォルダ以下にあるパッケージを自動で検索してビルドしてくれる。
もちろんパッケージを指定してビルドすることも可能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\gbdemo&amp;gt;gb build github.com/spiegel-im-spiegel/astrocalc/modjulian
github.com/spiegel-im-spiegel/astrocalc/modjulian

C:\workspace\gbdemo&amp;gt;gb build julian-day
julian-day
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらにテストもできる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:6e131725c8916e09bb821f8d42f65641:a&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:6e131725c8916e09bb821f8d42f65641:a&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\workspace\gbdemo&amp;gt;gb test -v github.com/spiegel-im-spiegel/astrocalc/modjulian
=== RUN   TestDayNumber
--- PASS: TestDayNumber (0.00s)
=== RUN   ExampleDayNumber
--- PASS: ExampleDayNumber (0.00s)                  
PASS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パッケージによっては &lt;code&gt;go test&lt;/code&gt; の結果と &lt;code&gt;gb test&lt;/code&gt; の結果が異なる場合があるので注意が必要。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:6e131725c8916e09bb821f8d42f65641&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/shinofara/items/ac0591fef95c2c6e936e&#34;&gt;golang - gbを知ったのでgojiを使ったWEBアプリケーションプロジェクトを管理してみた - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/06/26/golang-dependency-vendoring/&#34;&gt;Go言語のDependency/Vendoringの問題と今後．gbあるいはGo1.5 | SOTA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:6e131725c8916e09bb821f8d42f65641:b&#34;&gt;&lt;code&gt;go get&lt;/code&gt; の使い方については「&lt;a href=&#34;http://text.baldanders.info/golang/go-get-package/&#34;&gt;go get コマンドでパッケージを管理する&lt;/a&gt;」を参照のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:6e131725c8916e09bb821f8d42f65641:b&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:6e131725c8916e09bb821f8d42f65641:a&#34;&gt;テストについては「&lt;a href=&#34;http://text.baldanders.info/golang/testing/&#34;&gt;Go 言語のテスト・フレームワーク&lt;/a&gt;」を参照のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:6e131725c8916e09bb821f8d42f65641:a&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>セキュリティ脆弱性を修正した Go 1.4.3 がリリース - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2015/go-1-4-3-is-released/" />
		<id>tag:text.Baldanders.info,2015-09-25T00:42:22+0900:/remark/2015/go-1-4-3-is-released/</id>
		<published>2015-09-25T00:42:22+0900</published>
		
		<summary>Go 言語の net/http パッケージに脆弱性が発見された模様。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;figure lang=&#34;en&#34;&gt;
&lt;blockquote&gt;
The issues were reported in Go&#39;s net/http package. They affect programs using that package to proxy HTTP requests. We recommend that all users upgrade to Go 1.5, which fixes these issues. For users unable to upgrade to Go 1.5, we have released version 1.4.3, which is based on Go 1.4.2 plus fixes for these issues. Affected Go programs—those that use the net/http package as a proxy server—must be recompiled with Go 1.5 or Go 1.4.3 to receive the fixes. 
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-announce/iSIyW4lM4hY&#34;&gt;Go 1.4.3 is released (security fix) - Google グループ&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;p&gt;というわけで &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の &lt;a href=&#34;https://golang.org/pkg/net/http/&#34; title=&#34;http - The Go Programming Language&#34;&gt;&lt;code&gt;net/http&lt;/code&gt;&lt;/a&gt; パッケージに脆弱性が発見された模様。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/net/http/&#34; title=&#34;http - The Go Programming Language&#34;&gt;&lt;code&gt;net/http&lt;/code&gt;&lt;/a&gt; パッケージを使っている製品は最新バージョンで再コンパイルすること（パッケージ間の依存関係に注意）。
可能であれば 1.5 系を使うのが望ましい。
諸事情で 1.5 系が使えない場合は，リリースされた 1.4.3 を使ってもよい。&lt;/p&gt;

&lt;h2 id=&#34;影響度-cvss:c3a96b046f183dd79cb60ec78087c2e7&#34;&gt;影響度（CVSS）&lt;/h2&gt;

&lt;p&gt;CVSS 基本評価値 6.8 (AV:N/AC:M/Au:N/C:P/I:P/A:P) （暫定値）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://access.redhat.com/security/cve/CVE-2015-5739&#34;&gt;access.redhat.com | CVE-2015-5739&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://access.redhat.com/security/cve/CVE-2015-5740&#34;&gt;access.redhat.com | CVE-2015-5740&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://access.redhat.com/security/cve/CVE-2015-5741&#34;&gt;access.redhat.com | CVE-2015-5741&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;基本評価基準&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;評価値&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;攻撃元区分（AV）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ネットワーク（N）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;攻撃条件の複雑さ（AC）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;中（M）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;攻撃前の認証要否（Au）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不要（N）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;情報漏えいの可能性（機密性への影響, C）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;部分的（P）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;情報改ざんの可能性（完全性への影響, I）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;部分的（P）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;業務停止の可能性（可用性への影響, A）&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;部分的（P）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;figcaption&gt;CVSSv2 基本評価値&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;p&gt;CVSS については&lt;a href=&#34;http://www.baldanders.info/spiegel/archive/cvss/cvss2.html&#34;&gt;デモページ&lt;/a&gt;を参照のこと。&lt;/p&gt;

&lt;h2 id=&#34;参考:c3a96b046f183dd79cb60ec78087c2e7&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang&#34;&gt;プログラミング言語 Go - text.Baldanders.info&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
	</entry>
	
	<entry>
		<title>文字エンコーディング変換 - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/transform-character-encoding/" />
		<id>tag:text.Baldanders.info,2015-09-23T20:04:00+0900:/golang/transform-character-encoding/</id>
		<published>2015-09-23T20:04:00+0900</published>
		<updated>2015-09-24T12:30:00+0900</updated>
		<summary>文字エンコーディング変換に関してはあちこちに記事があるのだが，微妙に古い気がするので，メモとして書き記しておく。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/2e475b48226330aa5570&#34;&gt;Golang による文字エンコーディング変換 - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;文字エンコーディング変換に関してはあちこちに記事があるのだが，微妙に古い気がするので，メモとして書き記しておく。&lt;/p&gt;

&lt;h2 id=&#34;go-言語の文字エンコーディング変換:8c97bc776007d33febbab020a38c72f3&#34;&gt;Go 言語の文字エンコーディング変換&lt;/h2&gt;

&lt;p&gt;Go 言語では Unicode が既定となっている。
そもそもソースコードが UTF-8 前提になっているし，文字の単位である &lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; の実体は UTF-32 相当である&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8c97bc776007d33febbab020a38c72f3:a&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8c97bc776007d33febbab020a38c72f3:a&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;したがって UTF-8 以外の文字エンコーディングを扱う場合は何らかの変換処理を挟む必要がある。
そのためのパッケージが &lt;a href=&#34;https://godoc.org/golang.org/x/text/transform&#34; title=&#34;transform - GoDoc&#34;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; である。
また&lt;a href=&#34;https://godoc.org/golang.org/x/text/encoding&#34;&gt;エンコーディング&lt;/a&gt;についても各種そろっていて，日本語の場合は &lt;a href=&#34;https://godoc.org/golang.org/x/text/encoding/japanese&#34; title=&#34;japanese - GoDoc&#34;&gt;&lt;code&gt;encoding/japanese&lt;/code&gt;&lt;/a&gt; パッケージを使う。
&lt;a href=&#34;https://godoc.org/golang.org/x/text/encoding/japanese&#34; title=&#34;japanese - GoDoc&#34;&gt;&lt;code&gt;encoding/japanese&lt;/code&gt;&lt;/a&gt; パッケージでは Shift-JIS, EUC-JP, ISO-2202-JP を扱える。&lt;/p&gt;

&lt;h3 id=&#34;パッケージの導入:8c97bc776007d33febbab020a38c72f3&#34;&gt;パッケージの導入&lt;/h3&gt;

&lt;p&gt;日本語が必要なだけなら &lt;code&gt;golang.org/x/text/encoding/japanese&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8c97bc776007d33febbab020a38c72f3:b&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8c97bc776007d33febbab020a38c72f3:b&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; を &lt;code&gt;go get&lt;/code&gt; すれば全てインストールされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go get -v golang.org/x/text/encoding/japanese
Fetching https://golang.org/x/text/encoding/japanese?go-get=1
Parsing meta tags from https://golang.org/x/text/encoding/japanese?go-get=1 (status code 200)
get &amp;quot;golang.org/x/text/encoding/japanese&amp;quot;: found meta tag main.metaImport{Prefix:&amp;quot;golang.org/x/text&amp;quot;, VCS:&amp;quot;git&amp;quot;, RepoRoot:&amp;quot;https://go.googlesource.com/text&amp;quot;} at https://golang.org/x/text/encoding/japanese?go-get=1
get &amp;quot;golang.org/x/text/encoding/japanese&amp;quot;: verifying non-authoritative meta tag
Fetching https://golang.org/x/text?go-get=1
Parsing meta tags from https://golang.org/x/text?go-get=1 (status code 200)
golang.org/x/text (download)
golang.org/x/text/transform
golang.org/x/text/encoding/internal/identifier
golang.org/x/text/encoding
golang.org/x/text/encoding/internal
golang.org/x/text/encoding/japanese
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;変換ロジック-サンプルコード:8c97bc776007d33febbab020a38c72f3&#34;&gt;変換ロジック（サンプルコード）&lt;/h3&gt;

&lt;p&gt;変換ロジックのサンプルを以下に示す（thanks &lt;a href=&#34;http://qiita.com/mattn&#34;&gt;@mattn&lt;/a&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;golang.org/x/text/encoding/japanese&amp;quot;
	&amp;quot;golang.org/x/text/transform&amp;quot;
)

func main() {
	reader := NewDecoder(os.Stdin)
	writer := NewEncoder(os.Stdout)
	if _, err := io.Copy(writer, reader); err != nil {
		fmt.Fprintln(os.Stderr, err)
	}
}

func NewDecoder(reader io.Reader) *transform.Reader {
	return transform.NewReader(reader, japanese.ShiftJIS.NewDecoder())
}

func NewEncoder(writer io.Writer) *transform.Writer {
	return transform.NewWriter(writer, japanese.EUCJP.NewEncoder())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UTF-8 以外の文字エンコーディングから UTF-8 への変換は decode と呼ばれている。
一方， UTF-8 から UTF-8 以外の文字エンコーディングへの変換は encode と呼ばれている。&lt;/p&gt;

&lt;p&gt;上のサンプルでは Shift-JIS →（Decoder）→ UTF-8 →（Encoder）→ EUC-JP の手順で変換していることがお分かりであろうか。
では実際に動かしてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;echo Go言語で行こう | go run transform.go &amp;gt; euc.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで &lt;code&gt;euc.txt&lt;/code&gt; に「Go言語で行こう」と EUC-JP で書き込まれていたら成功である&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8c97bc776007d33febbab020a38c72f3:c&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8c97bc776007d33febbab020a38c72f3:c&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
今回は標準入出力を使ったが， Reader/Writer の stream で表せるものなら同様の処理でできるはずである。&lt;/p&gt;

&lt;h2 id=&#34;文字エンコーディング変換に関する注意点:8c97bc776007d33febbab020a38c72f3&#34;&gt;文字エンコーディング変換に関する注意点&lt;/h2&gt;

&lt;p&gt;Shift-JIS/EUC-JP と UTF-8/UTF-32 ではベースとなっている文字集合（文字エンコーディングではない）が異なる。
Shift-JIS/EUC-JP の文字集合は基本的に JIS 規格だが UTF-8/UTF-32 は Unicode であり，両者は非対称の関係である。
このため，今回のような異なる文字集合を跨ぐ変換を行うと変換が正しく行われない場合もあり得る（要検証）。&lt;/p&gt;

&lt;p&gt;更に困ったことに，歴史的経緯（便利な言葉だw）から Shift-JIS や EUC-JP の実装にはいくつかバリエーションがあるため，実装間の差異が問題になる場合もある。
&lt;a href=&#34;https://godoc.org/golang.org/x/text/encoding/japanese&#34; title=&#34;japanese - GoDoc&#34;&gt;&lt;code&gt;encoding/japanese&lt;/code&gt;&lt;/a&gt; パッケージはこの実装上の差異を考慮してはいないようである。&lt;/p&gt;

&lt;p&gt;更に更に言えば，汎用機などは旧JIS＋外字の構成になっていることが多く，このような需要に応えるなら独自の変換ロジックを開発するしかない。&lt;/p&gt;

&lt;h3 id=&#34;変換ロジックの別解:8c97bc776007d33febbab020a38c72f3&#34;&gt;変換ロジックの別解&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/transform&#34; title=&#34;transform - GoDoc&#34;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; を使った変換でうまくいかない場合は &lt;a href=&#34;https://github.com/djimenez/iconv-go&#34; title=&#34;djimenez/iconv-go&#34;&gt;&lt;code&gt;djimenez/iconv-go&lt;/code&gt;&lt;/a&gt; パッケージを使う手もある。
ただし， &lt;a href=&#34;https://github.com/djimenez/iconv-go&#34; title=&#34;djimenez/iconv-go&#34;&gt;&lt;code&gt;djimenez/iconv-go&lt;/code&gt;&lt;/a&gt; パッケージのビルドには &lt;code&gt;libiconv&lt;/code&gt; および &lt;code&gt;glibc&lt;/code&gt; が必要である（クロス環境では注意）。
このパッケージを使うことで &lt;code&gt;iconv&lt;/code&gt; 相当の処理が可能になる。&lt;/p&gt;

&lt;p&gt;（別の変換パッケージとして &lt;a href=&#34;https://godoc.org/code.google.com/p/mahonia&#34;&gt;&lt;code&gt;mahonia&lt;/code&gt;&lt;/a&gt; を紹介しているところがいくつか見られたが，ドキュメントを見る限り DEPRECATED となっていて使えないようだ。また repository にもアクセスできない）&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:8c97bc776007d33febbab020a38c72f3&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/uchiko/items/1810ddacd23fd4d3c934&#34;&gt;golang - Go言語で文字コード変換 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ja.stackoverflow.com/questions/6120/go%E3%81%A7byte%E3%82%92shift-jis%E3%81%AE%E6%96%87%E5%AD%97%E5%88%97%E3%81%AB%E5%A4%89%E6%8F%9B%E3%81%99%E3%82%8B&#34;&gt;go - Goで[]byteをshift-jisの文字列に変換する - スタック・オーバーフロー&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/irugo/items/390bd187871c7716a1e1&#34;&gt;GO言語で文字コードを扱うライブラリの使用例 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/nobuhito/items/ff782f64e32f7ed95e43&#34;&gt;Golangで文字コード判定 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:8c97bc776007d33febbab020a38c72f3:a&#34;&gt;「&lt;a href=&#34;http://text.baldanders.info/golang/string-and-rune/&#34;&gt;String と Rune&lt;/a&gt;」参照。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8c97bc776007d33febbab020a38c72f3:a&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8c97bc776007d33febbab020a38c72f3:b&#34;&gt;かつてパッケージの場所は &lt;code&gt;code.google.com/p/go.text/transform&lt;/code&gt; および &lt;code&gt;code.google.com/p/go.text/encoding/japanese&lt;/code&gt; だったが，ここの repository は今は存在しないので注意。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8c97bc776007d33febbab020a38c72f3:b&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8c97bc776007d33febbab020a38c72f3:c&#34;&gt;もちろんこれは Windows のコマンドプロンプトで動かした場合の話。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8c97bc776007d33febbab020a38c72f3:c&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>文字列連結はどれが速い？ - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/join-strings/" />
		<id>tag:text.Baldanders.info,2015-09-21T23:08:07+0900:/golang/join-strings/</id>
		<published>2015-09-21T23:08:07+0900</published>
		<updated>2015-09-23T20:00:00+0900</updated>
		<summary>Go 言語で文字列の連結を行う際にどうやるのが一番速いか，という話。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/16ab7dabbd0749281227&#34;&gt;Golang の文字列連結はどちらが速い？ - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/string-and-rune/&#34; title=&#34;String と Rune&#34;&gt;前回&lt;/a&gt;につづき &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; の話題。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で文字列の連結を行う際にどうやるのが一番速いか，という話。&lt;/p&gt;

&lt;h2 id=&#34;文字列連結を行う4つの方法:53cbada6770de764fdec60b0362267fb&#34;&gt;文字列連結を行う4つの方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で文字列の連結を行う際には概ね以下の4つの方法がある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;“&lt;code&gt;+&lt;/code&gt;” 演算子で連結する&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://golang.org/pkg/strings/&#34;&gt;&lt;code&gt;strings&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.Join&lt;/code&gt; で連結する&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://golang.org/pkg/bytes/&#34;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.Buffer&lt;/code&gt; に追記する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]byte&lt;/code&gt; に &lt;code&gt;append&lt;/code&gt; する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; は「不変（immutable）」なので，最初の2つが高コストになるだろうことはすぐに想像がつく。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/ruiu/items/2bb83b29baeae2433a79&#34;&gt;Goでは文字列連結はコストの高い操作 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://atotto.hatenadiary.jp/entry/2013/04/26/202701&#34;&gt;Go言語で効率良く文字列を連結する話 #golang - memoメモ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;では残りの2つはどうなのかというと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/ono_matope/items/d5e70d8a9ff2b54d5c37&#34;&gt;Goの文字列結合のパフォーマンス - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;によると最後のが一番速いらしい。ほんじゃまぁ，確かめてみるか。&lt;/p&gt;

&lt;h2 id=&#34;サンプルコードを用意:53cbada6770de764fdec60b0362267fb&#34;&gt;サンプルコードを用意&lt;/h2&gt;

&lt;p&gt;以下のコード &lt;code&gt;join.go&lt;/code&gt; を使って評価してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;bytes&amp;quot;
	&amp;quot;io&amp;quot;
)

//Read content (text data) from buffer
func ContentText(inStream io.Reader) ([]string, error) {
	scanner := bufio.NewScanner(inStream)
	list := make([]string, 0)
	for scanner.Scan() {
		list = append(list, scanner.Text())
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}
	return list, nil
}

//Write content (text data) to buffer
func WriteBuffer1(lines []string) []byte {
	//write to byte buffer
	content := make([]byte, 0)
	recode := &amp;quot;\r\n&amp;quot;
	for _, line := range lines {
		content = append(content, line...)
		content = append(content, recode...)
	}
	return content
}

//Write content (text data) to buffer
func WriteBuffer1Cap128(lines []string) []byte {
	//write to byte buffer
	content := make([]byte, 0, 128) //128 bytes capacity
	recode := &amp;quot;\r\n&amp;quot;
	for _, line := range lines {
		content = append(content, line...)
		content = append(content, recode...)
	}
	return content
}

//Write content (text data) to buffer
func WriteBuffer1Cap1K(lines []string) []byte {
	//write to byte buffer
	content := make([]byte, 0, 1024) //1K bytes capacity
	recode := &amp;quot;\r\n&amp;quot;
	for _, line := range lines {
		content = append(content, line...)
		content = append(content, recode...)
	}
	return content
}

//Write content (text data) to buffer (buffered I/O)
func WriteBuffer2(lines []string) []byte {
	//write to byte buffer
	content := bytes.NewBuffer(make([]byte, 0))
	recode := &amp;quot;\r\n&amp;quot;
	for _, line := range lines {
		content.WriteString(line)
		content.WriteString(recode)
	}
	return content.Bytes()
}

//Write content (text data) to buffer (buffered I/O)
func WriteBuffer2Cap128(lines []string) []byte {
	//write to byte buffer
	content := bytes.NewBuffer(make([]byte, 0, 128)) //128 bytes capacity
	recode := &amp;quot;\r\n&amp;quot;
	for _, line := range lines {
		content.WriteString(line)
		content.WriteString(recode)
	}
	return content.Bytes()
}

//Write content (text data) to buffer (buffered I/O)
func WriteBuffer2Cap1K(lines []string) []byte {
	//write to byte buffer
	content := bytes.NewBuffer(make([]byte, 0, 1024)) //1K bytes capacity
	recode := &amp;quot;\r\n&amp;quot;
	for _, line := range lines {
		content.WriteString(line)
		content.WriteString(recode)
	}
	return content.Bytes()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テストコード &lt;code&gt;join_test.go&lt;/code&gt; はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;os&amp;quot;
	&amp;quot;testing&amp;quot;
)

func readFile() []string {
	file, err := os.Open(&amp;quot;CollisionsForHashFunctions.txt&amp;quot;) //maybe file path
	if err != nil {
		panic(err)
	}
	defer file.Close()
	list, err := ContentText(file)
	if err != nil {
		panic(err)
	}
	return list
}

func BenchmarkWriteBuffer1(b *testing.B) {
	list := readFile()
	b.ResetTimer()
	for i := 0; i &amp;lt; b.N; i++ {
		content := WriteBuffer1(list)
		_ = string(content)
	}
}

func BenchmarkWriteBuffer1Cap128(b *testing.B) {
	list := readFile()
	b.ResetTimer()
	for i := 0; i &amp;lt; b.N; i++ {
		content := WriteBuffer1Cap128(list)
		_ = string(content)
	}
}

func BenchmarkWriteBuffer1Cap1K(b *testing.B) {
	list := readFile()
	b.ResetTimer()
	for i := 0; i &amp;lt; b.N; i++ {
		content := WriteBuffer1Cap1K(list)
		_ = string(content)
	}
}

func BenchmarkWriteBuffer2(b *testing.B) {
	list := readFile()
	b.ResetTimer()
	for i := 0; i &amp;lt; b.N; i++ {
		content := WriteBuffer2(list)
		_ = string(content)
	}
}

func BenchmarkWriteBuffer2Cap128(b *testing.B) {
	list := readFile()
	b.ResetTimer()
	for i := 0; i &amp;lt; b.N; i++ {
		content := WriteBuffer2Cap128(list)
		_ = string(content)
	}
}

func BenchmarkWriteBuffer2Cap1K(b *testing.B) {
	list := readFile()
	b.ResetTimer()
	for i := 0; i &amp;lt; b.N; i++ {
		content := WriteBuffer2Cap1K(list)
		_ = string(content)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のテストについては&lt;a href=&#34;http://text.baldanders.info/golang/testing/&#34;&gt;以前紹介した&lt;/a&gt;が，同じ要領で &lt;code&gt;Benchmark&lt;/code&gt; から始まる名前の関数を作るとベンチマーク用のコードとして認識される。
引数には &lt;code&gt;b *testing.B&lt;/code&gt; を指定する。&lt;/p&gt;

&lt;p&gt;ベンチマークの内訳は以下のとおり。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;ベンチマーク名&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;処理内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;BenchmarkWriteBuffer1&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;http://golang.org/pkg/bytes/&#34;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.Buffer&lt;/code&gt; に追記する&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;BenchmarkWriteBuffer1Cap128&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;http://golang.org/pkg/bytes/&#34;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.Buffer&lt;/code&gt; に追記する（ capacity 128B）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;BenchmarkWriteBuffer1Cap1K&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;http://golang.org/pkg/bytes/&#34;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.Buffer&lt;/code&gt; に追記する（ capacity 1KB）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;BenchmarkWriteBuffer2&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;[]byte&lt;/code&gt; に &lt;code&gt;append&lt;/code&gt; する&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;BenchmarkWriteBuffer2Cap128&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;[]byte&lt;/code&gt; に &lt;code&gt;append&lt;/code&gt; する（ capacity 128B）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;BenchmarkWriteBuffer2Cap1K&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;[]byte&lt;/code&gt; に &lt;code&gt;append&lt;/code&gt; する（ capacity 1KB）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;入力テキストだが，小さいファイルではテストにならない気がしたので，大昔に書いたテキスト &lt;a href=&#34;http://www.baldanders.info/spiegel/archive/CollisionsForHashFunctions.txt&#34;&gt;&lt;code&gt;CollisionsForHashFunctions.txt&lt;/code&gt;&lt;/a&gt; を使うことにした。
サイズは70行，7KB ほど。&lt;/p&gt;

&lt;h2 id=&#34;テスト結果:53cbada6770de764fdec60b0362267fb&#34;&gt;テスト結果&lt;/h2&gt;

&lt;p&gt;結果は以下のとおり。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go test -bench WriteBuffer -benchmem
testing: warning: no tests to run
PASS
BenchmarkWriteBuffer1-8           100000         17831 ns/op       37056 B/op     12 allocs/op
BenchmarkWriteBuffer1Cap128-8     100000         20321 ns/op       36992 B/op     11 allocs/op
BenchmarkWriteBuffer1Cap1K-8      100000         19301 ns/op       36096 B/op      8 allocs/op
BenchmarkWriteBuffer2-8           100000         17300 ns/op       33760 B/op     10 allocs/op
BenchmarkWriteBuffer2Cap128-8     100000         19451 ns/op       34992 B/op      9 allocs/op
BenchmarkWriteBuffer2Cap1K-8      100000         15490 ns/op       25712 B/op      6 allocs/op
ok      join    12.659s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ありゃりゃ。 &lt;a href=&#34;http://golang.org/pkg/bytes/&#34;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.Buffer&lt;/code&gt; を使ったほうが速いみたい（capacity を大きくとれば）。&lt;/p&gt;

&lt;p&gt;それなら，入力テキストを切り詰めて10行，0.3KB にしてやってみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go test -bench WriteBuffer -benchmem
testing: warning: no tests to run
PASS
BenchmarkWriteBuffer1-8          2000000           859 ns/op        1312 B/op      5 allocs/op
BenchmarkWriteBuffer1Cap128-8    2000000           707 ns/op        1248 B/op      4 allocs/op
BenchmarkWriteBuffer1Cap1K-8     2000000           796 ns/op        1376 B/op      2 allocs/op
BenchmarkWriteBuffer2-8          1000000          1686 ns/op        1600 B/op      6 allocs/op
BenchmarkWriteBuffer2Cap128-8    1000000          1411 ns/op        1680 B/op      5 allocs/op
BenchmarkWriteBuffer2Cap1K-8     2000000           980 ns/op        1488 B/op      3 allocs/op
ok      join    13.589s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今度は &lt;code&gt;[]byte&lt;/code&gt; の方が速くなった。&lt;/p&gt;

&lt;p&gt;まぁでも予想通りかな。
データのサイズが大きくなればバッファ操作のほうが有利になるのは分かりやすいっちゃあ分かりやすい。&lt;/p&gt;

&lt;p&gt;注目すべきは &lt;code&gt;BenchmarkWriteBuffer1Cap128&lt;/code&gt; と &lt;code&gt;BenchmarkWriteBuffer1Cap1K&lt;/code&gt; で， capacity を 1KB 取ったほうが若干遅くなっている。この辺のチューニングをどうするか，というところなのだろう（実はこれ，環境によって微妙に順位が変わるんだよなぁ）。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:53cbada6770de764fdec60b0362267fb&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/20131123/1385189088&#34;&gt;Go でベンチマーク - Block Rockin’ Codes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/Mulyu/items/ed585f2777496f29a725&#34;&gt;go言語でベンチマーク - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>String と Rune - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/string-and-rune/" />
		<id>tag:text.Baldanders.info,2015-09-19T23:45:56+0900:/golang/string-and-rune/</id>
		<published>2015-09-19T23:45:56+0900</published>
		<updated>2015-09-23T20:01:00+0900</updated>
		<summary>今回は文字列について。短めにさくっと。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/556166b6631c0369754f&#34;&gt;はじめての Go 言語 (on Windows) その4 - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;文字列を示す &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; は不変（immutable）なオブジェクトだが，中身は byte 配列である。
したがって以下のように&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;
	size := len(nihongo)

	fmt.Printf(&amp;quot;nihongo = %d bytes :&amp;quot;, size)
	for i := 0; i &amp;lt; size; i++ {
		fmt.Printf(&amp;quot; %x&amp;quot;, nihongo[i])
	}
	fmt.Print(&amp;quot;\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; をダンプすると以下の結果になる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:22aba2fd29e0e069728fb8201971f262:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:22aba2fd29e0e069728fb8201971f262:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run string01.go
nihongo = 9 bytes : e6 97 a5 e6 9c ac e8 aa 9e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; なんて名前なのに）文字単位で情報を保持しているわけではないため，最初の2文字を取り出すつもりでうっかり&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;

	fmt.Printf(&amp;quot;nihongo = %s\n&amp;quot;, nihongo)
	fmt.Printf(&amp;quot;nippon = %s\n&amp;quot;, nihongo[:2])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんてなコードを書くと以下の結果になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run string02.go
nihongo = 日本語
nippon = ��
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文字列を文字単位で扱うには &lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; を使う。
いや，ルーンってどんだけ厨二&amp;hellip; ゲフンゲフン。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;
	nihongoRune := []rune(nihongo)
	size := len(nihongoRune)

	fmt.Printf(&amp;quot;nihongo = %d characters : &amp;quot;, size)
	for i := 0; i &amp;lt; size; i++ {
		fmt.Printf(&amp;quot;%#U &amp;quot;, nihongoRune[i])
	}
	fmt.Printf(&amp;quot;\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:&amp;gt;go run string03.go
nihongo = 3 characters : U+65E5 &#39;日&#39; U+672C &#39;本&#39; U+8A9E &#39;語&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;または， &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; に対して &lt;a href=&#34;http://golang.org/ref/spec#For_statements&#34;&gt;for range 構文&lt;/a&gt;を使ってループを回すと文字（&lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt;）単位で取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;

	for pos, runeValue := range nihongo {
		fmt.Printf(&amp;quot;%#U starts at byte position %d\n&amp;quot;, runeValue, pos)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:&amp;gt;go run string03b.go
U+65E5 &#39;日&#39; starts at byte position 0
U+672C &#39;本&#39; starts at byte position 3
U+8A9E &#39;語&#39; starts at byte position 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; の実体は int32 で，内部表現は Unicode になっている。
&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; と &lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; 配列は相互変換できるので，文字列を切り取る場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;

	fmt.Printf(&amp;quot;nihongo = %s\n&amp;quot;, nihongo)
	fmt.Printf(&amp;quot;nippon = %s\n&amp;quot;, string([]rune(nihongo)[:2]))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; → []&lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; → &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; と変換していけば安全に処理できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run string02b.go
nihongo = 日本語
nippon = 日本
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう少し細かい処理が必要なら &lt;a href=&#34;http://golang.org/pkg/unicode/utf8/&#34;&gt;&lt;code&gt;unicode/utf8&lt;/code&gt;&lt;/a&gt; パッケージを使う手もある&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:22aba2fd29e0e069728fb8201971f262:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:22aba2fd29e0e069728fb8201971f262:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:22aba2fd29e0e069728fb8201971f262&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.golang.org/strings&#34;&gt;Strings, bytes, runes and characters in Go - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://knightso.hateblo.jp/entry/2014/06/24/090719&#34;&gt;Go言語のstring, runeの正体とは？ - golang - The Round&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/hokaccha/items/3d3f45b5927b4584dbac&#34;&gt;golang - Goでマルチバイトが混在した文字列をtruncateする - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:22aba2fd29e0e069728fb8201971f262:1&#34;&gt;ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で取り扱う文字列の文字エンコーディングは UTF-8 が既定である。他の文字エンコーディングで書かれた文字列を扱うには，一度 UTF-8 に変換する処理が必要になる。文字エンコーディングの変換については&lt;a href=&#34;http://text.baldanders.info/golang/transform-character-encoding/&#34;&gt;別の記事&lt;/a&gt;で改めて紹介する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:22aba2fd29e0e069728fb8201971f262:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:22aba2fd29e0e069728fb8201971f262:2&#34;&gt;ちなみに &lt;a href=&#34;http://golang.org/pkg/strings/&#34;&gt;&lt;code&gt;strings&lt;/code&gt;&lt;/a&gt; パッケージは内部で &lt;a href=&#34;http://golang.org/pkg/unicode/utf8/&#34;&gt;&lt;code&gt;unicode/utf8&lt;/code&gt;&lt;/a&gt; パッケージを使っているようだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:22aba2fd29e0e069728fb8201971f262:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Go 言語のドキュメント・フレームワーク - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/document/" />
		<id>tag:text.Baldanders.info,2015-09-19T23:43:25+0900:/golang/document/</id>
		<published>2015-09-19T23:43:25+0900</published>
		<updated>2015-09-23T19:57:00+0900</updated>
		<summary>パッケージ化したのならドキュメントを書きましょう。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/5f9e96f226f46089388f&#34;&gt;はじめての Go 言語 (on Windows) その8 - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/testing/&#34; title=&#34;Go 言語のテスト・フレームワーク&#34;&gt;前回&lt;/a&gt;の続き。
パッケージ化したのならドキュメントを書きましょう。&lt;/p&gt;

&lt;h2 id=&#34;godoc-のインストール:7445d9e511c27034085e252d0df49931&#34;&gt;godoc のインストール&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://godoc.org/golang.org/x/tools/cmd/godoc&#34; title=&#34;godoc - GoDoc&#34;&gt;&lt;code&gt;godoc&lt;/code&gt;&lt;/a&gt; は &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のドキュメント化ツールです。
&lt;code&gt;go get&lt;/code&gt; コマンドで導入できます。（&lt;code&gt;go get&lt;/code&gt; コマンドについては「&lt;a href=&#34;http://text.baldanders.info/golang/go-get-package/&#34;&gt;go get コマンドでパッケージを管理する&lt;/a&gt;」を参照）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;mkdir C:\workspace\godoc

C:&amp;gt;cd C:\workspace\godoc

C:\workspace\godoc&amp;gt;SET GOPATH=C:\workspace\godoc

C:\workspace\godoc&amp;gt;go get -v golang.org/x/tools/cmd/godoc
Fetching https://golang.org/x/tools/cmd/godoc?go-get=1
Parsing meta tags from https://golang.org/x/tools/cmd/godoc?go-get=1 (status code 200)
get &amp;quot;golang.org/x/tools/cmd/godoc&amp;quot;: found meta tag main.metaImport{Prefix:&amp;quot;golang.org/x/tools&amp;quot;, VCS:&amp;quot;git&amp;quot;, RepoRoot:&amp;quot;https://go.googlesource.com/tools&amp;quot;} at https://golang.org/x/tools/cmd/godoc?go-get=1
get &amp;quot;golang.org/x/tools/cmd/godoc&amp;quot;: verifying non-authoritative meta tag
Fetching https://golang.org/x/tools?go-get=1
Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200)
golang.org/x/tools (download)
golang.org/x/tools/blog/atom
golang.org/x/tools/present
golang.org/x/tools/go/ast/astutil
golang.org/x/tools/go/exact
golang.org/x/tools/go/buildutil
golang.org/x/tools/go/types
golang.org/x/tools/container/intsets
golang.org/x/tools/blog
golang.org/x/tools/godoc/vfs
golang.org/x/tools/godoc/redirect
golang.org/x/tools/godoc/static
golang.org/x/tools/playground
golang.org/x/tools/godoc/util
golang.org/x/tools/go/types/typeutil
golang.org/x/tools/go/loader
golang.org/x/tools/godoc/vfs/httpfs
golang.org/x/tools/godoc/vfs/gatefs
golang.org/x/tools/godoc/vfs/mapfs
golang.org/x/tools/godoc/vfs/zipfs
golang.org/x/tools/go/ssa
golang.org/x/tools/go/callgraph
golang.org/x/tools/go/ssa/ssautil
golang.org/x/tools/go/pointer
golang.org/x/tools/godoc/analysis
golang.org/x/tools/godoc
golang.org/x/tools/cmd/godoc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに &lt;code&gt;godoc&lt;/code&gt; の実行モジュールは &lt;code&gt;%GOPATH\bin&lt;/code&gt; フォルダではなく &lt;code&gt;%GOROOT%\bin&lt;/code&gt; フォルダに格納されます。
これで&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;godoc time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とかやるとパッケージ（この場合は &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; パッケージ）のドキュメントが表示されるのですが，さすがにコマンドプロンプトでこれを見るのは辛いので， HTTP サービスを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;godoc -http=&amp;quot;:3000&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでブラウザで &lt;a href=&#34;http://localhost:3000/&#34;&gt;http://localhost:3000/&lt;/a&gt; にアクセスするとドキュメントを見ることができます。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;https://www.flickr.com/photos/spiegel/18026303435/&#34;&gt;&lt;img src=&#34;https://farm9.staticflickr.com/8788/18026303435_7b136c64bb.jpg&#34; alt=&#34;godoc&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/18026303435/&#34;&gt;godoc&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;p&gt;たとえば &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; パッケージはこんなふうに表示されます。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;https://www.flickr.com/photos/spiegel/18023061102/&#34;&gt;&lt;img src=&#34;https://farm9.staticflickr.com/8847/18023061102_e5474f1ddc.jpg&#34; alt=&#34;godoc: time package&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/18023061102/&#34;&gt;godoc: time package&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;p&gt;本家サイトと同じですね。&lt;/p&gt;

&lt;h3 id=&#34;godoc-で-modjulian-パッケージを見てみる:7445d9e511c27034085e252d0df49931&#34;&gt;godoc で modjulian パッケージを見てみる&lt;/h3&gt;

&lt;p&gt;「&lt;a href=&#34;http://text.baldanders.info/golang/packaging/&#34;&gt;機能のパッケージ化&lt;/a&gt;」で作った &lt;a href=&#34;https://github.com/spiegel-im-spiegel/astrocalc&#34;&gt;&lt;code&gt;github.com/spiegel-im-spiegel/astrocalc&lt;/code&gt;&lt;/a&gt;&lt;code&gt;/modjulian&lt;/code&gt; はどうなっているでしょう。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;https://www.flickr.com/photos/spiegel/18023689372/&#34;&gt;&lt;img src=&#34;https://farm9.staticflickr.com/8831/18023689372_08795d4e8e.jpg&#34; alt=&#34;godoc: package list&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/18023689372/&#34;&gt;godoc: package list&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;https://www.flickr.com/photos/spiegel/17839022348/&#34;&gt;&lt;img src=&#34;https://farm9.staticflickr.com/8835/17839022348_4315878c95.jpg&#34; alt=&#34;godoc: modjulian package&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/17839022348/&#34;&gt;godoc: modjulian package&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;p&gt;全くコメントがないので，さすがに一覧には何もないですが，個別ページには最小限の情報が載っています。凄いなぁ。&lt;/p&gt;

&lt;h2 id=&#34;modjulian-パッケージにドキュメント用のコメントを追記する:7445d9e511c27034085e252d0df49931&#34;&gt;modjulian パッケージにドキュメント用のコメントを追記する&lt;/h2&gt;

&lt;p&gt;では，ソースコードを少しいじってドキュメント用のコードを追記してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Astronomical calculation for Golang.
 * These codes are licensed under CC0.
 * http://creativecommons.org/publicdomain/zero/1.0/deed.ja
 */

// modjulian パッケージは
// 修正ユリウス日（Modified Julian Date）の計算を行います。
package modjulian

import &amp;quot;time&amp;quot;

// DayNumber は
// 日付から修正ユリウス通日を取得します。
//
//   t := time.Date(2015, 1, 1, 0, 0, 0, 0, time.UTC)
//   fmt.Print(modjulian.DayNumber(t)) //57023
//
// 時刻（時分秒）は無視します。
// 1970年1月1日以前のグレゴリオ暦では Fliegel の公式を使って計算します。
// 1970年1月1日以降は UNIX Time を用いて通日を取得します。
func DayNumber(t time.Time) int64 {
	if t.Sub(time.Unix(0, 0)) &amp;gt;= 0 {
		return dnUnix(t)
	} else {
		return dnGregorian(t)
	}
}

// dnGregorian は
// Fliegel の公式を使い，日付から修正ユリウス通日を計算します。
//
// 時刻（時分秒）は無視します。
func dnGregorian(t time.Time) int64 {
	y := int64(t.Year())
	m := int64(t.Month())
	if m &amp;lt; 3 {
		y -= 1
		m += 9
	} else {
		m -= 3
	}
	d := int64(t.Day()) - 1
	return (1461*y)/4 + y/400 - y/100 + (153*m+2)/5 + d - 678881
}

// dnUnix は
// UNIX Time で1970年1月1日からの通日を取得し，修正ユリウス通日を計算します。
//
// 時刻（時分秒）は無視します。
// 1970年1月1日以前の日付では正しく計算できません。
func dnUnix(t time.Time) int64 {
	const (
		onday   = int64(86400) //seconds
		baseDay = int64(40587) //Modified Julian Date at January 1, 1970
	)
	return (t.Unix())/onday + baseDay
}
&lt;/code&gt;&lt;/pre&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;https://www.flickr.com/photos/spiegel/18002607746/&#34;&gt;&lt;img src=&#34;https://farm8.staticflickr.com/7732/18002607746_9990483503.jpg&#34; alt=&#34;godoc: package list&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/18002607746/&#34;&gt;godoc: package list&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;https://www.flickr.com/photos/spiegel/17408544863/&#34;&gt;&lt;img src=&#34;https://farm9.staticflickr.com/8897/17408544863_f0f5649e32.jpg&#34; alt=&#34;godoc: modjulian 2&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/17408544863/&#34;&gt;godoc: modjulian 2&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;p&gt;日本語ですみません。
英語不得手なもので。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;パッケージのコメントは &lt;code&gt;package&lt;/code&gt; 指定の直前のコメントが有効になる。（ファイル先頭のコメントは反映されない）&lt;/li&gt;
&lt;li&gt;パッケージリストの説明はパッケージ・コメントの最初の1文のみ表示される（日本語の句読点も理解しているらしい）&lt;/li&gt;
&lt;li&gt;関数等のコメントはそれぞれの記述の直前のコメントが有効になる。&lt;/li&gt;
&lt;li&gt;基本的に改行は無視される。ただし空行があれば別のパラグラフと理解しているようだ。&lt;/li&gt;
&lt;li&gt;空白文字2文字のインデントでコード記述領域（HTML 的には &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; 要素）とみなしているらしい。コードを書く必要はないけど。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上の例では説明のためにコメント内にサンプルコードを載せましたが，サンプルコードを記述するのであればもっとスマートな方法があります。
それはテストにサンプルコードを含める方法です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package modjulian_test

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/astrocalc/modjulian&amp;quot;
)

func ExampleDayNumber() {
	t := time.Date(2015, 1, 1, 0, 0, 0, 0, time.UTC)
	fmt.Print(modjulian.DayNumber(t))
	// Output:
	// 57023
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようなテスト &lt;code&gt;example_test.go&lt;/code&gt; を作ると，ドキュメントが以下のようになります。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;https://www.flickr.com/photos/spiegel/17843944479/&#34;&gt;&lt;img src=&#34;https://farm6.staticflickr.com/5327/17843944479_024f2f4073.jpg&#34; alt=&#34;godoc: modjulian 3&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/17843944479/&#34;&gt;godoc: modjulian 3&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;p&gt;もちろん，テストもできます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\workspace\jd&amp;gt;go test -v github.com/spiegel-im-spiegel/astrocalc/modjulian
=== RUN   TestDayNumber
--- PASS: TestDayNumber (0.00s)
=== RUN   ExampleDayNumber
--- PASS: ExampleDayNumber (0.00s)
PASS
ok      github.com/spiegel-im-spiegel/astrocalc/modjulian       2.755s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この仕組みを使えばサンプルコードを常に最新の仕様にマッチさせることが可能になります。
プログラマにとってドキュメントで一番欲しいのはサンプルコードなので，サンプルコードさえ正しければ，他はそれほど詳細に書かなくても推測できます。
そういう意味で，このようなテストと連動したドキュメント・フレームワークはなかなかおもしろいと思います。&lt;/p&gt;

&lt;h2 id=&#34;bookmark:7445d9e511c27034085e252d0df49931&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/megu_ma/items/2066aef2f8c7f0ce2cc3&#34;&gt;Go で godoc を使えるようにする〜godoc のインストール〜 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2014/05/26/go-code-review/&#34;&gt;Go言語のコードレビュー | SOTA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://papaeye.tumblr.com/post/92328649161/go&#34;&gt;Go コードのレビュー時によくされるコメント - build error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/taknb2nch/20131101/1383285018&#34;&gt;testingパッケージのExamplesについて - taknb2nchのメモ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://swdyh.tumblr.com/post/55771477125/go-example&#34;&gt;GoのExampleテストが便利 : swdyh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/taknb2nch/20140225/1393302743&#34;&gt;godoc.org への掲載方法を調べた - taknb2nchのメモ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Go 言語のテスト・フレームワーク - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/testing/" />
		<id>tag:text.Baldanders.info,2015-09-19T23:40:43+0900:/golang/testing/</id>
		<published>2015-09-19T23:40:43+0900</published>
		
		<summary>パッケージ化したのならテストをしましょう。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/64224f22ef17d916dc2d&#34;&gt;はじめての Go 言語 (on Windows) その7 - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/packaging/&#34; title=&#34;機能のパッケージ化&#34;&gt;前回&lt;/a&gt;の続き。&lt;/p&gt;

&lt;h2 id=&#34;テストコードを書く:3047d71ccf1370a2898eb92c70273f56&#34;&gt;テストコードを書く&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では最初からテスト・フレームワークが同梱されています。
いまどきの言語はみんなそうですよね。
テストコードを書くには対象のソースファイルと同じフォルダに &lt;code&gt;*_test.go&lt;/code&gt; という名前のファイルを用意します。
まぁ，説明するより書いた方が早いですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package modjulian

import (
	&amp;quot;os&amp;quot;
	&amp;quot;testing&amp;quot;
	&amp;quot;time&amp;quot;
)

type mjdnTest struct { //test case for DayNumber
	in time.Time //input data
	out int64 //expected result
}

var mjdnTests []mjdnTest  //test cases for DayNumber

func TestMain(m *testing.M) {
	//initialization
 	mjdnTests = []mjdnTest {  //test cases for DayNumber
		{time.Date(1969, 12, 31, 0, 0, 0, 0, time.UTC), int64(40586)},
		{time.Date(1970,  1,  1, 0, 0, 0, 0, time.UTC), int64(40587)},
		{time.Date(2015,  1,  1, 0, 0, 0, 0, time.UTC), int64(57023)},
	}

	//start test
    code := m.Run()

	//termination
    os.Exit(code)
}

func TestModifiedJulianDayNumber(t *testing.T) {
	for _, testCase := range mjdnTests {
		result := DayNumber(testCase.in)
		if result != testCase.out {
			t.Errorf(&amp;quot;DayNumber of \&amp;quot;%v\&amp;quot; = %d, want %d.&amp;quot;, testCase.in, result, testCase.out)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;package&lt;/code&gt; にはテスト対象のパッケージを指定します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import&lt;/code&gt; には &lt;a href=&#34;http://golang.org/pkg/testing/&#34;&gt;&lt;code&gt;testing&lt;/code&gt;&lt;/a&gt; パッケージを含めます。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Test...&lt;/code&gt; で始まる関数名がテスト実行用の関数です。引数には &lt;code&gt;t *testing.T&lt;/code&gt; を指定します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TestMain()&lt;/code&gt; は特別な関数です。テストの最初に呼び出され， &lt;code&gt;Run()&lt;/code&gt; で他のテスト関数群をキックします。引数には &lt;code&gt;m *testing.M&lt;/code&gt; を指定します。 &lt;code&gt;TestMain()&lt;/code&gt; 内で初期化や条件を変えたテストの繰り返しや後始末処理などを行うことができます。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/pkg/testing/&#34;&gt;&lt;code&gt;testing&lt;/code&gt;&lt;/a&gt; パッケージには，他の言語のテスト・フレームワークによくある &lt;a href=&#34;http://golang.jp/go_faq#assertions&#34;&gt;assertion 関数がありません&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3047d71ccf1370a2898eb92c70273f56:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3047d71ccf1370a2898eb92c70273f56:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。 &lt;a href=&#34;http://golang.jp/go_faq#testing_framework&#34;&gt;FAQ&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3047d71ccf1370a2898eb92c70273f56:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3047d71ccf1370a2898eb92c70273f56:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; によると&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一般的なテストフレームワークにおいて条件・制御・出力機構を持つ専用のミニ言語が用意される傾向がありますが、Go言語にはすでにこれらが備わっています。これらを再び作成するより、我々はGo言語のテストを進めたかったのです。このようにしたことで余計な言語を覚える必要がなくなり、テストを直接的かつ理解しやすくしています。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;とあります。
テスト駆動型開発の場合，テストコードはそれ自体が設計書として機能しますので，この割り切りは妥当と言えます&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3047d71ccf1370a2898eb92c70273f56:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3047d71ccf1370a2898eb92c70273f56:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
その代わりテストコードを（ドキュメントとして）きちんと書くのは骨が折れますが（笑）&lt;/p&gt;

&lt;p&gt;テストコードが書けたので早速動かしてみましょう。
環境は&lt;a href=&#34;http://text.baldanders.info/golang/packaging/&#34; title=&#34;機能のパッケージ化&#34;&gt;前回&lt;/a&gt;の最後の状態をそのまま引き継ぎます。&lt;/p&gt;

&lt;p&gt;テストを行うには &lt;code&gt;go test&lt;/code&gt; コマンドを使います。
以下の例ではパッケージを指定していますが， &lt;code&gt;./...&lt;/code&gt; と指定すれば全てのパッケージのテストが対象になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\workspace\jd&amp;gt;go test -v github.com/spiegel-im-spiegel/astrocalc/modjulian
=== RUN   TestDayNumber
--- PASS: TestDayNumber (0.00s)
PASS
ok      github.com/spiegel-im-spiegel/astrocalc/modjulian       0.229s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは成功例。じゃあ，&lt;a href=&#34;https://github.com/spiegel-im-spiegel/astrocalc/blob/master/modjulian/modjulian.go&#34;&gt;元のコード&lt;/a&gt;を少しいじってわざと失敗させてみましょうか（なんだかなぁ）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\workspace\jd&amp;gt;go test -v github.com/spiegel-im-spiegel/astrocalc/modjulian
=== RUN   TestDayNumber
--- FAIL: TestDayNumber (0.00s)
        modjulian_test.go:35: DayNumber of &amp;quot;1969-12-31 00:00:00 +0000 UTC&amp;quot; = 40587, want 40586.
FAIL
exit status 1
FAIL    github.com/spiegel-im-spiegel/astrocalc/modjulian       1.566s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーレポートを吐く &lt;code&gt;Errorf()&lt;/code&gt; は内部で &lt;code&gt;Fail()&lt;/code&gt; を呼び出し，テスト自体は続行します。
一方 &lt;code&gt;Errorf()&lt;/code&gt; の代わりに &lt;code&gt;Fatalf()&lt;/code&gt; を使うと，内部で &lt;code&gt;FailNow()&lt;/code&gt; を呼び出しテストを中断します。&lt;/p&gt;

&lt;p&gt;Go 言語のテスト・フレームワークでは benchmark や coverage もサポートしてますが，今回は割愛します。&lt;/p&gt;

&lt;h2 id=&#34;テストの自動化-continuous-integration:3047d71ccf1370a2898eb92c70273f56&#34;&gt;テストの自動化（Continuous Integration）&lt;/h2&gt;

&lt;p&gt;今回のコードは自動化するほどの規模でもないですが，話のついでに &lt;a href=&#34;https://travis-ci.org/&#34; title=&#34;Travis CI - Test and Deploy Your Code with Confidence&#34;&gt;Travis CI&lt;/a&gt; で自動化しちゃいましょう。
えっと，今回は &lt;a href=&#34;https://travis-ci.org/&#34; title=&#34;Travis CI - Test and Deploy Your Code with Confidence&#34;&gt;Travis CI&lt;/a&gt; の説明は割愛します。
興味のある方は「&lt;a href=&#34;http://text.baldanders.info/golang/packaging/&#34;&gt;ブックマーク&lt;/a&gt;」の項を参考にして下さい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/&#34; title=&#34;Travis CI - Test and Deploy Your Code with Confidence&#34;&gt;Travis CI&lt;/a&gt; でビルド・テストを行うためには &lt;code&gt;.travis.yml&lt;/code&gt; を書く必要がありますが，テストを行うだけなら &lt;code&gt;.travis.yml&lt;/code&gt; の記述は簡単です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;language: go

go:
  - 1.4
  - 1.5

script:
 - go test -v ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は&lt;a href=&#34;https://travis-ci.org/spiegel-im-spiegel/astrocalc&#34;&gt;ここ&lt;/a&gt;を参照して下さい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/document/&#34; title=&#34;Go 言語のドキュメント・フレームワーク&#34;&gt;次回&lt;/a&gt;はドキュメントの話。&lt;/p&gt;

&lt;h2 id=&#34;bookmark:3047d71ccf1370a2898eb92c70273f56&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/Jxck_/items/8717a5982547cfa54ebc&#34;&gt;Go の Test に対する考え方 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://straitwalk.hatenablog.com/entry/2014/09/18/232810&#34;&gt;Goでテストを書く - 成らぬは人の為さぬなりけり&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/umisama/items/0d589cca7e89b89c29a8&#34;&gt;golang 1.4で追加されたtestingの便利機能(テストの初期化とお片づけ) - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/dmnlk/items/3fb4e0abb98e39fee275&#34;&gt;Go + Travis CI + Coveralls でCI環境を作る - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sue445.hatenablog.com/entry/2013/06/01/170607&#34;&gt;GithubにあるリポジトリをTravis CI連携する手順 #junitbook - くりにっき&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2014/10/16/golang-in-ci-as-a-service/&#34;&gt;CI-as-a-ServiceでGo言語プロジェクトの最新ビルドを継続的に提供する | SOTA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://uchimanajet7.hatenablog.com/entry/2015/03/20/211352&#34;&gt;golangでTravis CIを使ってクロスコンパイルするときにハマったところ #golang #travisci - uchimanajet7のメモ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/atotto/items/b796c31c1755dbec13db&#34;&gt;Go言語のビルド生活を drone.ioで幸せに暮らす #golang - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:3047d71ccf1370a2898eb92c70273f56:1&#34;&gt;オリジナルは &lt;a href=&#34;http://golang-jp.org/doc/faq#assertions&#34;&gt;http://golang-jp.org/doc/faq#assertions&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3047d71ccf1370a2898eb92c70273f56:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3047d71ccf1370a2898eb92c70273f56:2&#34;&gt;オリジナルは &lt;a href=&#34;http://golang-jp.org/doc/faq#testing_framework&#34;&gt;http://golang-jp.org/doc/faq#testing_framework&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3047d71ccf1370a2898eb92c70273f56:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3047d71ccf1370a2898eb92c70273f56:3&#34;&gt;私は組み込みエンジニアなので，プログラミングで assert を多用するのは，エンジニアの怠慢だと思ってしまいます。まぁ，ベクタ・テーブルからゴリゴリ書くってのなら別ですが。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3047d71ccf1370a2898eb92c70273f56:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>機能のパッケージ化 - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/packaging/" />
		<id>tag:text.Baldanders.info,2015-09-19T22:41:30+0900:/golang/packaging/</id>
		<published>2015-09-19T22:41:30+0900</published>
		<updated>2015-09-21T10:43:00+0900</updated>
		<summary>今後のことを考えてパッケージ化の作業を行うことにします。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/404871d2bafd22bdbb90&#34;&gt;はじめての Go 言語 (on Windows) その6 - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/julian-day-number/&#34; title=&#34;「ユリウス日」で遊ぶ&#34;&gt;前回&lt;/a&gt;の続き。
なんだけど，今回はパッケージのお話。
ユリウス日の計算なんて簡単なので今まで &lt;code&gt;main()&lt;/code&gt; 関数の中にゴリゴリ書いてましたが，今後のことを考えて，これを使ってパッケージ化の作業を行うことにします。&lt;/p&gt;

&lt;h2 id=&#34;ユリウス日計算のパッケージ化:bf561d8ea0bbb40075d9094acab07703&#34;&gt;ユリウス日計算のパッケージ化&lt;/h2&gt;

&lt;p&gt;まずは，&lt;a href=&#34;http://text.baldanders.info/golang/julian-day-number/&#34; title=&#34;「ユリウス日」で遊ぶ&#34;&gt;前回&lt;/a&gt;のコードから計算処理部分をきちんと分離します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;time&amp;quot;
)

func ModifiedJulianDayNumber(t time.Time) int64 {
	if t.Sub(time.Unix(0, 0)) &amp;gt;= 0 {
		return mjdnUnix(t)
	} else {
		return mjdnGregorian(t)
	}
}

func mjdnGregorian(t time.Time) int64 {
	y := int64(t.Year())
	m := int64(t.Month())
	if m &amp;lt; 3 {
		y -= 1
		m += 9
	} else {
		m -= 3
	}
	d := int64(t.Day()) - 1
	return (1461*y)/4 + y/400 - y/100 + (153*m+2)/5 + d - 678881
}

func mjdnUnix(t time.Time) int64 {
	const (
		onday   = int64(86400) //seconds
		baseDay = int64(40587) //Modified Julian Date at January 1, 1970
	)
	return (t.Unix())/onday + baseDay
}

func main() {
	//引数のチェック
	flag.Parse()
	argsStr := flag.Args()
	if len(argsStr) &amp;lt; 3 {
		fmt.Fprintln(os.Stderr, &amp;quot;年月日を指定してください&amp;quot;)
		return
	}
	args := make([]int, 3)
	for i := 0; i &amp;lt; 3; i++ {
		num, err := strconv.Atoi(argsStr[i])
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			return
		} else {
			args[i] = num
		}
	}
	tm := time.Date(args[0], time.Month(args[1]), args[2], 0, 0, 0, 0, time.UTC)
	fmt.Printf(&amp;quot;%v\n&amp;quot;, tm)
	fmt.Printf(&amp;quot;MJD = %d日\n&amp;quot;, ModifiedJulianDayNumber(tm))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:&amp;gt;go run julian-day-4.go 1969 12 31
1969-12-31 00:00:00 +0000 UTC
MJD = 40586日

C:&amp;gt;go run julian-day-4.go 1970 1 1
1970-01-01 00:00:00 +0000 UTC
MJD = 40587日

C:&amp;gt;go run julian-day-4.go 2015 1 1
2015-01-01 00:00:00 +0000 UTC
MJD = 57023日
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ユリウス日の端数が鬱陶しいので修正ユリウス日の整数部分のみ計算しています。
あと1970年1月1日を境界として計算方法を変えています。
本当はユリウス暦の場合の計算も含めるべきなんでしょうけど，今回は割愛します。&lt;/p&gt;

&lt;p&gt;さて，上のコードのうち修正ユリウス日計算関数を別ファイルにしてパッケージ化します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package modjulian

import &amp;quot;time&amp;quot;

func DayNumber(t time.Time) int64 {
	if t.Sub(time.Unix(0, 0)) &amp;gt;= 0 {
		return dnUnix(t)
	} else {
		return dnGregorian(t)
	}
}

func dnGregorian(t time.Time) int64 {
	y := int64(t.Year())
	m := int64(t.Month())
	if m &amp;lt; 3 {
		y -= 1
		m += 9
	} else {
		m -= 3
	}
	d := int64(t.Day()) - 1
	return (1461*y)/4 + y/400 - y/100 + (153*m+2)/5 + d - 678881
}

func dnUnix(t time.Time) int64 {
	const (
		onday   = int64(86400) //seconds
		baseDay = int64(40587) //Modified Julian Date at January 1, 1970
	)
	return (t.Unix())/onday + baseDay
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パッケージ名は &lt;code&gt;modjulian&lt;/code&gt; としました。
ちなみにパッケージ内の関数等は名前の先頭が大文字のものだけが外部から参照可能です。&lt;/p&gt;

&lt;h3 id=&#34;go-言語における名前の問題:bf561d8ea0bbb40075d9094acab07703&#34;&gt;Go 言語における名前の問題&lt;/h3&gt;

&lt;p&gt;Go 言語およびそのコミュニティは名前にうるさいようです。
たとえば「&lt;a href=&#34;http://golang.jp/effective_go&#34;&gt;実践Go言語&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:bf561d8ea0bbb40075d9094acab07703:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:bf561d8ea0bbb40075d9094acab07703:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;」によると&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;慣例では，パッケージ名は小文字でひとつの単語です。アンダースコアや大文字が混ざって(mixedCaps)はいけません。パッケージ使用者がその名前をタイプすることを考慮して，簡潔すぎるぐらいにしてください。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;なんだそうで，本当はパッケージ名を &lt;code&gt;julianDate&lt;/code&gt; としたかったんだけど，それでは筋が悪いらしい。&lt;/p&gt;

&lt;p&gt;もうひとつ。&lt;/p&gt;

&lt;p&gt;もう一つの慣例は，パッケージ名がそのソースディレクトリのベース名であるということです。たとえば&lt;code&gt;src/pkg/encoding/base64&lt;/code&gt;に置かれているパッケージは，“&lt;code&gt;encoding/base64&lt;/code&gt;”としてインポートし，名前は&lt;code&gt;base64&lt;/code&gt;となります。&lt;code&gt;encoding_base64&lt;/code&gt;や&lt;code&gt;encodingBase64&lt;/code&gt;とはなりません。&lt;/p&gt;

&lt;p&gt;なのでパッケージの指定はハンガリアン記法とかではなく単語をディレクトリで区切って階層化することで整理できそうです。
これって Java とかに慣れてる人には比較的とっつきやすい仕組みかもしれません。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;長い名前は，慣れたとしても読みやすくなることはありません。複雑もしくは微妙なニュアンスを持つものに名前をつけるときは，すべての情報を名前で表現しようとするより，通常は役立つドキュメントコメントを書いたほうがよいでしょう。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;パッケージの配置と呼び出し:bf561d8ea0bbb40075d9094acab07703&#34;&gt;パッケージの配置と呼び出し&lt;/h2&gt;

&lt;p&gt;パッケージを呼び出すのには（標準のパッケージと同じく） &lt;code&gt;import&lt;/code&gt; を使えばいいのですが，記述によってパッケージをどこに配置するかが変わります。&lt;/p&gt;

&lt;p&gt;たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;./modjulian&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と相対パスで記述した場合は，呼び出し元のファイルの場所にある &lt;code&gt;modjulian&lt;/code&gt; フォルダを探します。
以下はパッケージが見つからなくてエラーになってる例です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\jd\src\julian-day-4b&amp;gt;go build julian-day-4b.go
julian-day-4b.go:10:2: open C:\workspace\jd\src\julian-day-4b\modjulian: The system cannot find the file specified.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一方&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;modjulian&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と記述した場合には，環境変数 &lt;code&gt;GOROOT&lt;/code&gt; および &lt;code&gt;GOPATH&lt;/code&gt; で指定されるフォルダ以下を探すようです。
以下もパッケージが見つからなくてエラーになってる例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\workspace\jd\src\julian-day-4b&amp;gt;go build julian-day-4b.go
julian-day-4b.go:10:2: cannot find package &amp;quot;modjulian&amp;quot; in any of:
        C:\Go\src\modjulian (from $GOROOT)
        C:\Gopath\src\modjulian (from $GOPATH)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;ではパッケージを相対パスで指定するのは（デバッグ時などを除いて）良くないと言われています。
これは &lt;code&gt;go get&lt;/code&gt; コマンドでパッケージをビルドする際，相対パスを解釈しないようにしているからのようです&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:bf561d8ea0bbb40075d9094acab07703:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:bf561d8ea0bbb40075d9094acab07703:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h3 id=&#34;パッケージを-github-上に配置する:bf561d8ea0bbb40075d9094acab07703&#34;&gt;パッケージを GitHub 上に配置する&lt;/h3&gt;

&lt;p&gt;「&lt;a href=&#34;http://text.baldanders.info/golang/go-get-package/&#34;&gt;go get コマンドでパッケージを管理する&lt;/a&gt;」でも紹介しましたが，インターネット上の repository にあるパッケージを&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;github.com/username/package&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように指定することで，任意に取り込むことが可能です。
そこで今回のパッケージを &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; 上に公開しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/astrocalc&#34;&gt;&lt;code&gt;github.com/spiegel-im-spiegel/astrocalc&lt;/code&gt;&lt;/a&gt;&lt;code&gt;/modjulian&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このパッケージを使って書いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/astrocalc/modjulian&amp;quot;
)

func main() {
	//引数のチェック
	flag.Parse()
	argsStr := flag.Args()
	if len(argsStr) &amp;lt; 3 {
		fmt.Fprintln(os.Stderr, &amp;quot;年月日を指定してください&amp;quot;)
		return
	}
	args := make([]int, 3)
	for i := 0; i &amp;lt; 3; i++ {
		num, err := strconv.Atoi(argsStr[i])
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			return
		} else {
			args[i] = num
		}
	}
	tm := time.Date(args[0], time.Month(args[1]), args[2], 0, 0, 0, 0, time.UTC)
	fmt.Printf(&amp;quot;%v\n&amp;quot;, tm)
	fmt.Printf(&amp;quot;MJD = %d日\n&amp;quot;, modjulian.DayNumber(tm))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このソースファイル &lt;code&gt;julian-day-4b.go&lt;/code&gt; と &lt;code&gt;modjulian&lt;/code&gt; パッケージを以下のように配置してビルドします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;SET GOPATH=C:\workspace\jd

C:&amp;gt;cd C:\workspace\jd

C:\workspace\jd&amp;gt;tree /f .
C:\WORKSPACE\JD
│
└─src
    └─julian-day-4b
            julian-day-4b.go

C:\workspace\jd&amp;gt;go get -v github.com/spiegel-im-spiegel/astrocalc/modjulian
github.com/spiegel-im-spiegel/astrocalc (download)
github.com/spiegel-im-spiegel/astrocalc/modjulian

C:\workspace\jd&amp;gt;go install ./...

C:\workspace\jd&amp;gt;tree /f .
C:\WORKSPACE\JD
│
├─bin
│      julian-day-4b.exe
│
├─pkg
│  └─windows_amd64
│      └─github.com
│          └─spiegel-im-spiegel
│              └─astrocalc
│                      modjulian.a
│
└─src
    ├─github.com
    │  └─spiegel-im-spiegel
    │      └─astrocalc
    │          │  .editorconfig
    │          │  .gitignore
    │          │  .travis.yml
    │          │  LICENSE
    │          │  README.md
    │          │
    │          └─modjulian
    │                  example_test.go
    │                  LICENSE
    │                  modjulian.go
    │                  modjulian_test.go
    │
    └─julian-day-4b
            julian-day-4b.go

C:\workspace\jd&amp;gt;bin\julian-day-4b.exe 1969 12 31
1969-12-31 00:00:00 +0000 UTC
MJD = 40586日

C:\workspace\jd&amp;gt;bin\julian-day-4b.exe 1970 1 1
1970-01-01 00:00:00 +0000 UTC
MJD = 40587日

C:\workspace\jd&amp;gt;bin\julian-day-4b.exe 2015 1 1
2015-01-01 00:00:00 +0000 UTC
MJD = 57023日
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まだまだ続くよ。
&lt;a href=&#34;http://text.baldanders.info/golang/testing/&#34; title=&#34;Go 言語のテスト・フレームワーク&#34;&gt;次回&lt;/a&gt;はテストについて。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:bf561d8ea0bbb40075d9094acab07703&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:bf561d8ea0bbb40075d9094acab07703:1&#34;&gt;オリジナルは “&lt;a href=&#34;https://golang.org/doc/effective_go.html&#34;&gt;Effective Go&lt;/a&gt;”
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:bf561d8ea0bbb40075d9094acab07703:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:bf561d8ea0bbb40075d9094acab07703:2&#34;&gt;これについてはいろいろな意見があるようですが，妥当な割り切りだと思います。特にコードを CI (Continuous Integration) によって管理している場合は重要なポイントです。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:bf561d8ea0bbb40075d9094acab07703:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>「ユリウス日」で遊ぶ - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/julian-day-number/" />
		<id>tag:text.Baldanders.info,2015-09-19T21:23:33+0900:/golang/julian-day-number/</id>
		<published>2015-09-19T21:23:33+0900</published>
		<updated>2015-09-21T11:43:51+0900</updated>
		<summary>今回は暦で遊びます。とりあえず，簡単なところで「ユリウス日」をいってみるか。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/e743d63ef5165d750eff&#34;&gt;はじめての Go 言語 (on Windows) その5 - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;今回は暦で遊びます。
とりあえず，簡単なところで「ユリウス日（Julian Date または Julian Day Number&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:dce87c312b9004de93da86b8c547be13:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:dce87c312b9004de93da86b8c547be13:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;）」をいってみるか。&lt;/p&gt;

&lt;h2 id=&#34;ユリウス日の定義:dce87c312b9004de93da86b8c547be13&#34;&gt;ユリウス日の定義&lt;/h2&gt;

&lt;p&gt;ユリウス日とは紀元前4713年1月1日正午&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:dce87c312b9004de93da86b8c547be13:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:dce87c312b9004de93da86b8c547be13:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; を起点とした通日のことです。
たとえば2015年1月1日零時はユリウス日では2,457,023.5日になります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://eco.mtk.nao.ac.jp/cgi-bin/koyomi/cande/date2jd.cgi&#34;&gt;ユリウス日&lt;/a&gt; （&lt;a href=&#34;http://eco.mtk.nao.ac.jp/koyomi/&#34;&gt;国立天文台暦計算室&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://homepage1.nifty.com/manome/astrology/julian.html&#34;&gt;ユリウス日(Julian Day)&lt;/a&gt; : 暦にまつわるエピソードを含めて参考になります&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tondering.dk/claus/cal/julperiod.php&#34;&gt;The Julian Period&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この際，いくつか気を付ける点があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;紀元前（BC）1年の翌年は紀元後（AD）1年。つまり AD1年を $1$ とするなら BC1年は $0$，BC2年は $-1$ となります。紀元前4713年は $-4712$ です。&lt;/li&gt;
&lt;li&gt;ユリウス暦は紀元前45年から開始されたと言われています。つまりそれ以前は異なる暦だったわけです。しかしユリウス日では紀元前45年より前の日付もユリウス暦と見なして取り扱います。&lt;/li&gt;
&lt;li&gt;欧州では西暦（紀元後）1582年に当時のローマ法王グレゴリオ13世によって（現在言われるところの）グレゴリオ暦が布告されましたが，この際に1582年10月4日の翌日を10月15日としたためギャップが生じました。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;年月日から-修正-ユリウス日を求める:dce87c312b9004de93da86b8c547be13&#34;&gt;年月日から（修正）ユリウス日を求める&lt;/h2&gt;

&lt;p&gt;というわけで大昔のユリウス日を求めるのは西暦を使う場合でもちょっと面倒くさいのですが，範囲をグレゴリオ暦に限るなら便利な式があります。&lt;/p&gt;

&lt;p&gt;グレゴリオ暦のある日を「$Y$ 年 $M$ 月 $D$ 日」で表せるとすると&lt;/p&gt;

&lt;blockquote&gt;
\begin{aligned}
    y   &amp; = Y + \left\lfloor \frac{M - 3}{12} \right\rfloor \\
    m   &amp; = \left( 12 + \left( M - 3 \right) \right) \bmod 12 \\
    d   &amp; = D - 1 \\
    MJD &amp; = \left\lfloor 365.25y \right\rfloor + \left\lfloor \frac{y}{400} \right\rfloor - \left\lfloor \frac{y}{100} \right\rfloor + \left\lfloor 30.60m + 0.5 \right\rfloor + d - 678881 \\
    JD  &amp; = MJD + 2400000.5
\end{aligned}
&lt;/blockquote&gt;

&lt;p&gt;でユリウス日 $JD $ を求めることができます&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:dce87c312b9004de93da86b8c547be13:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:dce87c312b9004de93da86b8c547be13:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:dce87c312b9004de93da86b8c547be13:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:dce87c312b9004de93da86b8c547be13:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:dce87c312b9004de93da86b8c547be13:5&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:dce87c312b9004de93da86b8c547be13:5&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;ちなみに $MJD$ は修正ユリウス日（Modified Julian Date）と呼ばれるものです。
定義は上の式の通りで，ユリウス日から240万日分をカットして日付の起点を正午から（私たちになじみのある）正子&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:dce87c312b9004de93da86b8c547be13:6&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:dce87c312b9004de93da86b8c547be13:6&#34;&gt;6&lt;/a&gt;&lt;/sup&gt; にずらしています。&lt;/p&gt;

&lt;p&gt;$ \left\lfloor x \right\rfloor $ は床関数と呼ばれるもので「実数 $x$ に対して $x$ 以下の最大の整数」と定義されます。
例えば&lt;/p&gt;

&lt;blockquote&gt;
\begin{aligned}
    \left\lfloor 1.0 \right\rfloor &amp; = 1 \\
    \left\lfloor 0.7 \right\rfloor &amp; = 0 \\
    \left\lfloor -0.5 \right\rfloor &amp; = -1 \\
    \left\lfloor -2.0 \right\rfloor &amp; = -2 \\
\end{aligned}
&lt;/blockquote&gt;

&lt;p&gt;となります。
単に小数点を取るだけではないということです。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の &lt;a href=&#34;http://golang.org/pkg/math/&#34;&gt;&lt;code&gt;math&lt;/code&gt;&lt;/a&gt; パッケージには，そのものずばりの &lt;code&gt;math.Floor()&lt;/code&gt; 関数があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
)

func main() {
	fmt.Printf(&amp;quot;[1.0] = %v\n&amp;quot;, math.Floor(1.0))
	fmt.Printf(&amp;quot;[0.7] = %v\n&amp;quot;, math.Floor(0.7))
	fmt.Printf(&amp;quot;[-0.5] = %v\n&amp;quot;, math.Floor(-0.5))
	fmt.Printf(&amp;quot;[-2.0] = %v\n&amp;quot;, math.Floor(-2.0))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run floor.go
[1.0] = 1
[0.7] = 0
[-0.5] = -1
[-2.0] = -2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では換算式を &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で実装してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
)

func main() {
	year := 2015
	month := 1
	day := 1
	fmt.Printf(&amp;quot;%v年%v月%v日\n\n&amp;quot;, year, month, day)

	mm := float64(month - 3)
	y := float64(year) + math.Floor(mm/12.0)
	m := math.Mod(12.0+mm, 12.0)
	d := float64(day - 1)
	fmt.Printf(&amp;quot;y = %f\n&amp;quot;, y)
	fmt.Printf(&amp;quot;m = %f\n&amp;quot;, m)
	fmt.Printf(&amp;quot;d = %f\n\n&amp;quot;, d)

	mjd := math.Floor(365.25*y) + math.Floor(y/400.0) - math.Floor(y/100.0) + math.Floor(30.60*m+0.5) + d - 678881.0
	fmt.Printf(&amp;quot;MJD = %f日\n&amp;quot;, mjd)
	fmt.Printf(&amp;quot;JD = %f日\n&amp;quot;, mjd+2400000.5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run julian-day-1.go
2015年1月1日

y = 2014.000000
m = 10.000000
d = 0.000000

MJD = 57023.000000日
JD = 2457023.500000日
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と，これではあまりにひどいので，少し変形。&lt;/p&gt;

&lt;p&gt;床関数は正の値に対しては小数点以下の切り捨てと同じ。
Go 言語では int 型の除算には int 型の結果が返り小数点以下が切り捨てられることを利用して&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	year := 2015
	month := 1
	day := 1
	fmt.Printf(&amp;quot;%v年%v月%v日\n\n&amp;quot;, year, month, day)

	y := 1
	m := 1
	if month &amp;lt; 3 {
		y = year - 1
		m = month + 9
	} else {
		y = year
		m = month - 3
	}
	d := day - 1
	fmt.Printf(&amp;quot;y = %d\n&amp;quot;, y)
	fmt.Printf(&amp;quot;m = %d\n&amp;quot;, m)
	fmt.Printf(&amp;quot;d = %d\n\n&amp;quot;, d)

	mjd := (1461*y)/4 + y/400 - y/100 + (153*m+2)/5 + d - 678881
	fmt.Printf(&amp;quot;MJD = %d日\n&amp;quot;, mjd)
	fmt.Printf(&amp;quot;JD = %f日\n&amp;quot;, float64(mjd)+2400000.5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run julian-day-2.go
2015年1月1日

y = 2014
m = 10
d = 0

MJD = 57023日
JD = 2457023.500000日
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これなら &lt;a href=&#34;http://golang.org/pkg/math/&#34;&gt;&lt;code&gt;math&lt;/code&gt;&lt;/a&gt; パッケージ自体不要になります。グレゴリオ暦は1582年より前では適用できない&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:dce87c312b9004de93da86b8c547be13:7&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:dce87c312b9004de93da86b8c547be13:7&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; のでこれで必要十分です。
以降で使いやすくするために，ここから更に変形して年月日を引数から取得するようにします（引数の Validation は省いています。ゴメンペコン）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
)

func main() {
	//引数のチェック
	flag.Parse()
	argsStr := flag.Args()
	if len(argsStr) &amp;lt; 3 {
		fmt.Fprintln(os.Stderr, &amp;quot;年月日を指定してください&amp;quot;)
		return
	}
	args := make([]int64, 3)
	for i := 0; i &amp;lt; 3; i++ {
		num, err := strconv.ParseInt(argsStr[i], 10, 64)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			return
		} else {
			args[i] = num
		}
	}
	fmt.Printf(&amp;quot;%v年%v月%v日\n\n&amp;quot;, args[0], args[1], args[2])

	y := args[0]
	m := args[1]
	if m &amp;lt; 3 {
		y -= 1
		m += 9
	} else {
		m -= 3
	}
	d := args[2] - 1
	fmt.Printf(&amp;quot;y = %d\n&amp;quot;, y)
	fmt.Printf(&amp;quot;m = %d\n&amp;quot;, m)
	fmt.Printf(&amp;quot;d = %d\n\n&amp;quot;, d)

	mjd := (1461*y)/4 + y/400 - y/100 + (153*m+2)/5 + d - 678881
	fmt.Printf(&amp;quot;MJD = %d日\n&amp;quot;, mjd)
	fmt.Printf(&amp;quot;JD = %f日\n&amp;quot;, float64(mjd)+2400000.5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:&amp;gt;go run julian-day-2b.go 2015 1 1
2015年1月1日

y = 2014
m = 10
d = 0

MJD = 57023日
JD = 2457023.500000日
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;unix-time-からユリウス日を求める:dce87c312b9004de93da86b8c547be13&#34;&gt;UNIX Time からユリウス日を求める&lt;/h2&gt;

&lt;p&gt;さて，これでグレゴリオ暦の任意の日付からユリウス日を求めることができるようになりました。
これを踏まえて，もう少し簡単にユリウス日を得る方法を考えてみます。&lt;/p&gt;

&lt;p&gt;Go 言語で時刻情報を取得・操作するために &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; パッケージが用意されています。
&lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; パッケージをつらつら眺めてみると &lt;code&gt;Unix()&lt;/code&gt; 関数を使って UNIX Time を得ることができるようです。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ということは，1970年1月1日零時 UTC のユリウス日が分かれば，そこを起点に UNIX Time を加算すればいいことになります。
簡単！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run julian-day-2b.go 1970 1 1
1970年1月1日

y = 1969
m = 10
d = 0

MJD = 40587日
JD = 2440587.500000日
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なので，こうなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	const onday = int64(86400)   //seconds
	const baseDay = int64(40587) //Modified Julian Date at January 1, 1970

	year := 2015
	month := 1
	day := 1
	fmt.Printf(&amp;quot;%v年%v月%v日\n\n&amp;quot;, year, month, day)

	tm := time.Date(year, time.Month(month), day, 0, 0, 0, 0, time.UTC)
	fmt.Printf(&amp;quot;%v\n&amp;quot;, tm)
	ut := tm.Unix()
	fmt.Printf(&amp;quot;UNIX Time = %v seconds = %v days and %v seconds\n\n&amp;quot;, ut, ut/onday, ut%onday)

	mjd := ut/onday + baseDay
	fmt.Printf(&amp;quot;MJD = %d日\n&amp;quot;, mjd)
	fmt.Printf(&amp;quot;JD = %f日\n&amp;quot;, float64(mjd)+2400000.5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run julian-day-3.go
2015年1月1日

2015-01-01 00:00:00 +0000 UTC
UNIX Time = 1420070400 seconds = 16436 days and 0 seconds

MJD = 57023日
JD = 2457023.500000日
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;えーっと。
コードを見ればお分かりと思いますが，これだと1970年1月1日より前の日付では正しく動きません。
任意の日付&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:dce87c312b9004de93da86b8c547be13:8&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:dce87c312b9004de93da86b8c547be13:8&#34;&gt;8&lt;/a&gt;&lt;/sup&gt; で正しく動かすには床関数を使う必要があります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/packaging/&#34;&gt;次回&lt;/a&gt;は，これをパッケージ化してみましょう。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:dce87c312b9004de93da86b8c547be13&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:dce87c312b9004de93da86b8c547be13:1&#34;&gt;ちなみに1日未満の端数を含む場合を「ユリウス日（Julian Date）」，端数を含まない場合を「ユリウス通日（Julian Day Number）」と呼び分けているようです。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:dce87c312b9004de93da86b8c547be13:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:dce87c312b9004de93da86b8c547be13:2&#34;&gt;もともと太陽暦は「子午線から太陽までの時角」が時刻のベースになってるため，ユリウス日を考えた人は正午を起点にすべきと考えたのでしょう。日常生活で昼に日付が変わったら色々面倒そうですが。あぁでも， B な企業に勤めている人には日付の起点とか関係ないかな（笑）
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:dce87c312b9004de93da86b8c547be13:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:dce87c312b9004de93da86b8c547be13:3&#34;&gt;この式は「Fliegel の公式」などと呼ばれることがありますが，厳密には Fliegel の公式を電卓向けに分かりやすく展開したもので，初等天文学の教科書などでよく登場する式です。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:dce87c312b9004de93da86b8c547be13:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:dce87c312b9004de93da86b8c547be13:4&#34;&gt;月の値から2を引くのは暦計算の基本的なテクニックだったります（今回の式では月を0基点にするために3を引いてますが）。現在の1月（Ianuarius または January）を年初としたのはユリウス暦以降からで，それまでは現在の3月（Martius または March）が年初でした。だから2月だけちょっと特殊なんですねぇ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:dce87c312b9004de93da86b8c547be13:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:dce87c312b9004de93da86b8c547be13:5&#34;&gt;余談ですが365.25日を「ユリウス年」と呼びます。天文学では1年の長さが年によって変わるのは困るので，一様な長さの「年」を考えたわけです。つまりこの式はユリウス年にうるう年の補正をかけてるわけですね。ちなみに「ユリウス世紀」は36525日です。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:dce87c312b9004de93da86b8c547be13:5&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:dce87c312b9004de93da86b8c547be13:6&#34;&gt;耳慣れないかもしれないですが，夜中の12時のことです。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:dce87c312b9004de93da86b8c547be13:6&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:dce87c312b9004de93da86b8c547be13:7&#34;&gt;もちろんこれはキリスト教圏の国や地域での話です。例えば，日本でグレゴリオ暦が適用されたのは1873年（明治6年）なので，1873年以前は別の暦になり換算方法も変わります。もっと言うと，日本の現行暦は厳密にはグレゴリオ暦ではなくグレゴリオ暦互換の独自の暦です（参考： &lt;a href=&#34;http://text.baldanders.info/remark/2015/japanese-koyomi/&#34;&gt;「暦」日本史&lt;/a&gt;）。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:dce87c312b9004de93da86b8c547be13:7&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:dce87c312b9004de93da86b8c547be13:8&#34;&gt;とはいえ UNIX Time の取りうる値の範囲内での話ですが。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:dce87c312b9004de93da86b8c547be13:8&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>素数探索アルゴリズムで遊ぶ - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/search-prime-numbers/" />
		<id>tag:text.Baldanders.info,2015-09-17T21:23:42+0900:/golang/search-prime-numbers/</id>
		<published>2015-09-17T21:23:42+0900</published>
		<updated>2015-09-18T15:06:00+0900</updated>
		<summary>これまた，みんな大好き素数探索アルゴリズム</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/047a9bd6436e6391ddd4&#34;&gt;はじめての Go 言語 (on Windows) その2 - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;は公式のドキュメントがとても充実していて（ただしほぼ英語だけど），私のような初学者に易しい環境といえる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/&#34;&gt;Documentation - The Go Programming Language&lt;/a&gt; : 言語仕様に関するドキュメントはこちら（&lt;a href=&#34;http://golang-jp.org/doc/&#34;&gt;一部日本語化&lt;/a&gt;されている）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/&#34;&gt;Packages - The Go Programming Language&lt;/a&gt; : 標準パッケージのドキュメントはこちら（&lt;a href=&#34;http://golang-jp.org/pkg/&#34;&gt;一部日本語化&lt;/a&gt;されている）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とはいえ，コードが実際にどのように機能するかは書いてみないと分からない部分もある。
なので，今回からは実際にコードを書きながら言語の癖のようなものを調べていくことにする。
仕事に使うなら厳密な評価が必要だけど，今のところはそんな予定もないし，まずはテキトーで（笑）&lt;/p&gt;

&lt;p&gt;早速，みんな大好き素数探索アルゴリズムで遊ぶ。&lt;/p&gt;

&lt;h2 id=&#34;素数の定義:ba5a2fe9dba0ce0dbb53ecd3120fd65e&#34;&gt;素数の定義&lt;/h2&gt;

&lt;p&gt;一応，素数（prime number）の定義を以下に示す。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1 と自分自身以外に正の約数を持たない 1 より大きい自然数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ここで自然数（natural number）は「ペアノの公理」に従う（0 が自然数に含まれるかどうかについては色々あるみたいだが，素数の定義には影響がないので，ここでは無視する）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%9A%E3%82%A2%E3%83%8E%E3%81%AE%E5%85%AC%E7%90%86&#34;&gt;ペアノの公理 - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/taketo1024/items/2ab856d21bf9b9f30357&#34;&gt;Swiftで自然数を作ってみた（ペアノの公理） - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ちなみに結城浩さんの『数学ガール／ゲーデルの不完全性定理』にペアノの公理について分かりやすく解説した章がある。
お勧め。&lt;/p&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1D6/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/415MuioBMJL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1D6/baldandersinf-22/&#34;&gt;数学ガール／ゲーデルの不完全性定理&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;結城 浩 &lt;/dd&gt;&lt;dd&gt;SBクリエイティブ株式会社 2014-02-14&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1FO/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1FO.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／乱択アルゴリズム&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1CM/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1CM.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／フェルマーの最終定理&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMK4/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00L0PDMK4.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／ガロア理論&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00W6NCLL0/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00W6NCLL0.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート/数列の広場&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00W6NCLJM/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00W6NCLJM.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート/丸い三角関数&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;結城浩さんの本はよく整備された遊歩道を散歩するような気楽さと安心感がある。だから「フェルマーの最終定理」とか「ゲーデルの不完全性定理」とかいった難解そうなテーマでも，迷うことなく，しかも一歩ずつ歩みを進めてゴールまで辿り着けるのかもしれない。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2015-09-16&#34;&gt;2015-09-16&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;alg1:ba5a2fe9dba0ce0dbb53ecd3120fd65e&#34;&gt;素数探索アルゴリズム（その1）&lt;/h2&gt;

&lt;p&gt;素数の定義を愚直にコードで表すなら以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	max := 100
	fmt.Printf(&amp;quot;%v 以下の素数:&amp;quot;, max)

	start := time.Now() //Start
	for n := 2; n &amp;lt;= max; n++ {
		flag := true
		for m := 2; m &amp;lt; n; m++ {
			if (n % m) == 0 { // n が m で割り切れる → 素数ではない
				flag = false
				break
			}
		}
		if flag {
			fmt.Printf(&amp;quot; %v&amp;quot;, n)
		}
	}
	goal := time.Now()                     //Goal
	fmt.Printf(&amp;quot;\n%v 経過&amp;quot;, goal.Sub(start)) //経過時間を表示
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run prime01.go
100 以下の素数: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
5.0002ms 経過
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この値を覚えておいてね。
検算に使うから。&lt;/p&gt;

&lt;h2 id=&#34;alg2:ba5a2fe9dba0ce0dbb53ecd3120fd65e&#34;&gt;素数探索アルゴリズム（その2: エラトステネスの篩の変形）&lt;/h2&gt;

&lt;p&gt;もう少しだけ効率的に素数を探すアルゴリズムとして「&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9&#34; title=&#34;エラトステネスの篩 - Wikipedia&#34;&gt;エラトステネスの篩&lt;/a&gt;」と呼ばれる方法がある。
ただし「&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9&#34; title=&#34;エラトステネスの篩 - Wikipedia&#34;&gt;エラトステネスの篩&lt;/a&gt;」は決まった範囲を探索するものなので少々使いづらい。
そこで「&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9&#34; title=&#34;エラトステネスの篩 - Wikipedia&#34;&gt;エラトステネスの篩&lt;/a&gt;」で使われている以下の素数の特徴を最初のアルゴリズムに加えてみる。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;2 以上の全ての自然数はひとつ以上の素数の積で構成される（この素数の集合を素因数（prime factor）という）。したがってある数が素数か否かの判定は，その数より小さい素数のみで調べればよい&lt;/li&gt;
&lt;li&gt;更に，積の可換則（commutative property あるいは交換法則）により，自然数 $n$ が素数か否か判定する場合は $\sqrt{n}$ 以下の素数で調べればよい&lt;br /&gt;
（たとえば 35 の素因数は 5 と 7 だが， $5 \times 7 = 7 \times 5 = 35$ なので，直前の素数 31 まで回さずとも 3 および 5 ($\le \sqrt{35}$) まで調べれば判定できる）&lt;/li&gt;
&lt;li&gt;素数の定義から 2 が素数であることは自明なので（1 と 2 の間に自然数は存在しない）， 2 より大きい 2 の倍数（すなわち偶数）については判定しなくてもよく，対象となる自然数は 3 以上の奇数のみでいいことになる。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;では，この特徴を加えたコードを書いてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	primes := make([]int64, 1)     // 素数のリスト
	primes_f := make([]float64, 1) // 素数のリスト（浮動小数点へのキャスト）
	primes[0] = 2                  // 2 は素数
	primes_f[0] = 2.0              // 2 は素数（浮動小数点）
	var max int64 = 100

	start := time.Now() // Start
	var n int64 = 3
	for n = 3; n &amp;lt; max; n += 2 { // 3 から始まる奇数のみを探索
		flag := true
		f := float64(n)                    // 浮動小数点に cating
		rf := math.Sqrt(f)                 // n に対して √n をとる
		for i := 1; i &amp;lt; len(primes); i++ { // 2 より大きい既知の素数でチェックする
			if primes_f[i] &amp;gt; rf { // n に対して √n 以下の素数まで探索すればよい
				break
			} else if (n % primes[i]) == 0 { // n が既知の素数で割り切れる → 素数ではない
				flag = false
				break
			}
		}
		if flag {
			primes = append(primes, n)     // 素数を追加
			primes_f = append(primes_f, f) // 素数を追加（浮動小数点）
		}
	}
	goal := time.Now() // Goal
	fmt.Printf(&amp;quot;%v 以下の素数: %v\n&amp;quot;, max, primes)
	fmt.Printf(&amp;quot;%v 経過&amp;quot;, goal.Sub(start)) // 経過時間を表示
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run prime02.go
100 以下の素数: [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97]
0 経過
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;slice-と-make-と-append:ba5a2fe9dba0ce0dbb53ecd3120fd65e&#34;&gt;slice と make() と append()&lt;/h3&gt;

&lt;p&gt;コード中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;primes := make([]int64, 1)     // 素数のリスト
primes_f := make([]float64, 1) // 素数のリスト（浮動小数点へのキャスト）
primes[0] = 2                  // 2 は素数
primes_f[0] = 2.0              // 2 は素数（浮動小数点）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の変数 &lt;code&gt;primes&lt;/code&gt; および &lt;code&gt;primes_f&lt;/code&gt; は &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; と呼ばれる可変長の配列型である。
更に組み込み関数 &lt;code&gt;make()&lt;/code&gt; は &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Map_types&#34;&gt;map&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; のみ使用可能なメモリ割り当て関数である。
ちなみに &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Map_types&#34;&gt;map&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; 以外は &lt;code&gt;new()&lt;/code&gt; を使う。
&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Map_types&#34;&gt;map&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; のみ特別なのは，これらの型は初期値と内部状態を持つためである。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; に要素を追加する場合は &lt;code&gt;append()&lt;/code&gt; 関数を使えばいいのだが，これが結構クセがある。
&lt;code&gt;append()&lt;/code&gt; 関数では &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; の容量（capacity）がいっぱいになると新たにメモリを確保してオリジナルの内容をコピーする。
つまりポインタが変わってしまうのだ。（メモリの割り当て方のパターンにも注目）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	a := make([]int, 0)                                         // 空の配列を用意
	fmt.Printf(&amp;quot;Slice(%02d) : %p : %v (%v)\n&amp;quot;, 0, a, a, cap(a)) // 配列の表示（初期状態）
	for num := 1; num &amp;lt;= 17; num++ {
		a = append(a, num)                                            //配列要素の追加
		fmt.Printf(&amp;quot;Slice(%02d) : %p : %v (%v)\n&amp;quot;, num, a, a, cap(a)) //配列の表示
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run slice.go
Slice(00) : 0x5cebb8 : [] (0)
Slice(01) : 0xc082002340 : [1] (1)
Slice(02) : 0xc082002380 : [1 2] (2)
Slice(03) : 0xc082006740 : [1 2 3] (4)
Slice(04) : 0xc082006740 : [1 2 3 4] (4)
Slice(05) : 0xc0820083c0 : [1 2 3 4 5] (8)
Slice(06) : 0xc0820083c0 : [1 2 3 4 5 6] (8)
Slice(07) : 0xc0820083c0 : [1 2 3 4 5 6 7] (8)
Slice(08) : 0xc0820083c0 : [1 2 3 4 5 6 7 8] (8)
Slice(09) : 0xc082050000 : [1 2 3 4 5 6 7 8 9] (16)
Slice(10) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10] (16)
Slice(11) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10 11] (16)
Slice(12) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10 11 12] (16)
Slice(13) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10 11 12 13] (16)
Slice(14) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10 11 12 13 14] (16)
Slice(15) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15] (16)
Slice(16) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16] (16)
Slice(17) : 0xc082056000 : [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17] (32)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;容量が変化するごとにポインタ値も変化していることがお分かりだろうか。&lt;/p&gt;

&lt;p&gt;ちなみに Go コンパイラは，返値を無視するコーディングに対してエラーを吐く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append(a, num)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の部分を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;append(a, num)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run prime02.go
# command-line-arguments
.\slice.go:9: append(a, num) evaluated but not used
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とエラーになる。&lt;/p&gt;

&lt;p&gt;また，容量はあらかじめ指定できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a := make([]int, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の部分を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a := make([]int, 0, 32)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run slice.go
Slice(00) : 0xc082050000 : [] (32)
Slice(01) : 0xc082050000 : [1] (32)
Slice(02) : 0xc082050000 : [1 2] (32)
Slice(03) : 0xc082050000 : [1 2 3] (32)
Slice(04) : 0xc082050000 : [1 2 3 4] (32)
Slice(05) : 0xc082050000 : [1 2 3 4 5] (32)
Slice(06) : 0xc082050000 : [1 2 3 4 5 6] (32)
Slice(07) : 0xc082050000 : [1 2 3 4 5 6 7] (32)
Slice(08) : 0xc082050000 : [1 2 3 4 5 6 7 8] (32)
Slice(09) : 0xc082050000 : [1 2 3 4 5 6 7 8 9] (32)
Slice(10) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10] (32)
Slice(11) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10 11] (32)
Slice(12) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10 11 12] (32)
Slice(13) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10 11 12 13] (32)
Slice(14) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10 11 12 13 14] (32)
Slice(15) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15] (32)
Slice(16) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16] (32)
Slice(17) : 0xc082050000 : [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17] (32)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。
メモリ割り当ては意外に高コストの操作なので， &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; を扱う場合はこの辺がチューニング・ポイントになるだろう。&lt;/p&gt;

&lt;h2 id=&#34;100万個目の素数:ba5a2fe9dba0ce0dbb53ecd3120fd65e&#34;&gt;100万個目の素数&lt;/h2&gt;

&lt;p&gt;上のコードを少し修正して $x$ 個目の素数を調べることにしよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	//コマンドライン引数の解析
	algno := flag.Int(&amp;quot;alg&amp;quot;, 0, &amp;quot;0: Basic algorithm , 1: Sieve of Eratosthenes&amp;quot;)
	flag.Parse()
	args := flag.Args()
	if *algno &amp;lt; 0 || *algno &amp;gt; 1 {
		fmt.Fprintln(os.Stderr, os.ErrInvalid)
		return
	}
	if len(args) != 1 {
		fmt.Fprintln(os.Stderr, os.ErrInvalid)
		return
	}
	max, err := strconv.ParseInt(args[0], 10, 64)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	if max &amp;lt;= 0 {
		max = 1
	}

	//素数探索
	prime := int64(0)
	start := time.Now() // Start
	switch *algno {
	case 1:
		prime = LastPrimeE(max)
	default:
		prime = LastPrimeB(max)
	}
	goal := time.Now()                       // Goal
	fmt.Printf(&amp;quot;%v 個目の素数: %v\n&amp;quot;, max, prime) // max 個目の素数
	fmt.Printf(&amp;quot;%v 経過\n&amp;quot;, goal.Sub(start))   // 経過時間を表示
}

func LastPrimeB(max int64) int64 {
	count := int64(0)

	for n := int64(2); ; n++ {
		flag := true
		for m := int64(2); m &amp;lt; n; m++ {
			if (n % m) == 0 { // n が m で割り切れる → 素数ではない
				flag = false
				break
			}
		}
		if flag {
			count++
			if count &amp;gt;= max {
				return n
			}
		}
	}
}

func LastPrimeE(max int64) int64 {
	if max &amp;lt;= 1 {
		return 2
	}
	primes := make([]int64, 1, max)     // 素数のリスト
	primes_f := make([]float64, 1, max) // 素数のリスト（浮動小数点へのキャスト）
	primes[0] = 2                       // 2 は素数
	primes_f[0] = 2.0                   // 2 は素数（浮動小数点）

	count := int64(1)
	for n := int64(3); ; n += 2 { // 3 から始まる奇数のみを探索
		flag := true
		f := float64(n)                    // 浮動小数点に cating
		rf := math.Sqrt(f)                 // n に対して √n をとる
		for i := 1; i &amp;lt; len(primes); i++ { // 2 より大きい既知の素数でチェックする
			if primes_f[i] &amp;gt; rf { // n に対して √n 以下の素数まで探索すればよい
				break
			} else if (n % primes[i]) == 0 { // n が既知の素数で割り切れる → 素数ではない
				flag = false
				break
			}
		}
		if flag {
			count++
			if count &amp;gt;= max {
				return n
			}
			primes = append(primes, n)     // 素数を追加
			primes_f = append(primes_f, f) // 素数を追加（浮動小数点）
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今後のためにコマンドライン解析の部分と実際の素数探索アルゴリズムを分けている。
まず検算。
25個目の素数が 97 なら OK。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run prime03.go -alg=0 25
25 個目の素数: 97
0 経過

C:&amp;gt;go run prime03.go -alg=1 25
25 個目の素数: 97
0 経過
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では実際に動かしてみよう。
まずは「&lt;a href=&#34;#alg1:ba5a2fe9dba0ce0dbb53ecd3120fd65e&#34;&gt;その1&lt;/a&gt;」のアルゴリズムから。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run prime03.go -alg=0 100
100 個目の素数: 541
0 経過

C:&amp;gt;go run prime03.go -alg=0 10000
10000 個目の素数: 104729
4.4072521s 経過
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;100万個目の素数は有意の時間で見つかりませんでした orz&lt;/p&gt;

&lt;p&gt;次に「&lt;a href=&#34;#alg2:ba5a2fe9dba0ce0dbb53ecd3120fd65e&#34;&gt;その2&lt;/a&gt;」のアルゴリズムで。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run prime03.go --alg=1 100
100 個目の素数: 541
0 経過

C:&amp;gt;go run prime03.go --alg=1 10000
10000 個目の素数: 104729
7.0004ms 経過

C:&amp;gt;go run prime03.go --alg=1 1000000

1000000 個目の素数: 15485863
4.9042805s 経過

C:&amp;gt;go run prime03.go --alg=1 10000000
10000000 個目の素数: 179424673
2m13.8686568s 経過
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というわけで，100万個目の素数探索に5秒弱，1000万個目の素数探索に2分ちょっとかかってしまった。
まぁ，でも，こんなもんか。&lt;/p&gt;

&lt;h2 id=&#34;alg3:ba5a2fe9dba0ce0dbb53ecd3120fd65e&#34;&gt;素数探索アルゴリズム（その3: エラトステネスの篩を並行処理で）&lt;/h2&gt;

&lt;p&gt;これまでのアルゴリズムは基本的に2重のループで値を順番に付き合わせているだけだったが，この部分を並行処理で行えば速いんじゃね？ と思うよね。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で並行処理を行うには &lt;a href=&#34;http://golang.org/ref/spec#Go_statements&#34;&gt;goroutine&lt;/a&gt;（「ゴルーチン」と読むらしい）を使う。
また &lt;a href=&#34;http://golang.org/ref/spec#Go_statements&#34;&gt;goroutine&lt;/a&gt; の worker 間ではメモリ共有ができないため， &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; を使い message-passing 方式&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ba5a2fe9dba0ce0dbb53ecd3120fd65e:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ba5a2fe9dba0ce0dbb53ecd3120fd65e:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;で通信を行う。&lt;/p&gt;

&lt;p&gt;で，実際に &lt;a href=&#34;http://golang.jp/go_tutorial#index12&#34;&gt;チュートリアルには並行処理を使った素数探索アルゴリズムが紹介&lt;/a&gt;されている&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ba5a2fe9dba0ce0dbb53ecd3120fd65e:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ba5a2fe9dba0ce0dbb53ecd3120fd65e:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。
いくつかサイトを巡ったが，このやり方がもっとも素直なようだ（後述するが速いわけではない）。
そこで，このコードを流用させてもらうことにした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func LastPrimeE2(max int64) int64 {
	if max &amp;lt;= 1 {
		return 2 // 最初の素数は2
	}

	count := int64(1)
	primes := sieve()
	for {
		prime := &amp;lt;-primes
		count++
		if count &amp;gt;= max {
			return prime
		}
	}
}

// 素数候補の数を生成する
func generate() chan int64 {
	ch := make(chan int64)
	go func() {
		for n := int64(3); ; n += 2 { // 3 以降の奇数を送信（2 以外の偶数は素数ではない）
			ch &amp;lt;- n
		}
	}()
	return ch
}

// 素数 &#39;prime&#39; に対するフィルタ
// &#39;prime&#39; で割り切れない値のみ通過可能
func filter(in chan int64, prime int64) chan int64 {
	out := make(chan int64)
	go func() {
		for {
			n := &amp;lt;-in
			if (n % prime) != 0 {
				out &amp;lt;- n
			}
		}
	}()
	return out
}

// エラトステネスの篩
func sieve() chan int64 {
	out := make(chan int64)
	go func() {
		ch := generate()
		for {
			prime := &amp;lt;-ch
			out &amp;lt;- prime
			ch = filter(ch, prime)
		}
	}()
	return out
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そうそう。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では関数は全て関数閉包（closure）として機能する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;main&lt;/code&gt; 関数も少しいじって &lt;code&gt;-alg=2&lt;/code&gt; でこのアルゴリズムを起動するようにする。
まずは検算ね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run prime04.go -alg=2 25
25 個目の素数: 97
0 経過
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;じゃあ，早速うごかしてみよっか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run prime04.go -alg=2 100
100 個目の素数: 541
2.0002ms 経過

C:&amp;gt;go run prime04.go -alg=2 10000
10000 個目の素数: 104729
4.2002402s 経過
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;100万個目の素数は有意の時間で見つかりませんでした orz&lt;/p&gt;

&lt;p&gt;まぁアルゴリズム的に「篩」っぽくはあるんだけどね。&lt;/p&gt;

&lt;p&gt;ある値が素数であると判定されるためには，その値より小さい全ての素数フィルタを通過しなければならない（つまり「&lt;a href=&#34;#alg2:ba5a2fe9dba0ce0dbb53ecd3120fd65e&#34;&gt;その2&lt;/a&gt;」で紹介した特徴の2番目を全く生かせていない）。
これが致命的。
しかもこのフィルタ処理 &lt;code&gt;filter()&lt;/code&gt; は素数フィルタの生成も兼ねていて，前の素数フィルタの出力を次の素数フィルタの入力として連結しているのでスキップできない。&lt;/p&gt;

&lt;p&gt;かなりインチキではあるけど，捜索範囲を「100万個目」までと限定し，「100万個目」の素数が 15,485,863 であると分かっているならもう少し速くできるかもしれない。
つまり以下のように改良する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func LastPrimeE2(max int64) int64 {
	if max &amp;lt;= 1 {
		return 2 // 最初の素数は2
	}

	count := int64(1)
	primes := sieve()
	for prime := range primes {
		count++
		if count &amp;gt;= max {
			return prime
		}
	}
	return count
}

// 素数候補の数を生成する
// ただし上限を 15485863 とする
func generate() chan int64 {
	ch := make(chan int64)
	go func() {
		for n := int64(3); n &amp;lt;= 15485863; n += 2 { // 3 以降の奇数を送信（2 以外の偶数は素数ではない）
			ch &amp;lt;- n
		}
		close(ch)
	}()
	return ch
}

// 素数 &#39;prime&#39; に対するフィルタ
func filter(in chan int64, prime int64) chan int64 {
	out := make(chan int64)
	go func() {
		for n := range in {
			if (n % prime) != 0 {
				out &amp;lt;- n
			}
		}
		close(out)
	}()
	return out
}

// エラトステネスの篩
func sieve() chan int64 {
	out := make(chan int64)
	go func() {
		ch := generate()
		fflag := true
		for {
			prime, ok := &amp;lt;-ch
			if !ok {
				break
			}
			out &amp;lt;- prime
			if fflag &amp;amp;&amp;amp; prime*prime &amp;lt;= 15485863 {
				ch = filter(ch, prime)
			} else { // 素数が最大値の平方根（√15485863）より大きい場合はフィルタを作らず無条件に通す
				fflag = false
			}
		}
		close(out)
	}()
	return out
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで実行してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run prime05.go -alg=2 100
100 個目の素数: 541
2.0001ms 経過

C:&amp;gt;go run prime05.go -alg=2 10000
10000 個目の素数: 104729
378.0216ms 経過

C:&amp;gt;go run prime05.go -alg=2 1000000
1000000 個目の素数: 15485863
39.4492564s 経過
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;おお。
ようやく有意の時間で探索できた。
それでも「&lt;a href=&#34;#alg2:ba5a2fe9dba0ce0dbb53ecd3120fd65e&#34;&gt;その2&lt;/a&gt;」の10倍以上かかるけど。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; への送信データが有限個の場合は最後に &lt;code&gt;close(ch)&lt;/code&gt; でクローズする。
一方 &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; からの受信側は &lt;a href=&#34;http://golang.org/ref/spec#For_statements&#34;&gt;for range 構文&lt;/a&gt;を使うことで安全に扱うことができる。
ただし上述の &lt;code&gt;sieve()&lt;/code&gt; 関数では 変数 &lt;code&gt;ch&lt;/code&gt; が新しい素数フィルタの出力に上書きされていくので &lt;a href=&#34;http://golang.org/ref/spec#For_statements&#34;&gt;for range 構文&lt;/a&gt;は使えない。
その代わり以下の記述で &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; を安全に扱うことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;prime, ok := &amp;lt;-ch
if !ok {
    break // channel が閉じられた
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回はここまで。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:ba5a2fe9dba0ce0dbb53ecd3120fd65e&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/20130414/1365960707&#34;&gt;Go の並行処理 - Block Rockin’ Codes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/sudix/items/f95ef0e5bbd0cd3d4378&#34;&gt;(翻訳)Goでのパイプラインとキャンセル - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/suin/items/eca21ed935115e5da2e8&#34;&gt;Go: 計算なしのFizzBuzz - Qiita&lt;/a&gt; : &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; の説明するのにいいかも&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/yuki2006/items/3f90e53ce74c6cff1608&#34;&gt;Goのchannelの送受信用の型について - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/hondata/items/64776c79063e93bea9ed&#34;&gt;Go言語のChannelは送信時にもブロックする - Qiita&lt;/a&gt; : 意外と見落とす channel 送信時のブロック&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/Jxck_/items/da3ca2db58734a966cac&#34;&gt;Go - select loop の小ネタ - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/sudix/items/67d4cad08fe88dcb9a6d&#34;&gt;Goのforとgoroutineでやりがちなミスとたった一つの冴えたgo vetと - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/tutuming/items/c0ffdd28001ee0e9320d&#34;&gt;golang - x/net/context の実装パターン - Qiita&lt;/a&gt; : &lt;a href=&#34;https://godoc.org/golang.org/x/net/context&#34;&gt;golang.org/x/net/context&lt;/a&gt; を使って並行処理を細かく制御&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2014/07/30/golang-parallel-by-cpu/&#34;&gt;Go言語でCPU数に応じて並列処理数を制限する | SOTA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/ymko/items/554e3630fefdc29393a8&#34;&gt;やはり俺のgolangがCPUを一つしか使わないのはまちがっている。 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:ba5a2fe9dba0ce0dbb53ecd3120fd65e:1&#34;&gt;message-passing 方式は Erlang などで一躍有名になったやつ。ただし Erlang ではプロセス間通信の手段として  message-passing を使う。これは Actor と呼ばれている。 &lt;a href=&#34;http://golang.org/ref/spec#Go_statements&#34;&gt;goroutine&lt;/a&gt; は「並行処理」であり「並列処理」ではない。また，いわゆる thread とも異なる。&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で並列処理を行うなら「&lt;a href=&#34;http://deeeet.com/writing/2014/07/30/golang-parallel-by-cpu/&#34;&gt;Go言語でCPU数に応じて並列処理数を制限する&lt;/a&gt;」あたりが参考になる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ba5a2fe9dba0ce0dbb53ecd3120fd65e:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:ba5a2fe9dba0ce0dbb53ecd3120fd65e:2&#34;&gt;ただし現在の&lt;a href=&#34;https://golang.org/doc/&#34;&gt;公式ドキュメント&lt;/a&gt;には存在しない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ba5a2fe9dba0ce0dbb53ecd3120fd65e:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
</feed>
