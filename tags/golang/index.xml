<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:cc="http://web.resource.org/cc/">
	<title>Golang - text.Baldanders.info</title>
	<link rel="alternate" type="text/html" href="http://text.baldanders.info/tags/golang/" />
	<link rel="self" type="application/atom+xml" href="http://text.baldanders.info/tags/golang/index.xml" />
	<id>tag:text.Baldanders.info,2016-04-10:/</id>
	<updated>2016-04-10T18:44:29+09:00</updated>
	<subtitle>帰ってきた「しっぽのさきっちょ」</subtitle>
	<icon>http://text.baldanders.info//images/avatar.jpg</icon>
	<logo>http://text.baldanders.info//images/avatar.jpg</logo>
	<generator uri="http://gohugo.io/">Hugo 0.15</generator>

	
	<entry>
		<title>週末スペシャル： まじめに規制に従っている人ほど馬鹿を見る社会 - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2016/04/10-stories/" />
		<id>tag:text.Baldanders.info,2016-04-10:/remark/2016/04/10-stories/</id>
		<published>2016-04-10T18:44:29+09:00</published>
		<updated>2016-04-11T23:40:13+09:00</updated>
		<summary>まじめに規制に従っている人ほど馬鹿を見る社会 / Linux サブシステムは Windows の終わりの始まり / 鍵管理システム CONIKS / Go 言語を使うようになって変わったこと / その他の気になる記事</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;3月は去りました。
春になっちゃったよ。&lt;/p&gt;

&lt;p&gt;うっかり左手首を痛めてしまった（疲労がたまるとたまになる）のでいろいろ控えてた。
溜まりまくった小ネタを消化しないと。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#code:131c422dd318de78a778ce2a1d39851c&#34;&gt;まじめに規制に従っている人ほど馬鹿を見る社会&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bash:131c422dd318de78a778ce2a1d39851c&#34;&gt;Linux サブシステムは Windows の終わりの始まり&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pki:131c422dd318de78a778ce2a1d39851c&#34;&gt;鍵管理システム CONIKS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go:131c422dd318de78a778ce2a1d39851c&#34;&gt;Go 言語を使うようになって変わったこと&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#other:131c422dd318de78a778ce2a1d39851c&#34;&gt;その他の気になる記事&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;code:131c422dd318de78a778ce2a1d39851c&#34;&gt;まじめに規制に従っている人ほど馬鹿を見る社会&lt;/h2&gt;

&lt;p&gt;もう何度も書いているが「警察にできることは犯罪者にもできる」。
問題は犯罪者にできることが警察にもできるかどうか駄菓子菓子&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://japan.cnet.com/news/society/35080404/&#34;&gt;米政府によるスマホデータ取り出しの協力要請、ACLUが実態調査 - CNET Japan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.itmedia.co.jp/news/articles/1604/01/news114.html&#34;&gt;FBIのiPhoneロック解除方法、Appleに知らされない可能性も (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;) - ITmedia ニュース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.itmedia.co.jp/news/articles/1604/08/news060.html&#34;&gt;FBI長官、「購入したロック解除ツールはiPhone 5sでは機能しなかった」 - ITmedia ニュース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jp.techcrunch.com/2016/04/09/20160408justice-department-keeps-pushing-apple-to-unlock-iphone-in-new-york-drug-case/&#34;&gt;司法省がまたAppleにiPhoneアンロック要求、今度はAppleが“相手を間違えた”国を訴訟か | TechCrunch Japan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FBI が端末を突破するのに外部企業を使ったということ，そして企業がそれに応じたことは重要だ。
もちろん実は NSA の息のかかった企業だった，としても驚かないけど。&lt;/p&gt;

&lt;p&gt;企業は利があると思えば警察にも犯罪者にだって加担する。
今回の件のポイントは「犯罪者にできることが警察にできるとは限らない」と証明してしまったことだ。
セキュリティ企業は新しい時代の「死の商人」になるかもしれない。&lt;/p&gt;

&lt;p&gt;警察が優位に立てるのは犯罪者よりもパワー（暴力・権力を含む）を有している場合のみである。
コンピュータ・ネットワーク技術あるいは暗号技術において政府・警察は優位に立てない。
米国司法省は法規制によって優位に立てると思ってるようだが，こんなもの最初から「法の外」にいる犯罪者やテロリストに対しては効力がない。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.itmedia.co.jp/news/articles/1604/09/news022.html&#34;&gt;暗号化解除をめぐる米法案、司法当局へのバックドア提供を義務付け - ITmedia ニュース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://japan.cnet.com/news/society/35080962/&#34;&gt;バックドア提供を拒む企業に制裁金を&amp;ndash;米国で法案が公開 - CNET Japan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これは「飲酒運転を減らすために飲酒運転規制を厳罰化する」というのとは話が違う。
犯罪者にはインパクトがないし，まじめに規制に従っている人ほど「馬鹿を見る」ことになる。&lt;/p&gt;

&lt;p&gt;有害なルールに従う必要はないし，それに従うことはむしろリスクを高めることになる。&lt;/p&gt;

&lt;h2 id=&#34;bash:131c422dd318de78a778ce2a1d39851c&#34;&gt;Linux サブシステムは Windows の終わりの始まり&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jp.techcrunch.com/2016/03/31/20160330be-very-afraid-hell-has-frozen-over-bash-is-coming-to-windows-10/&#34;&gt;Build 2016で驚きの発表―Microsoftはこの夏Windows 10でBashシェルをサポート | TechCrunch Japan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://japan.cnet.com/news/service/35080406/&#34;&gt;「Windows 10」で動作するUbuntuのBashシェル&amp;ndash;その実現方法 - CNET Japan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://satonaoki.wordpress.com/2016/03/31/bash-ubuntu-windows/&#34;&gt;開発者がWindows 10でBashシェルとユーザー モードのUbuntu Linuxバイナリを実行可能に | S/N Ratio (by SATO Naoki)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.publickey1.jp/blog/16/mariadbmariadb_columnstoreolap.html&#34;&gt;MariaDB、カラム型データベースエンジン「MariaDB ColumnStore」発表。OLAPへ参入 － Publickey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;del&gt;もともと Windows は POSIX サブシステムを持っている。
今回はそれに加えて&lt;/del&gt; Ubuntu ベースの Linux サブシステムを組み込むということらしいが子亀の上に親亀を乗っけるようなものだ。&lt;/p&gt;

&lt;p&gt;Windows の基本的な設計思想は20～25年くらい前の古いものだ。
しかも DOS/Windows はもともとシングルユーザ用に設計されたもので UNIX 等のマルチユーザ向けの OS とは全く異なる。&lt;/p&gt;

&lt;p&gt;Linux のベースとなっている UNIX もそうとう古いが，マルチユーザを前提とした考え方は今でも通用するし，なにより Linux はもはや UNIX に縛られない。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/yomoyomo/20160331/linux25years&#34;&gt;Linux公開25周年を受けたリーナス・トーバルズのインタビュー - YAMDAS現更新履歴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://japan.zdnet.com/article/35080722/&#34;&gt;Linux創始者トーバルズ氏、IoTを語る&amp;ndash;「セキュリティは二の次」と警鐘 - ZDNet Japan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Windows は永遠に Windows に縛られ続ける。
Microsoft が満を持して出した Windows 10 も結局は Windows に縛られている。&lt;/p&gt;

&lt;p&gt;Windows が時代遅れなのは明らかである。
Microsoft 自らこういう無茶をすること自体が「Windows の終わりの始まり」だ。
個人的に2020年までに自宅 PC のメインを Linux 機に換装する予定だが，ちょっと計画を前倒ししたほうがいいかもしれない。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://japan.zdnet.com/article/35080364/&#34;&gt;目的別のおすすめLinuxディストリビューション&amp;ndash;あなたにぴったりなのはどれ？ - ZDNet Japan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;追記:131c422dd318de78a778ce2a1d39851c&#34;&gt;追記&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mattn.kaoriya.net/software/why-i-use-cmd-on-windows.htm&#34;&gt;Big Sky :: Windows ユーザは cmd.exe で生きるべき。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;激しく同意。
もっとも私は &lt;a href=&#34;http://text.baldanders.info/remark/2015/conemu-and-nyagos/&#34;&gt;ConEmu &amp;amp; NYAGOS&lt;/a&gt; だけど（笑）&lt;/p&gt;

&lt;h2 id=&#34;sig:131c422dd318de78a778ce2a1d39851c&#34;&gt;WhatsApp がついに Signal ベースの E2E 暗号化を実装する&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://whispersystems.org/blog/whatsapp-complete/&#34;&gt;Open Whisper Systems &amp;gt;&amp;gt; Blog &amp;gt;&amp;gt; WhatsApp&amp;rsquo;s Signal Protocol integration is now complete&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://techcrunch.com/2016/04/05/whatsapp-completes-end-to-end-encryption-rollout/&#34;&gt;WhatsApp completes end-to-end encryption rollout | TechCrunch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.itmedia.co.jp/news/articles/1604/06/news069.html&#34;&gt;Facebook傘下のWhatsApp、完全暗号化を完了　「政府もわれわれも解除できない」 - ITmedia ニュース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jp.techcrunch.com/2016/04/06/20160405whatsapp-completes-end-to-end-encryption-rollout/&#34;&gt;WhatsApp、全てのプラットフォームのエンドツーエンド暗号化を完了 | TechCrunch Japan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もともと WhatsApp が Signal ベースの暗号化システムを実装することは予告されていた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://whispersystems.org/&#34;&gt;Open Whisper Systems&lt;/a&gt; (&lt;a href=&#34;https://github.com/WhisperSystems&#34;&gt;GitHub&lt;/a&gt;)

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://support.whispersystems.org/hc/en-us/articles/212477768-Is-it-secure-Can-I-trust-it-&#34;&gt;Is it private? Can I trust it? – Support&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Signal 自体は SMS アプリを置き換えることのできる優れたアプリなのだが SNS ベースのメッセンジャー・アプリとしては機能的に劣る。
WhatsApp がその辺を埋めることになるかどうか。
でも日本のユーザにはウケないかなぁ。&lt;/p&gt;

&lt;p&gt;メールは ProtonMail， SMS ベースのメッセンジャーには Signal，それ以外のメッセンジャーには WhatsApp と，だいぶ揃ってきたねぇ。&lt;/p&gt;

&lt;h2 id=&#34;pki:131c422dd318de78a778ce2a1d39851c&#34;&gt;鍵管理システム CONIKS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coniks.cs.princeton.edu/&#34;&gt;CONIKS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.schneier.com/blog/archives/2016/04/coniks.html&#34;&gt;CONIKS - Schneier on Security&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure lang=&#34;en&#34;&gt;
&lt;blockquote&gt;
&lt;q&gt;CONIKS is a key management system for end users capable of integration in end-to-end secure communication services. The main idea is that users should not have to worry about managing encryption keys when they want to communicate securely, but they also should not have to trust their secure communication service providers to act in their interest.&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;https://coniks.cs.princeton.edu/&#34;&gt;CONIKS&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;とりあえずメーリング・リストに入ってみた。&lt;/p&gt;

&lt;h2 id=&#34;go:131c422dd318de78a778ce2a1d39851c&#34;&gt;Go 言語を使うようになって変わったこと&lt;/h2&gt;

&lt;p&gt;内容自体にさほど文句があるわけではないが（細かい部分は置いておいて），「interface を中心に設計する」という記述が気になって。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;947e9a6ef68c4310baf21afdec4fcfab&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;私はそんなにたくさんの言語を知っているわけではないが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;を勉強するようになって設計の考え方が少し変わった。
まさに「制約は構造を生む」（by 結城浩「数学ガール」シリーズより）が如く，言語仕様によって思考も影響を受けるのである。
以下にいくつか例を挙げよう。&lt;/p&gt;

&lt;h3 id=&#34;value-object-から考える:131c422dd318de78a778ce2a1d39851c&#34;&gt;Value Object から考える&lt;/h3&gt;

&lt;p&gt;さて，いつもの図。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/DDD.svg&#34;&gt;&lt;img src=&#34;http://text.baldanders.info/images/DDD.svg&#34; alt=&#34;Domain-Driven Design&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;http://text.baldanders.info/images/DDD.svg&#34;&gt;Domain-Driven Design&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Domain Layer の中身は Domain Service, Entity, そして Value Object に分類される。
ビジネスロジックは図の右側，つまり Entity や Value Object に記述されるのが良い設計だと言われている（記述の重複を避けられるため）。
ただし Value Object はしばしば省略されることが多い。&lt;/p&gt;

&lt;p&gt;Value Object の特徴は以下のとおり。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内部状態を持たず不変である&lt;/li&gt;
&lt;li&gt;属性（property）の比較のみでオブジェクト同士が等価かどうか決定できる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そして実装上の要件としては「軽量」であることが求められる。
何故なら Value Object は Entity の属性として使われることが多く Value Object がボトルネックになるとシステム全般へのインパクトが大きいからだ。&lt;/p&gt;

&lt;p&gt;実は &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;はこの Value Object の実装にとても向いている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」 — プログラミング言語 Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/function-and-pointer/&#34;&gt;関数とポインタ — プログラミング言語 Go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の特徴である「強い型付け」も Value Object を念頭に置いて考えるなら合理的な仕様であることが分かるだろう。&lt;/p&gt;

&lt;h3 id=&#34;多態性を-振る舞い-から考える:131c422dd318de78a778ce2a1d39851c&#34;&gt;多態性を「振る舞い」から考える&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の多態性（polymorphism）は振る舞いによってのみ規定される（&lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia, the free encyclopedia&#34;&gt;duck typing&lt;/a&gt;）。
つまり「猫」のように振る舞うのであれば実体がロボットだろうがコスプレイヤーだろうが全部「猫」として括れるのである。
そして「猫」のようにあるためにロボットやコスプレイヤーの identity を書き換える必要はない。
これはとても重要な事である。&lt;/p&gt;

&lt;p&gt;たとえば「猫」を実装する際に，それに多態性を持たせなければならないかどうかは設計の割と早い段階で決めなければならないことが多い。
そうして先に &lt;code&gt;interface&lt;/code&gt; などを決めなければ具体的なクラスを記述することができない。
しかし &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;ではアプローチが逆になる。
先にロボットやコスプレイヤーといった具体的な型（&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt;）をバンバン作り，個々の振る舞いを見て，あとから「あっ，これ「猫」で括れるぢゃん♥」となるわけだ。
言い方を変えるなら refactoring 向きであるとも言える。&lt;/p&gt;

&lt;h3 id=&#34;要件定義からコードを書く:131c422dd318de78a778ce2a1d39851c&#34;&gt;要件定義からコードを書く&lt;/h3&gt;

&lt;p&gt;これは &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;に限らないが， refactoring しやすい言語は prototyping に向いている言語であるとも言える。
Prototyping に向いているということはプロジェクトのかなり早い段階（たとえば要件定義）からコードを書けるということでもある。
結局エンジニアにとって信用できるのは百万語を連ねた設計書より「動くコード」なのである。&lt;/p&gt;

&lt;h2 id=&#34;other:131c422dd318de78a778ce2a1d39851c&#34;&gt;その他の気になる記事&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://torrentfreak.com/transmission-releases-long-awaited-bittorrent-client-for-windows-160327/&#34;&gt;Transmission Releases Long-Awaited BitTorrent Client For Windows - TorrentFreak&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://postd.cc/npm-and-left-pad/&#34;&gt;NPMとleft-pad : 私たちはプログラミングのやり方を忘れてしまったのか？ | プログラミング | POSTD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jp.techcrunch.com/2016/03/29/20160328windows-users-finally-have-a-good-bittorrent-client/&#34;&gt;WindowsにBitTorrentクライアントの決定版Transmissionがやってくる | TechCrunch Japan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.iij.ad.jp/news/pressrelease/2016/0329-2.html&#34;&gt;IIJ、Webサイトにおけるユーザ認証のセキュリティを強化する 「IIJ SmartKeyマネージメントサービス」を提供開始 | 2016年 | IIJ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ipa.go.jp/security/technicalwatch/201600330.html&#34;&gt;IPAテクニカルウォッチ「公衆無線LAN利用に係る脅威と対策」：IPA 独立行政法人 情報処理推進機構&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jpcert.or.jp/research/apt-guide.html&#34;&gt;高度サイバー攻撃(APT)への備えと対応ガイド～企業や組織に薦める一連のプロセスについて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://p2ptk.org/copyright/231&#34;&gt;著作権削除要請の28％が「疑わしい」との研究結果 – P2Pとかその辺のお話R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://current.ndl.go.jp/node/31200&#34;&gt;国立極地研究所情報図書室、ウェブサイトをCC BYで公開 | カレントアウェアネス・ポータル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fanfun.jaxa.jp/jaxatv/files/20160408_hitomi.pdf&#34;&gt;Ｘ線天文衛星「ひとみ」（ASTRO-H）の状況について - 20160408_hitomi.pdf&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sorae.jp/030201/2016_04_02_jspoc.html&#34;&gt;X線天文衛星「ひとみ」、回転は破片を誤認？米軍発表 | Sorae.jp : 宇宙（そら）へのポータルサイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@tsukamoto/-f42bf7b5e25e&#34;&gt;定時帰宅のススメ — Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jp.techcrunch.com/2016/04/09/20160408spacex-just-landed-a-rocket-on-a-drone-ship-for-the-first-time/&#34;&gt;SpaceXのFalcon 9ロケット、洋上のドローン艀への軟着陸についに成功 | TechCrunch Japan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sonickun.hatenablog.com/entry/2016/04/03/183220&#34;&gt;GoogleがTLSでの採用を提唱している共通鍵暗号方式「ChaCha」についてまとめた - sonickun.log&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書:131c422dd318de78a778ce2a1d39851c&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/41aCueik45L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-15&lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117607/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117607.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;マイクロサービスアーキテクチャ&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117402/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117402.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;ハイパフォーマンスPython&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/0134190440/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/0134190440.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;The Go Programming Language (Addison-Wesley Professional Computing Series)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4774166340/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4774166340.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Vim script テクニックバイブル ~Vim使いの魔法の杖&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。買おうかどうか悩み中。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-03-12&#34;&gt;2016-03-12&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>関数とポインタ - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/function-and-pointer/" />
		<id>tag:text.Baldanders.info,2016-03-29:/golang/function-and-pointer/</id>
		<published>2016-03-29T22:16:41+09:00</published>
		<updated>2016-03-29T22:16:41+09:00</updated>
		<summary>Go 言語の引数は基本的に「値渡し（call by value）」である。「参照渡し（call by reference）」にしたい場合はポインタを使う。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;いまさらな内容なのだが覚え書きとして記しておく。&lt;/p&gt;

&lt;h2 id=&#34;go-言語における-calling-sequence:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;Go 言語における Calling Sequence&lt;/h2&gt;

&lt;p&gt;まずは簡単な足し算の関数を定義してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x int, y int) int {
	return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;add&lt;/code&gt; に続く括弧内が引数を定義していて，括弧の後ろの &lt;code&gt;int&lt;/code&gt; は返り値の型&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8182ac28bc68eb736cad9fff25d78d28:t&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8182ac28bc68eb736cad9fff25d78d28:t&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; を示している。
&lt;code&gt;add()&lt;/code&gt; 関数を呼び出すには以下のように記述する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func add(x, y int) int {
	return x + y
}

func main() {
	ans := add(42, 13)
	fmt.Println(ans)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は同じ int 型なので以下のように記述することもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y int) int {
	return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値として複数の値を定義することもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func split(sum int) (int, int) {
	x = sum * 4 / 9
	y = sum - x
	return x, y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また返り値は以下のように名前をつけることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y int) (ans int) {
	ans = x + y
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の &lt;code&gt;return&lt;/code&gt; がないとコンパイル・エラーになるので注意。
この書き方は &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;defer&lt;/a&gt; 構文と組み合わせるときに威力を発揮する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	err := r()
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(&amp;quot;Normal End.&amp;quot;)
	}
}

func r() (err error) {
	defer func() {
		if rec := recover(); rec != nil {
			err = fmt.Errorf(&amp;quot;Recovered from: %v&amp;quot;, rec)
		}
	}()

	f()
	err = nil
	return
}

func f() {
	panic(&amp;quot;Panic!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコード&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8182ac28bc68eb736cad9fff25d78d28:p&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8182ac28bc68eb736cad9fff25d78d28:p&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; では &lt;code&gt;r()&lt;/code&gt; 関数内で &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を捕まえ， 返り値の &lt;code&gt;err&lt;/code&gt; に値をセットしなおしている。&lt;/p&gt;

&lt;h3 id=&#34;go-言語の引数は-値渡し:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;Go 言語の引数は「値渡し」&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の引数は基本的に「値渡し（call by value）」である。
たとえば先程の足し算を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y int) int {
	x += y
	return x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義した場合でも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func add(x, y int) int {
	x += y
	return x
}

func main() {
    x := 42
    y := 13
	ans := add(x, y)
	fmt.Printf(&amp;quot;%d + %d = %d\n&amp;quot;, x, y, ans) //output: 42 + 13 = 55
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呼び出し元で &lt;code&gt;add()&lt;/code&gt; 関数の引数に渡した instance は関数実行後も変化しない。
このため「値渡し」は thread safe なコードに向いている。
たとえば value object を構成する際には関連する関数は「値渡し」のほうが安全である。
ただし関数呼び出し時に instance の値が常にコピーされるため&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8182ac28bc68eb736cad9fff25d78d28:copy&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8182ac28bc68eb736cad9fff25d78d28:copy&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，サイズの大きな instance の場合は呼び出し時のコストが高くなる。&lt;/p&gt;

&lt;p&gt;引数を「参照渡し（call by reference）」にしたい場合はポインタを使う。
つまり instance のポインタ値を渡すのである。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func add(x, y *int) int {
	*x += *y
	return *x
}

func main() {
	x := 42
	y := 13
	ans := add(&amp;amp;x, &amp;amp;y)
	fmt.Printf(&amp;quot;%d + %d = %d\n&amp;quot;, x, y, ans) //output: 55 + 13 = 55
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードでは &lt;code&gt;add()&lt;/code&gt; 関数実行後の &lt;code&gt;x&lt;/code&gt; の値が変更されている。
内部状態を持つ instance を引数に指定する場合は参照渡しにする必要がある。
しかし引数を参照渡しにすると関数実行が thread safe でなくなる可能性がある。
また引数の値が nil の場合も考慮する必要がある。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では通常の方法ではポインタ演算ができない。
たとえば，ついうっかり&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y *int) int {
	x += y
	return *x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とか書いてしまっても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;invalid operation: x += y (operator + not defined on pointer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とコンパイル・エラーになる。
ポインタ演算が必要な場合は &lt;a href=&#34;https://golang.org/pkg/unsafe/&#34; title=&#34;unsafe - The Go Programming Language&#34;&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; パッケージを使う。&lt;/p&gt;

&lt;h3 id=&#34;slice-map-channel-は常に-参照渡し:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;Slice, Map, Channel は常に「参照渡し」&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Map_types&#34;&gt;map&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; は組み込み型だが内部状態を持つ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8182ac28bc68eb736cad9fff25d78d28:make&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8182ac28bc68eb736cad9fff25d78d28:make&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。
したがって，これらの型の instance を引数に渡す場合はつねに「参照渡し」になる（つまり instance のコピーは発生しない）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func setItem(ary map[int]int, index, item int) {
	ary[index] = item
}

func main() {
    ary := map[int]int{0: 0}
	fmt.Println(ary) //output: map[0:0]
	setItem(ary, 0, 1)
	fmt.Println(ary) //output: map[0:1]
	setItem(ary, 10, 10)
	fmt.Println(ary) //output: map[0:1 10:10]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし固定の配列や &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8182ac28bc68eb736cad9fff25d78d28:str&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8182ac28bc68eb736cad9fff25d78d28:str&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; の instance は「値」として振る舞うため&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8182ac28bc68eb736cad9fff25d78d28:n&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8182ac28bc68eb736cad9fff25d78d28:n&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;，引数に指定した場合も「値渡し」になる。
&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; とは挙動が異なるためテキトーなコードを書いていると混乱しやすい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func setItem(ary [4]int, index, item int) {
	ary[index] = item
}

func main() {
	ary := [4]int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	setItem(ary, 1, 10)
	fmt.Println(ary) //output: [0 1 2 3]
	ary[2] = 200
	fmt.Println(ary) //output: [0 1 200 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;固定配列や &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型を「参照渡し」にしたい場合はやはりポインタ値を渡す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func setItem(ary *[4]int, index, item int) {
	(*ary)[index] = item
}

func main() {
	ary := [4]int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	setItem(&amp;amp;ary, 1, 10)
	fmt.Println(ary) //output: [0 10 2 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際には &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型の instance は「不変（immutable）」なので「参照渡し」が必要な局面はほとんど無いと思われる。
固定配列は不変ではないが，配列を操作するのであれば固定配列ではなく &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; のほうが扱いやすい。
たとえば上のコードでは &lt;code&gt;ary := []int{0, 1, 2, 3}&lt;/code&gt; と初期化すれば &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; として扱える。&lt;/p&gt;

&lt;h2 id=&#34;method-receiver:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;Method Receiver&lt;/h2&gt;

&lt;p&gt;ある型に関数を関連付ける場合は method receiver を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Vertex struct {
	X int
	Y int
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(v Vertex)&lt;/code&gt; の部分が method receiver である。
&lt;code&gt;Add()&lt;/code&gt; 関数を呼び出すには以下のように記述する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := Vertex{X: 1, Y: 2}
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)  //output: X = 1, Y = 2
	fmt.Println(vv) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数の calling sequence としては &lt;code&gt;v.Add(dv)&lt;/code&gt; と &lt;code&gt;Vertex.Add(v, dv)&lt;/code&gt; は等価である。
つまり &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;Add()&lt;/code&gt; 関数の0番目の引数として振る舞い，「値渡し」でセットされる。&lt;/p&gt;

&lt;p&gt;Method receiver の型をポインタ型にすれば「参照渡し」にできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := &amp;amp;Vertex{X: 1, Y: 2}
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合も calling sequence としては &lt;code&gt;v.Add(dv)&lt;/code&gt; と &lt;code&gt;(*Vertex).Add(v, dv)&lt;/code&gt; は等価である。&lt;/p&gt;

&lt;h3 id=&#34;method-receiver-の暗黙的変換:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;Method Receiver の暗黙的変換&lt;/h3&gt;

&lt;p&gt;Method receiver を「値渡し」にした場合，呼び出し元の instance がポインタ型であっても暗黙的に「値渡し」に変換される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := &amp;amp;Vertex{X: 1, Y: 2} //pointer
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)  //output: X = 1, Y = 2
	fmt.Println(vv) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Method receiver を「参照渡し」にした場合も暗黙的に「参照渡し」に変換される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := Vertex{X: 1, Y: 2} //not pointer
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;method-receiver-の値が-nil-の場合:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;Method Receiver の値が nil の場合&lt;/h3&gt;

&lt;p&gt;Method receiver の値が nil の場合はどうなるか。
まずは「値渡し」の場合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := (*Vertex)(nil) //nil
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)
	fmt.Println(vv)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合は &lt;code&gt;Add()&lt;/code&gt; 関数呼び出し時に &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; になる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;panic: runtime error: invalid memory address or nil pointer dereference
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まぁこれは分かりやすいよね。
では「参照渡し」の場合はどうなるか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := (*Vertex)(nil) //nil
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: &amp;lt;nil&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は &lt;code&gt;Add()&lt;/code&gt; 関数呼び出し時点では &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; にはならない。
上のコードでは &lt;code&gt;v&lt;/code&gt; に nil が渡される。
したがって &lt;code&gt;Add()&lt;/code&gt; 関数内の条件文を削除すると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (v *Vertex) Add(dv Vertex) {
	v.X += dv.X
	v.Y += dv.Y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;v&lt;/code&gt; 内の要素を参照としたところで &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; になる。
Method receiver を「参照渡し」にする場合は nil 値に注意する必要がある。&lt;/p&gt;

&lt;h2 id=&#34;for-range-構文も-値渡し:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;for-range 構文も「値渡し」&lt;/h2&gt;

&lt;p&gt;余談だが for-range 構文も「値渡し」（つまりコピーが発生する）なので注意が必要である。
たとえば以下のコードで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	ary := []int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	for _, item := range ary {
		item += 10
	}
	fmt.Println(ary) //output: [0 1 2 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for-range 構文内の &lt;code&gt;item&lt;/code&gt; は &lt;code&gt;ary&lt;/code&gt; 内の要素を指すのではなく要素のコピーである。
したがって &lt;code&gt;item&lt;/code&gt; を操作しても &lt;code&gt;ary&lt;/code&gt; には影響しない。
&lt;code&gt;ary&lt;/code&gt; 内の要素を操作するのであれば素朴に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	ary := []int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	for i := 0; i &amp;lt; len(ary); i++ {
		ary[i] += 10
	}
	fmt.Println(ary) //output: [10 11 12 13]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするしかない。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://skatsuta.github.io/2015/12/29/value-receiver-pointer-receiver/&#34;&gt;Go 言語の値レシーバとポインタレシーバ | Step by Step&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:8182ac28bc68eb736cad9fff25d78d28:t&#34;&gt;型については「&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」&lt;/a&gt;」を参照のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8182ac28bc68eb736cad9fff25d78d28:t&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8182ac28bc68eb736cad9fff25d78d28:p&#34;&gt;このコードについては「&lt;a href=&#34;http://text.baldanders.info/golang/error-handling/&#34;&gt;エラー・ハンドリングについて&lt;/a&gt;」で解説している。ちなみに &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を潰して error を返すのはエラー・ハンドリングとしてはいいやり方ではない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8182ac28bc68eb736cad9fff25d78d28:p&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8182ac28bc68eb736cad9fff25d78d28:copy&#34;&gt;値がどこにコピーされるかは型によって異なる。 &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 以外の基本型は値がスタックに積まれる。 &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; および基本型以外はヒープ領域に値がコピーされそのポインタがスタックに積まれる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8182ac28bc68eb736cad9fff25d78d28:copy&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8182ac28bc68eb736cad9fff25d78d28:make&#34;&gt;&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Map_types&#34;&gt;map&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; は内部状態を持つため &lt;code&gt;new()&lt;/code&gt; 関数ではなく &lt;code&gt;make()&lt;/code&gt; 関数で instance を生成する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8182ac28bc68eb736cad9fff25d78d28:make&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8182ac28bc68eb736cad9fff25d78d28:str&#34;&gt;&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型の実体は &lt;code&gt;[]byte&lt;/code&gt; 型である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8182ac28bc68eb736cad9fff25d78d28:str&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8182ac28bc68eb736cad9fff25d78d28:n&#34;&gt;たとえば固定の配列や &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型の instance は nil 値を持たない。 &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型のゼロ値は空文字列である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8182ac28bc68eb736cad9fff25d78d28:n&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>週末スペシャル： サイバーテロ企業 Microsoft - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2016/03/13-stories/" />
		<id>tag:text.Baldanders.info,2016-03-13:/remark/2016/03/13-stories/</id>
		<published>2016-03-13T13:03:59+09:00</published>
		<updated>2016-03-30T00:08:57+09:00</updated>
		<summary>サイバーテロ企業 Microsoft / 3月9日は皆既日食でした / いまさら「2033年問題」 / 『プログラミング言語 Go』</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#win:717e7722a178792caabc6c325915d05e&#34;&gt;サイバーテロ企業 Microsoft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#eclipse:717e7722a178792caabc6c325915d05e&#34;&gt;3月9日は皆既日食でした&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cal:717e7722a178792caabc6c325915d05e&#34;&gt;いまさら「2033年問題」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#prog:717e7722a178792caabc6c325915d05e&#34;&gt;『プログラミング言語 Go』&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;win:717e7722a178792caabc6c325915d05e&#34;&gt;サイバーテロ企業 Microsoft&lt;/h2&gt;

&lt;p&gt;あぁ，ついに知り合いに被害者が出てしまいましたよ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.netandfield.com/shar/2016/03/windows-10.html&#34;&gt;Windows 10 への強引アップデートというサイバーテロについて - 電気ウナギ的○○&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.netandfield.com/shar/2016/03/windows-10-1.html&#34;&gt;Windows 10 への強引アップデートというサイバーテロについて（つづき） - 電気ウナギ的○○&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;しかも &lt;a href=&#34;https://www.instagram.com/p/BC22bDzI4vI/&#34;&gt;Windows 7 に復元した後もトラブってる&lt;/a&gt;ようだ。
はっきりいって昔から Windows のメジャーバージョンのアップグレードはトラブることが多い。
やるなら真っさらな状態からクリーン・インストールしないと。&lt;/p&gt;

&lt;p&gt;今月の Windows Update は特に酷かったようで&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gigazine.net/news/20160311-windows10-nag-in-ie-patch/&#34;&gt;IEのセキュリティパッチにWindows 10アップグレード広告を挿入＆システム管理者にアップグレードを促す広告も現れいよいよMicrosoftの本気度が明らかに - GIGAZINE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://freesoft.tvbok.com/cat97/2016/2016_03_windows_update.html&#34;&gt;2016年3月のWindows Updateの注意事項&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://freesoft.tvbok.com/cat97/2016/gwx_app_2016_03.html&#34;&gt;(2016年3月)Windows10への半強制アップグレードが再び猛威を奮っている模様？(追記あり)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これ集団訴訟起こしたら勝てるんじゃねーの。
私は&lt;a href=&#34;http://text.baldanders.info/remark/2015/windows-10-upgrade-problem/&#34; title=&#34;また Windows 10 にヤラレタ（KB3112343 の恐怖） — しっぽのさきっちょ&#34;&gt;事前に対策&lt;/a&gt;してるので実害ないけど（でも危ないので Windows Update の自動更新は無効にした）。
もう Microsoft 社は「サイバーテロ企業」と認定していいんじゃないかな。
セキュリティ企業各社におかれましては何卒 Microsoft 社の蛮行から防御するツールを開発していただきたい。
買うよ，今なら。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/remark/2015/windows-10-upgrade-problem/&#34; title=&#34;また Windows 10 にヤラレタ（KB3112343 の恐怖） — しっぽのさきっちょ&#34;&gt;前にも書いた&lt;/a&gt;が， Windows 10 が悪いとは言わない（敢えてオススメはしないけど）。
しかし，その気がない人にまで無理やりアップグレードさせようというのは悪質極まる。
しかも今回はセキュリティ・アップデートに広告パッチを混ぜるという蛮行を犯した。
これが evil じゃないとは言わせない。&lt;/p&gt;

&lt;p&gt;Microsoft は Windows を捨てるべきである。
もう OS を売って儲ける時代ではない。
Windows の（マネタイズを含めた）思想は20年以上も&lt;strong&gt;大昔&lt;/strong&gt;のものでインターネットを含む現代の状況にマッチしていない。
自前でカーネルを作るのは諦めて &lt;a href=&#34;http://www.x.org/&#34; title=&#34;X.Org&#34;&gt;X11&lt;/a&gt; 上に Windows 風の GUI shell を構築するとか &lt;a href=&#34;https://www.winehq.org/&#34; title=&#34;WineHQ - Run Windows applications on Linux, BSD, Solaris and Mac OS X&#34;&gt;Wine&lt;/a&gt; にコミットするとかしたほうがいい。
&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/dn878908%28v=vs.110%29.aspx&#34; title=&#34;.NET Core とオープン ソース&#34;&gt;.NET だってオープンソース&lt;/a&gt;にできたんだから，できないことはないだろう。
どうしても Windows を残したいのなら携帯端末でやってくれ。&lt;/p&gt;

&lt;p&gt;2020年までに自宅のメインマシンを &lt;a href=&#34;http://www.ubuntu.com/&#34; title=&#34;The leading OS for PC, tablet, phone and cloud | Ubuntu&#34;&gt;Ubuntu&lt;/a&gt; か何かに換装しようと思ってるのだけど，こりゃあ計画を前倒しにした方がいいかなぁ。&lt;/p&gt;

&lt;p&gt;そうそう， OS X は個人的に「アウト・オブ・眼中」です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stocker.jp/500W/2016/03/12/switch2mac/&#34;&gt;「PCをWin7のままにしておきたいのに強制的にWin10にするMSが嫌だ！Macに行く！」という方へMacユーザーとして言っておきたいこと&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;参考:717e7722a178792caabc6c325915d05e&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.atmarkit.co.jp/ait/articles/1603/18/news047.html&#34;&gt;Tech TIPS：まだWindows 10へアップグレードしたくない人のための設定まとめ - ＠IT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://japan.zdnet.com/article/35080272/&#34;&gt;「Windows 10」自動アップデートをオフにするツール「Never 10」が公開 - ZDNet Japan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;eclipse:717e7722a178792caabc6c325915d05e&#34;&gt;3月9日は皆既日食でした&lt;/h2&gt;

&lt;p&gt;（以下の動画は音楽が流れるので再生時には周りに注意）&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;iframe class=&#34;youtube-player&#34; width=&#34;500&#34;  height=&#34;281&#34; src=&#34;https://www.youtube-nocookie.com/embed/VOdVQnUKmE0&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=VOdVQnUKmE0&#34;&gt;the total solar eclipse time laps movie 2016/皆既日食まとめ動画2016 weathernews - YouTube&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;日本では部分日食だったけど，あいにくの天気で見れなかった人が多そうだ。
今回は人工衛星からの映像が話題になった。
人工衛星からは皆既食の地域が丸い陰となっている。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://www.jma-net.go.jp/sat/data/web89/himawari8_sample_data.html#nisshoku&#34;&gt;&lt;img src=&#34;http://www.jma-net.go.jp/sat/data/web89/parts89/himawari8_sample_data/thumbnail/201603091110_TRC_SolarEclipse_s.png&#34; width=&#34;500&#34; alt=&#34;「ひまわり８号のサンプル画像」より&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;http://www.jma-net.go.jp/sat/data/web89/himawari8_sample_data.html#nisshoku&#34;&gt;「ひまわり８号のサンプル画像」より&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;今年は9月1日に金環日食があるが，これも日本からは見れない。&lt;/p&gt;

&lt;h2 id=&#34;cal:717e7722a178792caabc6c325915d05e&#34;&gt;いまさら「2033年問題」&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://hoshisora.jp/topics/?p=2029&#34;&gt;琉球新報コラム「2033年問題」 | TOPICS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大丈夫だ。
問題ない（笑）&lt;/p&gt;

&lt;p&gt;「2033年問題」について詳しくは国立天文台暦計算室による以下を参照のこと。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://eco.mtk.nao.ac.jp/koyomi/topics/html/topics2014.html&#34;&gt;旧暦2033年問題について&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2033年から2034年の春分にかけて中気&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:717e7722a178792caabc6c325915d05e:c&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:717e7722a178792caabc6c325915d05e:c&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;を含まない朔望月が3回もあり，いわゆる「旧暦」のルール&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;冬至を含む朔望月を11月とする&lt;/li&gt;
&lt;li&gt;春分を含む朔望月を2月とする&lt;/li&gt;
&lt;li&gt;夏至を含む朔望月を5月とする&lt;/li&gt;
&lt;li&gt;秋分を含む朔望月を8月とする&lt;/li&gt;
&lt;li&gt;1年が13ヶ月ある場合，中気を含まない朔望月を閏月とする&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;のうち 1 と 4 が衝突するため，どの月を閏月とすべきか決められないということのようだ。&lt;/p&gt;

&lt;p&gt;ルールにない事態なのだからルールを作ればよい。
具体的には 1 から 4 のルールの中で優先順位を決めればよい。
先程の国立天文台暦計算室の記事では「時憲暦」の「冬至を含む月から次に冬至を含む月までに13か月ある場合に，中気が入らない最初の月を閏月とする」というルールを紹介している。&lt;/p&gt;

&lt;p&gt;ポイントは誰がそれを決めるのか，ということだが&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;あなたが「旧暦」と思うものが「旧暦」です。ただし、他人の賛同を得られるとは限りません&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;でいいんじゃないかな。
得意ぢゃん，日本人って，そういうの。&lt;/p&gt;

&lt;p&gt;「旧暦」は民間暦のひとつに過ぎない。
民間暦なんてものは宗教・宗派あるいは地域で勝手に決めているものなのだから，それぞれのコミュニティで暦を合わせていれば深刻な問題にはならない。
「2033年問題」の場合は「中秋の名月」がいつになるかでちょっともめるくらいだろう。
ちなみに国立天文台には暦を決定する大事な役割がある&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:717e7722a178792caabc6c325915d05e:naoj&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:717e7722a178792caabc6c325915d05e:naoj&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; が民間暦は関知しない。&lt;/p&gt;

&lt;h2 id=&#34;prog:717e7722a178792caabc6c325915d05e&#34;&gt;『プログラミング言語 Go』&lt;/h2&gt;

&lt;p&gt;6月に出るという『&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語 Go&lt;/a&gt;』を買おうかどうか考え中。
&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/0134190440/baldandersinf-22/&#34;&gt;原書&lt;/a&gt;の目次を見るかぎり基本的な部分はちゃんと押さえてるみたいだし「買ってもいいかな」と思ってはいるのだけど。&lt;/p&gt;

&lt;p&gt;ちなみに『&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34;&gt;Go 言語による Web アプリケーション開発&lt;/a&gt;』は既に買った。
ざくっと斜め読みしただけだけど，そのうち役に立つ日が来るかもしれない。&lt;/p&gt;

&lt;p&gt;この手の本は，昔は重宝したけど今は賞味期限が早いので手にした時にはもう骨董品レベルだったりするんだよなぁ。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;はネットにあるドキュメント類が充実しているので正直「書籍」はなくてもいいんだが，英語が中心なので，英語不得手の私としては日本語のまとまったドキュメントが欲しいと思ってしまうわけなのさ。&lt;/p&gt;

&lt;h2 id=&#34;other:717e7722a178792caabc6c325915d05e&#34;&gt;その他の気になる記事&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/syui/items/429962c76f6c3117f351&#34;&gt;GitBookの使用例 - Qiita&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/nacika_ins/items/24b91f654cf2dc59dd81&#34;&gt;Gitbookを高速化する方法 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mattn.kaoriya.net/software/20160309091404.htm&#34;&gt;Big Sky :: コマンドラインから JSON が簡単に作れるツール jo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wired.jp/2016/03/10/five-years-after-fukushimas-contamination/&#34;&gt;福島原発事故から5年：水産物の放射性セシウム汚染の現状 « WIRED.jp&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://swfsc.noaa.gov/textblock.aspx?Division=FRD&amp;amp;id=20593&#34;&gt;Fukushima Radioactivity in U.S. West Coast Tuna - SWFSC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://iopscience.iop.org/1748-9326/7/3/034004/&#34;&gt;Model simulations on the long-term dispersal of 137Cs released into the Pacific Ocean off Fukushima - IOPscience&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hiroshima-cu.ac.jp/modules/peace_j/content0252.html&#34;&gt;『広島平和研究』第3号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://internet.watch.impress.co.jp/docs/news/20160310_747743.html&#34;&gt;TPPでよみがえる“マジコンプレイ違法化”の亡霊、「みなし侵害」で成仏するか？　著作権法改正案が明らかに -INTERNET Watch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://security.srad.jp/story/16/03/10/1530233/&#34;&gt;違法コピーに悩まされる美少女ゲームメーカー、「世界最高レベル」のコピープロテクト実装へ | スラド セキュリティ&lt;/a&gt; : 1ヶ月かそこらで突破されちゃうようなシロモノが「世界最高レベル」なのか？ つか，今時「コピー出来ないソフト」とか，悪人には関係ないし善人には使い勝手が悪いだけだと思うのだが，悪人が利するシステムに意味があるのか？&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://internet.watch.impress.co.jp/docs/news/20160311_747871.html&#34;&gt;GitHub、コメントに「いいね!」など6種類の感情表現が可能に -INTERNET Watch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書:717e7722a178792caabc6c325915d05e&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4416115458/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/51XoyiTnmFL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4416115458/baldandersinf-22/&#34;&gt;天文年鑑2016年版&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;天文年鑑編集委員会 &lt;/dd&gt;&lt;dd&gt;誠文堂新光社 2015-11-16&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4805208899/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4805208899.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;天文手帳 2016年版: 星座早見盤付 天文ポケット年鑑&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/462108965X/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/462108965X.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;理科年表 平成28年&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B016YNZD0I/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B016YNZD0I.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;天文ガイド 2016年 01 月号  [特大号 付録付き]&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B017VPHTX2/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B017VPHTX2.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;月刊 星ナビ 2016年 1月号&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4416115512/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4416115512.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;藤井 旭の天文年鑑 2016年版: スターウォッチング完全ガイド&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;天文ファン必携。2016年版&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2015-12-29&#34;&gt;2015-12-29&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/41aCueik45L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-15&lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117607/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117607.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;マイクロサービスアーキテクチャ&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117402/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117402.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;ハイパフォーマンスPython&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/0134190440/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/0134190440.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;The Go Programming Language (Addison-Wesley Professional Computing Series)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4774166340/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4774166340.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Vim script テクニックバイブル ~Vim使いの魔法の杖&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。買おうかどうか悩み中。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-03-12&#34;&gt;2016-03-12&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/51UoREcNrnL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34;&gt;Go言語によるWebアプリケーション開発&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Mat Ryer 鵜飼 文敏 &lt;/dd&gt;&lt;dd&gt;オライリージャパン 2016-01-22&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;4&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-4-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4621300253.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;プログラミング言語Go&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117607/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117607.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;マイクロサービスアーキテクチャ&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4774178667/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4774178667.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;nginx実践入門 (WEB+DB PRESS plus)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4863541783/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4863541783.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;改訂2版 基礎からわかる Go言語&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4774179930/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4774179930.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;サーバ/インフラエンジニア養成読本 DevOps編 [Infrastructure as Code を実践するノウハウが満載! ] (Software Design plus)&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;日本語監訳者による解説（付録 B）が意外に役に立つ感じ。 Web アプリケーションだけでなく，サーバサイドで動く CLI アプリへの言及もある。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-03-13&#34;&gt;2016-03-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:717e7722a178792caabc6c325915d05e:c&#34;&gt;「中気」は二十四節気のうち冬至を0起点として偶数番目のものを指す。奇数番目のものは「節気」と呼ぶ。現代の二十四節気は天球上の太陽の視黄経（太陽黄経）で決まる（定気法）。例えば太陽が黄経0度を通過した瞬間を含む日が春分となる。ただし二十四節気の暦上の基点は冬至で，古い暦では太陽観測により冬至を確定し次の冬至までの1年を24等分することで二十四節気が決まっていた（平気法）。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:717e7722a178792caabc6c325915d05e:c&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:717e7722a178792caabc6c325915d05e:naoj&#34;&gt;国立天文台では毎年2月1日に翌年の暦を発表する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:717e7722a178792caabc6c325915d05e:naoj&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>「ズンドコチェック」なるものが流行っているらしい - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/zundoko-choir/" />
		<id>tag:text.Baldanders.info,2016-03-12:/golang/zundoko-choir/</id>
		<published>2016-03-12T22:12:53+09:00</published>
		<updated>2016-03-16T17:35:35+09:00</updated>
		<summary>というわけで Go 言語で実装することを考えてみる。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Javaの講義、試験が「自作関数を作り記述しなさい」って問題だったから&lt;br&gt;「ズン」「ドコ」のいずれかをランダムで出力し続けて「ズン」「ズン」「ズン」「ズン」「ドコ」の配列が出たら「キ・ヨ・シ！」って出力した後終了って関数作ったら満点で単位貰ってた&lt;/p&gt;&amp;mdash; てくも (@kumiromilk) &lt;a href=&#34;https://twitter.com/kumiromilk/status/707437861881180160&#34;&gt;2016年3月9日&lt;/a&gt;&lt;/blockquote&gt;


&lt;/figure&gt;

&lt;p&gt;「習作（study）」としてはなかなか秀逸なアイデアだと思う。
これで満点くれる教官も流石だが（笑） 巷では「ズンドコキヨシ」とか「キヨシチェック」とか「ズンドコチェック」とか呼ばれているらしい。&lt;/p&gt;

&lt;p&gt;というわけで&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;「ズン」「ドコ」のいずれかをランダムで出力し続けて「ズン」「ズン」「ズン」「ズン」「ドコ」の配列が出たら「キ・ヨ・シ！」って出力した後終了って関数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;を &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で実装することを考えてみる。
私はコレを「ズンドコ・コール（zundoko-choir）」と呼ぶことにする。&lt;/p&gt;

&lt;p&gt;とはいえ，ズンドコ・コールを実装する事自体はそう難しくない。
たとえばこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;
)

const (
	zun     = &amp;quot;ズン&amp;quot;
	doko    = &amp;quot;ドコ&amp;quot;
	kiyoshi = &amp;quot;キ・ヨ・シ！&amp;quot;
)

func generate() chan string {
	ch := make(chan string)
	go func() {
		var zundoko = [2]string{zun, doko}
		rand.Seed(time.Now().UnixNano())
		for {
			ch &amp;lt;- zundoko[rand.Intn(2)]
		}
	}()
	return ch
}

func main() {
	zundoko := generate()
	zcount := 0
	for {
		zd := &amp;lt;-zundoko
		fmt.Print(zd)
		if zd == zun {
			zcount++
		} else if zcount &amp;gt;= 4 {
			break
		} else {
			zcount = 0
		}
	}
	fmt.Print(kiyoshi)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「ズン」および「ドコ」をランダムに生成する部分は &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; と &lt;a href=&#34;http://golang.org/ref/spec#Go_statements&#34;&gt;goroutine&lt;/a&gt; を使えばいいだろう（&lt;code&gt;generate()&lt;/code&gt; 関数内の処理）。
擬似乱数は厳密でなくてもいいので安直に &lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; を使うことにした&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ba7781b05a447c47fa6bc5c87477853e:rand&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ba7781b05a447c47fa6bc5c87477853e:rand&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
さらに「ズン」「ズン」「ズン」「ズン」「ドコ」の配列パターンのチェックだが，「ズン」が4回以上連続で来た直後に「ドコ」が来たら OK としてみた。
まぁ，これがもっとも素朴な実装でパフォーマンスとしてもそれほど遜色ない筈。&lt;/p&gt;

&lt;p&gt;と，ここまで考えてハタと気づいた。
問題は「自作関数を作り記述しなさい」なんだからメイン関数にロジック書いたらアカンやん！&lt;/p&gt;

&lt;p&gt;というわけでまたもゴリゴリとコードを書いてパッケージにしてしまった。
アホだ，私（笑）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/zundoko&#34;&gt;spiegel-im-spiegel/zundoko: Zundoko-choirs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;出力は標準出力に直書きするのではなく &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; の &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; に &lt;code&gt;append()&lt;/code&gt; することで実現する。
この出力先を &lt;code&gt;Choirs&lt;/code&gt; 型として定義した。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Choirs - zundoko-choirs list
type Choirs struct {
	c []string
}

//Push is append choirs
func (c *Choirs) Push(s string) {
	c.c = append(c.c, s) //maybe panic if c is nil.
}

func (c *Choirs) String() string {
	if c == nil {
		return &amp;quot;&amp;quot;
	}
	content := make([]byte, 0, 128)
	for _, s := range c.c {
		content = append(content, s...)
	}
	return string(content)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに文字列の連結は &lt;a href=&#34;https://golang.org/pkg/strings/&#34; title=&#34;strings - The Go Programming Language&#34;&gt;&lt;code&gt;strings&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Join()&lt;/code&gt; 関数は使わず「&lt;a href=&#34;http://text.baldanders.info/golang/join-strings/&#34; title=&#34;文字列連結はどれが速い？ — プログラミング言語 Go&#34;&gt;文字列連結はどれが速い？&lt;/a&gt;」で紹介した方法を使っている。&lt;/p&gt;

&lt;p&gt;これで最初のコードは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func generate() chan string {
	ch := make(chan string)
	go func() {
		var zd = [2]string{Zun, Doko}
		rand.Seed(time.Now().UnixNano())
		for {
			ch &amp;lt;- zd[rand.Intn(2)]
		}
	}()
	return ch
}

//Run zundoko-choirs
func Run() *Choirs {
	zd := generate()
	c := &amp;amp;Choirs{make([]string, 0)}
	zcount := 0
	for {
		s := &amp;lt;-zd
		c.Push(s)
		if s == Zun {
			zcount++
		} else if zcount &amp;gt;= 4 {
			break
		} else {
			zcount = 0
		}
	}
	c.Push(Kiyoshi)
	return c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書き換えることができる。
このパッケージを呼び出すメイン側は例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/zundoko&amp;quot;
)

func main() {
	c := zundoko.Run()
	fmt.Println(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書けばいい。&lt;/p&gt;

&lt;p&gt;ところで「ズン」「ドコ」の出力は &lt;code&gt;Choirs&lt;/code&gt; 型で保持られているので，末尾の5要素のパターンを調べる別の方法もあると気づく。
たとえばこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var matchingPattern = []string{Zun, Zun, Zun, Zun, Doko}

func (c *Choirs) match() bool {
	if c == nil {
		return false
	}
	if len(c.c) &amp;lt; 5 {
		return false
	}
	return reflect.DeepEqual(c.c[len(c.c)-5:], matchingPattern)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この関数を使えば &lt;code&gt;Run()&lt;/code&gt; 関数は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Run2 zundoko-choirs (another logic)
func Run2() *Choirs {
	zd := generate()
	c := &amp;amp;Choirs{make([]string, 0)}
	for {
		s := &amp;lt;-zd
		c.Push(s)
		if c.match() {
			break
		}
	}
	c.Push(Kiyoshi)
	return c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり随分すっきりする。
ただこれコストが高くつきそうである。
というわけで，これも調べてみた。
まず以下のベンチマークを書く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package zundoko

import &amp;quot;testing&amp;quot;

func BenchmarkRun1(b *testing.B) {
	for i := 0; i &amp;lt; b.N; i++ {
		Run()
	}
}

func BenchmarkRun2(b *testing.B) {
	for i := 0; i &amp;lt; b.N; i++ {
		Run2()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;BenchmarkRun1&lt;/code&gt; が従来のもの， &lt;code&gt;BenchmarkRun2&lt;/code&gt; が先程の &lt;code&gt;match()&lt;/code&gt; 関数を使ったバージョンである。
結果は以下のとおり。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go test -bench Run -benchmem
testing: warning: no tests to run
PASS
BenchmarkRun1-4    50000     28141 ns/op    1800 B/op     9 allocs/op
BenchmarkRun2-4    30000     40102 ns/op    3912 B/op   115 allocs/op
ok      github.com/spiegel-im-spiegel/zundoko   4.261s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;乱数の要素が絡むので毎回同じ値ではないが，傾向としてはこんな感じ。
&lt;code&gt;BenchmarkRun2&lt;/code&gt; のほうが allocation 回数が圧倒的に多いのが分かるだろう。
これがスピードにもダイレクトに反映されている感じである。&lt;/p&gt;

&lt;p&gt;今回は「「ズン」が4回以上連続で来た直後に「ドコ」が来たら OK」という単純なロジックだったが，もっと複雑なパターンが要求される場合は工夫が必要かもしれない&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ba7781b05a447c47fa6bc5c87477853e:lr&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ba7781b05a447c47fa6bc5c87477853e:lr&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;「ズン」と「ドコ」の出現回数を数える関数も作ってみた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//CountZunDoko returns count of &amp;quot;ZUN&amp;quot; and &amp;quot;DOKO&amp;quot; choirs
func (c *Choirs) CountZunDoko() (int, int) {
	z := 0
	d := 0
	if c == nil {
		return z, d
	}
	for _, s := range c.c {
		switch s {
		case Zun:
			z++
		case Doko:
			d++
		}
	}
	return z, d
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;たとえば &lt;code&gt;generate()&lt;/code&gt; 関数内で使っている擬似乱数パッケージを別のものに換えた時に統計処理で簡単な性能評価ができるかもしれない。
今回はそこまではしなけど（擬似乱数の話はいずれやりたい）。&lt;/p&gt;

&lt;p&gt;こうやって手遊びでコードを弄るのは楽しいものである。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:ba7781b05a447c47fa6bc5c87477853e&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/shunsugai@github/items/971a15461de29563bf90&#34;&gt;ズンドコキヨシまとめ - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/shinderuman@github/items/2ff67c2404647d2b7ea6&#34;&gt;ズンドコキヨシ with Go (n番煎じ) - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/Rompei/items/bfa03fbc9a94a37703bb&#34;&gt;ズンドコキヨシGolang並列版 - Qiita&lt;/a&gt; : 「ズン」「ドコ」の生成部分を CPU の数だけ並列処理で行わせてひとつの &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; に入力するというユニークな実装&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/6a5bc07dbfa46a328e26&#34;&gt;「ズンドコキヨシ」と擬似乱数 - Qiita&lt;/a&gt; : Qiita で擬似乱数について簡単にまとめてみた。整理できたらこちらでも記事にするかも&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書:ba7781b05a447c47fa6bc5c87477853e&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/41aCueik45L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-15&lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117607/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117607.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;マイクロサービスアーキテクチャ&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117402/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117402.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;ハイパフォーマンスPython&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/0134190440/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/0134190440.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;The Go Programming Language (Addison-Wesley Professional Computing Series)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4774166340/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4774166340.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Vim script テクニックバイブル ~Vim使いの魔法の杖&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。買おうかどうか悩み中。目次があればなぁ。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-03-12&#34;&gt;2016-03-12&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:ba7781b05a447c47fa6bc5c87477853e:rand&#34;&gt;&lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; の乱数生成アルゴリズムの既定は線形合同法らしい。&lt;a href=&#34;http://www001.upp.so-net.ne.jp/isaku/rand.html&#34; title=&#34;良い乱数・悪い乱数&#34;&gt;線形合同法は性能が良くなく&lt;/a&gt;ゲームや暗号等では使えない。&lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; の乱数生成アルゴリズムは他のものに入れ替えることができる。たとえば &lt;a href=&#34;https://github.com/seehuhn/mt19937&#34; title=&#34;seehuhn/mt19937: An implementation of Takuji Nishimura&#39;s and Makoto Matsumoto&#39;s Mersenne Twister pseudo random number generator in Go.&#34;&gt;&lt;code&gt;seehuhn/mt19937&lt;/code&gt;&lt;/a&gt; パッケージが使える。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ba7781b05a447c47fa6bc5c87477853e:rand&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:ba7781b05a447c47fa6bc5c87477853e:lr&#34;&gt;たとえば &lt;a href=&#34;https://golang.org/pkg/container/list/&#34; title=&#34;list - The Go Programming Language&#34;&gt;&lt;code&gt;container/list&lt;/code&gt;&lt;/a&gt; や &lt;a href=&#34;https://golang.org/pkg/container/ring/&#34; title=&#34;ring - The Go Programming Language&#34;&gt;&lt;code&gt;container/ring&lt;/code&gt;&lt;/a&gt; といったパッケージを使う手がある。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ba7781b05a447c47fa6bc5c87477853e:lr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>icat4json 公開 - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2016/02/icat4json/" />
		<id>tag:text.Baldanders.info,2016-02-25:/remark/2016/02/icat4json/</id>
		<published>2016-02-25T16:45:01+09:00</published>
		<updated>2016-02-26T17:40:58+09:00</updated>
		<summary>IPA が提供する “icat for JSON” にアクセスする Go 言語用のパッケージを公開した。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">&lt;p&gt;IPA が提供する “&lt;a href=&#34;https://www.ipa.go.jp/security/vuln/icat.html&#34; title=&#34;サイバーセキュリティ注意喚起サービス「icat for JSON」：IPA 独立行政法人 情報処理推進機構&#34;&gt;icat for JSON&lt;/a&gt;” にアクセスする &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;用のパッケージを公開した。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/icat4json&#34; title=&#34;spiegel-im-spiegel/icat4json: icat for JSON with Golang&#34;&gt;github.com/spiegel-im-spiegel/icat4json&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下のような感じで使える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/icat4json&amp;quot;
)

func main() {
	json, err := icat4json.Get(icat4json.ToolICATW)
	if err != nil {
		log.Fatal(err)
	}
	data, err := json.Decode()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf(&amp;quot;Title: %v\n&amp;quot;, data.Title)
	fmt.Printf(&amp;quot;  URL: %v\n&amp;quot;, data.Link)
	fmt.Printf(&amp;quot; Date: %v\n&amp;quot;, data.Date)
	fmt.Print(&amp;quot;Items:\n&amp;quot;)
	for _, item := range data.Itemdata {
		fmt.Printf(&amp;quot;\t%v: %v (%v)\n&amp;quot;, item.Date, item.Title, item.Link)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run sample.go
Title: IPAセキュリティセンター:重要なセキュリティ情報
  URL: https://www.ipa.go.jp/security/vuln/icat.html
 Date: 2016-02-10 11:58:22 +0900 JST
Items:
	2016-02-10 12:00:00 +0900 JST: Microsoft 製品の脆弱性対策について(2016年02月) (http://www.ipa.go.jp/security/ciadr/vul/20160210-ms.html)
	2016-02-10 12:00:00 +0900 JST: Adobe Flash Player の脆弱性対策について(APSB16-04)(CVE-2016-0985等) (http://www.ipa.go.jp/security/ciadr/vul/20160210-adobeflashplayer.html)
	2016-01-20 12:00:00 +0900 JST: Oracle Java の脆弱性対策について(CVE-2016-0494等) (http://www.ipa.go.jp/security/ciadr/vul/20160120-jre.html)
	2016-01-13 12:00:00 +0900 JST: Microsoft 製品の脆弱性対策について(2016年01月) (http://www.ipa.go.jp/security/ciadr/vul/20160113-ms.html)
	2016-01-13 12:00:00 +0900 JST: Adobe Reader および Acrobat の脆弱性対策について(APSB16-02)(CVE-2016-0932等) (http://www.ipa.go.jp/security/ciadr/vul/20160113-adobereader.html)
	2016-01-06 16:40:00 +0900 JST: 【注意喚起】インターネットに接続する複合機等のオフィス機器の再点検を！ (http://www.ipa.go.jp/security/ciadr/vul/20160106-printer.html)
	2016-01-05 14:00:00 +0900 JST: 「DXライブラリ」におけるバッファオーバーフローの脆弱性対策について(JVN#49476817) (http://www.ipa.go.jp/security/ciadr/vul/20160105-jvn.html)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“&lt;a href=&#34;https://www.ipa.go.jp/security/vuln/icat.html&#34; title=&#34;サイバーセキュリティ注意喚起サービス「icat for JSON」：IPA 独立行政法人 情報処理推進機構&#34;&gt;icat for JSON&lt;/a&gt;” という名前なのに IPA は API の仕様を公開していない。
そこで JavaScript コードの中身を見てみた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/4acefe47d3dda688a03e&#34;&gt;icat for JSON について - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/icat4json&#34; title=&#34;spiegel-im-spiegel/icat4json: icat for JSON with Golang&#34;&gt;&lt;code&gt;icat4json&lt;/code&gt;&lt;/a&gt; パッケージでは “&lt;a href=&#34;https://www.ipa.go.jp/security/vuln/icat.html&#34; title=&#34;サイバーセキュリティ注意喚起サービス「icat for JSON」：IPA 独立行政法人 情報処理推進機構&#34;&gt;icat for JSON&lt;/a&gt;” から取得した JSON データを以下の構造体にデコードする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Item - itemdata from icat
type Item struct {
	Title      string    `json:&amp;quot;item_title&amp;quot;`
	Link       string    `json:&amp;quot;item_link&amp;quot;`
	Date       time.Time `json:&amp;quot;item_date&amp;quot;`
	Identifier []string  `json:&amp;quot;item_identifier&amp;quot;`
}

//ICAT - data from icat
type ICAT struct {
	Itemdata []Item    `json:&amp;quot;itemdata&amp;quot;`
	Title    string    `json:&amp;quot;docTitle&amp;quot;`
	Fix      string    `json:&amp;quot;docTitleFix&amp;quot;`
	Link     string    `json:&amp;quot;docLink&amp;quot;`
	Date     time.Time `json:&amp;quot;docDate&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript コードを見ると &lt;code&gt;item_identifier&lt;/code&gt; 項目は使ってない模様。
&lt;code&gt;docTitleFix&lt;/code&gt; 項目は中身が &lt;code&gt;null&lt;/code&gt; かどうかしかチェックしてなくて&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2f15d11d1611e9dd61fef23ed1583d23:s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2f15d11d1611e9dd61fef23ed1583d23:s&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;， &lt;code&gt;null&lt;/code&gt; 以外だと &lt;code&gt;htmlentities()&lt;/code&gt; 関数を通さずに素のまま表示するという恐ろしいことをしている（普通こういうのって boolean 値を使うんじゃないのか？）。
これらの項目は無視でもいいだろう。
本当は IPA が仕様を公開してくれると有難いんだけどねぇ。&lt;/p&gt;

&lt;p&gt;脆弱性情報をクライアントサイドで取るのなら “&lt;a href=&#34;https://www.ipa.go.jp/security/vuln/icat.html&#34; title=&#34;サイバーセキュリティ注意喚起サービス「icat for JSON」：IPA 独立行政法人 情報処理推進機構&#34;&gt;icat for JSON&lt;/a&gt;” ではなく Twitter の @&lt;a href=&#34;https://twitter.com/ICATalerts/&#34;&gt;ICATalerts&lt;/a&gt; アカウントのタイム・ラインをチェックするほうがオススメ。
JSON データを使うのならサーバサイドでやるべきだよね。
&lt;a href=&#34;https://github.com/spiegel-im-spiegel/icat4json&#34; title=&#34;spiegel-im-spiegel/icat4json: icat for JSON with Golang&#34;&gt;&lt;code&gt;icat4json&lt;/code&gt;&lt;/a&gt; パッケージはドメイン・レイヤのエンティティとして使われることを意識している。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/icat4json.svg&#34;&gt;&lt;img src=&#34;http://text.baldanders.info/images/icat4json.svg&#34; alt=&#34;icat4json entity&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;http://text.baldanders.info/images/icat4json.svg&#34;&gt;icat4json entity&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;私はたまたま &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;を勉強中なので &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のパッケージとして実装したけど，本当なら Java とか Ruby とか node.js とかサーバサイドの実装があるといいよね。
IPA も jQuery じゃなくて，そういうので実装すればいいのに。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:2f15d11d1611e9dd61fef23ed1583d23:s&#34;&gt;ところで &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;における &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; の実体は &lt;code&gt;[]byte&lt;/code&gt; だが nil 状態はない。 &lt;a href=&#34;https://github.com/spiegel-im-spiegel/icat4json&#34; title=&#34;spiegel-im-spiegel/icat4json: icat for JSON with Golang&#34;&gt;&lt;code&gt;icat4json&lt;/code&gt;&lt;/a&gt; パッケージでは &lt;code&gt;docTitleFix&lt;/code&gt; 項目が &lt;code&gt;null&lt;/code&gt; の場合は空文字列に展開される。 JSON の &lt;code&gt;null&lt;/code&gt; 状態を区別したいのであれば &lt;a href=&#34;https://github.com/guregu/null&#34; title=&#34;guregu/null: reasonable handling of nullable values&#34;&gt;&lt;code&gt;github.com/guregu/null&lt;/code&gt;&lt;/a&gt; パッケージ等を使う手もある。ちなみに &lt;a href=&#34;https://github.com/guregu/null&#34; title=&#34;guregu/null: reasonable handling of nullable values&#34;&gt;&lt;code&gt;github.com/guregu/null&lt;/code&gt;&lt;/a&gt; パッケージの型の実体は &lt;a href=&#34;https://golang.org/pkg/database/sql/&#34; title=&#34;sql - The Go Programming Language&#34;&gt;&lt;code&gt;database/sql&lt;/code&gt;&lt;/a&gt; の &lt;code&gt;NullString&lt;/code&gt; 型等である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2f15d11d1611e9dd61fef23ed1583d23:s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Interface の謎 - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/interface/" />
		<id>tag:text.Baldanders.info,2016-02-22:/golang/interface/</id>
		<published>2016-02-22T19:22:33+09:00</published>
		<updated>2016-02-22T20:53:30+09:00</updated>
		<summary>Interface には落とし穴がある。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回も軽めの小ネタで。&lt;/p&gt;

&lt;p&gt;まず，文字列の配列を表示するだけの単純なコードを書いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	strlist := []string{&amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;gamma&amp;quot;}
	fmt.Println(strlist)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;[alpha beta gamma]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。
配列&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a38e724b1dfc1725327e2aea22a2a689:s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a38e724b1dfc1725327e2aea22a2a689:s&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; の中身をそのままダンプ出力しているだけなので，まぁ当たり前っちゃあ当たり前。
では，配列のダンプではなくきちんと項目を列挙したいとしよう。
やり方は色々あるが簡単に &amp;ldquo;&lt;code&gt;...&lt;/code&gt;” トークンを使って&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	strlist := []string{&amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;gamma&amp;quot;}
	fmt.Println(strlist...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と配列を展開すればいんじゃね？ って思うよね，普通。
&lt;a href=&#34;https://golang.org/pkg/fmt/&#34; title=&#34;fmt - The Go Programming Language&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Println()&lt;/code&gt; 関数の定義を見ても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Println(a ...interface{}) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっているし，問題ないように見える。&lt;/p&gt;

&lt;p&gt;でもこれはうまくいかない。
これを実行しようとすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;prog.go:7: cannot use strlist (type []string) as type []interface {} in argument to fmt.Println
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とエラーになる。&lt;/p&gt;

&lt;p&gt;実は &lt;code&gt;[]string&lt;/code&gt; 型の &lt;code&gt;strlist&lt;/code&gt; は &lt;a href=&#34;https://golang.org/pkg/fmt/&#34; title=&#34;fmt - The Go Programming Language&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Println()&lt;/code&gt; 関数に渡す際に &lt;code&gt;[]interface{}&lt;/code&gt; 型ではなく &lt;code&gt;interface{}&lt;/code&gt; 型に&lt;strong&gt;必ず&lt;/strong&gt;キャストされる。
だから &lt;code&gt;strlist...&lt;/code&gt; と展開しようとしても「そりゃあ無理（←超意訳）」と怒られてしまうわけだ。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の型（&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt;）は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Msg []string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように配列やポインタも型として定義できてしまうことを&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;思い出して&lt;/a&gt;欲しい。&lt;/p&gt;

&lt;p&gt;じゃあ，明示的なキャストならいけるのかと思ったが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Msg []string

func main() {
	strlist := []string{&amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;gamma&amp;quot;}
	fmt.Println(([]interface{})(strlist)...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;prog.go:9: cannot convert strlist (type []string) to type []interface {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と，これもエラーになった。&lt;/p&gt;

&lt;p&gt;ではどうすればいいのかというと &lt;code&gt;[]interface{}&lt;/code&gt; 型の配列を用意してそこに値をコピーする。
先程のコードであれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Msg []string

func main() {
	strlist := []string{&amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;gamma&amp;quot;}
	var list = make([]interface{}, 0)
	for _, str := range strlist {
		list = append(list, str)
	}
	fmt.Println(list...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;alpha beta gamma
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにめでたく列挙される。
この問題は &lt;a href=&#34;https://golang.org/pkg/fmt/&#34; title=&#34;fmt - The Go Programming Language&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Println()&lt;/code&gt; 関数だけじゃなく，ある型の配列を &lt;code&gt;[]interface{}&lt;/code&gt; 型にキャストしようとする際は必ず発生するようだ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a38e724b1dfc1725327e2aea22a2a689:c&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a38e724b1dfc1725327e2aea22a2a689:c&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;いや，「“&lt;code&gt;cannot use strlist (type []string) as type []interface {} in argument to fmt.Println&lt;/code&gt;” なんてコンパイルエラーを出せるならコンパイラ側でなんとかしてよ」と思うのだが，どうも無理らしい。&lt;/p&gt;

&lt;p&gt;やれやれ。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:a38e724b1dfc1725327e2aea22a2a689&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@tucnak/why-go-is-a-poorly-designed-language-1cc04e5daf2#.ucutrogyz&#34;&gt;Why Go is a poorly designed language — Medium&lt;/a&gt; （&lt;a href=&#34;http://postd.cc/why-go-is-a-poorly-designed-language/&#34;&gt;日本語訳&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/wiki/InterfaceSlice&#34;&gt;InterfaceSlice · golang/go Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:a38e724b1dfc1725327e2aea22a2a689:s&#34;&gt;厳密には &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;。分かってますよ，もちろん。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a38e724b1dfc1725327e2aea22a2a689:s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:a38e724b1dfc1725327e2aea22a2a689:c&#34;&gt;例えば &lt;code&gt;list&lt;/code&gt; に &lt;code&gt;strlist&lt;/code&gt; の内容をコピーする際に for 文で回すのではなく &lt;code&gt;list = append(list, strlist...)&lt;/code&gt; でできるかどうか試してみればいい。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a38e724b1dfc1725327e2aea22a2a689:c&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Travis CI でクロス・コンパイル - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/cross-compiling-in-travis-ci/" />
		<id>tag:text.Baldanders.info,2016-02-13:/golang/cross-compiling-in-travis-ci/</id>
		<published>2016-02-13T19:37:11+09:00</published>
		<updated>2016-02-25T09:39:28+09:00</updated>
		<summary>今回は Travis CI から GitHub へ mitchellh/gox で生成した実行バイナリを deploy することを考える。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;h2 id=&#34;gox-でまとめてクロス-コンパイル:fa953b67964726c338be9843a0c52e04&#34;&gt;Gox でまとめてクロス・コンパイル&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の特徴のひとつにクロス・コンパイルの容易さがあるが，複数プラットフォームのビルドをまとめて行う &lt;a href=&#34;https://github.com/mitchellh/gox&#34; title=&#34;mitchellh/gox: A dead simple, no frills Go cross compile tool&#34;&gt;mitchellh/gox&lt;/a&gt; を使うと便利である。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go get github.com/mitchellh/gox

$gox -h
Usage: gox [options] [packages]

  Gox cross-compiles Go applications in parallel.

  If no specific operating systems or architectures are specified, Gox
  will build for all pairs supported by your version of Go.

Options:

  -arch=&amp;quot;&amp;quot;            Space-separated list of architectures to build for
  -build-toolchain    Build cross-compilation toolchain
  -cgo                Sets CGO_ENABLED=1, requires proper C toolchain (advanced)
  -gcflags=&amp;quot;&amp;quot;         Additional &#39;-gcflags&#39; value to pass to go build
  -ldflags=&amp;quot;&amp;quot;         Additional &#39;-ldflags&#39; value to pass to go build
  -tags=&amp;quot;&amp;quot;            Additional &#39;-tags&#39; value to pass to go build
  -os=&amp;quot;&amp;quot;              Space-separated list of operating systems to build for
  -osarch=&amp;quot;&amp;quot;          Space-separated list of os/arch pairs to build for
  -osarch-list        List supported os/arch pairs for your Go version
  -output=&amp;quot;foo&amp;quot;       Output path template. See below for more info
  -parallel=-1        Amount of parallelism, defaults to number of CPUs
  -rebuild            Force rebuilding of package that were up to date
  -verbose            Verbose mode

Output path template:

  The output path for the compiled binaries is specified with the
  &amp;quot;-output&amp;quot; flag. The value is a string that is a Go text template.
  The default value is &amp;quot;{{.Dir}}_{{.OS}}_{{.Arch}}&amp;quot;. The variables and
  their values should be self-explanatory.

Platforms (OS/Arch):

  The operating systems and architectures to cross-compile for may be
  specified with the &amp;quot;-arch&amp;quot; and &amp;quot;-os&amp;quot; flags. These are space separated lists
  of valid GOOS/GOARCH values to build for, respectively. You may prefix an
  OS or Arch with &amp;quot;!&amp;quot; to negate and not build for that platform. If the list
  is made up of only negations, then the negations will come from the default
  list.

  Additionally, the &amp;quot;-osarch&amp;quot; flag may be used to specify complete os/arch
  pairs that should be built or ignored. The syntax for this is what you would
  expect: &amp;quot;darwin/amd64&amp;quot; would be a valid osarch value. Multiple can be space
  separated. An os/arch pair can begin with &amp;quot;!&amp;quot; to not build for that platform.

  The &amp;quot;-osarch&amp;quot; flag has the highest precedent when determing whether to
  build for a platform. If it is included in the &amp;quot;-osarch&amp;quot; list, it will be
  built even if the specific os and arch is negated in &amp;quot;-os&amp;quot; and &amp;quot;-arch&amp;quot;,
  respectively.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;オプションは色々あるが，とりあえずパッケージを指定して起動すれば全てのプラットフォームについてビルドを行う&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fa953b67964726c338be9843a0c52e04:bt&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fa953b67964726c338be9843a0c52e04:bt&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
私が今つくってる &lt;a href=&#34;https://github.com/spiegel-im-spiegel/gpgpdump&#34; title=&#34;spiegel-im-spiegel/gpgpdump: gpgpdump - OpenPGP packet visualizer&#34;&gt;gpgpdump&lt;/a&gt; を例にすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go get get github.com/spiegel-im-spiegel/gpgpdump

$ gox -output &amp;quot;goxdist/{{.OS}}_{{.Arch}}/{{.Dir}}&amp;quot; github.com/spiegel-im-spiegel/gpgpdump

--&amp;gt;      netbsd/arm: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;   windows/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;   freebsd/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;      darwin/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;    darwin/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;       linux/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     linux/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;       linux/arm: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     freebsd/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;      netbsd/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     freebsd/arm: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;    netbsd/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;   openbsd/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     openbsd/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     windows/386: github.com/spiegel-im-spiegel/gpgpdump

$ ls -l goxdist
drwx 0 2016-02-13 17:41 darwin_386/
drwx 0 2016-02-13 17:41 darwin_amd64/
drwx 0 2016-02-13 17:42 freebsd_386/
drwx 0 2016-02-13 17:41 freebsd_amd64/
drwx 0 2016-02-13 17:42 freebsd_arm/
drwx 0 2016-02-13 17:41 linux_386/
drwx 0 2016-02-13 17:41 linux_amd64/
drwx 0 2016-02-13 17:42 linux_arm/
drwx 0 2016-02-13 17:42 netbsd_386/
drwx 0 2016-02-13 17:42 netbsd_amd64/
drwx 0 2016-02-13 17:41 netbsd_arm/
drwx 0 2016-02-13 17:42 openbsd_386/
drwx 0 2016-02-13 17:42 openbsd_amd64/
drwx 0 2016-02-13 17:42 windows_386/
drwx 0 2016-02-13 17:41 windows_amd64/

$ ls -l goxdist/windows_amd64
-rw- 5712896 2016-02-13 17:41 gpgpdump.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といい感じに出力してくれる。&lt;/p&gt;

&lt;p&gt;OS を指定する場合は &lt;code&gt;-os &amp;quot;linux windows&amp;quot;&lt;/code&gt; のように指定する。
アーキテクチャは &lt;code&gt;-arch&lt;/code&gt; オプションを， OS とアーキテクチャを組み合わせる場合は &lt;code&gt;-osarch linux/arm&lt;/code&gt; などとする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-output&lt;/code&gt; オプションの &lt;code&gt;&amp;quot;goxdist/{{.OS}}_{{.Arch}}/{{.Dir}}&amp;quot;&lt;/code&gt; は出力先のテンプレートで &lt;code&gt;{{ }}&lt;/code&gt; で囲まれている部分に実際の値が埋め込まれる。
たとえば OS が windows でアーキテクチャが amd64 なら &lt;code&gt;goxdist/windows_amd64/gpgpdump&lt;/code&gt; と展開されるわけだ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fa953b67964726c338be9843a0c52e04:tpl&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fa953b67964726c338be9843a0c52e04:tpl&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;このようにクロス・コンパイルが非常に簡単なので &lt;a href=&#34;https://travis-ci.org/&#34; title=&#34;Travis CI - Test and Deploy Your Code with Confidence&#34;&gt;Travis CI&lt;/a&gt; などで複数プラットフォームのバイナリを生成するのも難しくない。&lt;/p&gt;

&lt;h2 id=&#34;ghr-を使って-github-に-deploy-する:fa953b67964726c338be9843a0c52e04&#34;&gt;ghr を使って GitHub に Deploy する&lt;/h2&gt;

&lt;p&gt;今回は &lt;a href=&#34;https://travis-ci.org/&#34; title=&#34;Travis CI - Test and Deploy Your Code with Confidence&#34;&gt;Travis CI&lt;/a&gt; から &lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; へ &lt;a href=&#34;https://github.com/mitchellh/gox&#34; title=&#34;mitchellh/gox: A dead simple, no frills Go cross compile tool&#34;&gt;mitchellh/gox&lt;/a&gt; で生成した実行バイナリを deploy することを考える。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mitchellh/gox&#34; title=&#34;mitchellh/gox: A dead simple, no frills Go cross compile tool&#34;&gt;mitchellh/gox&lt;/a&gt; で生成した実行バイナリをそのままアップしてもいいのだが，ちょっと気持ち悪いので&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fa953b67964726c338be9843a0c52e04:s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fa953b67964726c338be9843a0c52e04:s&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，まずは zip で固めてしまおう。
以下のような簡単な shell script を書いてみた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

DIR=`pwd`
mkdir ./goxdist/dist
for PLATFORM in $(find ./goxdist -mindepth 1 -maxdepth 1 -type d); do
    PLATFORM_NAME=$(basename ${PLATFORM})

    if [ ${PLATFORM_NAME} = &amp;quot;dist&amp;quot; ]; then
        continue
    fi

    cd ${PLATFORM}
    zip ${DIR}/goxdist/dist/${PLATFORM_NAME}.zip ./*
    cd ${DIR}
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先ほど &lt;code&gt;goxdist&lt;/code&gt; フォルダ以下に生成した各バイナリをひとつづつ zip 圧縮して &lt;code&gt;goxdist/dist&lt;/code&gt; フォルダに置くだけの簡単なお仕事。
これで &lt;code&gt;goxdist/dist&lt;/code&gt; フォルダの中身を &lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; に deploy すればよい。
&lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; への deploy には &lt;a href=&#34;https://github.com/tcnksm/ghr&#34; title=&#34;tcnksm/ghr: Create Github Release and upload artifacts in parallel&#34;&gt;tcnksm/ghr&lt;/a&gt; が便利である。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go get github.com/tcnksm/ghr

$ ghr -h

Usage: ghr [options] TAG PATH

  ghr is a tool to create Release on Github and upload your artifacts to
  it. ghr parallelizes upload multiple artifacts.

  You can use ghr on GitHub Enterprise. Change URL by GITHUB_API env var.

Options:

  --username, -u        GitHub username. By default, ghr extracts user
                        name from global gitconfig value.

  --repository, -r      GitHub repository name. By default, ghr extracts
                        repository name from current directory&#39;s .git/config
                        value.

  --token, -t           GitHub API Token. To use ghr, you will first need
                        to create a GitHub API token with an account which
                        has enough permissions to be able to create releases.
                        You can set this value via GITHUB_TOKEN env var.

  --parallel=-1         Parallelization factor. This option limit amount
                        of parallelism of uploading. By default, ghr uses
                        number of logic CPU of your PC.

  --delete              Delete release if it already created. If you want
                        to recreate release itself from begining, use
                        this. Just want to upload same artifacts to same
                        release again, use --replace option.

  --replace             Replace artifacts if it is already uploaded. Same
                        artifact measn, same release and same artifact
                        name.

  --stat=false          Show number of download of each release and quit.
                        This is special command.

Examples:

  $ ghr v1.0 dist/     Upload all artifacts which are in dist directory
                       with version v1.0.

  $ ghr --stat         Show download number of each relase and quit.

$ ghr --username spiegel-im-spiegel --token $GITHUB_TOKEN v0.1.2 goxdist/dist/
--&amp;gt; Uploading: windows_amd64_v0.1.2.zip
--&amp;gt; Uploading: linux_amd64_v0.1.2.zip
--&amp;gt; Uploading: darwin_386_v0.1.2.zip
--&amp;gt; Uploading: darwin_amd64_v0.1.2.zip
--&amp;gt; Uploading: freebsd_386_v0.1.2.zip
--&amp;gt; Uploading: freebsd_amd64_v0.1.2.zip
--&amp;gt; Uploading: freebsd_arm_v0.1.2.zip
--&amp;gt; Uploading: linux_386_v0.1.2.zip
--&amp;gt; Uploading: netbsd_arm_v0.1.2.zip
--&amp;gt; Uploading: linux_arm_v0.1.2.zip
--&amp;gt; Uploading: netbsd_386_v0.1.2.zip
--&amp;gt; Uploading: netbsd_amd64_v0.1.2.zip
--&amp;gt; Uploading: openbsd_amd64_v0.1.2.zip
--&amp;gt; Uploading: openbsd_386_v0.1.2.zip
--&amp;gt; Uploading: windows_386_v0.1.2.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;てな感じで deploy できる。
ちなみに &lt;code&gt;$GITHUB_TOKEN&lt;/code&gt; には &lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; の access token をセットする。
Access token は &lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; の &amp;ldquo;Settings” の &amp;ldquo;Personal access tokens” のページで取得できる。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a data-flickr-embed=&#34;true&#34; href=&#34;https://www.flickr.com/photos/spiegel/24367702843/&#34;&gt;&lt;img src=&#34;https://farm2.staticflickr.com/1626/24367702843_e72366313f.jpg&#34; alt=&#34;Get access token in GitHub&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/24367702843/&#34;&gt;Get access token in GitHub&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;repo の権限を付けること。
この access token を &lt;a href=&#34;https://travis-ci.org/&#34; title=&#34;Travis CI - Test and Deploy Your Code with Confidence&#34;&gt;Travis CI&lt;/a&gt; で参照するには， &amp;ldquo;Settings” の &amp;ldquo;Environment Variables” でセットすればよい。
Build log にこの access token が表示されないようにすること。&lt;/p&gt;

&lt;p&gt;最終的な &lt;code&gt;.travis.yml&lt;/code&gt; の内容はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;language: go

go:
  - 1.5.3

branches:
  only: master

before_install:
  - go get -v github.com/mitchellh/gox
  - go get -v github.com/tcnksm/ghr

script:
  - go test -v ./...

after_success:
  - gox -output &amp;quot;goxdist/{{.OS}}_{{.Arch}}_`git tag | tail -1`/{{.Dir}}&amp;quot; -ldflags &amp;quot;-X main.Version=`git tag | tail -1`&amp;quot;
  - sh scripts/package.sh
  - ghr --username spiegel-im-spiegel --token $GITHUB_TOKEN `git tag | tail -1` goxdist/dist/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git tag | tail -1&lt;/code&gt; で最新のタグを取得して，そこに deploy するようにしている。
&lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; に何か push するたびにビルドが走るのはウザいので， master ブランチのみテスト &amp;amp; ビルドの対象とした。&lt;/p&gt;

&lt;p&gt;まっ，こんなもんかな。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:fa953b67964726c338be9843a0c52e04&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/yanolab/items/5a6dfb3c07c94f7c760d&#34;&gt;Golang + Raspberry Pi + LPS331AP で気圧・温度を測定してみた - Qiita&lt;/a&gt; : arm アーキテクチャでいけるらしい&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/07/22/go1_5-cross-compile/&#34;&gt;Go1.5はクロスコンパイルがより簡単 | SOTA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/rerofumi/items/d6a8ba08270acb61b31c&#34;&gt;Raspberry PI ２ 用の consul を作る (201512版 - Qiita&lt;/a&gt; : Raspberry PI 上でビルドするより Linux のクロス環境を使ったほうが速いらしい&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2014/10/16/golang-in-ci-as-a-service/&#34;&gt;CI-as-a-ServiceでGo言語プロジェクトの最新ビルドを継続的に提供する | SOTA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/m0a/items/d933982293dcadd4998c&#34;&gt;RaspberryPi1(2とzeroも)で動かすgolang製アプリをクロスコンパイル(onMac) - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:fa953b67964726c338be9843a0c52e04:bt&#34;&gt;ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の 1.4 までは &lt;a href=&#34;https://github.com/mitchellh/gox&#34; title=&#34;mitchellh/gox: A dead simple, no frills Go cross compile tool&#34;&gt;mitchellh/gox&lt;/a&gt; インストール後に &lt;code&gt;gox -build-toolchain&lt;/code&gt; でクロス環境を生成する必要があったが， 1.5 からは不要になった。めでたい！
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fa953b67964726c338be9843a0c52e04:bt&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:fa953b67964726c338be9843a0c52e04:tpl&#34;&gt;&lt;code&gt;{{ }}&lt;/code&gt; でテンプレートをハンドリングするには &lt;a href=&#34;https://golang.org/pkg/text/template/&#34; title=&#34;template - The Go Programming Language&#34;&gt;&lt;code&gt;text/template&lt;/code&gt;&lt;/a&gt; パッケージを使う。静的サイト・ジェネレータの &lt;a href=&#34;http://gohugo.io/&#34; title=&#34;Hugo :: A fast and modern static website engine&#34;&gt;Hugo&lt;/a&gt; でもこのテンプレート・パッケージを使っている。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fa953b67964726c338be9843a0c52e04:tpl&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:fa953b67964726c338be9843a0c52e04:s&#34;&gt;企業などのネット環境では Web から exe ファイルなどの実行バイナリを直接ダウンロードすることを禁止している場合もある。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fa953b67964726c338be9843a0c52e04:s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>スタック追跡とパニック・ハンドリング - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/stack-trace-and-panic-handling/" />
		<id>tag:text.Baldanders.info,2016-02-13:/golang/stack-trace-and-panic-handling/</id>
		<published>2016-02-13T14:48:05+09:00</published>
		<updated>2016-02-13T14:48:05+09:00</updated>
		<summary>panic 時の出力をカスタマイズすることを考える。スタック情報を取得するには， panic を recover で捕まえた上で runtime.Caller() 関数を使う。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回は軽めの小ネタで。&lt;/p&gt;

&lt;p&gt;「&lt;a href=&#34;http://text.baldanders.info/golang/error-handling/&#34;&gt;エラー・ハンドリングについて&lt;/a&gt;」でも少し説明したが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では回復不能のエラー（ゼロ除算やメモリ不足など）が発生した場合には &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を投げる仕様になっている。
たとえば以下のコードでは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

func main() {
	os.Exit(run())
}

func run() int {
	f()
	return 0
}

func f() {
	numbers := []int{0, 1, 2}
	fmt.Println(numbers[3]) //panic!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のスタック情報が標準エラー出力に表示される&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4e4334940cfbd371abfb6e84384d704c:s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4e4334940cfbd371abfb6e84384d704c:s&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
（&lt;a href=&#34;https://play.golang.org/&#34;&gt;The Go Playground&lt;/a&gt; での実行結果）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;panic: runtime error: index out of range

goroutine 1 [running]:
main.f()
	/tmp/sandbox269685094/main.go:19 +0x160
main.run(0x20300, 0x104000e0)
	/tmp/sandbox269685094/main.go:13 +0x20
main.main()
	/tmp/sandbox269685094/main.go:9 +0x20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まぁ必要な情報はあるのでこれでも構わないのだが，ファイル名がフルパスで表示されるのがアレな感じである。
また出力先が標準エラー出力で固定されているのも面白くない。&lt;/p&gt;

&lt;p&gt;そこで &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; 時の出力をカスタマイズすることを考える。
スタック情報を取得するには， &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;recover&lt;/a&gt; で捕まえた上で &lt;a href=&#34;https://golang.org/pkg/runtime/&#34; title=&#34;runtime - The Go Programming Language&#34;&gt;&lt;code&gt;runtime&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Caller()&lt;/code&gt; 関数を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;runtime&amp;quot;
)

func main() {
	os.Exit(run(os.Stderr))
}

func run(log io.Writer) (exit int) {
	defer func() {
		if r := recover(); r != nil {
			fmt.Fprintf(log, &amp;quot;Panic: %v\n&amp;quot;, r)
			for depth := 0; ; depth++ {
				pc, src, line, ok := runtime.Caller(depth)
				if !ok {
					break
				}
				fmt.Fprintf(log, &amp;quot; -&amp;gt; %d: %s: %s(%d)\n&amp;quot;, depth, runtime.FuncForPC(pc).Name(), src, line)
			}
			exit = 1
		}
	}()

	f()
    exit = 0
    return
}

func f() {
	numbers := []int{0, 1, 2}
	fmt.Println(numbers[3]) //panic!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで出力は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Panic: runtime error: index out of range
 -&amp;gt; 0: main.run.func1: /tmp/sandbox562252505/main.go(19)
 -&amp;gt; 1: runtime.call16: /usr/local/go/src/runtime/asm_amd64p32.s(390)
 -&amp;gt; 2: runtime.gopanic: /usr/local/go/src/runtime/panic.go(423)
 -&amp;gt; 3: runtime.panicindex: /usr/local/go/src/runtime/panic.go(12)
 -&amp;gt; 4: main.f: /tmp/sandbox562252505/main.go(36)
 -&amp;gt; 5: main.run: /tmp/sandbox562252505/main.go(29)
 -&amp;gt; 6: main.main: /tmp/sandbox562252505/main.go(11)
 -&amp;gt; 7: runtime.main: /usr/local/go/src/runtime/proc.go(111)
 -&amp;gt; 8: runtime.goexit: /usr/local/go/src/runtime/asm_amd64p32.s(1133)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。
ファイル名を出力したくないなら for 文の中を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for depth := 0; ; depth++ {
	pc, _, line, ok := runtime.Caller(depth)
	if !ok {
		break
	}
	fmt.Fprintf(log, &amp;quot; -&amp;gt; %d: %s: (%d)\n&amp;quot;, depth, runtime.FuncForPC(pc).Name(), line)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とする手もある。
コードを書いてる人はスタック追跡情報とファイルの行番号があれば大体あたりをつけられるので，これだけでもありがたい。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:4e4334940cfbd371abfb6e84384d704c&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sgykfjsm.github.io/blog/2016/01/20/golang-function-tracing/&#34;&gt;Goでfunctionが実行された順番を追いかける - sgykfjsm.github.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:4e4334940cfbd371abfb6e84384d704c:s&#34;&gt;ちなみにこの情報は &lt;code&gt;-s&lt;/code&gt; のリンクオプション（ビルド時に &lt;code&gt;-ldflags &amp;quot;-s&amp;quot;&lt;/code&gt; と指定する）でデバッグ用のシンボル情報を削除しても表示されるようだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4e4334940cfbd371abfb6e84384d704c:s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>gpgpdump - OpenPGP packet visualizer - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2016/02/gpgpdump-released/" />
		<id>tag:text.Baldanders.info,2016-02-07:/remark/2016/02/gpgpdump-released/</id>
		<published>2016-02-07T00:18:50+09:00</published>
		<updated>2016-02-07T11:08:40+09:00</updated>
		<summary>OpenPGP パケットの内容を視覚化する gpgpdump の 0.1.0 をリリースした。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;余暇でちまちま作っていたが，とりあえず使えるようになったので。&lt;/p&gt;

&lt;p&gt;OpenPGP パケットの内容を視覚化する &lt;a href=&#34;https://github.com/spiegel-im-spiegel/gpgpdump&#34; title=&#34;spiegel-im-spiegel/gpgpdump: gpgpdump - OpenPGP packet visualizer&#34;&gt;gpgpdump&lt;/a&gt; の 0.1.0 をリリースした。
名前でピンとくる人もいるだろうが，山本和彦さんの &lt;a href=&#34;http://www.mew.org/~kazu/proj/pgpdump/&#34; title=&#34;pgpdump&#34;&gt;pgpdump&lt;/a&gt; の翻案である。
特徴は以下のとおり。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で作成。特別なパッケージは使用していないので &lt;code&gt;go get&lt;/code&gt; コマンドのみでビルド可能&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/toml-lang/toml&#34; title=&#34;toml-lang/toml: Tom&#39;s Obvious, Minimal Language&#34;&gt;TOML&lt;/a&gt; （または &lt;a href=&#34;https://tools.ietf.org/html/rfc7159&#34; title=&#34;RFC 7159 - The JavaScript Object Notation (JSON) Data Interchange Format&#34;&gt;JSON&lt;/a&gt;）フォーマットで出力&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc4880&#34; title=&#34;RFC 4880 - OpenPGP Message Format&#34;&gt;RFC 4880&lt;/a&gt;, &lt;a href=&#34;https://tools.ietf.org/html/rfc5581&#34; title=&#34;RFC 5581 - The Camellia Cipher in OpenPGP&#34;&gt;RFC 5581&lt;/a&gt; および &lt;a href=&#34;https://tools.ietf.org/html/rfc6637&#34; title=&#34;RFC 6637 - Elliptic Curve Cryptography (ECC) in OpenPGP&#34;&gt;RFC 6637&lt;/a&gt; をサポート&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;Apache License Version 2.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat sig
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iF4EARMIAAYFAlTDCN8ACgkQMfv9qV+7+hg2HwEA6h2iFFuCBv3VrsSf2BREQaT1
T1ZprZqwRPOjiLJg9AwA/ArTwCPz7c2vmxlv7sRlRLUI6CdsOqhuO1KfYXrq7idI
=ZOTN
-----END PGP SIGNATURE-----
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という OpenPGP 署名データがあるとする。
これを &lt;a href=&#34;http://www.mew.org/~kazu/proj/pgpdump/&#34; title=&#34;pgpdump&#34;&gt;pgpdump&lt;/a&gt; で表示すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pgpdump sig
Old: Signature Packet(tag 2)(94 bytes)
        Ver 4 - new
        Sig type - Signature of a canonical text document(0x01).
        Pub alg - Reserved for ECDSA(pub 19)
        Hash alg - SHA256(hash 8)
        Hashed Sub: signature creation time(sub 2)(4 bytes)
                Time - Sat Jan 24 11:52:15 東京 (標準時) 2015
        Sub: issuer key ID(sub 16)(8 bytes)
                Key ID - 0x31FBFDA95FBBFA18
        Hash left 2 bytes - 36 1f
        Unknown signature(pub 19)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。
一方， &lt;a href=&#34;https://github.com/spiegel-im-spiegel/gpgpdump&#34; title=&#34;spiegel-im-spiegel/gpgpdump: gpgpdump - OpenPGP packet visualizer&#34;&gt;gpgpdump&lt;/a&gt; の場合は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gpgpdump sig
[[Packet]]
  name = &amp;quot;Packet&amp;quot;
  value = &amp;quot;Signature Packet (tag 2)&amp;quot;
  note = &amp;quot;94 bytes&amp;quot;

  [[Packet.Item]]
    name = &amp;quot;Version&amp;quot;
    value = &amp;quot;4&amp;quot;
    dump = &amp;quot;04&amp;quot;
    note = &amp;quot;new&amp;quot;

  [[Packet.Item]]
    name = &amp;quot;Signiture Type&amp;quot;
    value = &amp;quot;Signature of a canonical text document (0x01)&amp;quot;

  [[Packet.Item]]
    name = &amp;quot;Public-key Algorithm&amp;quot;
    value = &amp;quot;ECDSA public key algorithm (pub 19)&amp;quot;

  [[Packet.Item]]
    name = &amp;quot;Hash Algorithm&amp;quot;
    value = &amp;quot;SHA256 (hash 8)&amp;quot;

  [[Packet.Item]]
    name = &amp;quot;Hashed Subpacket&amp;quot;

    [[Packet.Item.Item]]
      name = &amp;quot;Signature Creation Time (sub 2)&amp;quot;
      value = &amp;quot;2015-01-24T11:52:15+09:00&amp;quot;
      dump = &amp;quot;54 c3 08 df&amp;quot;

  [[Packet.Item]]
    name = &amp;quot;Unhashed Subpacket&amp;quot;

    [[Packet.Item.Item]]
      name = &amp;quot;Issuer (sub 16)&amp;quot;
      value = &amp;quot;0x31FBFDA95FBBFA18&amp;quot;

  [[Packet.Item]]
    name = &amp;quot;Hash left 2 bytes&amp;quot;
    dump = &amp;quot;36 1f&amp;quot;

  [[Packet.Item]]
    name = &amp;quot;Multi-precision integer&amp;quot;
    dump = &amp;quot;...&amp;quot;
    note = &amp;quot;ECDSA r (256 bits)&amp;quot;

  [[Packet.Item]]
    name = &amp;quot;Multi-precision integer&amp;quot;
    dump = &amp;quot;...&amp;quot;
    note = &amp;quot;ECDSA s (252 bits)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じで同等の内容を &lt;a href=&#34;https://github.com/toml-lang/toml&#34; title=&#34;toml-lang/toml: Tom&#39;s Obvious, Minimal Language&#34;&gt;TOML&lt;/a&gt; フォーマットで出力する。
また &lt;code&gt;-j&lt;/code&gt; オプションを付けると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gpgpdump -j sig
{
  &amp;quot;Packet&amp;quot;: [
    {
      &amp;quot;name&amp;quot;: &amp;quot;Packet&amp;quot;,
      &amp;quot;value&amp;quot;: &amp;quot;Signature Packet (tag 2)&amp;quot;,
      &amp;quot;note&amp;quot;: &amp;quot;94 bytes&amp;quot;,
      &amp;quot;Item&amp;quot;: [
        {
          &amp;quot;name&amp;quot;: &amp;quot;Version&amp;quot;,
          &amp;quot;value&amp;quot;: &amp;quot;4&amp;quot;,
          &amp;quot;dump&amp;quot;: &amp;quot;04&amp;quot;,
          &amp;quot;note&amp;quot;: &amp;quot;new&amp;quot;
        },
        {
          &amp;quot;name&amp;quot;: &amp;quot;Signiture Type&amp;quot;,
          &amp;quot;value&amp;quot;: &amp;quot;Signature of a canonical text document (0x01)&amp;quot;
        },
        {
          &amp;quot;name&amp;quot;: &amp;quot;Public-key Algorithm&amp;quot;,
          &amp;quot;value&amp;quot;: &amp;quot;ECDSA public key algorithm (pub 19)&amp;quot;
        },
        {
          &amp;quot;name&amp;quot;: &amp;quot;Hash Algorithm&amp;quot;,
          &amp;quot;value&amp;quot;: &amp;quot;SHA256 (hash 8)&amp;quot;
        },
        {
          &amp;quot;name&amp;quot;: &amp;quot;Hashed Subpacket&amp;quot;,
          &amp;quot;Item&amp;quot;: [
            {
              &amp;quot;name&amp;quot;: &amp;quot;Signature Creation Time (sub 2)&amp;quot;,
              &amp;quot;value&amp;quot;: &amp;quot;2015-01-24T11:52:15+09:00&amp;quot;,
              &amp;quot;dump&amp;quot;: &amp;quot;54 c3 08 df&amp;quot;
            }
          ]
        },
        {
          &amp;quot;name&amp;quot;: &amp;quot;Unhashed Subpacket&amp;quot;,
          &amp;quot;Item&amp;quot;: [
            {
              &amp;quot;name&amp;quot;: &amp;quot;Issuer (sub 16)&amp;quot;,
              &amp;quot;value&amp;quot;: &amp;quot;0x31FBFDA95FBBFA18&amp;quot;
            }
          ]
        },
        {
          &amp;quot;name&amp;quot;: &amp;quot;Hash left 2 bytes&amp;quot;,
          &amp;quot;dump&amp;quot;: &amp;quot;36 1f&amp;quot;
        },
        {
          &amp;quot;name&amp;quot;: &amp;quot;Multi-precision integer&amp;quot;,
          &amp;quot;dump&amp;quot;: &amp;quot;...&amp;quot;,
          &amp;quot;note&amp;quot;: &amp;quot;ECDSA r (256 bits)&amp;quot;
        },
        {
          &amp;quot;name&amp;quot;: &amp;quot;Multi-precision integer&amp;quot;,
          &amp;quot;dump&amp;quot;: &amp;quot;...&amp;quot;,
          &amp;quot;note&amp;quot;: &amp;quot;ECDSA s (252 bits)&amp;quot;
        }
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じに &lt;a href=&#34;https://tools.ietf.org/html/rfc7159&#34; title=&#34;RFC 7159 - The JavaScript Object Notation (JSON) Data Interchange Format&#34;&gt;JSON&lt;/a&gt; 形式で出力する。
だいぶ冗長な表現で申し訳ないが，解析結果を以下の &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; で正規化している。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Packets - OpenPGP packets
type Packets struct {
	Packet []*Item
}

//Item - item in Packets
type Item struct {
	Name  string  `toml:&amp;quot;name&amp;quot; json:&amp;quot;name&amp;quot;`
	Value string  `toml:&amp;quot;value,omitempty&amp;quot; json:&amp;quot;value,omitempty&amp;quot;`
	Dump  string  `toml:&amp;quot;dump,omitempty&amp;quot; json:&amp;quot;dump,omitempty&amp;quot;`
	Note  string  `toml:&amp;quot;note,omitempty&amp;quot; json:&amp;quot;note,omitempty&amp;quot;`
	Item  []*Item `toml:&amp;quot;Item,omitempty&amp;quot; json:&amp;quot;Item,omitempty&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/gpgpdump&#34; title=&#34;spiegel-im-spiegel/gpgpdump: gpgpdump - OpenPGP packet visualizer&#34;&gt;gpgpdump&lt;/a&gt; は &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の勉強用に作成した。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/crypto/openpgp/packet&#34;&gt;&lt;code&gt;golang.org/x/crypto/openpgp/packet&lt;/code&gt;&lt;/a&gt; というパッケージがあって，これを使えば簡単にできるだろうと思ったのが大間違いで，結局このパッケージで使えたのは &lt;a href=&#34;https://godoc.org/golang.org/x/crypto/openpgp/packet#OpaquePacket&#34;&gt;&lt;code&gt;OpaquePacket&lt;/code&gt;&lt;/a&gt; や &lt;a href=&#34;https://godoc.org/golang.org/x/crypto/openpgp/packet#OpaqueSubpacket&#34;&gt;&lt;code&gt;OpaqueSubpacket&lt;/code&gt;&lt;/a&gt; くらい。
実際のパケットの解析はゴリゴリとコードを書くはめになった。
いや，これだけでもだいぶ助かったけど。&lt;/p&gt;

&lt;p&gt;とはいえ，まだまだ課題はあって&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;パケット解析部分のテストが未実装。つか，古いフォーマットのパケットのテストどうしよう&lt;/li&gt;
&lt;li&gt;そもそもパケット解析部分は作りが悪くて，不正なパケットを食わせると簡単に &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; が起きてしまうので全面的に書きなおす予定&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc4880#section-5.6&#34;&gt;Compressed Data Packet (Tag 8)&lt;/a&gt; が未実装。どうやって実現しようか悩み中&lt;/li&gt;
&lt;li&gt;実は ECC (&lt;a href=&#34;https://tools.ietf.org/html/rfc6637&#34; title=&#34;RFC 6637 - Elliptic Curve Cryptography (ECC) in OpenPGP&#34;&gt;RFC 6637&lt;/a&gt;) がよく分かってない。もしかしたら解釈を間違えているかもしれない&lt;/li&gt;
&lt;li&gt;最終的には &lt;a href=&#34;http://www.mew.org/~kazu/proj/pgpdump/&#34; title=&#34;pgpdump&#34;&gt;pgpdump&lt;/a&gt; と同等な出力を目指す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といったあたりを，これからゆっくり手を入れていこうと考えている。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:a131791b2fce306ad1e4a38715959029&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.baldanders.info/spiegel/archive/pgpdump/openpgp.shtml&#34;&gt;わかる！ OpenPGP 暗号 — Baldanders.info&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/&#34;&gt;プログラミング言語 Go — text.Baldanders.info&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
	</entry>
	
	<entry>
		<title>Struct タグについて - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/struct-tag/" />
		<id>tag:text.Baldanders.info,2016-02-05:/golang/struct-tag/</id>
		<published>2016-02-05T00:11:53+09:00</published>
		<updated>2016-03-26T09:40:17+09:00</updated>
		<summary>Struct で正規化できる情報であれば，タグを使うことでアプリケーション外部とのやり取りがずっと楽になる。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;たとえば &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; で構造化されている情報を特定のファイルやデータベースに出力したり，逆にファイルやデータベースの情報を &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; に流し込みたい場合に &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; の各フィールドに目印になる情報があると便利である。
この目印として機能するのが &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; タグである&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5fa302080eeba16361245078fe0e5ca6:an&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:5fa302080eeba16361245078fe0e5ca6:an&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; タグは以下のように記述する。&lt;/p&gt;

&lt;figure lang=&#34;en&#34;&gt;
&lt;blockquote&gt;
&lt;q&gt;By convention, tag strings are a concatenation of optionally space-separated key:&#34;value&#34; pairs. Each key is a non-empty string consisting of non-control characters other than space (U+0020 &#39; &#39;), quote (U+0022 &#39;&#34;&#39;), and colon (U+003A &#39;:&#39;). Each value is quoted using U+0022 &#39;&#34;&#39; characters and Go string literal syntax.&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;https://golang.org/pkg/reflect/#example_StructTag&#34;&gt;reflect - The Go Programming Language&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Server struct {
	Host      string `elem:&amp;quot;host&amp;quot;`
	IPAddress string `elem:&amp;quot;ip_address&amp;quot;`
	Port      int    `elem:&amp;quot;port&amp;quot;`
	Note      string `elem:&amp;quot;note&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このタグ情報を取得するには &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt; パッケージを使う。
たとえばこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;reflect&amp;quot;
)

type Server struct {
	Host      string `elem:&amp;quot;host&amp;quot;`
	IPAddress string `elem:&amp;quot;ip_address&amp;quot;`
	Port      int    `elem:&amp;quot;port&amp;quot;`
	Note      string `elem:&amp;quot;note&amp;quot;`
}

func main() {
	s := Server{}
	t := reflect.TypeOf(s)
	for i := 0; i &amp;lt; t.NumField(); i++ {
		field := t.Field(i)
		fmt.Printf(&amp;quot;Name=%s , tag(elem)=%s\n&amp;quot;, field.Name, field.Tag.Get(&amp;quot;elem&amp;quot;))
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行するとこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Name=Host , tag(elem)=host
Name=IPAddress , tag(elem)=ip_address
Name=Port , tag(elem)=port
Name=Note , tag(elem)=note
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際には &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt; を直接使う局面は少なく，既にあるパッケージを利用することが多い。
たとえば &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; による構造化データを &lt;a href=&#34;https://tools.ietf.org/html/rfc7159&#34; title=&#34;RFC 7159 - The JavaScript Object Notation (JSON) Data Interchange Format&#34;&gt;JSON&lt;/a&gt; 形式に出力する &lt;a href=&#34;https://golang.org/pkg/encoding/json/&#34; title=&#34;json - The Go Programming Language&#34;&gt;&lt;code&gt;encoding/json&lt;/code&gt;&lt;/a&gt; パッケージがある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
)

type Server struct {
	Host      string `json:&amp;quot;host&amp;quot;`
	IPAddress string `json:&amp;quot;ip_address&amp;quot;`
	Port      int    `json:&amp;quot;port&amp;quot;`
	Note      string `json:&amp;quot;note&amp;quot;`
}

func main() {
	s := Server{Host: &amp;quot;localhost&amp;quot;, IPAddress: &amp;quot;127.0.0.1&amp;quot;, Port: 8080, Note: &amp;quot;Web Application&amp;quot;}
	j, err := json.MarshalIndent(s, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		return
	}
	fmt.Println(string(j))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行するとこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
  &amp;quot;ip_address&amp;quot;: &amp;quot;127.0.0.1&amp;quot;,
  &amp;quot;port&amp;quot;: 8080,
  &amp;quot;note&amp;quot;: &amp;quot;Web Application&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Server&lt;/code&gt; の内容が &lt;a href=&#34;https://tools.ietf.org/html/rfc7159&#34; title=&#34;RFC 7159 - The JavaScript Object Notation (JSON) Data Interchange Format&#34;&gt;JSON&lt;/a&gt; 形式で出力されているのが分かるだろう。
&lt;a href=&#34;https://tools.ietf.org/html/rfc7159&#34; title=&#34;RFC 7159 - The JavaScript Object Notation (JSON) Data Interchange Format&#34;&gt;JSON&lt;/a&gt; の要素名がタグで指定した名前になっていることを確認してほしい。&lt;/p&gt;

&lt;p&gt;反対もやってみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
)

type Server struct {
	Host      string `json:&amp;quot;host&amp;quot;`
	IPAddress string `json:&amp;quot;ip_address&amp;quot;`
	Port      int    `json:&amp;quot;port&amp;quot;`
	Note      string `json:&amp;quot;note&amp;quot;`
}

func main() {
	svr := []byte(`{
  &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
  &amp;quot;ip_address&amp;quot;: &amp;quot;127.0.0.1&amp;quot;,
  &amp;quot;port&amp;quot;: 8080,
  &amp;quot;note&amp;quot;: &amp;quot;Web Application&amp;quot;
}`)
	var s Server
	if err := json.Unmarshal(svr, &amp;amp;s); err != nil {
		return
	}
	fmt.Println(s)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果はこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{localhost 127.0.0.1 8080 Web Application}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;きれいに &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; に値が入っているのが分かると思う。&lt;/p&gt;

&lt;p&gt;ちなみにタグの書式は &lt;code&gt;key:&amp;quot;value&amp;quot;&lt;/code&gt; だが，間違って記述しても単に無視されるだけでコンパイル時も実行時もエラーにならないので注意が必要である。
なおタグ書式の文法ミスについては，静的検査ツールの &lt;a href=&#34;https://golang.org/cmd/vet/&#34; title=&#34;vet - The Go Programming Language&#34;&gt;vet&lt;/a&gt; でチェックできる。&lt;/p&gt;

&lt;p&gt;タグは複数列挙することができる。
たとえばサンプルの構造体を &lt;a href=&#34;https://github.com/toml-lang/toml&#34; title=&#34;toml-lang/toml: Tom&#39;s Obvious, Minimal Language&#34;&gt;TOML&lt;/a&gt; にも対応させたいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Server struct {
	Host      string `json:&amp;quot;host&amp;quot; toml:&amp;quot;host&amp;quot;`
	IPAddress string `json:&amp;quot;ip_address&amp;quot; toml:&amp;quot;ip_address&amp;quot;`
	Port      int    `json:&amp;quot;port&amp;quot; toml:&amp;quot;port&amp;quot;`
	Note      string `json:&amp;quot;note&amp;quot; toml:&amp;quot;note&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとする（デリミタは空白文字）。
じゃあ，先ほどと同じようにして &lt;a href=&#34;https://github.com/toml-lang/toml&#34; title=&#34;toml-lang/toml: Tom&#39;s Obvious, Minimal Language&#34;&gt;TOML&lt;/a&gt; で出力してみる。
&lt;a href=&#34;https://github.com/toml-lang/toml&#34; title=&#34;toml-lang/toml: Tom&#39;s Obvious, Minimal Language&#34;&gt;TOML&lt;/a&gt; を扱うには &lt;a href=&#34;https://github.com/BurntSushi/toml&#34;&gt;&lt;code&gt;github.com/BurntSushi/toml&lt;/code&gt;&lt;/a&gt; パッケージを使うとよい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/BurntSushi/toml&amp;quot;
)

type Server struct {
	Host      string `json:&amp;quot;host&amp;quot; toml:&amp;quot;host&amp;quot;`
	IPAddress string `json:&amp;quot;ip_address&amp;quot; toml:&amp;quot;ip_address&amp;quot;`
	Port      int    `json:&amp;quot;port&amp;quot; toml:&amp;quot;port&amp;quot;`
	Note      string `json:&amp;quot;note&amp;quot; toml:&amp;quot;note,omitempty&amp;quot;`
}

func main() {
	s := Server{Host: &amp;quot;localhost&amp;quot;, IPAddress: &amp;quot;127.0.0.1&amp;quot;, Port: 8080, Note: &amp;quot;&amp;quot;}
	t := new(bytes.Buffer)
	if err := toml.NewEncoder(t).Encode(s); err != nil {
		return
	}
	fmt.Println(t.String())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;host = &amp;quot;localhost&amp;quot;
ip_address = &amp;quot;127.0.0.1&amp;quot;
port = 8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;omitempty&lt;/code&gt; オプションはフィールドが空（&lt;code&gt;nil&lt;/code&gt; または空文字列）の場合に出力を省略できる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5fa302080eeba16361245078fe0e5ca6:oz&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:5fa302080eeba16361245078fe0e5ca6:oz&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。
このオプションは &lt;a href=&#34;https://golang.org/pkg/encoding/json/&#34; title=&#34;json - The Go Programming Language&#34;&gt;&lt;code&gt;encoding/json&lt;/code&gt;&lt;/a&gt; パッケージでも使える。&lt;/p&gt;

&lt;p&gt;ついでに反対もやってみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/BurntSushi/toml&amp;quot;
)

type Server struct {
	Host      string `json:&amp;quot;host&amp;quot; toml:&amp;quot;host&amp;quot;`
	IPAddress string `json:&amp;quot;ip_address&amp;quot; toml:&amp;quot;ip_address&amp;quot;`
	Port      int    `json:&amp;quot;port&amp;quot; toml:&amp;quot;port&amp;quot;`
	Note      string `json:&amp;quot;note&amp;quot; toml:&amp;quot;note,omitempty&amp;quot;`
}

func main() {
	svr := `
host = &amp;quot;localhost&amp;quot;
ip_address = &amp;quot;127.0.0.1&amp;quot;
port = 8080
note = &amp;quot;Web Application&amp;quot;
`
	var s Server
	if _, err := toml.Decode(svr, &amp;amp;s); err != nil {
		return
	}
	fmt.Println(s)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{localhost 127.0.0.1 8080 Web Application}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; で正規化できる情報であれば，タグ機能を使うことでアプリケーション外部とのやり取りがだいぶ楽になる。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:5fa302080eeba16361245078fe0e5ca6&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://hiyosi.tumblr.com/post/100922038678/go-%E3%81%A7-struct-%E3%81%AE%E3%82%BF%E3%82%B0%E6%83%85%E5%A0%B1%E3%82%92%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B&#34;&gt;Go で struct のタグ情報を取得する - hiyosi&amp;rsquo;s blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/amanoiverse/items/fcd25db64f341ad2471f&#34;&gt;struct にアノテーションつけてたら go vet . すべき - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.restartr.com/2014/08/13/golang-json-marshal-unmarshal/&#34;&gt;Goのjson.Marshal/Unmarshalの仕様を整理してみる - I Will Survive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/reiki4040/items/6556d4eba797329e9f51&#34;&gt;BurntSushi/tomlを使ってハマったこと - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/hnakamur/items/ba363e82332d4dbdf34a&#34;&gt;GoでJSONの一部分を利用者が定義した構造体に読み込める便利な手法を見つけた - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:5fa302080eeba16361245078fe0e5ca6:an&#34;&gt;「アノテーション（annotation）」と呼ぶ人もいる。たぶん Java の annotation 機能を意識しているんだろう。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5fa302080eeba16361245078fe0e5ca6:an&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:5fa302080eeba16361245078fe0e5ca6:oz&#34;&gt;数値の場合は &lt;code&gt;omitzero&lt;/code&gt; オプションを付けると 0 のときに出力を省略できる。ただし &lt;a href=&#34;https://github.com/BurntSushi/toml&#34;&gt;&lt;code&gt;BurntSushi/toml&lt;/code&gt;&lt;/a&gt; パッケージでは &lt;a href=&#34;http://qiita.com/reiki4040/items/6556d4eba797329e9f51&#34;&gt;&lt;code&gt;Decode()&lt;/code&gt; がうまく動かない&lt;/a&gt;らしい。実は &lt;code&gt;omitempty&lt;/code&gt; オプションも &lt;code&gt;Decode()&lt;/code&gt; 時の挙動が怪しいんだよなぁ。 &lt;a href=&#34;https://github.com/toml-lang/toml&#34; title=&#34;toml-lang/toml: Tom&#39;s Obvious, Minimal Language&#34;&gt;TOML&lt;/a&gt; パーサの別実装としては &lt;a href=&#34;https://github.com/naoina/toml&#34;&gt;naoina/toml&lt;/a&gt; というのもある。これは最新の &lt;a href=&#34;https://github.com/toml-lang/toml&#34; title=&#34;toml-lang/toml: Tom&#39;s Obvious, Minimal Language&#34;&gt;TOML&lt;/a&gt; 仕様に追随しているようだが &lt;code&gt;omitzero&lt;/code&gt; オプションには対応していない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5fa302080eeba16361245078fe0e5ca6:oz&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
</feed>
