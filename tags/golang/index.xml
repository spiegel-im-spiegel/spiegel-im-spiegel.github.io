<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:cc="http://web.resource.org/cc/">
	<title>Golang - text.Baldanders.info</title>
	<link rel="alternate" type="text/html" href="http://text.baldanders.info/tags/golang/" />
	<link rel="self" type="application/atom+xml" href="http://text.baldanders.info/tags/golang/index.xml" />
	<id>tag:text.Baldanders.info,2017-09-14:/tags</id>
	<updated>2017-09-14T10:01:49+09:00</updated>
	<subtitle>帰ってきた「しっぽのさきっちょ」</subtitle>
	<icon>http://text.baldanders.info//images/avatar.jpg</icon>
	<logo>http://text.baldanders.info//images/avatar.jpg</logo>
	<generator uri="https://gohugo.io/">Hugo 0.27.1</generator>

	
	<entry>
		<title>Go 1.9 と Type Alias - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/go-1_9-and-type-alias/" />
		<id>tag:text.Baldanders.info,2017-09-14:/golang/go-1_9-and-type-alias/</id>
		<published>2017-09-14T10:01:49+09:00</published>
		<updated>2017-09-14T10:01:49+09:00</updated>
		<summary>なんで type alias なんて妙ちきりんな言語仕様が追加されたかというと，実はこれ，リファクタリングの為に設けられたのである。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;遅ればせながらの記事で申し訳ないが Go 1.9 がリリースされた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/go1.9&#34;&gt;Go 1.9 is released - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/go1.9&#34;&gt;Go 1.9 Release Notes - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;詳しい内容は&lt;a href=&#34;https://golang.org/doc/go1.9&#34; title=&#34;Go 1.9 Release Notes - The Go Programming Language&#34;&gt;リリースノート&lt;/a&gt;を見ていただくとして，今回の目玉は &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; alias 機能だろう。&lt;/p&gt;

&lt;p&gt;まず &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードを使った簡単な足し算を書いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Num1 int

func (n1 Num1) Add(n2 Num1) Num1 {
	return n1 + n2
}

func main() {
	n1 := Num1(1)
	n2 := Num1(2)
	fmt.Println(n1.Add(n2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は 3 と出力されるはずである。
ここで “&lt;code&gt;type Num2 Num1&lt;/code&gt;&amp;rdquo; と記述を追加し，この型を使って足し算を行ってみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Num1 int

func (n1 Num1) Add(n2 Num1) Num1 {
	return n1 + n2
}

type Num2 Num1

func main() {
	n1 := Num2(1)
	n2 := Num2(2)
	fmt.Println(n1.Add(n2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行しようとすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;n1.Add undefined (type Num2 has no field or method Add)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とコンパイルエラーになる。
何故か。
&lt;code&gt;Num1&lt;/code&gt; と &lt;code&gt;Num2&lt;/code&gt; は異なる型だからだ。
型 &lt;code&gt;Num1&lt;/code&gt; に紐付いている関数 &lt;code&gt;Add()&lt;/code&gt; は，型 &lt;code&gt;Num2&lt;/code&gt; には紐付かない。
継承されないわけだ（&lt;code&gt;Num1&lt;/code&gt; へキャストはできる）。&lt;/p&gt;

&lt;p&gt;では今度は “&lt;code&gt;type Num2 = Num1&lt;/code&gt;&amp;rdquo; と記述を変更してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

type Num1 int

func (n1 Num1) Add(n2 Num1) Num1 {
	return n1 + n2
}

type Num2 = Num1

func main() {
	n1 := Num2(1)
	n2 := Num2(2)
	fmt.Println(n1.Add(n2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今度はコンパイルエラーにならず 3 と出力される。
この “&lt;code&gt;type Num2 = Num1&lt;/code&gt;&amp;rdquo; という構文が &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; alias を指し，この記述によって &lt;code&gt;Num1&lt;/code&gt; と &lt;code&gt;Num2&lt;/code&gt; は &lt;strong&gt;全く同じ型&lt;/strong&gt; として扱われる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;なんでこんな妙ちきりんな言語仕様が追加されたかというと，実はこれ，リファクタリングの為に設けられたのである。&lt;/p&gt;

&lt;figure lang=&#34;en&#34;&gt;
&lt;blockquote&gt;
&lt;q&gt;Go now supports type aliases to support gradual code repair while moving a type between packages.
The type alias design document and an article on refactoring cover the problem in detail.&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;https://golang.org/doc/go1.9&#34;&gt;Go 1.9 Release Notes&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;もともと &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;はリファクタリングを厚遇する言語と言える。
たとえば &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; などはその最たる例だろう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/remark/2017/03/generics-vs-duck-typing/&#34;&gt;きみは Generics がとくいなフレンズなんだね，または「制約は構造を生む」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まぁ，あまり積極的に使う機能ではないかもしれないが，こういうこともできると覚えておくといいだろう。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://qiita.com/weloan/items/8abbb4003cfa1031a9e9&#34;&gt;go言語1.9で追加予定の新機能 型エイリアス - Qiita&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1EU/baldandersinf-22/&#34;&gt;&lt;img src=&#34;https://images-fe.ssl-images-amazon.com/images/I/41GPVATQiZL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1EU/baldandersinf-22/&#34;&gt;Java言語で学ぶリファクタリング入門&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;結城 浩 &lt;/dd&gt;&lt;dd&gt;SBクリエイティブ 2007-01-26&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8ATHGW/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8ATHGW.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;増補改訂版 Java言語で学ぶデザインパターン入門&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1BS/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1BS.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;増補改訂版 Java言語で学ぶデザインパターン入門 マルチスレッド編&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B073F45B97/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B073F45B97.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／積分を見つめて&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00H372H40/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00H372H40.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;プログラマの数学&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1AO/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1AO.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Java言語プログラミングレッスン 第3版（下）　オブジェクト指向を始めよう&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B072JVPFL4/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B072JVPFL4.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;JavaScript関数型プログラミング 複雑性を抑える発想と実践法を学ぶ impress top gearシリーズ&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B071V7MY82/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B071V7MY82.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;プリンシプル オブ プログラミング 3年目までに身につけたい 一生役立つ101の原理原則&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1A4/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1A4.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Java言語プログラミングレッスン 第3版（上）　Java言語を始めよう&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B0185E10ZQ/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B0185E10ZQ.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;実践Javaコーディング作法&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00Y9EYOIW/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00Y9EYOIW.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／微分を追いかけて&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;結城浩さんによる「リファクタリング本」。意外に Java 以外でも使える優れもの。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2017-09-14&#34;&gt;2017-09-14&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:a1&#34;&gt;全く同じ型なので継承関係はなく，別名定義した型に独自に関数を紐付けることはできない。ちなみに別パッケージの型に対しても別名定義が可能である： &lt;code&gt;type Time = time.Time&lt;/code&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>『Goプログラミング実践入門』を眺める - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2017/04/go-web-programming/" />
		<id>tag:text.Baldanders.info,2017-04-23:/remark/2017/04/go-web-programming/</id>
		<published>2017-04-23T19:08:38+09:00</published>
		<updated>2017-04-24T09:26:58+09:00</updated>
		<summary>個人的には context パッケージについて解説があるとなおよかったが， Go 言語 の 1.6 をベースに書かれているので無理か。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;&lt;a href=&#34;https://www.manning.com/books/go-web-programming&#34; title=&#34;Manning | Go Web Programming&#34;&gt;原書のタイトルが “Go Web Programming&amp;rdquo;&lt;/a&gt; となっている通り，『&lt;a href=&#34;http://book.impress.co.jp/books/1115101145&#34; title=&#34;Goプログラミング実践入門 標準ライブラリでゼロからWebアプリを作る - インプレスブックス&#34;&gt;Goプログラミング実践入門&lt;/a&gt;』は「Web アプリケーションまたはサービスのプログラミング」について &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のコードを使って解説している本である。
しかも「実践入門」というよりは基礎学習に近い内容。
したがって既に現場でばりばりコードを書いてる人には物足りないだろう。
そういう人は（少し前に出た本だけど）オライリー・ジャパンの『&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; title=&#34;Go言語によるWebアプリケーション開発 | Mat Ryer, 鵜飼 文敏, 牧野 聡 |本 | 通販 | Amazon&#34;&gt;Go言語によるWebアプリケーション開発&lt;/a&gt;』のほうがいいかもしれない。&lt;/p&gt;

&lt;p&gt;特徴的なのが， &lt;a href=&#34;https://echo.labstack.com/&#34; title=&#34;Echo - High performance, minimalist Go web framework&#34;&gt;Echo&lt;/a&gt; のような有名どころのフレームワークは使わず， &lt;a href=&#34;https://golang.org/pkg/net/&#34; title=&#34;net - The Go Programming Language&#34;&gt;&lt;code&gt;net&lt;/code&gt;&lt;/a&gt;/&lt;a href=&#34;https://golang.org/pkg/net/http/&#34; title=&#34;http - The Go Programming Language&#34;&gt;&lt;code&gt;http&lt;/code&gt;&lt;/a&gt; や &lt;a href=&#34;https://golang.org/pkg/html/&#34; title=&#34;html - The Go Programming Language&#34;&gt;&lt;code&gt;html&lt;/code&gt;&lt;/a&gt;/&lt;a href=&#34;https://golang.org/pkg/html/template/&#34; title=&#34;template - The Go Programming Language&#34;&gt;&lt;code&gt;template&lt;/code&gt;&lt;/a&gt; といった標準パッケージのみで解説しているところ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:pkg&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:pkg&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
大昔によくあった， TCP/IP の解説を C 言語コードで行ったり CGI (Common Gateway Interface) の解説を Perl のコードで行ってた技術解説本のようなノリがあってなかなか楽しく読めた。&lt;/p&gt;

&lt;p&gt;Web アプリケーション以外でもそうだけど，フレームワークって「中身」がちゃんと分かってないと適切に使えないよね。
そういう意味ではよく出来てると思う。
個人的には &lt;a href=&#34;https://golang.org/pkg/context/&#34; title=&#34;context - The Go Programming Language&#34;&gt;&lt;code&gt;context&lt;/code&gt;&lt;/a&gt; パッケージについて解説があるとなおよかったが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt; の 1.6 をベースに書かれているので無理か。&lt;/p&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B06XKPNVWV/baldandersinf-22/&#34;&gt;&lt;img src=&#34;https://images-fe.ssl-images-amazon.com/images/I/51dQZeafzvL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B06XKPNVWV/baldandersinf-22/&#34;&gt;Goプログラミング実践入門　標準ライブラリでゼロからWebアプリを作る impress top gearシリーズ&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Sau Sheong Chang 武舎 広幸 阿部 和也 上西 昌弘 &lt;/dd&gt;&lt;dd&gt;インプレス 2017-03-17&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;4&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-4-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B06Y3JV86V/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B06Y3JV86V.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;IoTエンジニア養成読本&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B06XTKZS7J/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B06XTKZS7J.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Electronではじめるアプリ開発 ～JavaScript/HTML/CSSでデスクトップアプリを作ろう&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B06XJ86BFZ/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B06XJ86BFZ.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;プログラミング経験者がGo言語を本格的に勉強する前に読むための本&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B06XNQCW7B/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B06XNQCW7B.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;徹底マスター JavaScriptの教科書　プログラミングの教養から、言語仕様、開発技法までが正しく身につく&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01LMS7B1O/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01LMS7B1O.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;みんなのGo言語[現場で使える実践テクニック]&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B06X9PL5WD/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B06X9PL5WD.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Elixir/Phoenix 初級②: データベースとクエリ構造体 (OIAX BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MUS2RP9/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01MUS2RP9.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;JavaScriptエンジニアが手っ取り早くReactの基礎を理解するための「超」入門書&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01N183E3H/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01N183E3H.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;nginx実践ガイド impress top gearシリーズ&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01FH3KRTI/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01FH3KRTI.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01N1GOX62/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01N1GOX62.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;WebデベロッパーのためのReact開発入門 JavaScript UIライブラリの基本と活用&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;Web アプリケーションまたはサービスについて Go 言語のコードで解説。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2017-04-23&#34;&gt;2017-04-23&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/51UoREcNrnL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34;&gt;Go言語によるWebアプリケーション開発&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Mat Ryer 鵜飼 文敏 &lt;/dd&gt;&lt;dd&gt;オライリージャパン 2016-01-22&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;4&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-4-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4621300253.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;プログラミング言語Go&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117607/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117607.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;マイクロサービスアーキテクチャ&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4774178667/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4774178667.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;nginx実践入門 (WEB+DB PRESS plus)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4863541783/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4863541783.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;改訂2版 基礎からわかる Go言語&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4774179930/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4774179930.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;サーバ/インフラエンジニア養成読本 DevOps編 [Infrastructure as Code を実践するノウハウが満載! ] (Software Design plus)&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;日本語監訳者による解説（付録 B）が意外に役に立つ感じ。 Web アプリケーションだけでなく，サーバサイドで動く CLI アプリへの言及もある。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-03-13&#34;&gt;2016-03-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:pkg&#34;&gt;テストフレームワークや ORM (Object-Relational Mapping) についてはサードパーティのパッケージも紹介している。また RDBMS のドライバは標準パッケージとしては提供されないので，サードパーティのパッケージが使われている（『&lt;a href=&#34;http://book.impress.co.jp/books/1115101145&#34; title=&#34;Goプログラミング実践入門 標準ライブラリでゼロからWebアプリを作る - インプレスブックス&#34;&gt;Goプログラミング実践入門&lt;/a&gt;』では PostgreSQL なので &lt;a href=&#34;https://github.com/lib/pq&#34; title=&#34;lib/pq: Pure Go Postgres driver for database/sql&#34;&gt;&lt;code&gt;github.com/lib/pq&lt;/code&gt;&lt;/a&gt; を使用）。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:pkg&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Go 言語 1.8.1 がリリース - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2017/04/go-1_8_1-released/" />
		<id>tag:text.Baldanders.info,2017-04-08:/remark/2017/04/go-1_8_1-released/</id>
		<published>2017-04-08T15:48:30+09:00</published>
		<updated>2017-04-08T15:48:30+09:00</updated>
		<summary>Go 言語コンパイラのバージョン 1.8.1 がリリースされた。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;コンパイラのバージョン 1.8.1 がリリースされた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-announce/1-2Uow_7TjQ&#34;&gt;Go 1.8.1 is released - Google グループ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure lang=&#34;en&#34;&gt;
&lt;blockquote&gt;&lt;p&gt;“go1.8.1 (released 2017/04/07) includes fixes to the compiler, linker, runtime, documentation, go command and the &lt;code&gt;crypto/tls&lt;/code&gt;, &lt;code&gt;encoding/xml&lt;/code&gt;, &lt;code&gt;image/png&lt;/code&gt;, &lt;code&gt;net&lt;/code&gt;, &lt;code&gt;net/http&lt;/code&gt;, &lt;code&gt;reflect&lt;/code&gt;, &lt;code&gt;text/template&lt;/code&gt;, and &lt;code&gt;time&lt;/code&gt; packages.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;https://golang.org/doc/devel/release.html#go1.8.minor&#34;&gt;Release History - The Go Programming Language&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;セキュリティ・アップデートではないようだがかなり広範囲に改修が行われているようだ。
アップデートは計画的に。&lt;/p&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>ソートを使う - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/sort/" />
		<id>tag:text.Baldanders.info,2017-04-07:/golang/sort/</id>
		<published>2017-04-07T20:01:34+09:00</published>
		<updated>2017-09-15T11:15:05+09:00</updated>
		<summary>ソートをアルゴリズムまで言及すると非常に深いテーマになるのだが，今回は標準の sort パッケージの使い方に絞って「こんな感じ」で説明していく。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回はソート（sort）のお話。&lt;/p&gt;

&lt;p&gt;プログラマでソートを知らない人はいないだろうが，一応説明しておくと，あるデータの集合を一定の規則に従って並べ替えることを指す。
日本語では「整列」と呼んだりするらしい。
ソートをアルゴリズムまで言及すると非常に深いテーマになるのだが，今回は標準の &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; パッケージの使い方に絞って「こんな感じ」で説明していく。&lt;/p&gt;

&lt;p&gt;なお，この記事で紹介するコードは &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; パッケージのドキュメントに書かれているものを流用している。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のコンパイラ・コードは MIT ライセンスで提供されているのでご注意を。&lt;/p&gt;

&lt;h2 id=&#34;基本型データ列のソート&#34;&gt;基本型データ列のソート&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; パッケージでは基本型の int, float64, string についてはソート関数が用意されている。&lt;/p&gt;

&lt;p&gt;たとえば &lt;code&gt;{0.055, 0.815, 1.0, 0.107}&lt;/code&gt; というデータ列があるとしよう。
これを昇順（小さい値から大きい値へ順に並べること）で並べることを考える。
この場合は &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Float64s()&lt;/code&gt; 関数を使えば簡単である。
コードにするとこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;sort&amp;quot;
)

func main() {
	fset := []float64{0.055, 0.815, 1.0, 0.107}
	for _, f := range fset {
		fmt.Printf(&amp;quot;%f &amp;quot;, f)
	}
	fmt.Print(&amp;quot;\n&amp;quot;)
	sort.Float64s(fset)
	for _, f := range fset {
		fmt.Printf(&amp;quot;%f &amp;quot;, f)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果はこんな感じになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run sort1.go
0.055000 0.815000 1.000000 0.107000
0.055000 0.107000 0.815000 1.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では，降順（大きい値から小さい値へ順に並べること）で並べるにはどうすればいいだろう。
これはちょっとだけ面倒くさくなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;sort&amp;quot;
)

func main() {
	fset := []float64{0.055, 0.815, 1.0, 0.107}
	for _, f := range fset {
		fmt.Printf(&amp;quot;%f &amp;quot;, f)
	}
	fmt.Print(&amp;quot;\n&amp;quot;)
    sort.Sort(sort.Reverse(sort.Float64Slice(fset)))
	for _, f := range fset {
		fmt.Printf(&amp;quot;%f &amp;quot;, f)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Float64Slice&lt;/code&gt; は &lt;code&gt;[]float64&lt;/code&gt; を示す型である。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Float64Slice []float64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この型が示すデータ集合を &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Sort()&lt;/code&gt; 関数で並べ替えるのだが，並べ替えの規則を &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Reverse()&lt;/code&gt; 関数で反転させている。
実行結果はこんな感じでちゃんと降順になっているのが分かるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run sort2.go
0.055000 0.815000 1.000000 0.107000
1.000000 0.815000 0.107000 0.055000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は最初に出た &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Float64s()&lt;/code&gt; 関数は内部で &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Sort()&lt;/code&gt; 関数を呼んでいる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Float64s sorts a slice of float64s in increasing order.
func Float64s(a []float64) { Sort(Float64Slice(a)) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で， &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Sort()&lt;/code&gt; 関数の内部では &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Float64Slice&lt;/code&gt; に紐付く &lt;code&gt;Len()&lt;/code&gt;, &lt;code&gt;Less()&lt;/code&gt;, &lt;code&gt;Swap()&lt;/code&gt; 各メソッドが呼ばれている。
&lt;code&gt;Len()&lt;/code&gt;, &lt;code&gt;Less()&lt;/code&gt;, &lt;code&gt;Swap()&lt;/code&gt; 各メソッドを持つ &lt;a href=&#34;https://golang.org/doc/effective_go.html#interfaces_and_types&#34; title=&#34;Effective Go - The Go Programming Language&#34;&gt;interface&lt;/a&gt; を Sorter と呼び，以下のように定義されている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// A type, typically a collection, that satisfies sort.Interface can be
// sorted by the routines in this package. The methods require that the
// elements of the collection be enumerated by an integer index.
type Interface interface {
	// Len is the number of elements in the collection.
	Len() int
	// Less reports whether the element with
	// index i should sort before the element with index j.
	Less(i, j int) bool
	// Swap swaps the elements with indexes i and j.
	Swap(i, j int)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;オブジェクトのソート&#34;&gt;オブジェクトのソート&lt;/h2&gt;

&lt;p&gt;つまり Sorter インタフェースを持つ型であれば &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Sort()&lt;/code&gt; 関数でソート可能ということになる。
たとえば以下のオブジェクト集合を考える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// A Planet defines the properties of a solar system object.
type Planet struct {
	Name     string
	Mass     float64
	Distance float64
}

var planets = []Planet{
	{&amp;quot;Mercury&amp;quot;, 0.055, 0.4},
	{&amp;quot;Venus&amp;quot;, 0.815, 0.7},
	{&amp;quot;Earth&amp;quot;, 1.0, 1.0},
	{&amp;quot;Mars&amp;quot;, 0.107, 1.5},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Planet&lt;/code&gt; オブジェクトの集合に対する Sorter インタフェースはこんな感じにする&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:str&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:str&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ByMass implements sort.Interface for []Planet based on the Mass field.
type ByMass []Planet

func (a ByMass) Len() int           { return len(a) }
func (a ByMass) Less(i, j int) bool { return a[i].Mass &amp;lt; a[j].Mass }
func (a ByMass) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり &lt;code&gt;Mass&lt;/code&gt; フィールド値の昇順に並べるわけだ。&lt;/p&gt;

&lt;p&gt;全体ではこんな感じになるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;sort&amp;quot;
)

// A Planet defines the properties of a solar system object.
type Planet struct {
	Name     string
	Mass     float64
	Distance float64
}

func (p Planet) String() string {
	return p.Name
}

// ByMass implements sort.Interface for []Planet based on the Mass field.
type ByMass []Planet

func (a ByMass) Len() int           { return len(a) }
func (a ByMass) Less(i, j int) bool { return a[i].Mass &amp;lt; a[j].Mass }
func (a ByMass) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

func main() {
	planets := []Planet{
		{&amp;quot;Mercury&amp;quot;, 0.055, 0.4},
		{&amp;quot;Venus&amp;quot;, 0.815, 0.7},
		{&amp;quot;Earth&amp;quot;, 1.0, 1.0},
		{&amp;quot;Mars&amp;quot;, 0.107, 1.5},
	}

	for _, p := range planets {
		fmt.Printf(&amp;quot;%v &amp;quot;, p)
	}
	fmt.Print(&amp;quot;\n&amp;quot;)
	sort.Sort(ByMass(planets))
	for _, p := range planets {
		fmt.Printf(&amp;quot;%v &amp;quot;, p)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は以下の通りで意図通りの動作になっているのが分かるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run sort3.go
Mercury Venus Earth Mars
Mercury Mars Venus Earth
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sort-slice-関数を使う場合&#34;&gt;&lt;code&gt;sort.Slice()&lt;/code&gt; 関数を使う場合&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; 限定であるが， &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Slice()&lt;/code&gt; 関数を使えば Sorter インタフェースを定義しなくてもソートを行うことができる。
&lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Slice()&lt;/code&gt; 関数の定義は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Slice(slice interface{}, less func(i, j int) bool)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際のコードはこんな感じになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;sort&amp;quot;
)

// A Planet defines the properties of a solar system object.
type Planet struct {
	Name     string
	Mass     float64
	Distance float64
}

func (p Planet) String() string {
	return p.Name
}

func main() {
	planets := []Planet{
		{&amp;quot;Mercury&amp;quot;, 0.055, 0.4},
		{&amp;quot;Venus&amp;quot;, 0.815, 0.7},
		{&amp;quot;Earth&amp;quot;, 1.0, 1.0},
		{&amp;quot;Mars&amp;quot;, 0.107, 1.5},
	}

	for _, p := range planets {
		fmt.Printf(&amp;quot;%v &amp;quot;, p)
	}
	fmt.Print(&amp;quot;\n&amp;quot;)
	sort.Slice(planets, func(i, j int) bool {
		return planets[i].Mass &amp;lt; planets[j].Mass
	})
	for _, p := range planets {
		fmt.Printf(&amp;quot;%v &amp;quot;, p)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Slice()&lt;/code&gt; 関数の第2引数が関数閉包（closure）になっている点に注意&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:c&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:c&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。
これなら第2引数の関数の内容を変えれば任意の規則でソートを行うことができる。&lt;/p&gt;

&lt;p&gt;結果は Sorter インタフェースがある場合と同じく&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run sort4.go
Mercury Venus Earth Mars
Mercury Mars Venus Earth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となった。&lt;/p&gt;

&lt;p&gt;さて，実際に &lt;code&gt;sort.Slice()&lt;/code&gt; 関数を覗いてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// maxDepth returns a threshold at which quicksort should switch
// to heapsort. It returns 2*ceil(lg(n+1)).
func maxDepth(n int) int {
	var depth int
	for i := n; i &amp;gt; 0; i &amp;gt;&amp;gt;= 1 {
		depth++
	}
	return depth * 2
}

// lessSwap is a pair of Less and Swap function for use with the
// auto-generated func-optimized variant of sort.go in
// zfuncversion.go.
type lessSwap struct {
	Less func(i, j int) bool
	Swap func(i, j int)
}

// Slice sorts the provided slice given the provided less function.
//
// The sort is not guaranteed to be stable. For a stable sort, use
// SliceStable.
//
// The function panics if the provided interface is not a slice.
func Slice(slice interface{}, less func(i, j int) bool) {
	rv := reflect.ValueOf(slice)
	swap := reflect.Swapper(slice)
	length := rv.Len()
	quickSort_func(lessSwap{less, swap}, 0, length, maxDepth(length))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;ValueOf()&lt;/code&gt; 関数は &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Value&lt;/code&gt; を取得する関数だ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:rf1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:rf1&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
その次の &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Swapper()&lt;/code&gt; 関数がポイント。
この関数は先程の  Sorter インタフェースでいうところの &lt;code&gt;Swap()&lt;/code&gt; 関数に相当するものを返す&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:rf2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:rf2&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。
なのでこんなこともできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;reflect&amp;quot;
)

func main() {
	s := []int{1, 2, 3}
	fmt.Println(s) // [1 2 3]
	reflect.Swapper(s)(0, 2)
	fmt.Println(s) // [3 2 1]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;残りの &lt;code&gt;Len()&lt;/code&gt; 関数に相当するものは &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Value&lt;/code&gt; で用意されているし， &lt;code&gt;Less()&lt;/code&gt; 関数に相当するものは &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Slice()&lt;/code&gt; 関数の引数として与えられる。
これでソートに必要な3つの関数が揃うわけだ。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;code&gt;quickSort_func()&lt;/code&gt; 関数は，名前の通り，クイックソートである。
ただしクイックソートでは安定ソートにならないため，安定ソートを実行するための &lt;code&gt;sort.SliceStable()&lt;/code&gt; 関数も用意されている。
&lt;code&gt;sort.SliceStable()&lt;/code&gt; 関数ではアルゴリズムに挿入ソートを用いる。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/sugyan/items/fd7138a756c1a409f5fd&#34;&gt;sliceのシャッフル - Qiita&lt;/a&gt; : &lt;a href=&#34;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle&#34;&gt;Fisher–Yates shuffle&lt;/a&gt; というアルゴリズムらしい&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/nyamadandan/items/2c82011801b148c98e52&#34;&gt;Go言語でバイトニックソート実装してみた - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/ohkawa/items/269507985b3ae10cbff9&#34;&gt;Goでバケットソートアルゴリズム(ビット列を使用) - Qiita&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://qiita.com/amesho/items/64dcd231038c96345848&#34;&gt;Goでのアルゴリズムクイックリファレンス第2版(4.1.1 挿入ソート) - Qiita&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://qiita.com/tchssk/items/b61f1f06d22a6232d4c8&#34;&gt;interface{} をソートする - Qiita&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://mattn.kaoriya.net/software/lang/go/20161004092237.htm&#34;&gt;Big Sky :: golang の sort インタフェース難しい問題が解決した&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/remark/2017/02/go-1_8-released/&#34;&gt;Go 言語 1.8 がリリース&lt;/a&gt; : &lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Slice()&lt;/code&gt; 関数はバージョン 1.8 で導入された&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1FO/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/416jAxVU4NL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1FO/baldandersinf-22/&#34;&gt;数学ガール／乱択アルゴリズム&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;結城 浩 &lt;/dd&gt;&lt;dd&gt;SBクリエイティブ株式会社 2014-02-14&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1D6/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1D6.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／ゲーデルの不完全性定理&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1CM/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1CM.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／フェルマーの最終定理&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMK4/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00L0PDMK4.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／ガロア理論&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00EYXMA9I/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00EYXMA9I.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMIQ/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00L0PDMIQ.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／式とグラフ&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34; &gt;工学ガール，リサちゃん登場！&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#34;#maker&#34; class=&#34;reviewer&#34;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2015-04-19&#34;&gt;2015/04/19&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34;&gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:str&#34;&gt;今回は簡単のため &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; を使っているが，データ集合は &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; である必要はなく Sorter インタフェースを持つ任意のオブジェクトであればよい。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:str&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:c&#34;&gt;つか， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の関数は全て関数閉包として動作するんだけどね。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:c&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:rf1&#34;&gt;&lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt; パッケージについての詳細は割愛する。簡単に言うと， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;において &lt;a href=&#34;https://golang.org/doc/effective_go.html#interfaces_and_types&#34; title=&#34;Effective Go - The Go Programming Language&#34;&gt;interface&lt;/a&gt; 型のインスタンスは型情報と値への参照の2つを保持していて，これに対応するのが &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Type&lt;/code&gt; と &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Value&lt;/code&gt; である（参考： &lt;a href=&#34;https://research.swtch.com/interfaces&#34;&gt;research!rsc: Go Data Structures: Interfaces&lt;/a&gt;）。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:rf1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:rf2&#34;&gt;&lt;code&gt;reflect.Swapper()&lt;/code&gt; 関数は引数の型が &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; であることを前提にしていて， &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; でない場合は panic が返る。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:rf2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>インスタンスの生成と Functional Options パターン - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/functional-options-pattern/" />
		<id>tag:text.Baldanders.info,2017-04-04:/golang/functional-options-pattern/</id>
		<published>2017-04-04T01:01:59+09:00</published>
		<updated>2017-04-04T16:22:14+09:00</updated>
		<summary>今回も自分用の覚え書きとして書いておく。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;「&lt;a href=&#34;http://qiita.com/weloan/items/56f1c7792088b5ede136&#34;&gt;Go言語のFunctional Option Pattern - Qiita&lt;/a&gt;」を参考にして今回も自分用の覚え書きとして書いておく。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;には C++ や Java 等にある class 宣言がない。
つまりインスタンス（instance）生成時の構築子（constructor）もない。
ではどうやってインスタンスを生成するのか。&lt;/p&gt;

&lt;p&gt;たとえば以下のような型を考える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package ui

import (
	&amp;quot;io&amp;quot;
)

// UI is Command line user interface
type UI struct {
	reader      io.Reader
	writer      io.Writer
	errorWriter io.Writer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ui.UI&lt;/code&gt; 型のインスタンスを生成するにはいくつかの方法がある。&lt;/p&gt;

&lt;p&gt;まずは &lt;code&gt;new()&lt;/code&gt; 関数を使う方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;u := new(ui.UI)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;new()&lt;/code&gt; 関数でインスタンスを生成する場合は必ずゼロ値で初期化される。
&lt;code&gt;ui.UI&lt;/code&gt; の場合は &lt;code&gt;reader&lt;/code&gt;, &lt;code&gt;writer&lt;/code&gt;, &lt;code&gt;errorWriter&lt;/code&gt; の各フィールドには nil がセットされる。
しかし &lt;a href=&#34;https://golang.org/pkg/io/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Reader&lt;/code&gt; および &lt;a href=&#34;https://golang.org/pkg/io/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Writer&lt;/code&gt; は nil のまま使用すると panic になるため何らかの初期値を与える必要がある。&lt;/p&gt;

&lt;p&gt;2番目は複合リテラル（composite literals）で記述する方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;u := UI{reader: os.Stdin, writer: os.Stdout, errorWriter: os.Stderr}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この方法であれば各フィールドに初期値を与えることができる。
ただしフィールドがパッケージの外からは不可視の場合は（普通そうするよね）この手は使えない。&lt;/p&gt;

&lt;p&gt;そこで，3番目の方法として構築子に相当する関数を考える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package ui

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
)

// UI is Command line user interface
type UI struct {
	reader      io.Reader
	writer      io.Writer
	errorWriter io.Writer
}

// New returns a new UI instance
func New(r io.Reader, w, e io.Writer) *UI {
	if r == nil {
		r = ioutil.NopCloser(bytes.NewReader(nil))
	}
	if w == nil {
		w = ioutil.Discard
	}
	if e == nil {
		e = ioutil.Discard
	}
	return &amp;amp;UI{reader: r, writer: w, errorWriter: e}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうすれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;u := ui.New(os.Stdin, os.Stdout, os.Stderr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と記述することでパッケージ外でも初期化済みのインスタンスを生成できる。
また&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;u := ui.New(nil, nil, nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と無効な値（nil）を引数に指定した場合でもフィールドには（nil ではなく）安全な値がセットされる。&lt;/p&gt;

&lt;p&gt;この方法の問題点は引数に必ず何らかの値をセットしなければならないことだ（&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;にはデフォルト引数（default argument）のような仕組みはない）。
たとえば &lt;code&gt;errorWriter&lt;/code&gt; は既定では使わないことが分かっていてもインスタンス生成時には&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;u := ui.New(os.Stdin, os.Stdout, nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとしなければならない。
また&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// NewWithoutErr returns a new UI instance
func NewWithoutErr(r io.Reader, w io.Writer) *UI {
	return New(r, w, nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと構築子を別途増やす手もあるが，それでは有効なフィールドの組み合わせが増えると関数の管理が煩雑になってしまう。&lt;/p&gt;

&lt;p&gt;そこで4番目の方法。
構築子の引数に初期値をセットするのではなく，初期化関数をセットするのである。
この初期化関数の型を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Option is function value of functional options
type Option func(*UI)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義する&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:srf&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:srf&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
すると構築子は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Option is function value of functional options
type Option func(*UI)

// New returns a new UI instance
func New(opts ...Option) *UI {
	u := &amp;amp;UI{reader: ioutil.NopCloser(bytes.NewReader(nil)), writer: ioutil.Discard, errorWriter: ioutil.Discard}
	for _, opt := range opts {
		opt(u)
	}
	return u
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と記述することができる。&lt;/p&gt;

&lt;p&gt;さらにフィールドごとに &lt;code&gt;Option&lt;/code&gt; 関数を返す関数も定義する（これらの関数を用意することで &lt;code&gt;ui&lt;/code&gt; パッケージを利用するユーザから関数閉包（closure）を隠蔽できる）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Reader returns closure as type Option
func Reader(r io.Reader) Option {
    return func(u *UI) {
        if r != nil {
            u.reader = r
        }

    }
}

//Writer returns closure as type Option
func Writer(w io.Writer) Option {
    return func(u *UI) {
        if w != nil {
            u.writer = w
        }
    }
}

//ErrorWriter returns closure as type Option
func ErrorWriter(e io.Writer) Option {
    return func(u *UI) {
        if e != nil {
            u.errorWriter = e
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうしておけばインスタンス生成時の記述は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;u := ui.New(ui.Reader(os.Stdin), ui.Writer(os.Stdout))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと初期化の必要なフィールドのみ引数で指定でき，かつコードの見た目も分かりやすくできる。
このようなプログラミング・パターンを “Functional Options&amp;rdquo; と呼ぶようである。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://commandcenter.blogspot.jp/2014/01/self-referential-functions-and-design.html&#34;&gt;command center: Self-referential functions and the design of options&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis&#34;&gt;Functional options for friendly APIs | Dave Cheney&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/gocli&#34;&gt;spiegel-im-spiegel/gocli: Command line interface&lt;/a&gt; : 本記事と全く同じではないが， Functional Options パターンの実装例を作ってみた&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:srf&#34;&gt;これを自己参照関数（self-referential function）と呼ぶそうだ。 “&lt;a href=&#34;https://commandcenter.blogspot.jp/2014/01/self-referential-functions-and-design.html&#34; title=&#34;command center: Self-referential functions and the design of options&#34;&gt;Self-referential functions and the design of options&lt;/a&gt;” には自己参照関数の様々なバリエーションが紹介されている。この記事ではもっとも簡単な構造のみ紹介している。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:srf&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>配列と Slice - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/array-and-slice/" />
		<id>tag:text.Baldanders.info,2017-03-15:/golang/array-and-slice/</id>
		<published>2017-03-15T00:31:48+09:00</published>
		<updated>2017-04-04T00:51:45+09:00</updated>
		<summary>配列と slice との関係について。あくまでも私のための覚え書きである。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;以下の記事を見て思わず膝を打った。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/seihmd/items/d9bc98a4f4f606ecaef7&#34;&gt;Goのarrayとsliceを理解するときがきた - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なるほど！ こういう風に説明すればいいのか。
というわけで，私も便乗してみる。
あくまでも私のための覚え書きである。&lt;/p&gt;

&lt;h2 id=&#34;配列は常に-値-である&#34;&gt;配列は常に「値」である&lt;/h2&gt;

&lt;p&gt;まずはこんなコードを書いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func main() {
	ary := Array4{0, 1, 2, 3}
	fmt.Printf(&amp;quot;ary = %p\n&amp;quot;, &amp;amp;ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;[4]int8&lt;/code&gt; が「型」であることを意識してもらうために敢えて &lt;code&gt;Array4&lt;/code&gt; という型を宣言している。
実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary = 0x1040a124
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まぁ分かりやすいよね。
今度はダンプ表示部分を別関数にしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dump(ary Array4) {
	fmt.Printf(&amp;quot;ary(dump) = %p\n&amp;quot;, &amp;amp;ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}

func main() {
	ary := Array4{0, 1, 2, 3}
	fmt.Printf(&amp;quot;ary(org) = %p\n&amp;quot;, &amp;amp;ary)
	dump(ary)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードの実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary(org) = 0x1040a124
ary(dump) = 0x1040a128
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;dump()&lt;/code&gt; 関数の引数として渡される配列がオリジナルのものと異なることが分かるだろう。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では関数の引数は原則として「値渡し（call by value）」であるため，配列を渡す場合でも配列のコピーを作って渡すことになる。
配列を値渡しではなく「参照渡し（call by reference）」にしたい場合はポインタを使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dump(ary *Array4) {
	fmt.Printf(&amp;quot;ary(dump) = %p\n&amp;quot;, ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}

func main() {
	ary := Array4{0, 1, 2, 3}
	fmt.Printf(&amp;quot;ary(org) = %p\n&amp;quot;, &amp;amp;ary)
	dump(&amp;amp;ary)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary(org) = 0x1040a124
ary(dump) = 0x1040a124
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;slice-は配列への参照である&#34;&gt;Slice は配列への参照である&lt;/h2&gt;

&lt;p&gt;次は配列を &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; に置き換えてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func dump(slc []int8) {
	fmt.Printf(&amp;quot;slc(dump) = %p\n&amp;quot;, slc)
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func main() {
	slc := []int8{0, 1, 2, 3}
	fmt.Printf(&amp;quot;slc(org) = %p\n&amp;quot;, slc)
	dump(slc)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配列の場合の記述の違いが分かるだろうか。
この場合 &lt;code&gt;slc&lt;/code&gt; には配列 &lt;code&gt;{0, 1, 2, 3}&lt;/code&gt; へのポインタがセットされる。
したがって &lt;code&gt;dump()&lt;/code&gt; 関数の引数には（見かけ上）配列 &lt;code&gt;{0, 1, 2, 3}&lt;/code&gt; への参照がセットされていることになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;slc(org) = 0x1040a124
slc(dump) = 0x1040a124
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では応用として今度はこんなコードを考えてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dumpA(ary Array4) {
	fmt.Printf(&amp;quot;ary(dumpA) = %p\n&amp;quot;, &amp;amp;ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}

func dumpS(slc []int8) {
	fmt.Printf(&amp;quot;slc(dumpS) = %p\n&amp;quot;, slc)
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func main() {
	ary := Array4{0, 1, 2, 3}
	fmt.Printf(&amp;quot;ary(org) = %p\n&amp;quot;, &amp;amp;ary)
	dumpA(ary)
	slc := ary[:]
	dumpS(slc)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;slc := ary[:]&lt;/code&gt; で配列 &lt;code&gt;ary&lt;/code&gt; が &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; &lt;code&gt;slc&lt;/code&gt; にキャストされているのがポイントである。
実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary(org) = 0x1040a124
ary(dumpA) = 0x1040a128
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
slc(dumpS) = 0x1040a124
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配列 &lt;code&gt;ary&lt;/code&gt; のオリジナルのポインタ値がそのまま &lt;code&gt;slc&lt;/code&gt; の値になっているのが分かると思う。
この「&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; は配列への参照である」ということを踏まえると，こんな面白いコードも書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dumpA(ary Array4) {
	fmt.Printf(&amp;quot;ary(dumpA) = %p\n&amp;quot;, &amp;amp;ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}

func dumpS(slc []int8) {
	fmt.Printf(&amp;quot;pointer(dumpS) = %p\n&amp;quot;, slc)
	fmt.Printf(&amp;quot;size(dumpS) = %v\n&amp;quot;, len(slc))
	fmt.Printf(&amp;quot;capacity(dumpS) = %v\n&amp;quot;, cap(slc))
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func main() {
	ary := Array4{0, 1, 2, 3}
	fmt.Printf(&amp;quot;ary(org) = %p\n&amp;quot;, &amp;amp;ary)
	dumpA(ary)
	slc1 := ary[0:2]
	dumpS(slc1)
	slc2 := slc1[0:4]
	dumpS(slc2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;サイズ 2 の &lt;code&gt;slc1&lt;/code&gt; からサイズ4の &lt;code&gt;slc2&lt;/code&gt; を取得しているのがポイント。
このコードの実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary(org) = 0x1040a124
ary(dumpA) = 0x1040a128
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
pointer(dumpS) = 0x1040a124
size(dumpS) = 2
capacity(dumpS) = 4
0x1040a124: 0
0x1040a125: 1
pointer(dumpS) = 0x1040a124
size(dumpS) = 4
capacity(dumpS) = 4
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; は配列に対してポインタとサイズと容量の3つの属性を持つオブジェクトである。
上述のコードでは配列 &lt;code&gt;ary&lt;/code&gt; を反映し， &lt;code&gt;slc1&lt;/code&gt; の容量が4となるため &lt;code&gt;slc2&lt;/code&gt; ではサイズ4の &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; が作れるわけだ。&lt;/p&gt;

&lt;p&gt;たとえば &lt;code&gt;slc1 := ary[2:4]&lt;/code&gt; と書き換えると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dumpA(ary Array4) {
	fmt.Printf(&amp;quot;ary(dumpA) = %p\n&amp;quot;, &amp;amp;ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}

func dumpS(slc []int8) {
	fmt.Printf(&amp;quot;pointer(dumpS) = %p\n&amp;quot;, slc)
	fmt.Printf(&amp;quot;size(dumpS) = %v\n&amp;quot;, len(slc))
	fmt.Printf(&amp;quot;capacity(dumpS) = %v\n&amp;quot;, cap(slc))
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func main() {
	ary := Array4{0, 1, 2, 3}
	fmt.Printf(&amp;quot;ary(org) = %p\n&amp;quot;, &amp;amp;ary)
	dumpA(ary)
	slc1 := ary[2:4]
	dumpS(slc1)
	slc2 := slc1[0:4]
	dumpS(slc2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;slc1&lt;/code&gt; の容量が変わるため，以下のように実行時 panic になる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary(org) = 0x1040a124
ary(dumpA) = 0x1040a128
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
pointer(dumpS) = 0x1040a126
size(dumpS) = 2
capacity(dumpS) = 2
0x1040a126: 2
0x1040a127: 3
panic: runtime error: slice bounds out of range
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように配列と &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; の関係が分かると &lt;code&gt;append()&lt;/code&gt; 関数の挙動も理解しやすくなる。&lt;/p&gt;

&lt;p&gt;ところで先ほど &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; は「ポインタとサイズと容量の3つの属性を持つオブジェクト」と書いた。
つまり厳密に言えば，関数の引数に &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; をセットするということは「ポインタとサイズと容量の3つの属性を持つオブジェクト」を値渡しでセットしているということになる。
たとえば以下のようなコードを考える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dumpS(slc []int8) {
	fmt.Printf(&amp;quot;pointer(dumpS) = %p\n&amp;quot;, slc)
	fmt.Printf(&amp;quot;size(dumpS) = %v\n&amp;quot;, len(slc))
	fmt.Printf(&amp;quot;capacity(dumpS) = %v\n&amp;quot;, cap(slc))
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func addS(slc []int8, e int8) {
	slc = append(slc, e)
	dumpS(slc)
}

func main() {
	slc := make([]int8, 4, 8)
	slc[0] = 0
	slc[1] = 1
	slc[2] = 2
	slc[3] = 3
	dumpS(slc)
	addS(slc, 4)
	dumpS(slc)
	slc2 := slc[0:5]
	dumpS(slc2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;杜撰なコードではあるが，サイズ4容量8の配列に5番目の要素を &lt;code&gt;append()&lt;/code&gt; しても内部の配列そのものは更新されないため動きとしては問題ないように見える。
しかし実際には以下のような実行結果になる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;pointer(dumpS) = 0x1040a128
size(dumpS) = 4
capacity(dumpS) = 8
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
pointer(dumpS) = 0x1040a128
size(dumpS) = 5
capacity(dumpS) = 8
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
0x1040a12c: 4
pointer(dumpS) = 0x1040a128
size(dumpS) = 4
capacity(dumpS) = 8
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
pointer(dumpS) = 0x1040a128
size(dumpS) = 5
capacity(dumpS) = 8
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
0x1040a12c: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり &lt;code&gt;addS()&lt;/code&gt; 関数に渡す &lt;code&gt;slc&lt;/code&gt; は値渡しなので &lt;code&gt;addS()&lt;/code&gt; 関数内で &lt;code&gt;slc&lt;/code&gt; のサイズが変わっても関数の呼び出し元には反映されないことになる（配列自体には値がセットされている）。
&lt;code&gt;append()&lt;/code&gt; 関数実行後は必ず状態が変わるため正しく &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; の「値」を更新する必要がある。&lt;/p&gt;

&lt;h2 id=&#34;配列の複製&#34;&gt;配列の複製&lt;/h2&gt;

&lt;p&gt;配列を明示的に複製して使いたい場合がある。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では配列の複製はとても簡単である。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Array4 [4]int8

func dump(ary *Array4) {
	fmt.Printf(&amp;quot;ary(dump) = %p\n&amp;quot;, ary)
	for i := 0; i &amp;lt; len(ary); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;ary[i], ary[i])
	}
}

func main() {
	ary := Array4{0, 1, 2, 3}
	var ary2 Array4
	fmt.Printf(&amp;quot;ary(org) = %p\n&amp;quot;, &amp;amp;ary)
	dump(&amp;amp;ary)
	ary2 = ary
	dump(&amp;amp;ary2)
    if ary == ary2 {
		fmt.Println(&amp;quot;ary == ary2&amp;quot;)
	} else {
		fmt.Println(&amp;quot;ary != ary2&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ary(org) = 0x1040a124
ary(dump) = 0x1040a124
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
ary(dump) = 0x1040a128
0x1040a128: 0
0x1040a129: 1
0x1040a12a: 2
0x1040a12b: 3
ary == ary2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ary&lt;/code&gt; と &lt;code&gt;ary2&lt;/code&gt; が同じ内容の異なるインスタンス（instance）であることが分かると思う。
また配列同士の比較も同じ型であれば単純である。
&lt;code&gt;[3]int8&lt;/code&gt; と &lt;code&gt;[4]int8&lt;/code&gt; は異なる型と見なされるため単純比較はできない。&lt;/p&gt;

&lt;p&gt;一方， &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; の複製が欲しい場合は &lt;code&gt;copy()&lt;/code&gt; 関数を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;reflect&amp;quot;
)

type Array4 [4]int8

func dumpS(slc []int8) {
	fmt.Printf(&amp;quot;pointer(dumpS) = %p\n&amp;quot;, slc)
	fmt.Printf(&amp;quot;size(dumpS) = %v\n&amp;quot;, len(slc))
	fmt.Printf(&amp;quot;capacity(dumpS) = %v\n&amp;quot;, cap(slc))
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func main() {
	slc1 := []int8{0, 1, 2, 3}
	dumpS(slc1)
	slc2 := make([]int8, len(slc1), cap(slc1))
	copy(slc2, slc1)
	dumpS(slc2)
	if reflect.DeepEqual(slc1, slc2) {
		fmt.Println(&amp;quot;slc1 == slc2&amp;quot;)
	} else {
		fmt.Println(&amp;quot;slc1 != slc2&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コピー先の &lt;code&gt;slc2&lt;/code&gt; について &lt;code&gt;make()&lt;/code&gt; 関数であらかじめサイズと容量を確保しておくのがポイント。
実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;pointer(dumpS) = 0x1040a124
size(dumpS) = 4
capacity(dumpS) = 4
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
pointer(dumpS) = 0x1040a144
size(dumpS) = 4
capacity(dumpS) = 4
0x1040a144: 0
0x1040a145: 1
0x1040a146: 2
0x1040a147: 3
slc1 == slc2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; 同士を比較するのも単純ではないが， &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;DeepEqual()&lt;/code&gt; 関数が使える。
ちなみに 宣言構文を使ってもっと単純に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;reflect&amp;quot;
)

type Array4 [4]int8

func dumpS(slc []int8) {
	fmt.Printf(&amp;quot;pointer(dumpS) = %p\n&amp;quot;, slc)
	fmt.Printf(&amp;quot;size(dumpS) = %v\n&amp;quot;, len(slc))
	fmt.Printf(&amp;quot;capacity(dumpS) = %v\n&amp;quot;, cap(slc))
	for i := 0; i &amp;lt; len(slc); i++ {
		fmt.Printf(&amp;quot;%p: %v\n&amp;quot;, &amp;amp;slc[i], slc[i])
	}
}

func main() {
	slc1 := []int8{0, 1, 2, 3}
	dumpS(slc1)
    slc2 := slc1
	dumpS(slc2)
	if reflect.DeepEqual(slc1, slc2) {
		fmt.Println(&amp;quot;slc1 == slc2&amp;quot;)
	} else {
		fmt.Println(&amp;quot;slc1 != slc2&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすればいいじゃない，と思われるかもしれないが，結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;pointer(dumpS) = 0x1040a124
size(dumpS) = 4
capacity(dumpS) = 4
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
pointer(dumpS) = 0x1040a124
size(dumpS) = 4
capacity(dumpS) = 4
0x1040a124: 0
0x1040a125: 1
0x1040a126: 2
0x1040a127: 3
slc1 == slc2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;slc1&lt;/code&gt; と &lt;code&gt;slc2&lt;/code&gt; の指す配列が同じになり複製できない。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/go-slices-usage-and-internals&#34;&gt;Go Slices: usage and internals - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/slices&#34;&gt;Arrays, slices (and strings): The mechanics of &amp;lsquo;append&amp;rsquo; - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/golang-slice-internals2&#34;&gt;Go のスライスでハマッたところ - Block Rockin’ Codes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/mattn/items/176459728ff4f854b165&#34;&gt;golang で string を []byte にキャストしてもメモリコピーが走らない方法を考えてみる - Qiita&lt;/a&gt; : ネタ記事&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/function-and-pointer/&#34;&gt;関数とポインタ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>きみは Generics がとくいなフレンズなんだね，または「制約は構造を生む」 - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2017/03/generics-vs-duck-typing/" />
		<id>tag:text.Baldanders.info,2017-03-11:/remark/2017/03/generics-vs-duck-typing/</id>
		<published>2017-03-11T14:55:06+09:00</published>
		<updated>2017-09-14T09:22:48+09:00</updated>
		<summary>これはどちらが正しいかという問題ではない。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;figure&gt;
&lt;blockquote&gt;
&lt;q&gt;公理によって与えられる暗黙の制約。この制約が集合の要素同士をしっかり結びつける。単純にしばるのではない、相互に秩序ある関係を結ぶ。言い換えれば――公理によって与えられる制約が構造を生み出しているのだ&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1CM/baldandersinf-22/&#34;&gt;数学ガール／フェルマーの最終定理&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;今回は戯れ言モードなので「&lt;a href=&#34;http://text.baldanders.info/golang/&#34;&gt;プログラミング言語 Go&lt;/a&gt;」ではなくこちらで書いてみる。
コードは1行も書かないのでご安心を（笑）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mattn.kaoriya.net/software/lang/go/20170309201506.htm&#34;&gt;Big Sky :: golang と Generics と私&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/yuroyoro/items/6bf33f3cd4bb35469e0b&#34;&gt;golang と Generics と吾 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/t2y/items/139c6a38173d7750ddfc&#34;&gt;Java の Generics にもの思い - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;私は出自が組込みエンジニアで（今は何でも屋），アセンブラや C/C++ から始まり Java などの制御に向いていると言われる言語を遍歴している（PHP を機器制御に使うとかいうこともやったが）。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;もその流れから興味を持っているが，あいにく私が住んでいる地方都市で &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の出番はまだない。&lt;/p&gt;

&lt;p&gt;そういう経歴を持つ私から見て &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;が特異だと思ったのは以下の2点である。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;例外処理がない&lt;/li&gt;
&lt;li&gt;明示的なクラス定義構文がない&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;私だけでなく C++ や Java などから来た人は大抵これで面食らうらしい。&lt;/p&gt;

&lt;p&gt;このうち1番目については「&lt;a href=&#34;http://text.baldanders.info/golang/&#34;&gt;プログラミング言語 Go&lt;/a&gt;」で&lt;a href=&#34;http://text.baldanders.info/golang/error-handling/&#34; title=&#34;エラー・ハンドリングについて&#34;&gt;記事にした&lt;/a&gt;ので割愛する。&lt;/p&gt;

&lt;p&gt;さて，2番目の「明示的なクラス定義構文がない」について。&lt;/p&gt;

&lt;p&gt;そもそも「クラス」とはなにか。
クラスとは以下の要素をひとまとめの「モノ（object）」として定義したものである。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;名前（必ず1個）&lt;/li&gt;
&lt;li&gt;属性（0個以上）&lt;/li&gt;
&lt;li&gt;操作（0個以上）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では明示的なクラス定義構文がない代わりに &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; と &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt;，およびメソッド・レシーバを組み合わせることでクラスの要素である名前，属性，操作を定義できる。&lt;/p&gt;

&lt;p&gt;そしてクラス定義で重要なのは「クラス間の関係」を定義することである。
クラス間の関係としては大雑把に以下の2つがある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;汎化・特化（継承 等）&lt;/li&gt;
&lt;li&gt;関連（集約，依存 等）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;このうち2番目の関連は定義しやすい。
あるクラスの属性として別のクラスを定義するか，操作によって関連付けるかすればいいからだ。
問題は1番目の汎化・特化をどうやって定義するかである。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の場合は &lt;a href=&#34;https://golang.org/ref/spec#Interface_types&#34; title=&#34;Interface types&#34;&gt;interface&lt;/a&gt; を使った &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:dt&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:dt&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; を採用した。
&lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; とはクラスの振る舞いに注目してクラス間の汎化・特化関係を帰納法的に定義することである。
例を挙げると，それが「にゃーん」と鳴くのなら机器猫だろうが猫耳メイドだろうがサーバルキャットだろうが全部「猫」である，ということだ。&lt;/p&gt;

&lt;p&gt;クラス間の関係を定義するのは意外に大変である。
皆さんは「クラス設計」をどのように行っているだろうか。
まずは具体的なクラスを列挙していき，それらの関係を考察していくのではないだろうか（「ユーザ」や「管理者」を定義するのに 動物→人間→&amp;hellip; と考えていく人はいないだろう）。
考察する過程で（クラスとクラスを繋ぐ）不可視のクラスを発見したり複数のクラスがひとつの概念で括れることに気づいたりすることもある。
つまり設計する過程では「具象→抽象」へと遡っていく。&lt;/p&gt;

&lt;p&gt;一方，実装する際には， C++ や Java では最初にテンプレート・クラスやインタフェース・クラスを作ってからインプリメント・クラスに落とし込む。&lt;/p&gt;

&lt;p&gt;たとえば，最初に「猫」という抽象クラスを作っておいて，それを継承する形で机器猫や猫耳メイドやサーバルキャットといった具体的なクラスを実装していく。
つまり「抽象→具象」へと作業していくわけだ。
そしてその過程において Generics&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:g1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:g1&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; は，ほとんど必須と言えるほど利用価値の高い機能と言える。&lt;/p&gt;

&lt;p&gt;これが &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;による実装ではひっくり返る。
たとえば，最初に机器猫や猫耳メイドやサーバルキャットといった具体的なクラスを作っていって「これってみんな『にゃーん』って鳴くじゃん」と気がつけば後付けで「猫」という抽象クラスを実装できるのである。&lt;/p&gt;

&lt;p&gt;どういうことかというと， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;においては設計と実装を同時進行で「具象→抽象」へと考察していくことができる，ということである。
このような思考過程においては Generics の有無はさして重要ではなくなる。
だって具象化されたオブジェクトから作り始めるのだから。&lt;/p&gt;

&lt;p&gt;「抽象→具象」へと実装する人にとっては Generics のない &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;はとてもまだるこしく見えるかもしれない。
「なんで Generics がねーんだよ。いちいち全部書かせる気か。このポンコツ言語が！」となること請け合いである。
しかし一度 &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; に慣れた人にとっては抽象クラスから書かなければならない C++ や Java こそが面倒くさい。
何故なら，脳内では「具象→抽象」で思考していくのに実際に書くときには「考え終わらないと書けない&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:cd1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:cd1&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;」からである。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;なら「考えながら書ける」のに。&lt;/p&gt;

&lt;p&gt;これはどちらが正しいかという問題ではない。&lt;/p&gt;

&lt;p&gt;たとえばウォータフォール型&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:wf&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:wf&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; の開発スタイルでは実装を開始するまでに設計が終わることが（建前上は）保証されているため「抽象→具象」へと書き進めることが容易な言語が向いている。
一方，要件が絶えず変わったり実験的な製品の場合は設計が終わるまで待っていられないため &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のような言語が向いてるかもしれない。
まぁ設計と実装を同時にやろうとするとリファクタリングが頻繁に発生するのでコピペ・プログラマにはキツい作業になるかもしれないが。&lt;/p&gt;

&lt;p&gt;個人的には「プログラマは要件定義の段階から参加してコードを書くべき」と思ってるので，これを容易にするであろう &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;には注目している。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;Why Everyone Hates Go · npf.io&#34;&gt;Why Everyone Hates Go · npf.io&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/hirokidaichi/items/adccebb41f77eaa6132f&#34;&gt;[翻訳]なんでGoってみんなに嫌われてるの？ - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dave.cheney.net/2017/03/20/why-go&#34;&gt;Why Go? | Dave Cheney&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/methane/items/b627f20457873a504638&#34;&gt;[翻訳] Why Go? - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jsstudy.hatenablog.com/entry/2017/03/29/214931&#34;&gt;JavaScriptで継承を使わないプログラミングスタイル - JavaScript勉強会&lt;/a&gt; : オブジェクト指向設計について上手くまとめている&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:dt&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; の由来は &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_test&#34; title=&#34;Duck test - Wikipedia&#34;&gt;duck test&lt;/a&gt; だそうで， &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_test&#34; title=&#34;Duck test - Wikipedia&#34;&gt;duck test&lt;/a&gt; とは “If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.” と帰納法的に対象を推測する手法を指すらしい。 &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; のメリットのひとつは多重継承で発生する様々な問題（名前の衝突や菱形継承など）を気にする必要がない点である。念のために言うと， &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; の概念自体は  &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;が初出というわけではない。オブジェクト指向プログラミングをサポートするスクリプト言語（Ruby など）では大抵 &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; な記述が可能である。またコンパイル言語でも Generics やそれに近い機能（C# の dynamic 型など）をサポートする場合は &lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34; title=&#34;Duck typing - Wikipedia&#34;&gt;duck typing&lt;/a&gt; な記述が可能な場合がある。  &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;が特異なのは（class キーワードなどを使った）古典的な継承関係の定義構文をざっくり捨て去ってる点にある。プログラミングの「考え方」を切り替える必要があるのだ。これは私たちプログラマが息をするように書いてきた継承（is-a）関係の実装について改めて考察する機会だと私は思う。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:dt&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:g1&#34;&gt;知らない人のために Generics について簡単に説明しておくと，変数の型あるいはインスタンス（instance）に対するクラス（class）に関係なく単一の記述で変数ないしインスタンスを扱うことのできる仕組みである。汎化の一種と考えてもよい。いわゆる多態性（polymorphism）とは異なり，継承関係の異なるクラスでも一緒くたに扱うことが可能なかなり強力な仕組みである。 Generics は特にコンテナ（container; オブジェクトの集まりを表現するデータ構造，配列など）操作で威力を発揮する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:g1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:cd1&#34;&gt;私はこれを「写経」と呼んでいる。はっきり言ってプログラミングでもっとも苦痛なのがコーディング＝写経だったりする。ちなみに一番好きなのはデバッグ。特に他人の書いたコードをデバッグするのは大好物。あれは極上の数理パズルである（締切さえなければね）。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:cd1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:wf&#34;&gt;「ウォータフォール型」とは滝の水が上から下へと落ちていくように 要件定義→設計→製造 と上流工程から下流工程へ順番にプロセスを進めていく開発スタイル。工程ごとにマイルストーンを設けてチェックを行い，各工程が完了しないと先に進めないようにする。まぁ実際にはスケジュールやらの関係でチェックを端折って先に進めてしまうことが多く，下流工程に入ってから致命的な欠陥に気づいて抜き差しならない状況に陥ることもしばしばある（笑）
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:wf&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>「プレミアムフライデー」を求めるパッケージを作ってみた - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/premium-friday/" />
		<id>tag:text.Baldanders.info,2017-03-04:/golang/premium-friday/</id>
		<published>2017-03-04T09:40:51+09:00</published>
		<updated>2017-03-07T09:38:50+09:00</updated>
		<summary>もちろん息抜きである。潤いは大事。でも実用性はないと思われ。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;そういえば先月の「プレミアムフライデー」，皆様はいかがお過ごしでしたか。
私は3時間も残業してしまいましたよ（笑）&lt;/p&gt;

&lt;p&gt;ちうわけで，以下を真似して「プレミアムフライデー」を求めるパッケージを考えてみる。
もちろん息抜きである。
潤いは大事。
でも実用性はないと思われ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/neko_the_shadow/items/4ebf94a8a6d9282e7207&#34;&gt;プレミアムフライデーを求めるメソッドを作った - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/deaf_tadashi/items/963a62072338f09f12a5&#34;&gt;プレミアムフライデーを求めるメソッドを作った（Java8版） - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まずはパッケージ分割しないでベタに書いてみる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:rf1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:rf1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;time&amp;quot;
)

//GetPremiumFriday returns day of premium friday
func GetPremiumFriday(y int, m time.Month) (int, error) {
	//引数のチェック
    if y &amp;lt; 2017 || m &amp;lt; time.January || m &amp;gt; time.December {
		return 0, os.ErrInvalid
	}
	if y == 2017 &amp;amp;&amp;amp; m &amp;lt; time.February { //2017年1月は実施前なのでエラー
		return 0, os.ErrInvalid
	}

	//指定月末（翌月0日）で初期化する
    tm := time.Date(y, m+1, 0, 0, 0, 0, 0, time.UTC) //時差は影響しないので，とりあえず UTC で

    w := tm.Weekday() - time.Friday
	if w &amp;lt; 0 {
		w += 7
	}
	return tm.Day() - (int)(w), nil
}

func main() {
	flag.Parse()
	argsStr := flag.Args()
	if len(argsStr) &amp;lt; 2 {
		fmt.Fprintln(os.Stderr, &amp;quot;年月を指定してください&amp;quot;)
		return
	}
	args := make([]int, 2)
	for i := 0; i &amp;lt; 2; i++ {
		num, err := strconv.Atoi(argsStr[i])
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			return
		}
		args[i] = num
	}
	d, err := GetPremiumFriday(args[0], time.Month(args[1]))
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	fmt.Println(d)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定月末を求めるのに「翌月0日」で初期化するのがポイント（つか，ここしかポイントになるものがない&lt;code&gt;w&lt;/code&gt;）。
実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run pf.go 2017 2
24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;期待通りの値が得られた。&lt;/p&gt;

&lt;p&gt;関数1個だけなんでパッケージにするのもどうかと思うけど折角なのでパッケージ化してみた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/pf&#34;&gt;spiegel-im-spiegel/pf: Premium Friday&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内容は &lt;code&gt;GetPremiumFriday()&lt;/code&gt; 関数を切り出しただけ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package pf

import (
	&amp;quot;os&amp;quot;
	&amp;quot;time&amp;quot;
)

//GetPremiumFriday returns day of premium friday
func GetPremiumFriday(y int, m time.Month) (int, error) {
	//引数のチェック
    if y &amp;lt; 2017 || m &amp;lt; time.January || m &amp;gt; time.December {
		return 0, os.ErrInvalid
	}
	if y == 2017 &amp;amp;&amp;amp; m &amp;lt; time.February { //2017年1月は実施前なのでエラー
		return 0, os.ErrInvalid
	}

	//指定月末（翌月0日）で初期化する
    tm := time.Date(y, m+1, 0, 0, 0, 0, 0, time.UTC) //時差は影響しないので，とりあえず UTC で

    w := tm.Weekday() - time.Friday
	if w &amp;lt; 0 {
		w += 7
	}
	return tm.Day() - (int)(w), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;したがって &lt;code&gt;main()&lt;/code&gt; 関数はこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/pf&amp;quot;
)

func main() {
	flag.Parse()
	argsStr := flag.Args()
	if len(argsStr) &amp;lt; 2 {
		fmt.Fprintln(os.Stderr, &amp;quot;年月を指定してください&amp;quot;)
		return
	}
	args := make([]int, 2)
	for i := 0; i &amp;lt; 2; i++ {
		num, err := strconv.Atoi(argsStr[i])
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			return
		}
		args[i] = num
	}
	d, err := pf.GetPremiumFriday(args[0], time.Month(args[1]))
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	fmt.Println(d)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まぁこんなもんかな。
遊んだ遊んだ。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/qube81/items/1e93c837c0a7e3d99a10&#34;&gt;Golangでプレミアムフライデーかどうか判定する - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:rf1&#34;&gt;元記事のコードがループさせてたんでこっちもついループさせちゃったけど，考えてみれば（いや考えるまでもなく）ループを回す必要はなかった。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:rf1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>演算子とステートメント - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/operators-and-statements/" />
		<id>tag:text.Baldanders.info,2017-02-20:/golang/operators-and-statements/</id>
		<published>2017-02-20T21:07:33+09:00</published>
		<updated>2017-02-21T11:44:15+09:00</updated>
		<summary>今回は「つまみ食い」的に演算子（operator）とステートメント（statement）について解説する。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（この記事は &lt;a href=&#34;http://qiita.com/&#34;&gt;Qiita&lt;/a&gt; に投稿した「&lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/2c6cf5ff44d816d1be7b&#34;&gt;Go 言語の &lt;code&gt;++&lt;/code&gt; や &lt;code&gt;--&lt;/code&gt; は演算子ではない - Qiita&lt;/a&gt;」を大幅に修正して再構成したものです）&lt;/p&gt;

&lt;p&gt;あるプログラミング言語を習得する際に最も早道なのは「たくさんの（他人の）コードを読むこと」であり「たくさんのコードを（コピペではなく自分で）書く」ことである。
これは間違いない。
しかし，その言語の仕様をきちんと把握してないとコードを読んでも間違って理解するかもしれないし，何より実際に自分でコードを書く際に躓く原因になる。&lt;/p&gt;

&lt;p&gt;というわけで，少なくとも学ぶ言語の言語仕様を一度は眺めておくことをお勧めする。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の場合は以下のページで言語仕様を見ることができる（“&lt;a href=&#34;https://tour.golang.org/&#34;&gt;A Tour of Go&lt;/a&gt;” の後で読むと頭に入りやすいかもしれない）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://golang.jp/go_spec&#34;&gt;Goプログラミング言語仕様 - golang.jp&lt;/a&gt; : 日本語だが内容が古いので注意&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回は「つまみ食い」的に演算子（operator）とステートメント（statement）&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:stmt&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:stmt&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; について軽く紹介してみる。&lt;/p&gt;

&lt;h2 id=&#34;stmnt&#34;&gt;ステートメント&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;においては「ステートメント」は以下のように定義されている。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Statement =
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;まぁ名前で何か大体わかると思う。
ここでは &lt;code&gt;SimpleStmt&lt;/code&gt; (simple statement) に絞って紹介しよう。&lt;/p&gt;

&lt;h3 id=&#34;empty-statements&#34;&gt;Empty Statements&lt;/h3&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;EmptyStmt = .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;文字通り空のステートメント。&lt;/p&gt;

&lt;h3 id=&#34;expression-statements&#34;&gt;Expression Statements&lt;/h3&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ExpressionStmt = Expression .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;式（expression）を表すステートメント。
関数呼び出しや受信操作のコンテキスト内に記述できる。&lt;/p&gt;

&lt;p&gt;さらに式は以下のように定義される。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = &amp;quot;||&amp;quot; | &amp;quot;&amp;amp;&amp;amp;&amp;quot; | rel_op | add_op | mul_op .
rel_op     = &amp;quot;==&amp;quot; | &amp;quot;!=&amp;quot; | &amp;quot;&amp;lt;&amp;quot; | &amp;quot;&amp;lt;=&amp;quot; | &amp;quot;&amp;gt;&amp;quot; | &amp;quot;&amp;gt;=&amp;quot; .
add_op     = &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;|&amp;quot; | &amp;quot;^&amp;quot; .
mul_op     = &amp;quot;*&amp;quot; | &amp;quot;/&amp;quot; | &amp;quot;%&amp;quot; | &amp;quot;&amp;lt;&amp;lt;&amp;quot; | &amp;quot;&amp;gt;&amp;gt;&amp;quot; | &amp;quot;&amp;amp;&amp;quot; | &amp;quot;&amp;amp;^&amp;quot; .

unary_op   = &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;!&amp;quot; | &amp;quot;^&amp;quot; | &amp;quot;*&amp;quot; | &amp;quot;&amp;amp;&amp;quot; | &amp;quot;&amp;lt;-&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;（&lt;code&gt;PrimaryExpr&lt;/code&gt; (primary expression) については割愛する。詳細は「&lt;a href=&#34;https://golang.org/ref/spec&#34; title=&#34;The Go Programming Language Specification - The Go Programming Language&#34;&gt;言語仕様&lt;/a&gt;」で確かめてみてください。ここでは &lt;code&gt;Expression&lt;/code&gt; を構成する要素にはステートメントが含まれないことに注目）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;binary_op&lt;/code&gt;, &lt;code&gt;rel_op&lt;/code&gt;, &lt;code&gt;add_op&lt;/code&gt;, &lt;code&gt;mul_op&lt;/code&gt;, &lt;code&gt;unary_op&lt;/code&gt; は演算子である。
演算子については&lt;a href=&#34;#op&#34;&gt;後述&lt;/a&gt;する。&lt;/p&gt;

&lt;h3 id=&#34;send-statements&#34;&gt;Send Statements&lt;/h3&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;SendStmt = Channel &amp;quot;&amp;lt;-&amp;quot; Expression .
Channel  = Expression .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; 送信のステートメント。&lt;/p&gt;

&lt;h3 id=&#34;incdec-statements&#34;&gt;IncDec Statements&lt;/h3&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;IncDecStmt = Expression ( &amp;quot;++&amp;quot; | &amp;quot;--&amp;quot; ) .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;インクリメント（increment）およびデクリメント（decrement）のステートメント。
C/C++ のように &lt;code&gt;++x&lt;/code&gt; みたいな記述はできないので注意。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;code&gt;IncDecStmt&lt;/code&gt; は次の代入ステートメントの以下の記述と同じである。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IncDec statement&lt;/th&gt;
&lt;th&gt;Assignment&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x++&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x += 1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x -= 1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;assignments&#34;&gt;Assignments&lt;/h3&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Assignment = ExpressionList assign_op ExpressionList .
assign_op = [ add_op | mul_op ] &amp;quot;=&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;代入。
&lt;code&gt;add_op&lt;/code&gt;, &lt;code&gt;mul_op&lt;/code&gt; は先ほど出た &lt;code&gt;Expression&lt;/code&gt; の演算子を指す。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;add_op     = &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;|&amp;quot; | &amp;quot;^&amp;quot; .
mul_op     = &amp;quot;*&amp;quot; | &amp;quot;/&amp;quot; | &amp;quot;%&amp;quot; | &amp;quot;&amp;lt;&amp;lt;&amp;quot; | &amp;quot;&amp;gt;&amp;gt;&amp;quot; | &amp;quot;&amp;amp;&amp;quot; | &amp;quot;&amp;amp;^&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;定義だと &lt;code&gt;assign_op&lt;/code&gt; は演算子っぽく見える。
そもそも代入を “assignment operation” と表記しているのだ。
どうなんだろう。
まぁ，いずれにしろ代入自体は間違いなくステートメントであり式の中には含められない。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;code&gt;ExpressionList&lt;/code&gt; は &lt;code&gt;Expression&lt;/code&gt; を列挙したものである。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ExpressionList = Expression { &amp;quot;,&amp;quot; Expression } .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;これにより代入の左辺・右辺を組（tuple）で記述できる。
たとえば2つの変数の値を入れ替える場合は以下のように記述する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x, y = y, x
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;short-variable-declarations&#34;&gt;Short Variable Declarations&lt;/h3&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;ShortVarDecl = IdentifierList &amp;quot;:=&amp;quot; ExpressionList .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;変数宣言の短縮表現。
&lt;code&gt;var&lt;/code&gt; キーワードを使った以下の表現と同じ。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;&amp;quot;var&amp;quot; IdentifierList = ExpressionList .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;IdentifierList&lt;/code&gt; は &lt;code&gt;identifier&lt;/code&gt; を列挙したもので&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;IdentifierList = identifier { &amp;quot;,&amp;quot; identifier } .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;これにより &lt;code&gt;identifier&lt;/code&gt; で記述される複数の変数をまとめて宣言・初期化できる。
&lt;code&gt;identifier&lt;/code&gt; の定義は以下の通り&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;identifier = letter { letter | unicode_digit } .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;ちなみに変数名となる &lt;code&gt;identifier&lt;/code&gt; は全ての Unicode 文字を許容する。
なので日本語交じりでこんな書き方もできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    わーい := &amp;quot;わーい！ たのしー！&amp;quot;
    fmt.Println(わーい)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;op&#34;&gt;演算子&lt;/h2&gt;

&lt;p&gt;さて，式と演算子の定義を再び掲げる。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = &amp;quot;||&amp;quot; | &amp;quot;&amp;amp;&amp;amp;&amp;quot; | rel_op | add_op | mul_op .
rel_op     = &amp;quot;==&amp;quot; | &amp;quot;!=&amp;quot; | &amp;quot;&amp;lt;&amp;quot; | &amp;quot;&amp;lt;=&amp;quot; | &amp;quot;&amp;gt;&amp;quot; | &amp;quot;&amp;gt;=&amp;quot; .
add_op     = &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;|&amp;quot; | &amp;quot;^&amp;quot; .
mul_op     = &amp;quot;*&amp;quot; | &amp;quot;/&amp;quot; | &amp;quot;%&amp;quot; | &amp;quot;&amp;lt;&amp;lt;&amp;quot; | &amp;quot;&amp;gt;&amp;gt;&amp;quot; | &amp;quot;&amp;amp;&amp;quot; | &amp;quot;&amp;amp;^&amp;quot; .

unary_op   = &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;!&amp;quot; | &amp;quot;^&amp;quot; | &amp;quot;*&amp;quot; | &amp;quot;&amp;amp;&amp;quot; | &amp;quot;&amp;lt;-&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で式に使える演算子はここに挙げられているものが全てである。
このうち二項演算子（&lt;code&gt;binary_op&lt;/code&gt;）には優先順位が付けられている。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Precedence&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Operator&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;*  /  %  &amp;lt;&amp;lt;  &amp;gt;&amp;gt;  &amp;amp;  &amp;amp;^&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;+  -&lt;/code&gt;  |  &lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;==  !=  &amp;lt;  &amp;lt;=  &amp;gt;  &amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;||&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;なお単項演算子（&lt;code&gt;unary_op&lt;/code&gt;）は二項演算子よりも高い優先順位で機能する。
したがって全体としてはこんな感じだろうか。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Precedence&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Operator&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;unary_op&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;mul_op&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;add_op&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;rel_op&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;||&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;インクリメント-デクリメントは演算子ではない&#34;&gt;インクリメント／デクリメントは演算子ではない&lt;/h3&gt;

&lt;p&gt;たとえば &lt;a href=&#34;http://www.bohyoh.com/CandCPP/C/operator.html&#34; title=&#34;BohYoh.com【Ｃ言語講座】演算子一覧表&#34;&gt;C 言語の演算子&lt;/a&gt;と比較すると &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;ではインクリメント（&lt;code&gt;++&lt;/code&gt;）／デクリメント（&lt;code&gt;--&lt;/code&gt;）が演算子として扱われていないことに気付く&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:op&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:op&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;ではインクリメント／デクリメント（および代入）はステートメントである。&lt;/p&gt;

&lt;p&gt;これはどういうことかというと，たとえば C 言語のコードに似せて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	i := 1
	fmt.Println(i++)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書いてコンパイルしようとしても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;syntax error: unexpected ++, expecting comma or )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とコンパイルエラーになるということである（式を構成する要素にステートメントは含まれないことを思い出してほしい）。
これはコードを，以下のように，代入に置き換えたほうが直感的で分かりやすいかもしれない。
（この場合も「&lt;code&gt;syntax error: unexpected +=, expecting comma or )&lt;/code&gt;」でコンパイルエラーになる）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	i := 1
	fmt.Println(i+=1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私見で申し訳ないが，私は「式中の演算子は変数の状態を変えるべきではない」と考えている。
たとえば C/C++ では &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt; 演算子を前置にすべきか後置にすべきかというのでよく議論になる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:pp&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:pp&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
しかし，これはそもそも &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt; 演算子が式の中で対象の変数の状態を変えてしまうことに問題があるのだ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;ではインクリメントやデクリメント（あるいは代入）といった変数の状態を変える操作をステートメントとし，式の中に埋め込むことを禁止することでこの問題を回避しているように見える。
式の中で変数の状態が変わらないのであれば副作用を気にすることなく安全にコードを書くことができる。&lt;/p&gt;

&lt;p&gt;ただし例外がある。&lt;/p&gt;

&lt;h3 id=&#34;channel-操作&#34;&gt;&lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; 操作&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; 操作では，送信はステートメントだが受信は &lt;code&gt;&amp;lt;-&lt;/code&gt; 単項演算子を使う。
したがって，こんな記述もできる（意味があるかどうかはともかく）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch2 &amp;lt;- &amp;lt;-ch1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; 受信を含んだ式では &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; 変数の状態が変わる副作用（特に deadlock 関連）に注意を払う必要がある。&lt;/p&gt;

&lt;h2 id=&#34;とまぁ-こんな感じで&#34;&gt;とまぁ，こんな感じで&lt;/h2&gt;

&lt;p&gt;手を動かしながら「&lt;a href=&#34;https://golang.org/ref/spec&#34; title=&#34;The Go Programming Language Specification - The Go Programming Language&#34;&gt;言語仕様&lt;/a&gt;」を眺めていくと，いろいろ発見があって楽しいと思う。&lt;/p&gt;

&lt;p&gt;ではまた。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/tonkotsuboy_com/items/0adc5dac54e690fcf706&#34;&gt;web制作者にもわかる、Swift 3が++と&amp;ndash;を削除した理由 - Qiita&lt;/a&gt; : Swift 3 では &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt; 演算子を仕様から削除したらしい&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:stmt&#34;&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34; title=&#34;The Go Programming Language Specification - The Go Programming Language&#34;&gt;言語仕様&lt;/a&gt;における “statement” の適切な日本語訳が思いつかなかったので，今回はカタカナにのばして「ステートメント」と表記する。教えて，英語得手の人。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:stmt&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:op&#34;&gt;「&lt;a href=&#34;https://golang.org/ref/spec&#34; title=&#34;The Go Programming Language Specification - The Go Programming Language&#34;&gt;言語仕様&lt;/a&gt;」では文章上の表現として operator と記述しているところが幾つかあるが定義としては演算子として扱われていない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:op&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:pp&#34;&gt;C/C++ で &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt; 演算子を前置にするか後置にするかという問題は挙動の分かりにくさと実行時パフォーマンスの2つの論点がある。いずれにしろ前置に統一する方がよいと言われているが，&lt;a href=&#34;http://cpp.aquariuscode.com/preincriment-vs-postincriment&#34; title=&#34;前置インクリメント vs 後置インクリメント | 闇夜のC++&#34;&gt;パフォーマンスに関しては異論もある&lt;/a&gt;ようだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:pp&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Go 言語 1.8 がリリース - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2017/02/go-1_8-released/" />
		<id>tag:text.Baldanders.info,2017-02-19:/remark/2017/02/go-1_8-released/</id>
		<published>2017-02-19T15:45:53+09:00</published>
		<updated>2017-05-02T12:35:52+09:00</updated>
		<summary>Go 言語コンパイラのバージョン 1.8 がリリースされた。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;コンパイラのバージョン 1.8 がリリースされた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/go1.8&#34;&gt;Go 1.8 is released - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主な改善点を上げると&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;コンパイル時間の短縮&lt;/li&gt;
&lt;li&gt;ガベージコレクションの改善（通常で 100μsec 未満，しばしば 10μsec 未満）&lt;/li&gt;
&lt;li&gt;HTTP/2 Push の追加&lt;/li&gt;
&lt;li&gt;標準ライブラリの &lt;a href=&#34;https://golang.org/pkg/context/&#34; title=&#34;context - The Go Programming Language&#34;&gt;&lt;code&gt;context&lt;/code&gt;&lt;/a&gt; パッケージについてキャンセルとタイムアウトの仕組みを追加

&lt;ul&gt;
&lt;li&gt;HTTP サーバのシャットダウンの改善など&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/sort/&#34; title=&#34;sort - The Go Programming Language&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.&lt;a href=&#34;https://golang.org/pkg/sort/#Slice&#34;&gt;&lt;code&gt;Slice&lt;/code&gt;&lt;/a&gt; 関数の追加。 &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; のソートが簡単になった&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;その他，詳しくは以下のリリースノートを参照のこと。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/go1.8&#34;&gt;Go 1.8 Release Notes - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;戯れ言&#34;&gt;戯れ言&lt;/h2&gt;

&lt;p&gt;2015年頃から（仕事以外でだが） &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で遊ぶようになって2年半近くが過ぎた。&lt;/p&gt;

&lt;p&gt;仕事においては，業務システムでは相変わらず Java への replace 仕事ばっかりだし（私のようなロートルエンジニアは過去の&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E6%8A%80%E8%A1%93%E7%9A%84%E8%B2%A0%E5%82%B5&#34;&gt;技術的負債&lt;/a&gt;の後始末をするのがお役目），組み込みでは C/C++ がメインなので， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;を使う機会がないのだが，恐ろしいことに私の中で &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;が「&lt;a href=&#34;http://text.baldanders.info/remark/2015/programming-language/&#34; title=&#34;プログラミング言語との付き合い方&#34;&gt;母国語&lt;/a&gt;」になりつつある。
つまり，あるロジックをプログラム・コードに「翻訳」する際に，まず &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のコードが思い浮かぶようになってきた。&lt;/p&gt;

&lt;p&gt;この業界に四半世紀以上も足を突っ込んでるが脳内の&lt;a href=&#34;http://text.baldanders.info/remark/2015/programming-language/&#34; title=&#34;プログラミング言語との付き合い方&#34;&gt;母国語&lt;/a&gt;が変わるという経験は初めてで，まるで転生物のラノベ作品を読むがごとく，年甲斐もなく「&lt;a href=&#34;https://nijipi.com/it-news/kemono-lang_ruby-brainfuck/&#34;&gt;わーい！ たのしー！&lt;/a&gt;」な気分でコードを眺める日々である。&lt;/p&gt;

&lt;p&gt;もっとも，有り余る計算資源を持つクラウド環境ならともかくリソースの限られた RTOS (Real-Time Operating System) 環境下では息を吸うようにヒープを使いまくる &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;での実装は向いてない気がするので，「これは言語のチョイスを間違えたかなぁ」とも思わないでもない。
まぁでもそれならそれで C/C++ を使えばいいので困ることでもないんだけどね。&lt;/p&gt;

&lt;p&gt;でも  &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;が&lt;a href=&#34;http://text.baldanders.info/remark/2015/programming-language/&#34; title=&#34;プログラミング言語との付き合い方&#34;&gt;母国語&lt;/a&gt;になると（アセンブラに近い C 言語はともかく） C++ って本当に面倒くさい言語だったんだなぁ，と涙が出ちゃう。
だってエンジニアだもん。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://postd.cc/why-go-is-not-good/&#34;&gt;Go言語がダメな理由 | プログラミング | POSTD&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://postd.cc/golangs-real-time-gc-in-theory-and-practice/&#34;&gt;Go言語のリアルタイムGC　理論と実践 | プログラミング | POSTD&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/&#34;&gt;プログラミング言語 Go&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4320026926/baldandersinf-22/&#34;&gt;&lt;img src=&#34;https://images-fe.ssl-images-amazon.com/images/I/41W69WGATNL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4320026926/baldandersinf-22/&#34;&gt;プログラミング言語C 第2版 ANSI規格準拠&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;B.W. カーニハン D.M. リッチー 石田 晴久 &lt;/dd&gt;&lt;dd&gt;共立出版 1989-06-15&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4320027485/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4320027485.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;プログラミング言語Cアンサー・ブック 第2版&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4874084141/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4874084141.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;C言語による最新アルゴリズム事典 (ソフトウェアテクノロジー)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4774111422/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4774111422.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;C言語ポインタ完全制覇 (標準プログラマーズライブラリ)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4797304952/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4797304952.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;定本 Cプログラマのためのアルゴリズムとデータ構造 (SOFTBANK BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4900900648/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4900900648.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;C実践プログラミング 第3版&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4781908535/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4781908535.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;工科系の数学 (5)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4781908896/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4781908896.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;工科系の数学〈6〉関数論&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4756136494/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4756136494.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;プログラミング作法&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798030147/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798030147.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;苦しんで覚えるC言語&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798101036/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798101036.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Cの絵本―C言語が好きになる9つの扉&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;通称 “K&amp;amp;R”。その筋の人々には「バイブル」と呼ばれる名著。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2017-02-19&#34;&gt;2017-02-19&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
</content>
	</entry>
	
</feed>
