<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:cc="http://web.resource.org/cc/">
	<title>Defer - text.Baldanders.info</title>
	<link rel="alternate" type="text/html" href="http://text.baldanders.info/tags/defer/" />
	<link rel="self" type="application/atom+xml" href="http://text.baldanders.info/tags/defer/index.xml" />
	<id>tag:text.Baldanders.info,2017-09-19:/tags</id>
	<updated>2017-09-19T17:31:49+09:00</updated>
	<subtitle>帰ってきた「しっぽのさきっちょ」</subtitle>
	<icon>http://text.baldanders.info//images/avatar.jpg</icon>
	<logo>http://text.baldanders.info//images/avatar.jpg</logo>
	<generator uri="https://gohugo.io/">Hugo 0.27.1</generator>

	
	<entry>
		<title>Gzip 操作について覚え書き - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/gzip-operation/" />
		<id>tag:text.Baldanders.info,2017-09-19:/golang/gzip-operation/</id>
		<published>2017-09-19T17:31:49+09:00</published>
		<updated>2017-09-22T16:37:42+09:00</updated>
		<summary>このようにインスタンスの生存期間を意識することで Go 言語の得意なパターンに嵌めることが容易になる。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/ta_ta_ta_miya/items/3a1cba3a13418b732811&#34;&gt;gzip のやり方 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この記事を見て「んん？」となったので，覚え書きとして &lt;a href=&#34;https://golang.org/pkg/compress/gzip/&#34; title=&#34;gzip - The Go Programming Language&#34;&gt;&lt;code&gt;gzip&lt;/code&gt;&lt;/a&gt; パッケージについて紹介する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/ta_ta_ta_miya/items/3a1cba3a13418b732811&#34; title=&#34;gzip のやり方 - Qiita&#34;&gt;リンク先の記事&lt;/a&gt;で挙げられているコードは以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func makeGzip(body string) []byte {
  var b bytes.Buffer
  gw := gzip.NewWriter(&amp;amp;b)
  _, err := gw.Write([]byte(body)); if err != nil {
    ...
  }
  gw.Flush()
  gw.Close()
  return b.Bytes()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで &lt;code&gt;gw.Close()&lt;/code&gt; 関数を &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;defer&lt;/a&gt; 指定すると返ってくるバイト列が不完全なデータになってしまう，という話。
これは，&lt;a href=&#34;http://qiita.com/ta_ta_ta_miya/items/3a1cba3a13418b732811&#34; title=&#34;gzip のやり方 - Qiita&#34;&gt;リンク先の記事&lt;/a&gt;で指摘されている通り， &lt;a href=&#34;https://golang.org/pkg/compress/gzip/&#34; title=&#34;gzip - The Go Programming Language&#34;&gt;&lt;code&gt;gzip&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Writer.Close()&lt;/code&gt; 関数で gzip のフッタデータをフラッシュしているからである。&lt;/p&gt;

&lt;figure lang=&#34;en&#34;&gt;
&lt;blockquote&gt;
&lt;q&gt;Close closes the Writer by flushing any unwritten data to the underlying io.Writer and writing the GZIP footer. It does not close the underlying io.Writer.&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;https://golang.org/pkg/compress/gzip/&#34;&gt;gzip - The Go Programming Language&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;つまり &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;defer&lt;/a&gt; で指定した関数は return 後に駆動するため &lt;code&gt;b.Bytes()&lt;/code&gt; 関数を呼び出した時点ではまだ不完全なデータということになる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:b1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:b1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;ここでちょっと考える。&lt;/p&gt;

&lt;p&gt;関数の再利用性を考えるのなら，関数内でバッファを生成してバッファ処理の結果を返すのはあまり筋がよろしくない。
また圧縮データを書き込む先はメモリバッファじゃなくてファイルかもしれない。&lt;/p&gt;

&lt;p&gt;ゆえに関数をこう書き換える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func makeGzip(dst io.Writer, content []byte) error {
	zw, err := gzip.NewWriterLevel(dst, gzip.BestCompression)
	if err != nil {
		return err
	}
	defer zw.Close()

	if _, err := zw.Write(content); err != nil {
		return err
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり圧縮データの書き込み先である &lt;code&gt;Writer&lt;/code&gt; を引数で指定するのである。
これなら生成した &lt;a href=&#34;https://golang.org/pkg/compress/gzip/&#34; title=&#34;gzip - The Go Programming Language&#34;&gt;&lt;code&gt;gzip&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Writer.Close()&lt;/code&gt; 関数を問題なく &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;defer&lt;/a&gt; で指定できる。&lt;/p&gt;

&lt;p&gt;これを踏まえて完全なコードは以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;compress/gzip&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
)

func makeGzip(dst io.Writer, content []byte) error {
	zw, err := gzip.NewWriterLevel(dst, gzip.BestCompression)
	if err != nil {
		return err
	}
	defer zw.Close()

	if _, err := zw.Write(content); err != nil {
		return err
	}
	return nil
}

func main() {
	content := []byte(&amp;quot;Hello world\n&amp;quot;)

	file, err := os.Create(&amp;quot;test.txt.gz&amp;quot;)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	defer file.Close()

	if err := makeGzip(file, content); err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードでは圧縮データの書き込む先をファイルにしている。
もちろん書き込み先を &lt;a href=&#34;https://golang.org/pkg/bytes/&#34; title=&#34;bytes - The Go Programming Language&#34;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Buffer&lt;/code&gt; に置き換えることもできる。
このようにインスタンスの生存期間を意識することで &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の得意なパターンに嵌めることが容易になる。&lt;/p&gt;

&lt;p&gt;ついでに対となる読み込み処理のコードも示しておこう。
ここでは復元したデータを標準出力に直接出力している。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;compress/gzip&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
)

func readGzip(dst io.Writer, src io.Reader) error {
	zr, err := gzip.NewReader(src)
	if err != nil {
		return err
	}
	defer zr.Close()

	io.Copy(dst, zr)

	return nil
}

func main() {
	file, err := os.Open(&amp;quot;test.txt.gz&amp;quot;)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	defer file.Close()

	if err := readGzip(os.Stdout, file); err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ところで，ファイル操作では生のデータを直接 gzip 圧縮するシチュエーションは少なく，大抵は tar と組み合わせることになる。
そこで tar と組み合わせ，指定フォルダ直下の複数ファイルを gzip 圧縮するコードも以下に示しておく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;archive/tar&amp;quot;
	&amp;quot;compress/gzip&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;path/filepath&amp;quot;
)

func makeTarGzip(dst io.Writer, rt string) error {
	zw, err := gzip.NewWriterLevel(dst, gzip.BestCompression)
	if err != nil {
		return err
	}
	defer zw.Close()

	tw := tar.NewWriter(zw)
	defer tw.Close()

	filepath.Walk(rt, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}
		fmt.Println(path)

		hd, e := tar.FileInfoHeader(info, &amp;quot;&amp;quot;)
		if e != nil {
			return e
		}
		content, e := ioutil.ReadFile(path)
		if e != nil {
			return e
		}

		if e := tw.WriteHeader(hd); e != nil {
			return e
		}
		if _, e := tw.Write(content); e != nil {
			return e
		}
		return nil
	})
	if err != nil {
		return err
	}

	return nil
}

func main() {
	file, err := os.Create(&amp;quot;test.tar.gz&amp;quot;)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	defer file.Close()

	if err := makeTarGzip(file, &amp;quot;./&amp;quot;); err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;追記-別解あります&#34;&gt;【追記】別解あります&lt;/h2&gt;

&lt;p&gt;実は最初の &lt;code&gt;makeGzip()&lt;/code&gt; には別解がある。
要するに &lt;a href=&#34;https://golang.org/pkg/compress/gzip/&#34; title=&#34;gzip - The Go Programming Language&#34;&gt;&lt;code&gt;gzip&lt;/code&gt;&lt;/a&gt; 処理部分を関数スコープで囲ってしまえばいいのだ。
実際にはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func makeGzip(body []byte) ([]byte, error) {
	var b bytes.Buffer
	err := func() error {
		gw := gzip.NewWriter(&amp;amp;b)
		defer gw.Close()

		if _, err := gw.Write(body); err != nil {
			return err
		}
		return nil
	}()
	return b.Bytes(), err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完全なコードはこんな感じになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;compress/gzip&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

func makeGzip(body []byte) ([]byte, error) {
	var b bytes.Buffer
	err := func() error {
		gw := gzip.NewWriter(&amp;amp;b)
		defer gw.Close()

		if _, err := gw.Write(body); err != nil {
			return err
		}
		return nil
	}()
	return b.Bytes(), err
}

func main() {
	content := []byte(&amp;quot;Hello world\n&amp;quot;)

	file, err := os.Create(&amp;quot;test.txt.gz&amp;quot;)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	defer file.Close()

	z, err := makeGzip(content)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}

	if _, err := file.Write(z); err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように（&lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;defer&lt;/a&gt; を含む）一連の処理を関数スコープで囲うやり方は，条件分岐や繰り返し処理の中で役に立つこともあるだろう。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/kroton/items/431e6dad9e5e4dbc44cf&#34;&gt;「連結されたgzipを1行ずつ見る」をgolangでやったらハマった - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mattn.kaoriya.net/software/lang/go/20151212021608.htm&#34;&gt;Big Sky :: golang では for ループの中で defer してはいけない。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:b1&#34;&gt;この挙動から分かるとおり， &lt;a href=&#34;https://golang.org/pkg/bytes/&#34; title=&#34;bytes - The Go Programming Language&#34;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Buffer.Bytes()&lt;/code&gt; 関数は，バッファの内容をそのまま返しているのではなく，内容のコピーを返している。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:b1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>関数とポインタ - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/function-and-pointer/" />
		<id>tag:text.Baldanders.info,2016-03-29:/golang/function-and-pointer/</id>
		<published>2016-03-29T22:16:41+09:00</published>
		<updated>2017-09-19T17:22:39+09:00</updated>
		<summary>Go 言語の引数は基本的に「値渡し（call by value）」である。「参照渡し（call by reference）」にしたい場合はポインタを使う。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;いまさらな内容なのだが覚え書きとして記しておく。&lt;/p&gt;

&lt;h2 id=&#34;go-言語における-calling-sequence&#34;&gt;Go 言語における Calling Sequence&lt;/h2&gt;

&lt;p&gt;まずは簡単な足し算の関数を定義してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x int, y int) int {
	return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;add&lt;/code&gt; に続く括弧内が引数を定義していて，括弧の後ろの &lt;code&gt;int&lt;/code&gt; は返り値の型&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:t&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:t&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; を示している。
&lt;code&gt;add()&lt;/code&gt; 関数を呼び出すには以下のように記述する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func add(x int, y int) int {
	return x + y
}

func main() {
	ans := add(42, 13)
	fmt.Println(ans)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は同じ int 型なので以下のように記述することもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y int) int {
	return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値を組（tuple）で定義することもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func split(sum int) (int, int) {
	x = sum * 4 / 9
	y = sum - x
	return x, y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また返り値は以下のように名前をつけることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y int) (ans int) {
	ans = x + y
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の &lt;code&gt;return&lt;/code&gt; がないとコンパイル・エラーになるので注意。
この書き方は &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;defer&lt;/a&gt; 構文と組み合わせるときに威力を発揮する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	err := r()
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(&amp;quot;Normal End.&amp;quot;)
	}
}

func r() (err error) {
	defer func() {
		if rec := recover(); rec != nil {
			err = fmt.Errorf(&amp;quot;Recovered from: %v&amp;quot;, rec)
		}
	}()

	f()
	err = nil
	return
}

func f() {
	panic(&amp;quot;Panic!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコード&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:p&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:p&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; では &lt;code&gt;r()&lt;/code&gt; 関数内で &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を捕まえ， 返り値の &lt;code&gt;err&lt;/code&gt; に値をセットしなおしている。&lt;/p&gt;

&lt;h3 id=&#34;go-言語の引数は-値渡し&#34;&gt;Go 言語の引数は「値渡し」&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の引数は基本的に「値渡し（call by value）」である。
たとえば先程の足し算を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y int) int {
	x += y
	return x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義した場合でも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func add(x, y int) int {
	x += y
	return x
}

func main() {
    x := 42
    y := 13
	ans := add(x, y)
	fmt.Printf(&amp;quot;%d + %d = %d\n&amp;quot;, x, y, ans) //output: 42 + 13 = 55
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呼び出し元で &lt;code&gt;add()&lt;/code&gt; 関数の引数に渡した instance は関数実行後も変化しない。
このため「値渡し」は thread safe なコードに向いている。
たとえば value object を構成する際には関連する関数は「値渡し」のほうが安全である。
ただし関数呼び出し時に instance の値が常にコピーされるため&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:copy&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:copy&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，サイズの大きな instance の場合は呼び出し時のコストが高くなる。&lt;/p&gt;

&lt;p&gt;引数を「参照渡し（call by reference）」にしたい場合はポインタを使う。
つまり instance のポインタ値を渡すのである。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func add(x, y *int) int {
	*x += *y
	return *x
}

func main() {
	x := 42
	y := 13
	ans := add(&amp;amp;x, &amp;amp;y)
	fmt.Printf(&amp;quot;%d + %d = %d\n&amp;quot;, x, y, ans) //output: 55 + 13 = 55
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードでは &lt;code&gt;add()&lt;/code&gt; 関数実行後の &lt;code&gt;x&lt;/code&gt; の値が変更されている。
内部状態を持つ instance を引数に指定する場合は参照渡しにする必要がある。
しかし引数を参照渡しにすると関数実行が thread safe でなくなる可能性がある。
また引数の値が nil の場合も考慮する必要がある。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では通常の方法ではポインタ演算ができない。
たとえば，ついうっかり&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y *int) int {
	x += y
	return *x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とか書いてしまっても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;invalid operation: x += y (operator + not defined on pointer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とコンパイル・エラーになる。
したがって通常は「&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のポインタは nullable 参照&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:nr&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:nr&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; と同じ」と考えてよい。&lt;/p&gt;

&lt;p&gt;ちなみにポインタ演算が必要な場合は &lt;a href=&#34;https://golang.org/pkg/unsafe/&#34; title=&#34;unsafe - The Go Programming Language&#34;&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; パッケージを使う。&lt;/p&gt;

&lt;h3 id=&#34;slice-map-channel-は-参照渡し-として振る舞う&#34;&gt;Slice, Map, Channel は「参照渡し」として振る舞う&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Map_types&#34;&gt;map&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; は組み込み型だが内部状態を持つ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:make&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:make&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。
これらの型の instance を引数に渡す場合は「参照渡し」として振る舞う&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:slc&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:slc&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func setItem(ary map[int]int, index, item int) {
	ary[index] = item
}

func main() {
    ary := map[int]int{0: 0}
	fmt.Println(ary) //output: map[0:0]
	setItem(ary, 0, 1)
	fmt.Println(ary) //output: map[0:1]
	setItem(ary, 10, 10)
	fmt.Println(ary) //output: map[0:1 10:10]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし固定の配列や &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:str&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:str&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; の instance は「値」として振る舞うため&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:n&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:n&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;，引数に指定した場合も「値渡し」になる。
&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; とは挙動が異なるためテキトーなコードを書いていると混乱しやすい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func setItem(ary [4]int, index, item int) {
	ary[index] = item
}

func main() {
	ary := [4]int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	setItem(ary, 1, 10)
	fmt.Println(ary) //output: [0 1 2 3]
	ary[2] = 200
	fmt.Println(ary) //output: [0 1 200 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;固定配列や &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型を「参照渡し」にしたい場合はやはりポインタ値を渡す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func setItem(ary *[4]int, index, item int) {
	(*ary)[index] = item
}

func main() {
	ary := [4]int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	setItem(&amp;amp;ary, 1, 10)
	fmt.Println(ary) //output: [0 10 2 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際には &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型の instance は「不変（immutable）」なので「参照渡し」が必要な局面はほとんど無いと思われる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:s&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;。
固定配列は不変ではないが，配列を操作するのであれば固定配列ではなく &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; のほうが扱いやすい。
たとえば上のコードでは &lt;code&gt;slc := ary[:]&lt;/code&gt; といった感じにキャストするか最初から &lt;code&gt;ary := []int{0, 1, 2, 3}&lt;/code&gt; と初期化すれば &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; として扱える。&lt;/p&gt;

&lt;h2 id=&#34;method-receiver&#34;&gt;Method Receiver&lt;/h2&gt;

&lt;p&gt;ある型に関数を関連付ける場合は method receiver を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Vertex struct {
	X int
	Y int
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(v Vertex)&lt;/code&gt; の部分が method receiver である。
&lt;code&gt;Add()&lt;/code&gt; 関数を呼び出すには以下のように記述する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := Vertex{X: 1, Y: 2}
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)  //output: X = 1, Y = 2
	fmt.Println(vv) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数の calling sequence としては &lt;code&gt;v.Add(dv)&lt;/code&gt; と &lt;code&gt;Vertex.Add(v, dv)&lt;/code&gt; は等価である。
つまり &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;Add()&lt;/code&gt; 関数の0番目の引数として振る舞い，「値渡し」でセットされる。&lt;/p&gt;

&lt;p&gt;Method receiver の型をポインタ型にすれば「参照渡し」にできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := &amp;amp;Vertex{X: 1, Y: 2}
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合も calling sequence としては &lt;code&gt;v.Add(dv)&lt;/code&gt; と &lt;code&gt;(*Vertex).Add(v, dv)&lt;/code&gt; は等価である。&lt;/p&gt;

&lt;h3 id=&#34;method-receiver-の暗黙的変換&#34;&gt;Method Receiver の暗黙的変換&lt;/h3&gt;

&lt;p&gt;Method receiver を「値渡し」にした場合，呼び出し元の instance がポインタ型であっても暗黙的に「値渡し」に変換される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := &amp;amp;Vertex{X: 1, Y: 2} //pointer
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)  //output: X = 1, Y = 2
	fmt.Println(vv) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Method receiver を「参照渡し」にした場合も暗黙的に「参照渡し」に変換される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := Vertex{X: 1, Y: 2} //not pointer
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;method-receiver-の値が-nil-の場合&#34;&gt;Method Receiver の値が nil の場合&lt;/h3&gt;

&lt;p&gt;Method receiver の値が nil の場合はどうなるか。
まずは「値渡し」の場合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := (*Vertex)(nil) //nil
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)
	fmt.Println(vv)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合は &lt;code&gt;Add()&lt;/code&gt; 関数呼び出し時に &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; になる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;panic: runtime error: invalid memory address or nil pointer dereference
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まぁこれは分かりやすいよね。
では「参照渡し」の場合はどうなるか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := (*Vertex)(nil) //nil
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: &amp;lt;nil&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は &lt;code&gt;Add()&lt;/code&gt; 関数呼び出し時点では &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; にはならない。
上のコードでは &lt;code&gt;v&lt;/code&gt; に nil が渡される。
したがって &lt;code&gt;Add()&lt;/code&gt; 関数内の条件文を削除すると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (v *Vertex) Add(dv Vertex) {
	v.X += dv.X
	v.Y += dv.Y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;v&lt;/code&gt; 内の要素を参照としたところで &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; になる。
Method receiver を「参照渡し」にする場合は nil 値に注意する必要がある。&lt;/p&gt;

&lt;h2 id=&#34;for-range-構文も-値渡し&#34;&gt;for-range 構文も「値渡し」&lt;/h2&gt;

&lt;p&gt;余談だが for-range 構文も「値渡し」（つまりコピーが発生する）なので注意が必要である。
たとえば以下のコードで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	ary := []int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	for _, item := range ary {
		item += 10
	}
	fmt.Println(ary) //output: [0 1 2 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for-range 構文内の &lt;code&gt;item&lt;/code&gt; は &lt;code&gt;ary&lt;/code&gt; 内の要素を指すのではなく要素のコピーである。
したがって &lt;code&gt;item&lt;/code&gt; を操作しても &lt;code&gt;ary&lt;/code&gt; には影響しない。
&lt;code&gt;ary&lt;/code&gt; 内の要素を操作するのであれば素朴に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	ary := []int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	for i := 0; i &amp;lt; len(ary); i++ {
		ary[i] += 10
	}
	fmt.Println(ary) //output: [10 11 12 13]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするしかない。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://skatsuta.github.io/2015/12/29/value-receiver-pointer-receiver/&#34;&gt;Go 言語の値レシーバとポインタレシーバ | Step by Step&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:t&#34;&gt;型については「&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」&lt;/a&gt;」を参照のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:t&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:p&#34;&gt;このコードについては「&lt;a href=&#34;http://text.baldanders.info/golang/error-handling/&#34;&gt;エラー・ハンドリングについて&lt;/a&gt;」で解説している。ちなみに &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を潰して error を返すのはエラー・ハンドリングとしてはいいやり方ではない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:p&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:copy&#34;&gt;値がどこにコピーされるかは型によって異なる。 &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 以外の基本型は値がスタックに積まれる。 &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; および基本型以外はヒープ領域に値がコピーされそのポインタがスタックに積まれる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:copy&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:nr&#34;&gt;nullable 参照は「null を許容する参照」くらいの意味。 &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;なら nil 値。 &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;は「null 安全（null safty）」ではないので null 参照（＝無効な参照）の始末について instance を参照する側が責務を負うことになる。（参考： &lt;a href=&#34;http://text.baldanders.info/remark/2016/11/null-safety/&#34;&gt;「null 安全」について&lt;/a&gt;）
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:nr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:make&#34;&gt;&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Map_types&#34;&gt;map&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; は内部状態を持つため &lt;code&gt;new()&lt;/code&gt; 関数ではなく &lt;code&gt;make()&lt;/code&gt; 関数で instance を生成する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:make&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:slc&#34;&gt;このうち &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; については特殊な振る舞いをする。詳しくは「&lt;a href=&#34;http://text.baldanders.info/golang/array-and-slice/&#34;&gt;配列と Slice&lt;/a&gt;」を参照のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:slc&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:str&#34;&gt;&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型の実体は &lt;code&gt;[]byte&lt;/code&gt; 型である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:str&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:n&#34;&gt;たとえば固定の配列や &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型の instance は nil 値を持たない。 &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型のゼロ値は空文字列である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:n&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:s&#34;&gt;このような需要としては文字列操作で「NULL 状態」が必要な場合であろう。たとえば DBMS にアクセスする場合は NULL 状態を扱う必要がある。なお &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のコア・パッケージには &lt;a href=&#34;https://golang.org/pkg/database/sql/&#34; title=&#34;sql - The Go Programming Language&#34;&gt;&lt;code&gt;database/sql&lt;/code&gt;&lt;/a&gt; があり &lt;code&gt;NullString&lt;/code&gt; を使うことにより NULL 状態を扱える。このように NULL 状態を扱う必要がある場合は，直にポインタ操作するのではなく，何らかの value object を用意してカプセル化するほうが安全である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>エラー・ハンドリングについて（追記あり） - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/error-handling/" />
		<id>tag:text.Baldanders.info,2015-09-30:/golang/error-handling/</id>
		<published>2015-09-30T00:27:48+09:00</published>
		<updated>2017-09-19T17:22:06+09:00</updated>
		<summary>C&#43;&#43; や Java のような言語圏から来た（私のような）人間にとって Go 言語の「オブジェクト指向」はかなり異質なのだが，慣れてみると逆にとても合理的に見えてくる。この最たるものが error 型である。（追記あり）</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;C++ や Java のような言語圏から来た（私のような）人間にとって &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の「オブジェクト指向」はかなり異質なのだが，慣れてみると逆にとても合理的に見えてくる。
なんで C++ や Java はこのようなアプローチをとらなかったのか不思議なほどである。&lt;/p&gt;

&lt;p&gt;この最たるものがエラー・ハンドリングだ。&lt;/p&gt;

&lt;h2 id=&#34;go-言語には-例外-がない&#34;&gt;Go 言語には「例外」がない&lt;/h2&gt;

&lt;p&gt;「例外（exception）」は本来の処理の流れをぶった切って「大域脱出」するための仕組みである。
でも考えてみれば例外というのはかなり微妙な言語仕様だ。&lt;/p&gt;

&lt;p&gt;例外が抱える問題というのは本質的に &lt;code&gt;goto&lt;/code&gt; 文の問題と同じ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:aa&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:aa&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
オブジェクトの状態ごと脱出するため，（脱出前ではなく）脱出後にオブジェクトの後始末を記述せざるを得ないし，記述するためには脱出前の状態（の可能性）を「知識」として知っていなければならない&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。
もし後始末をきちんとしないと，それがバグやリークやその他の脆弱性のもとになる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;はそんな面倒くさいことは考えない。
どうするかというと，普通に返り値に &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を返す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;file, err := os.Open(filename)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; は無視することもできる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;file, _ := os.Open(filename)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;検出した &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; はその場で処理して抜けてしまえばよい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;file, err := os.Open(filename)
if err != nil {
    fmt.Fprintln(os.Stderr, err)
    return false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;開始処理と終了（後始末）処理が対になっている場合（&lt;code&gt;Open&lt;/code&gt;/&lt;code&gt;Close&lt;/code&gt; とは限らない）は &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Defer&lt;/a&gt; 構文で終了処理を保証する&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:c&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:c&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;file, err := os.Open(filename)
if err != nil {
    fmt.Fprintln(os.Stderr, err)
    return false
}
defer file.Close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これが &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の基本的な書き方。
特徴的なのは，ある処理に纏わる処理をセットで記述できる点である。
&lt;code&gt;try&lt;/code&gt; と &lt;code&gt;catch&lt;/code&gt; と &lt;code&gt;finally&lt;/code&gt; の間で目線を行ったり来たりさせなくても，「そこ」だけを見れば把握できる。
ある意味でとても文芸的なコード&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:b&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:b&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; であると言える&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:bb&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:bb&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;error&#34;&gt;error&lt;/h2&gt;

&lt;p&gt;ここで &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; について改めて説明しておく。
&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; は以下の形式で表現できる &lt;a href=&#34;https://golang.org/doc/effective_go.html#interfaces_and_types&#34; title=&#34;Effective Go - The Go Programming Language&#34;&gt;interface&lt;/a&gt; 型のひとつである&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
type error interface {
	Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり &lt;code&gt;Error()&lt;/code&gt; 関数を持つオブジェクトなら &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; として使える。
これのいちばん簡単な実装が &lt;a href=&#34;https://golang.org/pkg/errors/&#34; title=&#34;errors - The Go Programming Language&#34;&gt;&lt;code&gt;errors&lt;/code&gt;&lt;/a&gt; パッケージである。
&lt;a href=&#34;https://golang.org/pkg/errors/&#34; title=&#34;errors - The Go Programming Language&#34;&gt;&lt;code&gt;errors&lt;/code&gt;&lt;/a&gt; パッケージの中身は以下のようになっている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package errors

// New returns an error that formats as the given text.
func New(text string) error {
	return &amp;amp;errorString{text}
}

// errorString is a trivial implementation of error.
type errorString struct {
	s string
}

func (e *errorString) Error() string {
	return e.s
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは実体として &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型の property がひとつだけあって &lt;code&gt;Error()&lt;/code&gt; 関数で property をそのまま返すというものだ。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の標準パッケージの多くはこの &lt;a href=&#34;https://golang.org/pkg/errors/&#34; title=&#34;errors - The Go Programming Language&#34;&gt;&lt;code&gt;errors&lt;/code&gt;&lt;/a&gt; パッケージを使って &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を定義している。
たとえば &lt;a href=&#34;https://golang.org/pkg/os/&#34; title=&#34;os - The Go Programming Language&#34;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; パッケージの最下位の &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; は以下のように定義されている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package os

import (
	&amp;quot;errors&amp;quot;
)

// Portable analogs of some common system call errors.
var (
	ErrInvalid    = errors.New(&amp;quot;invalid argument&amp;quot;)
	ErrPermission = errors.New(&amp;quot;permission denied&amp;quot;)
	ErrExist      = errors.New(&amp;quot;file already exists&amp;quot;)
	ErrNotExist   = errors.New(&amp;quot;file does not exist&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう少し複雑な &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; では，以下のように詳細情報を持つものもある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PathError records an error and the operation and file path that caused it.
type PathError struct {
	Op   string
	Path string
	Err  error
}

func (e *PathError) Error() string { return e.Op + &amp;quot; &amp;quot; + e.Path + &amp;quot;: &amp;quot; + e.Err.Error() }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3つのエラー-ハンドリング&#34;&gt;3つのエラー・ハンドリング&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を判別する方法としては以下の3つがある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; インスタンスを比較する&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; の型を判別する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Error()&lt;/code&gt; 関数で出力される文字列を解釈する&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;インスタンスを比較する&#34;&gt;インスタンスを比較する&lt;/h3&gt;

&lt;p&gt;あらかじめ定義済みの &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; インスタンスがあれば，インスタンスの比較で判別できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if err != nil {
    switch err {
    case os.ErrInvalid:
        fmt.Fprintln(os.Stderr, &amp;quot;引数が不正&amp;quot;)
    case os.ErrPermission:
        fmt.Fprintln(os.Stderr, &amp;quot;アクセスは許可できない&amp;quot;)
    case os.ErrExist:
        fmt.Fprintln(os.Stderr, &amp;quot;そのファイルは既にある&amp;quot;)
    case os.ErrNotExist:
        fmt.Fprintln(os.Stderr, &amp;quot;ファイルが存在しない&amp;quot;)
    default:
        fmt.Fprintln(os.Stderr, err)
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;単純にエラーの種類が分かればいいのであれば，この方法が最もシンプル。&lt;/p&gt;

&lt;h3 id=&#34;型を判別する&#34;&gt;型を判別する&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; は &lt;a href=&#34;https://golang.org/doc/effective_go.html#interfaces_and_types&#34; title=&#34;Effective Go - The Go Programming Language&#34;&gt;interface&lt;/a&gt; 型なので &lt;a href=&#34;https://golang.org/ref/spec#Conversions&#34; title=&#34;The Go Programming Language Specification - The Go Programming Language&#34;&gt;Conversion&lt;/a&gt; 構文で判別できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if err != nil {
    switch e := err.(type) {
    case *os.PathError:
        if errno, ok := e.Err.(syscall.Errno); ok {
            switch errno {
            case syscall.ENOENT:
                fmt.Fprintln(os.Stderr, &amp;quot;ファイルが存在しない&amp;quot;)
            case syscall.ENOTDIR:
                fmt.Fprintln(os.Stderr, &amp;quot;ディレクトリが存在しない&amp;quot;)
            default:
                fmt.Fprintln(os.Stderr, &amp;quot;Errno =&amp;quot;, errno)
            }
        } else {
            fmt.Fprintln(os.Stderr, &amp;quot;その他の PathError&amp;quot;)
        }
    default:
        fmt.Fprintln(os.Stderr, &amp;quot;その他のエラー&amp;quot;)
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; に状態（status）を持たせる必要がある場合は，この方法を使うべき。&lt;/p&gt;

&lt;h3 id=&#34;文字列を比較する&#34;&gt;文字列を比較する&lt;/h3&gt;

&lt;p&gt;上述の方法で判別できない場合は &lt;code&gt;Error()&lt;/code&gt; 関数で出力される文字列を解釈して処理するしかない。
&lt;a href=&#34;http://0xcc.net/misc/bad-knowhow.html&#34;&gt;バッドノウハウ&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;エラー-ハンドリングの設計&#34;&gt;エラー・ハンドリングの設計&lt;/h2&gt;

&lt;p&gt;エラー・ハンドリングの方針としては，以下の2つのうちのどちらかだろう。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を下位ロジックから上位ロジックまで持ち回し，最上位ロジックで最終的な判定と処理を行う&lt;/li&gt;
&lt;li&gt;下位ロジックの &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; をカプセル化した新たなインスタンスを生成し上位ロジックに渡す。上位ロジックは直近のロジックの &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; のみが見える&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最初のやり方は一見よさげだが，この方針では上位ロジックが下位ロジックの全ての &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を把握している必要があり現実的でない。
またオブジェクト指向設計では “Don&amp;rsquo;t talk to strangers” の原則があり，いわゆる「友達の友達」のことは知らないふりをするのがよい設計と言われている。&lt;/p&gt;

&lt;p&gt;こう考えると文字列での比較は最も下策であると言える。
また，型を判別する場合でも，下位レイヤの状態を生のまま見せるのではなく，必要な情報のみを返す関数を実装するほうが上策と言えるだろう。&lt;/p&gt;

&lt;p&gt;もうひとつ考慮すべき点としてエラー・メッセージの設計が挙げられるだろう。
&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; に対するメッセージをどのように設計するかは（大規模アプリケーションでは特に）重要である。&lt;/p&gt;

&lt;p&gt;（「&lt;a href=&#34;http://text.baldanders.info/golang/error-handling2/&#34;&gt;Error の構造化&lt;/a&gt;」へ続く）&lt;/p&gt;

&lt;h2 id=&#34;追記-panic-と-recover&#34;&gt;【追記】 Panic と Recover&lt;/h2&gt;

&lt;p&gt;たとえばゼロ除算を行った場合や配列などで領域外を参照・設定しようとした場合，あるいは allocation に失敗した場合など，致命的なエラーが発生する場合がある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	f()
}

func f() {
	numbers := []int{0, 1, 2}

	fmt.Println(numbers[3])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:\workspace\go-practice\src\panic01&amp;gt;go run panic01.go
panic: runtime error: index out of range

goroutine 1 [running]:
main.f()
        C:/workspace/go-practice/src/panic01/panic01.go:12 +0x14a
main.main()
        C:/workspace/go-practice/src/panic01/panic01.go:6 +0x1b
exit status 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり，大域脱出させてアプリケーションを強制終了させているのが分かる。
この仕組みを &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Panic&lt;/a&gt; と呼ぶ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Panic&lt;/a&gt; は意図的に発生させることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

func main() {
	f()
}

func f() {
	panic(&amp;quot;Panic!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:\workspace\go-practice\src\panic02&amp;gt;go run panic02.go
panic: Panic!

goroutine 1 [running]:
main.f()
        C:/workspace/go-practice/src/panic02/panic02.go:8 +0x6c
main.main()
        C:/workspace/go-practice/src/panic02/panic02.go:4 +0x1b
exit status 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。&lt;/p&gt;

&lt;p&gt;一方で， &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Panic&lt;/a&gt; を &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Recover&lt;/a&gt; することもできる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:e&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:e&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	err := r()
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(&amp;quot;Normal End.&amp;quot;)
	}
}

func r() (err error) {
	defer func() {
		if rec := recover(); rec != nil {
			err = fmt.Errorf(&amp;quot;Recovered from: %v&amp;quot;, rec)
		}
	}()

	f()
	err = nil
	return
}

func f() {
	panic(&amp;quot;Panic!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:\workspace\go-practice\src\panic03&amp;gt;go run panic03.go
Recovered from: Panic!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。
&lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Panic&lt;/a&gt; を &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Recover&lt;/a&gt; で捕まえて通常の &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; として返しているのがお分かりだろうか。&lt;/p&gt;

&lt;p&gt;一般的に &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Panic&lt;/a&gt; はアプリケーション内で続行不可能な致命的エラーが発生した場合に投げられる。
例えばゼロ除算や領域外アクセスのようなエラーは &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Panic&lt;/a&gt; が発生する前に回避するコードにすべきだ。
Allocation エラーのような回避不能かつアプリケーション続行不可能なエラーの場合は &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Panic&lt;/a&gt; が投げられるのもやむを得ないが， &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Recover&lt;/a&gt; することにほとんど意味はない。&lt;/p&gt;

&lt;p&gt;例外的な使い方として &lt;a href=&#34;https://golang.org/pkg/bytes/&#34; title=&#34;bytes - The Go Programming Language&#34;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Buffer&lt;/code&gt; では，メモリ確保で panic が発生した際に &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Recover&lt;/a&gt; で捕まえ， &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; インスタンスを入れ替えて &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Panic&lt;/a&gt; を投げ直している。
このような用途で &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Recover&lt;/a&gt; を使うことはあり得る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// makeSlice allocates a slice of size n. If the allocation fails, it panics
// with ErrTooLarge.
func makeSlice(n int) []byte {
	// If the make fails, give a known error.
	defer func() {
		if recover() != nil {
			panic(ErrTooLarge)
		}
	}()
	return make([]byte, n)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また再帰処理中に続行不能なエラーが発生した場合に &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Panic&lt;/a&gt; を投げてトップレベルの関数に一気に復帰するような使い方をすることもある。
この場合，トップレベルの関数は（続行不可能なら）改めて &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Panic&lt;/a&gt; を投げるか（処理続行できる根拠があるのなら）通常の &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を返すことになる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:f&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:f&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;いずれにしろ，いわゆる「例外処理」的なハンドリングを &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Panic&lt;/a&gt;/&lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Recover&lt;/a&gt; で行うべきではない。&lt;/p&gt;

&lt;h2 id=&#34;追記-error-の-nil-が-nil-にならない場合&#34;&gt;【追記】 error の nil が nil にならない場合&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@tucnak/why-go-is-a-poorly-designed-language-1cc04e5daf2#.ucutrogyz&#34;&gt;Why Go is a poorly designed language — Medium&lt;/a&gt; （&lt;a href=&#34;http://postd.cc/why-go-is-a-poorly-designed-language/&#34;&gt;日本語訳&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;figure style=&#39;margin:0 auto;&#39;&gt;
&lt;script src=&#34;https://gist.github.com/tucnak/eccdb53e7884084f5674.js&#34;&gt;&lt;/script&gt;
&lt;/figure&gt;

&lt;p&gt;このコードの実行結果は “Hello, Mr. Pike!” を出力する。
このコードのポイントは &lt;code&gt;Generate()&lt;/code&gt; 関数が &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; ではなく &lt;code&gt;*MagicError&lt;/code&gt; 型を返している点にある。&lt;/p&gt;

&lt;p&gt;実は &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を含む &lt;a href=&#34;https://golang.org/doc/effective_go.html#interfaces_and_types&#34; title=&#34;Effective Go - The Go Programming Language&#34;&gt;interface&lt;/a&gt; 型のインスタンスは値（への参照）と型情報をセットで保持っているため，上述のような形で nil を返しても受け取った側は「nil 状態を持つなにか」という評価になり，ただの &lt;code&gt;&amp;lt;nil&amp;gt;&lt;/code&gt; にはならないのだ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://research.swtch.com/interfaces&#34;&gt;research!rsc: Go Data Structures: Interfaces&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;たとえば上のコードを以下のように書き換えると分かりやすいかもしれない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type MagicError struct{}

func (m *MagicError) Error() string {
    return fmt.Sprintf(&amp;quot;%#v&amp;quot;, m)
}

func Generate() *MagicError {
	return nil
}

func Test() error {
	return Generate()
}

func main() {
	if err := Test(); err != nil {
		fmt.Println(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードを実行すると “(*main.MagicError)(nil)” と出力する。
&lt;code&gt;Generate()&lt;/code&gt; 関数が返す nil がどのように機能しているか分かると思う。
「&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」&lt;/a&gt;」で解説するが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の型（&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt;）は C++ や Java で言うところの class のように機能するため，このような動きになると思われる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:nil&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:nil&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;エラーハンドリングを行う際は結構ここがハマりどころになる。
ご注意を。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kaoriya.net/blog/2014/04/17/&#34;&gt;または私は如何にして例外するのを止めて golang を愛するようになったか — KaoriYa&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mattn.kaoriya.net/software/lang/go/20140416212413.htm&#34;&gt;Big Sky :: golang で複数のエラーをハンドリングする方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dsas.blog.klab.org/archives/go-errors.html&#34;&gt;DSAS開発者の部屋:Go ではエラーを文字列比較する？という話について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/ruiu/items/ff98ded599d97cf6646e&#34;&gt;panicはともかくrecoverに使いどころはほとんどない - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/stsn/items/73714caf8458b1d973f2&#34;&gt;Golang: nil Pointer Receiverの話 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/tienlen/items/5f2bcfe06eb83830ee55&#34;&gt;echoのAPIサーバ実装とエラーハンドリングの落とし穴 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2016/04/25/go-pkg-errors/&#34;&gt;Golangのエラー処理とpkg/errors | SOTA&lt;/a&gt; : 必見！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:aa&#34;&gt;ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の &lt;code&gt;goto&lt;/code&gt; や ラベル付きの &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt; は&lt;a href=&#34;https://golang.org/test/goto.go&#34;&gt;飛び先に制約&lt;/a&gt;があり，どこにでもジャンプできるわけではない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:aa&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:a&#34;&gt;例外を備える言語でこれを緩和する仕様はいくつかある。例えば Java は 1.7 から &lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html&#34;&gt;try-with-resources 構文&lt;/a&gt;を導入した。もちろんこの構文を有効にするためには対象となるオブジェクトがこの構文に対応した作りになっていなければならない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:0&#34;&gt;いや，ファイル・オープンのエラーを無視したらダメです（笑）
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:c&#34;&gt;&lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Defer&lt;/a&gt; 構文で指定された処理は &lt;code&gt;return&lt;/code&gt; 時に起動することが保証される。したがって，エラー発生時にはその都度 &lt;code&gt;return&lt;/code&gt; で抜けて問題ない。むしろ &lt;code&gt;goto&lt;/code&gt; や &lt;code&gt;break&lt;/code&gt; で強制的に処理を抜けるよりは処理を分割して &lt;code&gt;return&lt;/code&gt; で安全に処理を抜ける方法がないか検討すべきである。なお &lt;code&gt;os.Exit()&lt;/code&gt; などで強制終了した場合は， &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Defer&lt;/a&gt; 構文で指定した処理は起動しないので注意。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:c&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:b&#34;&gt;いわゆる「文芸的プログラミング」とは異なるけど。紛らわしくてゴメン。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:b&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:bb&#34;&gt;これからのコードは「文芸的」であることが必要条件だと思う。何故ならエンジニアにとって最も信頼できる「設計書」は（動いている）コードだからだ。コードをひとりで考えてひとりで書いてひとりで使ってひとりでメンテナンスするなら（本人さえ理解していれば）文芸的である必要はないかもしれない。が，実用的なコードでそんな状況はもはやありえない。コードにおいても暗黙知をできるだけ排除していくことが重要。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:bb&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:d&#34;&gt;&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; は組み込み型。組み込み型や組み込み関数（&lt;code&gt;append()&lt;/code&gt; とか）は &lt;a href=&#34;https://golang.org/pkg/builtin/&#34; title=&#34;builtin - The Go Programming Language&#34;&gt;&lt;code&gt;builtin&lt;/code&gt;&lt;/a&gt; パッケージに定義が記述されているが，実際にこのパッケージを import して使うわけではない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:e&#34;&gt;&lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Recover&lt;/a&gt; は &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Defer&lt;/a&gt; 構文とともに使用する。つまり &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Panic&lt;/a&gt; 発生時でも &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Defer&lt;/a&gt; 構文で予約された処理は実行される。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:e&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:f&#34;&gt;これ以外にサーバ用途などでプロセスを落とせない場合に &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;Recover&lt;/a&gt; で回避することもあるが，既に続行不可能な状態で無理やりプロセスを続行するのが正しい動きなのかどうかは疑問が残る。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:f&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:nil&#34;&gt;それでもやっぱり nil は nil として扱ってほしいのだが。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:nil&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
</feed>
