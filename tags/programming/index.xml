<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:cc="http://web.resource.org/cc/">
	<title>Programming - text.Baldanders.info</title>
	<link rel="alternate" type="text/html" href="http://text.baldanders.info/tags/programming/" />
	<link rel="self" type="application/atom+xml" href="http://text.baldanders.info/tags/programming/index.xml" />
	<id>tag:text.Baldanders.info,2015-12-15:/</id>
	<updated>2015-12-15T21:19:58+09:00</updated>
	<subtitle>帰ってきた「しっぽのさきっちょ」</subtitle>
	<icon>http://text.baldanders.info//images/avatar.jpg</icon>
	<logo>http://text.baldanders.info//images/avatar.jpg</logo>
	<generator uri="http://gohugo.io/">Hugo 0.15</generator>

	
	<entry>
		<title>Go 言語における「オブジェクト」 - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/object-oriented-programming/" />
		<id>tag:text.Baldanders.info,2015-12-15:/golang/object-oriented-programming/</id>
		<published>2015-12-15T21:19:58+09:00</published>
		<updated>2015-12-16T12:42:10+09:00</updated>
		<summary>Go 言語がいわゆる「オブジェクト指向言語」と言えるかどうかについては色々とあるようだが，オブジェクト指向プログラミングを助けるための仕掛けはいくつか存在する。今回はその中の type キーワードを中心に解説していく。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;がいわゆる「オブジェクト指向言語」と言えるかどうかについては色々とあるようだが，オブジェクト指向プログラミングを助けるための仕掛けはいくつか存在する。
今回はその中の &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードを中心に解説していく。&lt;/p&gt;

&lt;p&gt;なお，今回のソースコードは “&lt;a href=&#34;https://tour.golang.org/&#34;&gt;A Tour of Go&lt;/a&gt;” のものをかなり流用しているため取り扱いに注意。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の公式ドキュメントは CC License の by 3.0，ソースコードは &lt;a href=&#34;https://golang.org/LICENSE&#34;&gt;BSD license&lt;/a&gt; で提供されている。&lt;/p&gt;

&lt;h2 id=&#34;go-言語の基本型:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;Go 言語の基本型&lt;/h2&gt;

&lt;p&gt;今さらだけど， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の基本型（basic type）は以下の通り。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bool&lt;/li&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;int, int8, int16, int32, int64&lt;/li&gt;
&lt;li&gt;uint, uint8, uint16, uint32, uint64&lt;/li&gt;
&lt;li&gt;uintptr&lt;/li&gt;
&lt;li&gt;byte&lt;/li&gt;
&lt;li&gt;rune&lt;/li&gt;
&lt;li&gt;float32, float64&lt;/li&gt;
&lt;li&gt;complex64, complex128&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このうち byte は uint8 の別名で rune&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:rn&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:rn&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; は int32 の別名である。
また int, uint, uintptr のサイズはプラットフォーム依存になっている。
string は不変（immutable）な値で，その実体は byte 配列である。
基本型は組み込み型であり，振る舞いを追加・変更することはできない。&lt;/p&gt;

&lt;p&gt;さらにこれらの基本型を束ねた構造体 struct を定義できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	vertex := struct {
		X int
		Y int
	}{X: 1, Y: 2}
	fmt.Println(vertex)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに構造体のフィールド（field）には構造体を含めて入れ子にすることもできる。&lt;/p&gt;

&lt;p&gt;この他に配列（array/slice）や連想配列（map）あるいは関数値（function value）といったものもあるが，今回は踏み込まない&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:slc&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:slc&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;型に名前を付ける:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;型に名前を付ける&lt;/h2&gt;

&lt;p&gt;全ての型には &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードを使って名前を付けることができる。
例えば先ほどのコードは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func main() {
	vertex := Vertex{X: 1, Y: 2}
	fmt.Println(vertex)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書き直すことができる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードが使えるのは構造体だけではない。
上述の基本型も &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードを使って型を再定義できる。&lt;/p&gt;

&lt;p&gt;たとえば，2つの時点間の時間を表す &lt;a href=&#34;https://golang.org/pkg/time/&#34; title=&#34;time - The Go Programming Language&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Duration&lt;/code&gt; は以下のように定義されている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Duration int64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また，配列なども型として再定義できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Msgs []string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードを使って型に名前を付ける利点は3つある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;名前を付けることでコードの可読性を上げる（オブジェクト指向設計では名前はとても重要）&lt;/li&gt;
&lt;li&gt;再利用性の向上（特に構造体の場合）&lt;/li&gt;
&lt;li&gt;型に関数を関連付けることができる。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードによる名付けは単なる別名定義ではないということだ。&lt;/p&gt;

&lt;h2 id=&#34;型に関数を関連付ける:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;型に関数を関連付ける&lt;/h2&gt;

&lt;p&gt;型に関数を関連付けるには以下のように記述する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (v *Vertex) String() string {
	return fmt.Sprint(&amp;quot;X =&amp;quot;, v.X, &amp;quot;, Y =&amp;quot;, v.Y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(v *Vertex)&lt;/code&gt; の部分はメソッド・レシーバ（method receiver）と呼ばれ，これが型と関数を関連付ける役割を果たす。
内部処理としては&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func String(v *Vertex) string {
	return fmt.Sprint(&amp;quot;X =&amp;quot;, v.X, &amp;quot;, Y =&amp;quot;, v.Y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と等価である。
関数の呼び出し側は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v *Vertex) String() string {
	return fmt.Sprint(&amp;quot;X =&amp;quot;, v.X, &amp;quot;, Y =&amp;quot;, v.Y)
}

func main() {
	vertex := &amp;amp;Vertex{X: 1, Y: 2}
	fmt.Println(vertex.String())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにピリオドで連結して記述する&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:pr&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:pr&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;構造体そのものには関数を付与できない&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:mt&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:mt&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。
たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func (v *struct{ X, Y int }) String() string {
	return fmt.Sprint(&amp;quot;X =&amp;quot;, v.X, &amp;quot;, Y =&amp;quot;, v.Y)
}

func main() {
	var vertex = &amp;amp;struct {
		X int
		Y int
	}{X: 1, Y: 2}
	fmt.Println(vertex.String())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと書いても，コンパイル時に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;invalid receiver type *struct { X int; Y int } (struct { X int; Y int } is an unnamed type)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と怒られる。
&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードによって型に名前が付けられていることが重要なのだ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;には class キーワードはないが， &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードを使うことで，名前と属性と操作を持つクラスを記述することができる。&lt;/p&gt;

&lt;h2 id=&#34;汎化-特化と処理の委譲:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;汎化・特化と処理の委譲&lt;/h2&gt;

&lt;p&gt;オブジェクト指向設計においてクラス間の関係は大きく2つある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;汎化・特化&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:c1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:c1&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;（継承または is-a 関係）&lt;/li&gt;
&lt;li&gt;関連&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:c2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:c2&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;（包含または has-a 関係）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;このうち関連についてはこれまで説明した方法で実現できるが，汎化・特化は表現できない。
そこで以下の機能を使って汎化・特化を実現する。&lt;/p&gt;

&lt;h3 id=&#34;振る舞いのみを定義した型:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;振る舞いのみを定義した型&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Interface_types&#34; title=&#34;Interface types&#34;&gt;interface&lt;/a&gt; を使うと型の振る舞いのみを記述することができる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Interface_types&#34; title=&#34;Interface types&#34;&gt;interface&lt;/a&gt; で定義された型で最もよく目にするのは &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; だろう。
&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; は以下のように定義できる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:er1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:er1&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type error interface {
	Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; は「string 型を返す &lt;code&gt;Error()&lt;/code&gt; 関数」のみが定義されている。
逆に言うと「string 型を返す &lt;code&gt;Error()&lt;/code&gt; 関数」を持つ全ての型は &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; の一種（つまり is-a 関係）であると見なすことができる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:dt&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:dt&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package os

import (
	&amp;quot;errors&amp;quot;
)

// PathError records an error and the operation and file path that caused it.
type PathError struct {
	Op   string
	Path string
	Err  error
}

func (e *PathError) Error() string { return e.Op + &amp;quot; &amp;quot; + e.Path + &amp;quot;: &amp;quot; + e.Err.Error() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義される &lt;a href=&#34;https://golang.org/pkg/os/&#34; title=&#34;os - The Go Programming Language&#34;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;PathError&lt;/code&gt; は &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; の一種である。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Interface_types&#34; title=&#34;Interface types&#34;&gt;interface&lt;/a&gt; も &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードで名前を付けることができ，他の型と同じように扱うことができる。
さらに &lt;a href=&#34;https://golang.org/ref/spec#Interface_types&#34; title=&#34;Interface types&#34;&gt;interface&lt;/a&gt; で定義した型は振る舞いのみで具体的な実装を含まないため，多態性を持たせた記述が可能になる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:if&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:if&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h3 id=&#34;型の埋め込み:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;型の埋め込み&lt;/h3&gt;

&lt;p&gt;もうひとつの汎化・特化の機能が型の埋め込み（embed）である。&lt;/p&gt;

&lt;p&gt;たとえば &lt;a href=&#34;https://golang.org/pkg/io/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;ReadWriter&lt;/code&gt; は以下のように &lt;code&gt;Reader&lt;/code&gt; および &lt;code&gt;Writer&lt;/code&gt; を埋め込んでいる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package io

import (
	&amp;quot;errors&amp;quot;
)

// Implementations must not retain p.
type Reader interface {
	Read(p []byte) (n int, err error)
}

// Implementations must not retain p.
type Writer interface {
	Write(p []byte) (n int, err error)
}

// ReadWriter is the interface that groups the basic Read and Write methods.
type ReadWriter interface {
	Reader
	Writer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これによって &lt;code&gt;ReadWriter&lt;/code&gt; は &lt;code&gt;Read()&lt;/code&gt; および &lt;code&gt;Write()&lt;/code&gt; を自身の関数のように扱うことができる。
この場合も &lt;code&gt;ReadWriter&lt;/code&gt; は &lt;code&gt;Reader&lt;/code&gt; および &lt;code&gt;Writer&lt;/code&gt; の一種（つまり is-a 関係）であると見なすことができる。&lt;/p&gt;

&lt;p&gt;同様に &lt;a href=&#34;https://golang.org/pkg/bufio/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;bufio&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;ReadWriter&lt;/code&gt; についても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package bufio

// ReadWriter stores pointers to a Reader and a Writer.
// It implements io.ReadWriter.
type ReadWriter struct {
	*Reader
	*Writer
}

// NewReadWriter allocates a new ReadWriter that dispatches to r and w.
func NewReadWriter(r *Reader, w *Writer) *ReadWriter {
	return &amp;amp;ReadWriter{r, w}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と実装されていて， &lt;a href=&#34;https://golang.org/pkg/bufio/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;bufio&lt;/code&gt;&lt;/a&gt; の &lt;code&gt;Reader&lt;/code&gt; および &lt;code&gt;Writer&lt;/code&gt; を埋め込み，これらの型の一種として実装されている。
なお， &lt;a href=&#34;https://golang.org/pkg/bufio/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;bufio&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;ReadWriter&lt;/code&gt; は &lt;a href=&#34;https://golang.org/pkg/io/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;ReadWriter&lt;/code&gt; の一種として機能している点にも注目してほしい。&lt;/p&gt;

&lt;h3 id=&#34;関数のオーバーライドと処理の委譲:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;関数のオーバーライドと処理の委譲&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を使って以下のコードを書いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type ErrorInfo interface {
	error
	Errno() int
}

type ErrorInfo1 struct{}

func (err *ErrorInfo1) Error() string {
	return fmt.Sprint(&amp;quot;Error Information: &amp;quot;, err.Errno())
}

func (err *ErrorInfo1) Errno() int {
	return 1
}

func Action() error {
	err := &amp;amp;ErrorInfo1{}
	return err
}

func main() {
    if err := Action(); err != nil {
		fmt.Println(err)
        return
	}
    fmt.Println(&amp;quot;Normal End&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; の拡張として &lt;code&gt;ErrorInfo&lt;/code&gt; を定義する。
&lt;code&gt;ErrorInfo&lt;/code&gt; では &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を埋め込み，さらに &lt;code&gt;Errno()&lt;/code&gt; を追加している。
これを実装したのが &lt;code&gt;ErrorInfo1&lt;/code&gt; である。
したがって実行結果は “&lt;code&gt;Error Information: 1&lt;/code&gt;” が出力される。
ここまでは今まで説明した通り。&lt;/p&gt;

&lt;p&gt;次に &lt;code&gt;ErrorInfo1&lt;/code&gt; のバリエーションとして &lt;code&gt;ErrorInfo2&lt;/code&gt; を追加してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type ErrorInfo interface {
	error
	Errno() int
}

type ErrorInfo1 struct{}

func (err *ErrorInfo1) Error() string {
	return fmt.Sprint(&amp;quot;Error Information: &amp;quot;, err.Errno())
}

func (err *ErrorInfo1) Errno() int {
	return 1
}

type ErrorInfo2 struct {
	ErrorInfo1
}

func (err *ErrorInfo2) Errno() int {
	return 2
}

func Action() error {
	err := &amp;amp;ErrorInfo2{}
	return err
}

func main() {
    if err := Action(); err != nil {
		fmt.Println(err)
        return
	}
    fmt.Println(&amp;quot;Normal End&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ErrorInfo2&lt;/code&gt; では &lt;code&gt;Error()&lt;/code&gt; は &lt;code&gt;ErrorInfo1&lt;/code&gt; のものをそのまま使い回したいが &lt;code&gt;Errno()&lt;/code&gt; では異なる値を出力したい，と考えた。
実行結果として “&lt;code&gt;Error Information: 2&lt;/code&gt;” が出力されることを期待したが，実際には前回と同じ “&lt;code&gt;Error Information: 1&lt;/code&gt;” が出力される。&lt;/p&gt;

&lt;p&gt;通常，型の埋め込みによって関数名が衝突する場合は型と直接関連付けられた関数が優先的に呼ばれるが，これは C++ や Java などにある仮想関数のオーバーライドとは少し異なる。&lt;/p&gt;

&lt;p&gt;上のコードでは &lt;code&gt;ErrorInfo2&lt;/code&gt; と直接関連付けられた &lt;code&gt;Error()&lt;/code&gt; がないため &lt;code&gt;ErrorInfo1&lt;/code&gt; の &lt;code&gt;Error()&lt;/code&gt; が呼ばれるが，その関数の中で呼ばれる &lt;code&gt;Errno()&lt;/code&gt; は &lt;code&gt;ErrorInfo2&lt;/code&gt; と関連付けられた関数ではなく &lt;code&gt;ErrorInfo1&lt;/code&gt; と関連付けられた関数になる。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;https://www.flickr.com/photos/spiegel/23151473894/&#34;&gt;&lt;img src=&#34;https://farm6.staticflickr.com/5804/23151473894_e23789de66_o.png&#34; alt=&#34;delegation&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/23151473894/&#34;&gt;delegation&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;これは &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;ではスーパークラスの関数の呼び出しが「委譲」として機能しているためである。
たとえば C++ 言語では virtual 修飾子を付与して仮想関数化することで意図的にオーバーライドできるが&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:dlg&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:dlg&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;ではこのような仕掛けがないため，呼ばれた関数は常に委譲として機能する。&lt;/p&gt;

&lt;p&gt;上の例はクラス設計からして明らかにダメダメなのだが，ポイントはサブクラスから &lt;code&gt;Errno()&lt;/code&gt; 関数を上書きすることでスーパークラスの &lt;code&gt;Error()&lt;/code&gt; 関数の処理を書き換えようとした点にある。
継承&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:ih&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:ih&#34;&gt;11&lt;/a&gt;&lt;/sup&gt; の実装で一番よくあるミスがこのカプセル化の破れで， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の場合は敢えて移譲を強制することで実装上の不具合が発生するのを回避しようとしているように見える。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/shibukawa/items/16acb36e94cfe3b02aa1&#34;&gt;オブジェクト指向言語としてGolangをやろうとするとハマること - Qiita&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/sona-tar/items/2b4b70694fd680f6297c&#34;&gt;オブジェクト指向言語としてGolangをやろうとするとハマる点を整理してみる - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://otiai10.hatenablog.com/entry/2014/01/15/220136&#34;&gt;Go言語に継承は無いんですか【golang】 - DRYな備忘録&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://otiai10.hatenablog.com/entry/2014/06/16/224109&#34;&gt;Go言語でジェネリクスっぽいことがしたいでござる【generics】【golang】 - DRYな備忘録&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:rn&#34;&gt;rune は Unicode 文字の符号位置（code point）を示す型で文字そのものを表現する。 string と rune の関係については「&lt;a href=&#34;http://text.baldanders.info/golang/string-and-rune/&#34;&gt;String と Rune&lt;/a&gt;」を参照のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:rn&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:slc&#34;&gt;slice については「&lt;a href=&#34;http://text.baldanders.info/golang/search-prime-numbers/&#34;&gt;素数探索アルゴリズムで遊ぶ&lt;/a&gt;」で少し紹介している。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:slc&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:pr&#34;&gt;ちなみに &lt;a href=&#34;https://golang.org/pkg/fmt/&#34; title=&#34;time - The Go Programming Language&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Print&lt;/code&gt; などでは引数が &lt;code&gt;String()&lt;/code&gt; を持っていることを期待し，この関数の出力結果をデフォルト書式にしている。したがって &lt;code&gt;fmt.Println(vertex.String())&lt;/code&gt; と &lt;code&gt;fmt.Println(vertex)&lt;/code&gt; は同じ結果になる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:pr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:mt&#34;&gt;他にも基本型や他パッケージで定義されている型に関数を追加することはできない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:mt&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:c1&#34;&gt;言わずもがなだが，サブクラスから見たスーパークラスが「汎化」でその逆が「特化」である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:c1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:c2&#34;&gt;関連には更に集約と複合があるが今回は踏み込まない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:c2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:er1&#34;&gt;&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; は組み込み型なので，実際にこのような定義が標準パッケージにあるわけではない。 &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; について詳しくは「&lt;a href=&#34;http://text.baldanders.info/golang/error-handling/&#34;&gt;エラー・ハンドリングについて&lt;/a&gt;」を参照のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:er1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:dt&#34;&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では Java の implement のような継承を明示するキーワードはない。記述された振る舞いからクラス関係を決定する方法を「&lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34;&gt;ダック・タイピング（duck typing）&lt;/a&gt;」と呼ぶ。ダック・タイピングとは「&lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_test&#34;&gt;ダック・テスト（duck test）&lt;/a&gt;」に由来する言葉だそうで，ダック・テストとは “If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.” と帰納法的に対象を推測する手法を指すらしい。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:dt&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:if&#34;&gt;たとえば &lt;code&gt;interface{}&lt;/code&gt; と記述すればあらゆる型を含むことになる。これを利用して &lt;a href=&#34;https://golang.org/pkg/fmt/&#34; title=&#34;time - The Go Programming Language&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Print&lt;/code&gt; は &lt;code&gt;func Print(a ...interface{}) (n int, err error) { ... }&lt;/code&gt; と定義されている。ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;にはいわゆる&lt;a href=&#34;https://golang.org/doc/faq#generics&#34;&gt;「総称型」はサポートされていない&lt;/a&gt;。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:if&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:dlg&#34;&gt;逆に Java では関数は常に仮想関数として機能しオーバーライドされる可能性がある。これを抑止するためには final 修飾子を付加する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:dlg&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:ih&#34;&gt;ここで言う継承は設計時の「汎化・特化」のことではなく，言語機能などを使った実装上の継承のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:ih&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Git.io から短縮 URL を取得するコード - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/get-shortened-url-from-gitio/" />
		<id>tag:text.Baldanders.info,2015-11-26:/golang/get-shortened-url-from-gitio/</id>
		<published>2015-11-26T20:29:30+09:00</published>
		<updated>2015-11-26T20:29:30+09:00</updated>
		<summary>これって curl で書けるんなら Go 言語で表現できるんじゃね？</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/042751d98e315e4e3382&#34;&gt;Git.io 短縮 URL を golang コードで取得してみる - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;h2 id=&#34;git-io-で短縮-url-が取得できるらしい:0223b5e2f12da4589f164146964cba22&#34;&gt;Git.io で短縮 URL が取得できるらしい&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/sotayamashita/items/1cf05f2a2be3d6fb3388&#34;&gt;Git・Githubに隠された便利な機能 | GitHub Cheat Sheet（日本語訳） - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを読んでたら後ろの方に &lt;a href=&#34;http://git.io/&#34; title=&#34;git.io&#34;&gt;Git.io&lt;/a&gt; の話が出ていた。
このサイトで短縮 URL を生成できるらしい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/blog/985-git-io-github-url-shortener&#34;&gt;Git.io: GitHub URL Shortener&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;API が &lt;a href=&#34;http://curl.haxx.se/&#34; title=&#34;curl and libcurl&#34;&gt;curl&lt;/a&gt; で掲載されていて，例えば私の &lt;a href=&#34;https://github.com/spiegel-im-spiegel&#34;&gt;https://github.com/spiegel-im-spiegel&lt;/a&gt; なら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -i &amp;quot;http://git.io&amp;quot; -F &amp;quot;url=https://github.com/spiegel-im-spiegel&amp;quot;
HTTP/1.1 201 Created
Server: Cowboy
Connection: keep-alive
Date: Sat, 08 Aug 2015 02:42:16 GMT
Status: 201 Created
Content-Type: text/html;charset=utf-8
Location: http://git.io/vOj52
Content-Length: 37
X-Xss-Protection: 1; mode=block
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-Runtime: 0.210952
X-Node: 871d903e-a8e0-46ff-a96f-ef424385e5ed
X-Revision: b1d9ce07ccb700fc90398edafd397beb8d3bd772
Via: 1.1 vegur

https://github.com/spiegel-im-spiegel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;てな感じで，ヘッダの Location 要素に短縮 URL が返ってくる仕組みらしい。
って，これって &lt;a href=&#34;http://curl.haxx.se/&#34; title=&#34;curl and libcurl&#34;&gt;curl&lt;/a&gt; で書けるんなら &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で表現できるんじゃね？&lt;/p&gt;

&lt;h2 id=&#34;curl-as-dsl:0223b5e2f12da4589f164146964cba22&#34;&gt;cURL as DSL&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://shibukawa.github.io/curl_as_dsl/&#34;&gt;cURL as DSL — cURL as DSL 1.0 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.shibu.jp/article/115602749.html&#34;&gt;Shibu&amp;rsquo;s Diary: cURL as DSLとは何だったのか。あるいは細かすぎて伝わらないcURL as DSL。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://shibukawa.github.io/curl_as_dsl/&#34; title=&#34;cURL as DSL — cURL as DSL 1.0 documentation&#34;&gt;cURL as DSL&lt;/a&gt; とは &lt;a href=&#34;http://curl.haxx.se/&#34; title=&#34;curl and libcurl&#34;&gt;curl&lt;/a&gt; の構文を任意のコード&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0223b5e2f12da4589f164146964cba22:a&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0223b5e2f12da4589f164146964cba22:a&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; に変換してくれるもので，どういうことかというと「&lt;a href=&#34;http://qiita.com/Hiraku/items/dfda2f8a5353b0742271&#34;&gt;Web API は curl で表現すればいいんじゃね？&lt;/a&gt;」ということらしい。&lt;/p&gt;

&lt;h2 id=&#34;さっそく-curl-を-go-言語に変換してみる:0223b5e2f12da4589f164146964cba22&#34;&gt;さっそく curl を Go 言語に変換してみる&lt;/h2&gt;

&lt;p&gt;では早速，上述の curl コマンドを &lt;a href=&#34;https://shibukawa.github.io/curl_as_dsl/&#34; title=&#34;cURL as DSL — cURL as DSL 1.0 documentation&#34;&gt;cURL as DSL&lt;/a&gt; を使って &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;に変換してみる（ただし &lt;code&gt;-i&lt;/code&gt; オプションは付けない）。
結果はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;mime/multipart&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func main() {
	var buffer bytes.Buffer
	writer := multipart.NewWriter(&amp;amp;buffer)
	writer.WriteField(&amp;quot;url&amp;quot;, &amp;quot;https://github.com/spiegel-im-spiegel&amp;quot;)
	writer.Close()

	resp, err := http.Post(&amp;quot;http://git.io&amp;quot;, &amp;quot;multipart/form-data; boundary=&amp;quot;+writer.Boundary(), &amp;amp;buffer)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	log.Print(string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出力のみちょっと弄って&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;mime/multipart&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func main() {
	var buffer bytes.Buffer
	writer := multipart.NewWriter(&amp;amp;buffer)
	writer.WriteField(&amp;quot;url&amp;quot;, &amp;quot;https://github.com/spiegel-im-spiegel&amp;quot;)
	writer.Close()

	resp, err := http.Post(&amp;quot;http://git.io&amp;quot;, &amp;quot;multipart/form-data; boundary=&amp;quot;+writer.Boundary(), &amp;amp;buffer)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	log.Println(&amp;quot;  Status: &amp;quot;, resp.Header.Get(&amp;quot;Status&amp;quot;))
	log.Println(&amp;quot;Location: &amp;quot;, resp.Header.Get(&amp;quot;Location&amp;quot;))
	log.Println(&amp;quot;    Body: &amp;quot;, string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:&amp;gt;go run gitio.go
2015/08/08 12:00:00   Status: 201 Created
2015/08/08 12:00:00 Location: http://git.io/vOj52
2015/08/08 12:00:00     Body: https://github.com/spiegel-im-spiegel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり，めでたく短縮 URL が取得できた。&lt;/p&gt;

&lt;p&gt;ちなみに最初の &lt;a href=&#34;http://curl.haxx.se/&#34; title=&#34;curl and libcurl&#34;&gt;curl&lt;/a&gt; コマンドの &lt;code&gt;-F&lt;/code&gt; を &lt;code&gt;-d&lt;/code&gt; に替えて &lt;a href=&#34;https://shibukawa.github.io/curl_as_dsl/&#34; title=&#34;cURL as DSL — cURL as DSL 1.0 documentation&#34;&gt;cURL as DSL&lt;/a&gt; にかけると&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0223b5e2f12da4589f164146964cba22:b&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0223b5e2f12da4589f164146964cba22:b&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;net/url&amp;quot;
)

func main() {
	values := url.Values{
		&amp;quot;url&amp;quot;: {&amp;quot;https://github.com/spiegel-im-spiegel&amp;quot;},
	}

	resp, err := http.PostForm(&amp;quot;http://git.io&amp;quot;, values)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	log.Print(string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように変換される。
&lt;a href=&#34;https://golang.org/pkg/net/http/&#34; title=&#34;http - The Go Programming Language&#34;&gt;&lt;code&gt;http&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Post()&lt;/code&gt; 関数から &lt;a href=&#34;https://golang.org/pkg/net/http/&#34; title=&#34;http - The Go Programming Language&#34;&gt;&lt;code&gt;http&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;PostForm()&lt;/code&gt; 関数に替わってかなりコードがすっきりした。
今回のような単純な request ならこちらの方がいいだろう。&lt;/p&gt;

&lt;h2 id=&#34;ついでにパッケージも作ってみた:0223b5e2f12da4589f164146964cba22&#34;&gt;ついでにパッケージも作ってみた&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/gitioapi&#34;&gt;spiegel-im-spiegel/gitioapi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを称して「他人の褌で相撲を取る」という&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0223b5e2f12da4589f164146964cba22:c&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0223b5e2f12da4589f164146964cba22:c&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
なるほど。
こうやって API を実装していくんだね。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:0223b5e2f12da4589f164146964cba22&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:0223b5e2f12da4589f164146964cba22:a&#34;&gt;今のところは &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のほかに Python3, PHP, JavaScript (node.js/XMLHttpRequest), Java, Objective-C (NSURL_Session/NSURLConnection), Vim Script (WebAPI-vim) に対応している。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0223b5e2f12da4589f164146964cba22:a&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:0223b5e2f12da4589f164146964cba22:b&#34;&gt;&lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/042751d98e315e4e3382&#34;&gt;初出の記事&lt;/a&gt;のコメントで &lt;a href=&#34;https://shibukawa.github.io/curl_as_dsl/&#34; title=&#34;cURL as DSL — cURL as DSL 1.0 documentation&#34;&gt;cURL as DSL&lt;/a&gt; の作者の方に教えていただいた。感謝！
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0223b5e2f12da4589f164146964cba22:b&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:0223b5e2f12da4589f164146964cba22:c&#34;&gt;実はジェネレータで生成したコードの著作権は誰に帰属するのか，とかいろいろ思うところはあるのだけど，それはまた別の機会に。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0223b5e2f12da4589f164146964cba22:c&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>プログラミング言語との付き合い方 - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2015/programming-language/" />
		<id>tag:text.Baldanders.info,2015-11-17:/remark/2015/programming-language/</id>
		<published>2015-11-17T21:52:50+09:00</published>
		<updated>2015-11-21T05:30:21+09:00</updated>
		<summary>こういう話は好きなので便乗してみる。（「おまけ」追加）</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://rentwi.textfile.org/?666213569055166464s&#34;&gt;考えてみると結城はC, Perl, Javaの本は書いたけれど&amp;hellip; - 結城浩の連ツイ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今朝見かけたこれ。
こういう話は好きなので便乗してみる。&lt;/p&gt;

&lt;p&gt;ちなみに，結城浩さんの通称「デザパタ本」はずい分昔に買っている。
お世話になってます。&lt;/p&gt;

&lt;h2 id=&#34;プログラミング言語の-母国語:79bafae369a776b9f3fc1a35fedebca1&#34;&gt;プログラミング言語の「母国語」&lt;/h2&gt;

&lt;figure&gt;
&lt;blockquote&gt;
&lt;q&gt;プログラミング言語との付き合い方というのはいろいろあってですね。自分の母国語という言語はある。それから現在学んでいる最中の言語というのもある。そして、仕事用の言語やら、他の人とのコミュニケーション用言語というのもある。そのあたりは、自然言語とちょっと似ている。&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;http://rentwi.textfile.org/?666213569055166464s&#34;&gt;考えてみると結城はC, Perl, Javaの本は書いたけれど...&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;個人的に母国語と言えるのはアセンブラとC言語。
私の場合はコードを脳内でインストラクションに翻訳する。
手続き型の言語ならこの「翻訳」をほとんど無意識でできる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:79bafae369a776b9f3fc1a35fedebca1:0&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:79bafae369a776b9f3fc1a35fedebca1:0&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
だから手続き型の言語であれば知らない言語でも見ればだいたい理解できる。&lt;/p&gt;

&lt;p&gt;逆に，関数型のような非手続き型言語はあまり得意ではないのだが，簡単なものであれば手続き型に翻訳できるので，簡単なものを組み合わせて考えることで，まぁ何とか理解することはできる。&lt;/p&gt;

&lt;h3 id=&#34;ちまりまわるつ:79bafae369a776b9f3fc1a35fedebca1&#34;&gt;ちまりまわるつ&lt;/h3&gt;

&lt;p&gt;そういえば，竹本泉さんの作品に『ちまりまわるつ』シリーズというのがある&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:79bafae369a776b9f3fc1a35fedebca1:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:79bafae369a776b9f3fc1a35fedebca1:1&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。
このシリーズの世界では「魔法」が科学的（？）に体系化されていて，工場で生産できるようになっている。なので，人力（？）で魔法を使う「魔法使い」は（工場で生産できない高度な魔法を使うことのできる一部の大魔法使いを除いては）古臭い職業として子供たちからは敬遠されている。
魔法使い達は能力でランク分けされていて，低ランクの魔法使いは簡単な呪文で簡単な魔法しか使えない。&lt;/p&gt;

&lt;p&gt;でもここからが竹本泉作品らしいところで，簡単な呪文しか使えない魔法使いも呪文を組み合わせることで高度な魔法を使うことができるのだ（ただし高度な魔法は制御が難しいので，ふつうは使わせてもらえない）。
プログラムに例えるなら，高級言語で1行で書けるプログラムをアセンブラで数十ステップで書くような感じだと思えばよい。&lt;/p&gt;

&lt;p&gt;こういう世界設定を少女漫画でさらっと描いてしまうところが竹本泉さんの凄いところである。&lt;/p&gt;

&lt;h3 id=&#34;目的別の言語:79bafae369a776b9f3fc1a35fedebca1&#34;&gt;目的別の言語&lt;/h3&gt;

&lt;p&gt;話が逸れた。&lt;/p&gt;

&lt;p&gt;そういうわけなので個人的に「学んでいる最中の言語」というのはない。
見て理解できるかできないか。
いや，ぺーぺーの新人の頃はアセンブラやC言語を必死こいて学んでいたが，一度基礎ができればあとは全部「応用編」なのである。
そういう意味じゃ「今現在学んでない言語なんかない」とも言えるか&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:79bafae369a776b9f3fc1a35fedebca1:a1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:79bafae369a776b9f3fc1a35fedebca1:a1&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:79bafae369a776b9f3fc1a35fedebca1:a2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:79bafae369a776b9f3fc1a35fedebca1:a2&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;私は職業プログラマなので当然「仕事用の言語」というのは存在するが，「コミュニケーション用言語」というのはないな。
『数学ガール』冒頭のミルカさんの登場シーンはなかなかインパクトがあるが，あんな感じだろうか。&lt;/p&gt;

&lt;p&gt;プログラマにとって最も信頼できる言葉は「動くコード」なので，ある意味で「仕事用の言語」が「コミュニケーション用言語」と言えるかもしれない。
ただ，職業プログラマは非プログラマとも話ができないといけない。
というか，大抵の顧客はそう。
顧客の「言語化されない意図」をいかに聞き取れるかが重要。
ホンマ「コミュニケーション用言語」なるものがあるなら欲しいよ。&lt;/p&gt;

&lt;p&gt;あぁでも，&lt;a href=&#34;http://www.baldanders.info/spiegel/log2/000869.shtml&#34;&gt;要求開発&lt;/a&gt;で使う「概念モデリング」は「コミュニケーション用言語」と言えなくもない？&lt;/p&gt;

&lt;h2 id=&#34;言語を巡る愛憎:79bafae369a776b9f3fc1a35fedebca1&#34;&gt;言語を巡る愛憎&lt;/h2&gt;

&lt;figure&gt;
&lt;blockquote&gt;
&lt;q&gt;自然言語と同じようにプログラミング言語を使う人（要はプログラマ）には、その言語に対する愛情がこもる（愛憎がこもる）。なので、エンジニアリングや効率の話題と思っているのにいつのまにか忠誠心や貢献度みたいな話になることも。&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;http://rentwi.textfile.org/?666213569055166464s&#34;&gt;考えてみると結城はC, Perl, Javaの本は書いたけれど...&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;仕事でプログラミングを行う際に言語を選べることはほとんどない。
顧客が指定してくることもあるし（顧客がコード資産を持っている），プロジェクト管理者が指定してくることもある（すでにある資産を使おうとする）。
そうじゃない場合でも要求と予算と期間とプロジェクトの面子によって（つまりそれを使うメリットとか関係なしに）言語が決まってしまう。&lt;/p&gt;

&lt;p&gt;もし，そういうのが一切ないのなら，今なら &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;か JavaScript/&lt;a href=&#34;http://electron.atom.io/&#34; title=&#34;Electron&#34;&gt;Electron&lt;/a&gt; がいいなぁ。
これらで十分だよね。&lt;/p&gt;

&lt;p&gt;一時期は Ruby も好きだったが，きれいさっぱり忘れてしまった。
今では Ruby の最新バージョンがいくつかさえ知らない。
なんか Rails 以降，凄い面倒くさいイメージがあるんだよね。
ある機能を Ruby で実装した記事を見かけたら，同じ機能を他の言語でもっと簡単にできないか，つい探してしまう。
こういうのが「宗教的」って言われるんだろうな，きっと（笑）&lt;/p&gt;

&lt;p&gt;まぁ，でも，上で書いたように仕事で言語を選べることはほとんどないので，「グダグダ言わずにコード書け」って感じだけど。&lt;/p&gt;

&lt;h2 id=&#34;ひとつのプログラミング言語に縛られることの恐さ:79bafae369a776b9f3fc1a35fedebca1&#34;&gt;ひとつのプログラミング言語に縛られることの恐さ&lt;/h2&gt;

&lt;figure&gt;
&lt;blockquote&gt;
&lt;q&gt;一つの技術に縛られることの恐さは、エンジニアなら誰でも知っている。では一つのプログラミング言語に縛られることの恐さは知っているか。一つのプログラミング言語がパーフェクトなことはない。時代が変われば要請も変わる。リソース配分は時々刻々変わる。そんな中で何にコミットするか。&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;http://rentwi.textfile.org/?666213569055166464s&#34;&gt;考えてみると結城はC, Perl, Javaの本は書いたけれど...&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;手続き型言語の弱点は「ノイマン型コンピュータ」に最適化されていることだ。&lt;/p&gt;

&lt;p&gt;ノイマン型コンピュータの構造はプロセッサとメモリが分かれているのが特徴で&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:79bafae369a776b9f3fc1a35fedebca1:b&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:79bafae369a776b9f3fc1a35fedebca1:b&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;，メモリから命令を順番にプロセッサにフェッチして実行していく。&lt;/p&gt;

&lt;p&gt;もちろん「非ノイマン型コンピュータ」というのもある。
典型的なのは，いわゆるニューロチップである。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://japan.zdnet.com/article/35073012/&#34;&gt;脳を模したチップ「TrueNorth」でコンピューティング革命を模索するIBM - ZDNet Japan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;こういうタイプのコンピュータは（ノイマン型コンピュータで言うところの）プロセッサとメモリがセットでひとつの素子になっているのが特徴で，しかも素子同士はお互いに非同期で動く。
こういうのが本気で市場に台頭してきたら私のようなロートル・エンジニアはお払い箱だ。&lt;/p&gt;

&lt;h2 id=&#34;若い人が正しい:79bafae369a776b9f3fc1a35fedebca1&#34;&gt;若い人が正しい&lt;/h2&gt;

&lt;figure&gt;
&lt;blockquote&gt;
&lt;q&gt;いつの時代でも、若い人は自由だ。何でも選べる。何でも言える。ときにはバカにされるかもしれない。わかってないよと侮られるかもしれない。でも、ほとんどの場合、若い人が正しい。&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;http://rentwi.textfile.org/?666213569055166464s&#34;&gt;考えてみると結城はC, Perl, Javaの本は書いたけれど...&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;先のことは誰にもわからない。
特に今の時代は。
だから「より多くの未来を持っている人」が正しいと言える。
私のように人生の残り時間を勘定している人ではない。&lt;/p&gt;

&lt;p&gt;願わくば「何でも選べる。何でも言える」未来を引き渡したいものである。&lt;/p&gt;

&lt;h2 id=&#34;おまけ-tensorflow-に関するブックマーク:79bafae369a776b9f3fc1a35fedebca1&#34;&gt;【おまけ】 TensorFlow に関するブックマーク&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;#feedback&#34;&gt;フィードバック&lt;/a&gt;で &lt;a href=&#34;http://tensorflow.org/&#34; title=&#34;TensorFlow is an Open Source Software Library for Machine Intelligence&#34;&gt;TensorFlow&lt;/a&gt; について言及があったので，ついでに。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tensorflow.org/&#34; title=&#34;TensorFlow is an Open Source Software Library for Machine Intelligence&#34;&gt;TensorFlow&lt;/a&gt; は Google がオープンソースとして提供する多次元配列（tensor）&lt;a href=&#34;https://en.wikipedia.org/wiki/Flow_%28mathematics%29&#34;&gt;演算（flow）&lt;/a&gt;ライブラリ。
いわゆる「機械学習（machine learning）」で威力を発揮し， &lt;a href=&#34;http://tensorflow.org/&#34; title=&#34;TensorFlow is an Open Source Software Library for Machine Intelligence&#34;&gt;TensorFlow&lt;/a&gt; の元となっている Google 内製のインフラ &lt;a href=&#34;http://research.google.com/pubs/pub40565.html&#34;&gt;DistBelief&lt;/a&gt; では既に実績がある。&lt;/p&gt;

&lt;p&gt;バックエンドは C++ で構築しているそうだが，フロントエンドでは Python が使える（将来的には他の言語にも対応するそうだ）。
携帯端末から GPU バリバリのワークステーションまでスケーラブルに対応し，簡易な記述で実装できるのが特徴。
可視化ツールもある。&lt;/p&gt;

&lt;p&gt;たしかに「&lt;a href=&#34;https://plus.google.com/+HidekiSaito/posts/EJZgMkANqou&#34;&gt;何か作れそうな気がする&lt;/a&gt;」感じではある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tensorflow.org/&#34;&gt;TensorFlow is an Open Source Software Library for Machine Intelligence&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tensorflow/tensorflow&#34;&gt;tensorflow/tensorflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.itmedia.co.jp/news/articles/1511/10/news055.html&#34;&gt;Google、機械学習システム「TensorFlow」をオープンソースで公開 - ITmedia ニュース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nextdeveloper.hatenablog.com/entry/2015/11/10/204609&#34;&gt;Googleの公開した人工知能ライブラリTensorFlowを触ってみた - 株式会社ネクスト　エンジニアBlog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/icoxfog417/items/fb5c24e35a849f8e2c5d&#34;&gt;TensorFlowを算数で理解する - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/haminiku/items/36982ae65a770565458d&#34;&gt;TensorFlow 畳み込みニューラルネットワークで手書き認識率99.2%の分類器を構築 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/kazuhirokomoda/items/a4cd0f6f42eb75c757e4&#34;&gt;自然言語処理をはじめたい人のためのゆるい記事 - Qiita&lt;/a&gt; : &lt;a href=&#34;http://tensorflow.org/&#34; title=&#34;TensorFlow is an Open Source Software Library for Machine Intelligence&#34;&gt;TensorFlow&lt;/a&gt; についても少しだけ言及&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/n_kats_/items/73538c7c66559d09f35d&#34;&gt;わざわざTensorFlowの機械学習で$\sqrt{2}$を計算する - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/TomokIshii/items/f355d8e87d23ee8e0c7a&#34;&gt;Python - 初めてのTensorFlow - イントロダクションとしての線形回帰 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;iframe class=&#34;youtube-player&#34; width=&#34;500&#34;  height=&#34;281&#34; src=&#34;https://www.youtube-nocookie.com/embed/oZikw5k_2FM&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=oZikw5k_2FM&#34;&gt;TensorFlow: Open source machine learning - YouTube&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&#34;参考図書:79bafae369a776b9f3fc1a35fedebca1&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00EYXMA9I/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/41ETMZ7i9qL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00EYXMA9I/baldandersinf-22/&#34;&gt;数学ガール&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;結城 浩 &lt;/dd&gt;&lt;dd&gt;SBクリエイティブ株式会社 2014-02-14&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00Y9EYOIW/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00Y9EYOIW.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート/微分を追いかけて&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1CM/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1CM.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／フェルマーの最終定理&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1D6/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1D6.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／ゲーデルの不完全性定理&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00W6NCLL0/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00W6NCLL0.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート/数列の広場&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00W6NCLJM/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00W6NCLJM.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート/丸い三角関数&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34; &gt;「数学ガール」シリーズ第1作目。ミルカさん衝撃の登場から分割数まで。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#34;#maker&#34; class=&#34;reviewer&#34;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2015-06-06&#34;&gt;2015/06/06&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34;&gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:79bafae369a776b9f3fc1a35fedebca1:0&#34;&gt;たとえば，C言語では「ポインタ」の概念でよく躓くと言われているが，インストラクションで考えれば実にシンプル。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:79bafae369a776b9f3fc1a35fedebca1:0&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:79bafae369a776b9f3fc1a35fedebca1:1&#34;&gt;多分もう絶版。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:79bafae369a776b9f3fc1a35fedebca1:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:79bafae369a776b9f3fc1a35fedebca1:a1&#34;&gt;評価を中断している言語はある。 Erlang とか Scala とか Haskell とか。仕事で絡むようなことがあれば是非やりたい。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:79bafae369a776b9f3fc1a35fedebca1:a1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:79bafae369a776b9f3fc1a35fedebca1:a2&#34;&gt;そう考えると，私にとって &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;はちょっと例外的かも。今のところ身近に &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;を使った仕事がないということもあるが，仕事抜きで完全に&lt;a href=&#34;http://text.baldanders.info/golang&#34;&gt;「遊び」でやってる&lt;/a&gt;。はっきり言って C/C++ や初期の Java 以来「これでなに作ろうかな」って思わせる言語に久しぶりに出会った感じ。もっとも，今は仕事が忙しすぎて全然かまってあげられないのだが orz
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:79bafae369a776b9f3fc1a35fedebca1:a2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:79bafae369a776b9f3fc1a35fedebca1:b&#34;&gt;キャッシュやパイプライン等の話はとりあえずチャイしてね。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:79bafae369a776b9f3fc1a35fedebca1:b&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>制約は構造を生む - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2015/the-structure-from-restriction/" />
		<id>tag:text.Baldanders.info,2015-09-30:/remark/2015/the-structure-from-restriction/</id>
		<published>2015-09-30T20:33:14+09:00</published>
		<updated>2015-09-30T20:33:14+09:00</updated>
		<summary>制約は programmable である</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">&lt;p&gt;「制約は構造を生む」というのは確か結城浩さんの『数学ガール』の中にあったフレーズだと思うが，私はこの言葉が好きである。
ただし，私の中ではこの言葉に続きがあって，それは「制約は programmable である」というものだ。&lt;/p&gt;

&lt;p&gt;「言葉」というのは面白いもので，表現のためのすばらしい手段でありながら，それ自体が表現に制約を加える。
自然言語の場合，その「制約」が硬直化するのを防ぐため自己を改変していく&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ddb5603ffc2de5a81cdadbb2d23d8d85:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ddb5603ffc2de5a81cdadbb2d23d8d85:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
しかしプログラミング言語の場合は「仕様」であり「ルール」であるため自己改変がしづらい面がある。
つまり，どんなプログラミング言語にも「賞味期限」があるのだ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.baldanders.info/spiegel/log2/000529.shtml&#34;&gt;前にも書いた&lt;/a&gt;けど，私は職業プログラマなので，プログラミングが好きでも嫌いでもない。
私から見れば「プログラミングが好き」というのは「鋸が好き」と言ってるのと大差ない。
プログラミング言語も同様で，基本的にはどんな言語にも対応できる自信はあるが，特定の言語が好きというのはない。&lt;/p&gt;

&lt;p&gt;それでも「これで何かを作ってみたい」と思う言語はいくつかあって，私の場合はそれが C/C++ や Java そして Go 言語である。
どういうわけかスクリプト言語にはあまり食指は向かなかった。
これはたぶん後付けの理由だけど，スクリプト言語というのはひたすら対象を「記述」しているだけで，あまり「作ってる」実感がない。&lt;/p&gt;

&lt;p&gt;先日，ついカッとなって「&lt;a href=&#34;http://text.baldanders.info/golang/error-handling/&#34;&gt;エラー・ハンドリングについて&lt;/a&gt;」という記事を書いたが&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ddb5603ffc2de5a81cdadbb2d23d8d85:a&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ddb5603ffc2de5a81cdadbb2d23d8d85:a&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，書いてて思い出したのが，まさに「制約は構造を生む」というフレーズだった。&lt;/p&gt;

&lt;p&gt;いわゆる「オブジェクト指向言語」が台頭しだした頃， C++ や Java でなかなか馴染めなかったのが「例外処理」である。
「&lt;a href=&#34;http://www.kaoriya.net/blog/2014/04/17/&#34;&gt;または私は如何にして例外するのを止めて golang を愛するようになったか&lt;/a&gt;」で「Java の例外が発生しうるメソッドの呼び出しは分岐を隠蔽・内包している」と指摘されているように，まさにこれは呼び出した関数から見て正体不明の &lt;code&gt;longjump&lt;/code&gt; をかまされるのとほとんど同じであり&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ddb5603ffc2de5a81cdadbb2d23d8d85:b&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ddb5603ffc2de5a81cdadbb2d23d8d85:b&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，「そんな危ないもん使えるか！」というのが最初の印象だった。
まぁ，もうすっかり馴らされたけどね。&lt;/p&gt;

&lt;p&gt;かつての私のように，例外になじめない人は結構いるようで，中には呼び出す関数ひとつひとつを &lt;code&gt;try-catch&lt;/code&gt; で囲ってる人とかもいて，「それって例外で実装する意味あるのか？」って感じである。
で，結局，関数の返値専用のオブジェクトを作って，返ってくるオブジェクトの状態を見てエラー・ハンドリングしたり。
それって CDD (Context-Driven Design) の萌芽かも（笑）&lt;/p&gt;

&lt;p&gt;Go 言語のエラー・ハンドリングと「古き良き」例外処理のどちらが優れているのかは一概に言えないと思うが，個人的には Go 言語のやり方に慣れてしまったら例外処理には戻れない&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ddb5603ffc2de5a81cdadbb2d23d8d85:c&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ddb5603ffc2de5a81cdadbb2d23d8d85:c&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。
今まで触ってみた感触だけど，おそらく Go 言語の肝は &lt;code&gt;return&lt;/code&gt; にあると思う。
Go 言語の &lt;code&gt;return&lt;/code&gt; をどう記述するか（あるいはしないか&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ddb5603ffc2de5a81cdadbb2d23d8d85:d&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ddb5603ffc2de5a81cdadbb2d23d8d85:d&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;）がコードの構造を決める鍵になっている。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:ddb5603ffc2de5a81cdadbb2d23d8d85:1&#34;&gt;逆に言うと自己改変しなくなった言語は緩慢な死を迎える。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ddb5603ffc2de5a81cdadbb2d23d8d85:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:ddb5603ffc2de5a81cdadbb2d23d8d85:a&#34;&gt;後悔はしていない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ddb5603ffc2de5a81cdadbb2d23d8d85:a&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:ddb5603ffc2de5a81cdadbb2d23d8d85:b&#34;&gt;今はもう存在しないと思うが，初期の C++ の実装のいくつかは例外を &lt;code&gt;longjump&lt;/code&gt; で実装していた。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ddb5603ffc2de5a81cdadbb2d23d8d85:b&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:ddb5603ffc2de5a81cdadbb2d23d8d85:c&#34;&gt;いや，もちろん仕事ならやりますよ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ddb5603ffc2de5a81cdadbb2d23d8d85:c&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:ddb5603ffc2de5a81cdadbb2d23d8d85:d&#34;&gt;記述しないことは記述することの一種である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ddb5603ffc2de5a81cdadbb2d23d8d85:d&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
</feed>
