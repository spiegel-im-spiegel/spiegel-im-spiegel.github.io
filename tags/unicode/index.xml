<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:cc="http://web.resource.org/cc/">
	<title>Unicode - text.Baldanders.info</title>
	<link rel="alternate" type="text/html" href="http://text.baldanders.info/tags/unicode/" />
	<link rel="self" type="application/atom+xml" href="http://text.baldanders.info/tags/unicode/index.xml" />
	<id>tag:text.Baldanders.info,2017-04-25:/tags</id>
	<updated>2017-04-25T22:16:55+09:00</updated>
	<subtitle>帰ってきた「しっぽのさきっちょ」</subtitle>
	<icon>http://text.baldanders.info//images/avatar.jpg</icon>
	<logo>http://text.baldanders.info//images/avatar.jpg</logo>
	<generator uri="https://gohugo.io/">Hugo 0.20.5</generator>

	
	<entry>
		<title>Punycode によるホモグラフ攻撃例とその回避 - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2017/04/homograph-attack/" />
		<id>tag:text.Baldanders.info,2017-04-25:/remark/2017/04/homograph-attack/</id>
		<published>2017-04-25T22:16:55+09:00</published>
		<updated>2017-04-30T21:34:04+09:00</updated>
		<summary>この手の攻撃の回避法だが， Chrome についてはバージョン 58 以降であれば対応済みである。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.xudongz.com/blog/2017/idn-phishing/&#34;&gt;Phishing with Unicode Domains - Xudong Zheng&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;たとえば，以下の &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;コードで2つの “apple&amp;rdquo; を考える（元ネタは&lt;a href=&#34;https://play.golang.org/p/BzJVWN78pA&#34; title=&#34;The Go Playground&#34;&gt;ここ&lt;/a&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	for _, value := range &amp;quot;apple&amp;quot; {
		fmt.Printf(&amp;quot;%#U\n&amp;quot;, value)
	}
	fmt.Println()
	for _, value := range &amp;quot;аррӏе&amp;quot; {
		fmt.Printf(&amp;quot;%#U\n&amp;quot;, value)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見た目では分かりにくいかもしれないが，最初の “apple&amp;rdquo; は US ASCII で2番目の “аррӏе&amp;rdquo; はキリル文字なんだそうだ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:grp&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:grp&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
このコードの実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;U+0061 &#39;a&#39;
U+0070 &#39;p&#39;
U+0070 &#39;p&#39;
U+006C &#39;l&#39;
U+0065 &#39;e&#39;

U+0430 &#39;а&#39;
U+0440 &#39;р&#39;
U+0440 &#39;р&#39;
U+04CF &#39;ӏ&#39;
U+0435 &#39;е&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現在，国際化ドメイン名（Internationalized Domain Name; IDN）については &lt;code&gt;xn--&lt;/code&gt; から始まる &lt;a href=&#34;https://en.wikipedia.org/wiki/Punycode&#34; title=&#34;Punycode - Wikipedia&#34;&gt;punycode&lt;/a&gt; を使った表記が認められている。
更に &lt;a href=&#34;https://en.wikipedia.org/wiki/Punycode&#34; title=&#34;Punycode - Wikipedia&#34;&gt;punycode&lt;/a&gt; を使った「ホモグラフ攻撃（homograph attack）」については以前から議論があり，少なくとも複数の言語の文字が混在する場合はブラウザ側で Unicode 文字による表記がキャンセルされる。
たとえば &lt;code&gt;xn-pple-43d.com&lt;/code&gt; は Unicode 表記では &lt;code&gt;аpple.com&lt;/code&gt; （先頭の а がキリル文字）だが， Chrome や Firefox といった主要ブラウザでは &lt;a href=&#34;https://en.wikipedia.org/wiki/Punycode&#34; title=&#34;Punycode - Wikipedia&#34;&gt;punycode&lt;/a&gt; のまま &lt;code&gt;xn-pple-43d.com&lt;/code&gt; と表記される（試さないように）。&lt;/p&gt;

&lt;p&gt;しかし複数言語が混在しない場合，つまり最初に挙げたキリル文字だけの “аррӏе&amp;rdquo; のような場合にはこの制約は効かない。
その言語による真っ当な名前なのかホモグラフ攻撃なのか見分けがつかないからである。
たとえば &lt;code&gt;xn--80ak6aa92e.com&lt;/code&gt; は &lt;code&gt;аррӏе.com&lt;/code&gt; だが “аррӏе&amp;rdquo; の部分は全てキリル文字なので主要ブラウザでも &lt;code&gt;аррӏе.com&lt;/code&gt; と表示される。&lt;/p&gt;

&lt;p&gt;PoC として &lt;a href=&#34;https://www.xn--80ak6aa92e.com/&#34;&gt;https://www.xn--80ak6aa92e.com/&lt;/a&gt; が用意されているので，皆さんが使っているブラウザで（証明書の詳細情報も含めて）ドメイン名がどう表示されるか確認して欲しい。&lt;/p&gt;

&lt;p&gt;さて，この手の攻撃の回避法だが， Chrome についてはバージョン 58 以降であれば &lt;code&gt;xn--80ak6aa92e.com&lt;/code&gt; も &lt;a href=&#34;https://en.wikipedia.org/wiki/Punycode&#34; title=&#34;Punycode - Wikipedia&#34;&gt;punycode&lt;/a&gt; 表記になる。
どういうロジックなのかは不明&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:idn&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:idn&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。
Firefox については，設定の &lt;code&gt;network.IDN_show_punycode&lt;/code&gt; 項目&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:cfg&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:cfg&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; を true にすれば強制的に &lt;a href=&#34;https://en.wikipedia.org/wiki/Punycode&#34; title=&#34;Punycode - Wikipedia&#34;&gt;punycode&lt;/a&gt; 表記になる。&lt;/p&gt;

&lt;p&gt;個人的には国際化ドメイン名は要らんのじゃないかと思うのだが，どうなんだろうねぇ。
果てしなく紛らわしい。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://arstechnica.com/security/2017/04/chrome-firefox-and-opera-users-beware-this-isnt-the-apple-com-you-want/&#34;&gt;Chrome, Firefox, and Opera users beware: This isn’t the apple.com you want | Ars Technica&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://securingtomorrow.mcafee.com/business/neutralize-threats/chrome-and-firefox-adding-protection-against-this-nasty-phishing-trick/&#34;&gt;Chrome And Firefox Adding Protection Against This Nasty Phishing Trick | McAfee Blogs&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://bugs.chromium.org/p/chromium/issues/detail?id=683314&#34;&gt;683314 - Security: Whole-script confusable domain label spoofing (Cyrillic) - chromium - Monorail&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://bugzilla.mozilla.org/show_bug.cgi?id=1332714&#34;&gt;1332714 - IDN Phishing using whole-script confusables on Windows and Linux&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://forest.watch.impress.co.jp/docs/news/1055935.html&#34;&gt;「Google Chrome 58」が正式版に ～“Indexed DB 2.0”対応と29件の脆弱性修正 - 窓の杜&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://eset-info.canon-its.jp/malware_info/special/detail/151001.html&#34;&gt;本物と偽物の区別がつかないホモグラフ攻撃 | マルウェア情報局&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://punycode.jp/&#34;&gt;日本語JPドメイン名のPunycode変換・逆変換 - 日本語.jp&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.arearesearch.co.jp/learn/program/06.html&#34;&gt;日本語ドメイン→Punycode表記への変換 | IPラーニング&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:grp&#34;&gt;キリル文字の “аррӏе&amp;rdquo; の並びに単語としての意味はない。ここでは単純に字形の類似性のみに着目して考える。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:grp&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:idn&#34;&gt;Firefox のように &lt;a href=&#34;https://en.wikipedia.org/wiki/Punycode&#34; title=&#34;Punycode - Wikipedia&#34;&gt;punycode&lt;/a&gt; をまるっと無視するのではないようだ。たとえば Chrome 58 でも「情報処理試験.jp（&lt;code&gt;xn--n9q36mh1hnxuksz7wt.jp&lt;/code&gt;）」はちゃんと Unicode 表記になる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:idn&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:cfg&#34;&gt;&lt;code&gt;about:config&lt;/code&gt; から設定する。 “punycode&amp;rdquo; で検索すれば一発で出てくる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:cfg&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Go 言語と Unicode 正規化 - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/unicode-normalization/" />
		<id>tag:text.Baldanders.info,2016-01-30:/golang/unicode-normalization/</id>
		<published>2016-01-30T04:05:52+09:00</published>
		<updated>2017-04-05T18:33:35+09:00</updated>
		<summary>今回は少し目先を変えて「Unicode 正規化」のお話。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回は少し目先を変えて「Unicode 正規化（normalization）」のお話。&lt;/p&gt;

&lt;h2 id=&#34;2羽の-ペンギン&#34;&gt;2羽の「ペンギン」&lt;/h2&gt;

&lt;p&gt;まず「ペンギン」という文字列を思い浮かべてみる。
この文字列を Unicode のコードポイントで表すと以下のようになる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ペ：U+30DA&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;li&gt;ギ：U+30AE&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ところでペンギンの「ペ」と「ギ」は半濁点および濁点を含む。
Unicode は「ペ」と「ギ」をそれぞれ2つの要素に分解できる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ペ：U+30D8 + U+309A&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;li&gt;ギ：U+30AD + U+3099&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;U+309A および U+3099 はそれぞれ半濁点と濁点を表す「結合文字（combining character）」である。
「ヘ」や「キ」のような「基底文字（base character）」に結合文字を1つ以上&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:cs&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:cs&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 付加した文字を「合成列（composite sequence）」と呼ぶ。
これに対して「ペ：U+30DA」や「ギ：U+30AE」のような文字を「事前合成形（precomposed）」と呼ぶ。&lt;/p&gt;

&lt;p&gt;つまり同じ文字を同じ文字集合&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ccs&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ccs&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; で表しているのにもかかわらず複数の符号化&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ecd&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ecd&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; が存在するわけだ。
これを「重複符号化」と言う。
文字集合に重複符号化があるというのは，はっきり言って「クソ仕様」である。&lt;/p&gt;

&lt;p&gt;もちろんこれは Unicode を作った連中がヘボいのではなく（いや，ヘボいのかもしれないが），いわゆる「歴史的経緯」というやつである&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:jis&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:jis&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。
だからこれはこういうものだと諦めるしかない。&lt;/p&gt;

&lt;p&gt;しかし情報処理を行う上では，この2羽の「ペンギン」が等価（equivalance）であることを示す手立てを考えなければならない。&lt;/p&gt;

&lt;h2 id=&#34;正規等価&#34;&gt;正規等価&lt;/h2&gt;

&lt;p&gt;2羽の「ペンギン」が等価であることを示す一番簡単な方法は，文字列を事前合成形あるいは合成列のどちらかに統一（＝正規化）してしまえばいい。
これを「正規等価（canonical equivalance）」と呼ぶ。
このうち，事前合成形に正規化する方法を “NFC（Normalization Form Composition）”，合成列に正規化する方法を “NFD（Normalization Form Decomposition）” と呼ぶ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では &lt;code&gt;golang.org/x/text/unicode/&lt;/code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34; title=&#34;norm - GoDoc&#34;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; パッケージで Unicode 文字列を正規化できる。
まぁ，コードで書いたほうがはやいか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	penguin := &amp;quot;ペンギン&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFD.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin3 := string(norm.NFC.Bytes([]byte(penguin2)))
	for pos, runeValue := range penguin3 {
		fmt.Printf(&amp;quot;penguin3[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+30DA &#39;ペ&#39;
penguin[3] = U+30F3 &#39;ン&#39;
penguin[6] = U+30AE &#39;ギ&#39;
penguin[9] = U+30F3 &#39;ン&#39;
penguin2[0] = U+30D8 &#39;ヘ&#39;
penguin2[3] = U+309A &#39;゚&#39;
penguin2[6] = U+30F3 &#39;ン&#39;
penguin2[9] = U+30AD &#39;キ&#39;
penguin2[12] = U+3099 &#39;゙&#39;
penguin2[15] = U+30F3 &#39;ン&#39;
penguin3[0] = U+30DA &#39;ペ&#39;
penguin3[3] = U+30F3 &#39;ン&#39;
penguin3[6] = U+30AE &#39;ギ&#39;
penguin3[9] = U+30F3 &#39;ン&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NFC と NFD が交換可能であることがわかると思う。&lt;/p&gt;

&lt;h2 id=&#34;3羽目の-ペンギン-と互換等価&#34;&gt;3羽目の「ペンギン」と互換等価&lt;/h2&gt;

&lt;p&gt;さてここで3羽目の「ﾍﾟﾝｷﾞﾝ」に登場してもらおう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ﾍ：U+FF8D&lt;/li&gt;
&lt;li&gt;ﾟ：U+FF9F&lt;/li&gt;
&lt;li&gt;ﾝ：U+FF9D&lt;/li&gt;
&lt;li&gt;ｷ：U+FF77&lt;/li&gt;
&lt;li&gt;ﾞ：U+FF9E&lt;/li&gt;
&lt;li&gt;ﾝ：U+FF9D&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これはいわゆる「半角カナ」である。
半角カナの半濁点 U+FF9F および濁点 U+FF9E は結合文字の半濁点 U+309A および濁点 U+3099 と同等とみなされているが「ペ」や「ギ」に相当する半角カナの事前合成形は存在しないため NFC で事前合成形に正規化しようとしても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	penguin := &amp;quot;ﾍﾟﾝｷﾞﾝ&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFC.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+FF8D &#39;ﾍ&#39;
penguin[3] = U+FF9F &#39;ﾟ&#39;
penguin[6] = U+FF9D &#39;ﾝ&#39;
penguin[9] = U+FF77 &#39;ｷ&#39;
penguin[12] = U+FF9E &#39;ﾞ&#39;
penguin[15] = U+FF9D &#39;ﾝ&#39;
penguin2[0] = U+FF8D &#39;ﾍ&#39;
penguin2[3] = U+FF9F &#39;ﾟ&#39;
penguin2[6] = U+FF9D &#39;ﾝ&#39;
penguin2[9] = U+FF77 &#39;ｷ&#39;
penguin2[12] = U+FF9E &#39;ﾞ&#39;
penguin2[15] = U+FF9D &#39;ﾝ&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何も変わらないことが分かるだろう。
そもそも半角カナは「互換用文字（Compatibility Character）」として異なるコードポイントが割り当てられているため，このままでは3羽目の「ﾍﾟﾝｷﾞﾝ」が等価であることを示せない。&lt;/p&gt;

&lt;p&gt;このような場合は「ﾍﾟﾝｷﾞﾝ」と互換性のある別の文字列に正規化できるとよい。
これを「互換等価（compatibility equivalance）」と呼ぶ。
具体的には，事前合成形に正規化する NFKC（Normalization Form Compatibility Composition）と合成列に正規化する NFKD（Normalization Form Compatibility Decomposition）の2つがある。&lt;/p&gt;

&lt;p&gt;早速 &lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34; title=&#34;norm - GoDoc&#34;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; パッケージを使ってコードを書いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	penguin := &amp;quot;ﾍﾟﾝｷﾞﾝ&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFKC.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+FF8D &#39;ﾍ&#39;
penguin[3] = U+FF9F &#39;ﾟ&#39;
penguin[6] = U+FF9D &#39;ﾝ&#39;
penguin[9] = U+FF77 &#39;ｷ&#39;
penguin[12] = U+FF9E &#39;ﾞ&#39;
penguin[15] = U+FF9D &#39;ﾝ&#39;
penguin2[0] = U+30DA &#39;ペ&#39;
penguin2[3] = U+30F3 &#39;ン&#39;
penguin2[6] = U+30AE &#39;ギ&#39;
penguin2[9] = U+30F3 &#39;ン&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり， NFC で正規化した「ペンギン」と等価であることがわかる。&lt;/p&gt;

&lt;p&gt;互換等価による正規化は応用範囲が広い。
たとえば「㈱」（U+3231）は「(株)」（U+0028 + U+682A + U+0029）に変換される。
文字列検索の前に互換等価による正規化を行っておくことで処理がやりやすくなるというのはあるかもしれない。
ただし， NFC と NFD は交換可能だが（ただしオリジナル文字列が事前合成形と合成列とで混在している場合は元に戻せないが）， NFKC や NFKD で正規化した文字列を元に戻す方法はないので注意が必要である&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:hw&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:hw&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;恐怖の-cjk-互換文字&#34;&gt;恐怖の CJK 互換文字&lt;/h2&gt;

&lt;p&gt;正規等価については注意すべき点がある。
有名な「神」を例に挙げよう。
これを NFC / NFD で正規化する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	god := &amp;quot;神&amp;quot;
	for pos, runeValue := range god {
		fmt.Printf(&amp;quot;god[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	god2 := string(norm.NFC.Bytes([]byte(god)))
	for pos, runeValue := range god2 {
		fmt.Printf(&amp;quot;god2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	god3 := string(norm.NFD.Bytes([]byte(god)))
	for pos, runeValue := range god3 {
		fmt.Printf(&amp;quot;god3[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;god[0] = U+FA19 &#39;神&#39;
god2[0] = U+795E &#39;神&#39;
god3[0] = U+795E &#39;神&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり，NFC でも NFD でも違う文字になってしまった。
ちなみに「神」から「神」へ正規化する方法はない。
困ったね。&lt;/p&gt;

&lt;p&gt;実は「神」は「CJK 互換文字」と呼ばれるグループに属し，「神」とは異体字の関係にある。
故に「神」を「神」に正規化してしまったのである。&lt;/p&gt;

&lt;p&gt;これは明らかに仕様ミスである。
「神」と「神」のような異体字の関係は本来なら正規等価ではなく互換等価であるべきだからだ。&lt;/p&gt;

&lt;p&gt;&amp;hellip;やっぱり Unicode はクソ仕様だ。&lt;/p&gt;

&lt;p&gt;ただ，これが実際の場面で問題になることは少ないと思われる。
なぜなら，正規化を行うのは「2つの文字列が等価であるか？」を調べるための手段にすぎないからだ。
普通はね。&lt;/p&gt;

&lt;p&gt;ところが，普通でないことをする馬鹿がいるのである。&lt;/p&gt;

&lt;h3 id=&#34;独自路線に走る-apple&#34;&gt;独自路線に走る Apple&lt;/h3&gt;

&lt;p&gt;Apple の OS X （iOS も？）のファイルシステムである HFS+ はファイル名を NFD 相当に正規化するという恐ろしい仕様になっている&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fs&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fs&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。
しかしそれでは先ほどの例のように異体字を別の文字に変えられてしまうため困ったことになってしまう。&lt;/p&gt;

&lt;p&gt;そこで Apple は CJK 互換文字を含むいくつかの文字を正規化の対象から外すという蛮行に出た。
俗に “UTF-8-MAC&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:nm&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:nm&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;” などと呼ばれる独自路線に走ってしまったわけだ。
クソの上塗りである。&lt;/p&gt;

&lt;p&gt;これにより様々な（特にマルチプラットフォームな）アプリケーションが多大なる迷惑を被ることになるが&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:mac&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:mac&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;，深くはツッコむまい。&lt;/p&gt;

&lt;h3 id=&#34;追記-2017-03-29&#34;&gt;追記（2017-03-29）&lt;/h3&gt;

&lt;p&gt;新しくリリースされた APFS (Apple File System) では上述のような似非正規化は行わないらしい。
よーし，うむうむ，よーし。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mjtsai.com/blog/2017/03/24/apfss-bag-of-bytes-filenames/&#34;&gt;Michael Tsai - Blog - APFS’s “Bag of Bytes” Filenames&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://naruse.hateblo.jp/entry/2017/03/28/181519&#34;&gt;macOS上のAPFSはUnicode Normalizationを行うのか? - なるせにっき&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/dankogai/items/6564a5a92288dd2a35d7&#34;&gt;APFSで再燃したNFD問題 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;unicode-正規化に関するまとめ&#34;&gt;Unicode 正規化に関するまとめ&lt;/h2&gt;

&lt;p&gt;以上， Unicode 正規化の4つの方式をまとめると以下のようになる。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;Composing&lt;/th&gt;
    &lt;th&gt;Decomposing&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th style=&#34;text-align:right;&#34;&gt;Canonical equivalence&lt;/th&gt;
    &lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34;&gt;norm&lt;/a&gt;.NFC&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34;&gt;norm&lt;/a&gt;.NFD&lt;/code&gt;&lt;br&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th style=&#34;text-align:right;&#34;&gt;Compatibility equivalence&lt;/th&gt;
    &lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34;&gt;norm&lt;/a&gt;.NFKC&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34;&gt;norm&lt;/a&gt;.NFKD&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://blog.golang.org/normalization&#34;&gt;via “Text normalization in Go”&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34; title=&#34;norm - GoDoc&#34;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; パッケージでは “UTF-8-MAC” なるローカル仕様には対応していないので，必要なら自作する必要がある。&lt;/p&gt;

&lt;p&gt;Unicode 文字列の等価属性を調べる際には是非参考にどうぞ。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://internet.watch.impress.co.jp/www/column/ogata/sp24.htm&#34;&gt;特別編24 JIS X 0213の改正は、文字コードにどんな未来をもたらすか（7）　番外編：改正JIS X 0213とUnicodeの等価属性／正規化について（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://internet.watch.impress.co.jp/www/column/ogata/sp25.htm&#34;&gt;特別編24 JIS X 0213の改正は、文字コードにどんな未来をもたらすか（7）　番外編：改正JIS X 0213とUnicodeの等価属性／正規化について（下）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nomenclator.la.coocan.jp/unicode/normalization.htm&#34;&gt;Unicode正規化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/normalization&#34;&gt;Text normalization in Go - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/masakielastic/items/01a4fb691c572dd71a19&#34;&gt;Go で UTF-8 の文字列を扱う - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tech.albert2005.co.jp/blog/2014/11/21/mco-normalize/&#34;&gt;文字コード地獄秘話 第3話：後戻りの効かないUnicode正規化 - ALBERT Engineer Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cpplover.blogspot.jp/2015/01/blog-post_14.html&#34;&gt;本の虫: Linus Torvalds、HFS+に激怒&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://moriyoshi.hatenablog.com/entry/2017/03/13/011005&#34;&gt;「ユニコード」で予期せぬ目に遭った話 - moriyoshiの日記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:cs&#34;&gt;結合文字はひとつの基底文字に対して複数付加される場合もある。しかもこの場合に結合文字同士の順序は不定である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:cs&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:ccs&#34;&gt;正しくは「符号化文字集合（coded character set）」である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ccs&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:ecd&#34;&gt;これは UTF-8 などの「文字エンコーディング」とは異なるものだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ecd&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:jis&#34;&gt;日本の JIS 規格にも「歴史的経緯」による重複符号化がある。言わずと知れた「半角」「全角」文字である。異体字も一種の重複符号化と言える。もちろんこれは日本語圏だけの問題ではなく，大抵の言語圏は似たような重複符号化の問題を抱えている。そして Unicode はそうした仕様上の欠陥も含めて併呑してしてしまっているため，このような有様になっているわけだ。問題を先送りして更に酷いことになるという失敗例の典型ですな。この辺の「歴史的経緯」の一部については大昔に拙文「&lt;span&gt;&lt;a href=&#34;http://www.baldanders.info/spiegel/archive/charset-pdfa.pdf&#34;&gt;文字コードとその実装&lt;sup&gt;&lt;i class=&#34;fa fa-file-pdf-o&#34;&gt;&lt;/i&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;」で言及しているので参考にどうぞ。古すぎて一部使えない記述もあるけど。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:jis&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:hw&#34;&gt;単に全角・半角変換ができればいいのなら &lt;code&gt;golang.org/x/text/&lt;/code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/width&#34; title=&#34;width - GoDoc&#34;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; パッケージをお勧めする。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:hw&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:fs&#34;&gt;ちなみに Windows のファイルシステムはフォルダ・ファイルの名前を正規化するとかいうアホなことはしない。事前合成形も合成列も受け入れる。見かけ同じ名前のフォルダ・ファイルが複数できる可能性はあるが，それはそれ。多分，ほとんどの OS のファイルシステムは名前の正規化なんてしてないはず。この HFS+ による Unicode 正規化のおかげで他プラットフォームはかなりの迷惑を被ることになる。たとえば複数のプラットフォームをまたぐファイル交換（例えば Linux → OS X → Windows みたいな経路）を行った場合に OS X を経由した途端にフォルダ・ファイル名を書き換えられてしまうのだ。しかもユーザやアプリケーションは基本的に干渉できない。迷惑千万な話である。もっとも Windows ユーザは Windows ファイルシステムのダメさ加減が身に沁みてるので他所を嗤えないけど（笑）
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fs&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:nm&#34;&gt;この記事では最初 NFD-mac と書いていたのだが，どうも巷では UTF-8-MAC というのが一般的らしい。しかしこの件はあくまでも正規化の問題であり文字エンコーディングの問題ではない。なので UTF-8-MAC という呼び名は的を得ていないと思うのだが， Apple 信者ではない私がどうこう言ってもしょうがないので UTF-8-MAC 表記で統一しておく。まぁ符号化文字集合と文字エンコーディングと正規化の区別もつかない馬鹿ばっかりだからこのような愚行を犯してしまったのだろう。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:nm&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:mac&#34;&gt;たとえば Linus Torvalds は HFS+ に起因する git の脆弱性問題で&lt;a href=&#34;http://cpplover.blogspot.jp/2015/01/blog-post_14.html&#34;&gt;激怒&lt;/a&gt;している。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:mac&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>String と Rune - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/string-and-rune/" />
		<id>tag:text.Baldanders.info,2015-09-19:/golang/string-and-rune/</id>
		<published>2015-09-19T23:45:56+09:00</published>
		<updated>2016-10-29T23:44:09+09:00</updated>
		<summary>今回は文字列について。短めにさくっと。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/556166b6631c0369754f&#34;&gt;はじめての Go 言語 (on Windows) その4 - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;文字列を示す &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; は不変（immutable）なオブジェクトだが，中身は byte 配列である。
したがって以下のように&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;
	size := len(nihongo)

	fmt.Printf(&amp;quot;nihongo = %d bytes :&amp;quot;, size)
	for i := 0; i &amp;lt; size; i++ {
		fmt.Printf(&amp;quot; %x&amp;quot;, nihongo[i])
	}
	fmt.Print(&amp;quot;\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; をダンプすると以下の結果になる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run string01.go
nihongo = 9 bytes : e6 97 a5 e6 9c ac e8 aa 9e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; なんて名前なのに）文字単位で情報を保持しているわけではないため，最初の2文字を取り出すつもりでうっかり&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;

	fmt.Printf(&amp;quot;nihongo = %s\n&amp;quot;, nihongo)
	fmt.Printf(&amp;quot;nippon = %s\n&amp;quot;, nihongo[:2])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんてなコードを書くと以下の結果になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run string02.go
nihongo = 日本語
nippon = ��
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文字列を文字単位で扱うには &lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; を使う。
いや，ルーンってどんだけ厨二&amp;hellip; ゲフンゲフン。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;
	nihongoRune := []rune(nihongo)
	size := len(nihongoRune)

	fmt.Printf(&amp;quot;nihongo = %d characters : &amp;quot;, size)
	for i := 0; i &amp;lt; size; i++ {
		fmt.Printf(&amp;quot;%#U &amp;quot;, nihongoRune[i])
	}
	fmt.Printf(&amp;quot;\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:&amp;gt;go run string03.go
nihongo = 3 characters : U+65E5 &#39;日&#39; U+672C &#39;本&#39; U+8A9E &#39;語&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;または， &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; に対して &lt;a href=&#34;http://golang.org/ref/spec#For_statements&#34;&gt;for range 構文&lt;/a&gt;を使ってループを回すと文字（&lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt;）単位で取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;

	for pos, runeValue := range nihongo {
		fmt.Printf(&amp;quot;%#U starts at byte position %d\n&amp;quot;, runeValue, pos)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:&amp;gt;go run string03b.go
U+65E5 &#39;日&#39; starts at byte position 0
U+672C &#39;本&#39; starts at byte position 3
U+8A9E &#39;語&#39; starts at byte position 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; の実体は int32 で，内部表現は Unicode の符号点（code point）になっている。
&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; と &lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; 配列は相互変換できるので，文字列を切り取る場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;

	fmt.Printf(&amp;quot;nihongo = %s\n&amp;quot;, nihongo)
	fmt.Printf(&amp;quot;nippon = %s\n&amp;quot;, string([]rune(nihongo)[:2]))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; → []&lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; → &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; と変換していけば安全に処理できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run string02b.go
nihongo = 日本語
nippon = 日本
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう少し細かい処理が必要なら &lt;a href=&#34;http://golang.org/pkg/unicode/utf8/&#34;&gt;&lt;code&gt;unicode/utf8&lt;/code&gt;&lt;/a&gt; パッケージを使う手もある&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.golang.org/strings&#34;&gt;Strings, bytes, runes and characters in Go - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://knightso.hateblo.jp/entry/2014/06/24/090719&#34;&gt;Go言語のstring, runeの正体とは？ - golang - The Round&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/hokaccha/items/3d3f45b5927b4584dbac&#34;&gt;Goでマルチバイトが混在した文字列をtruncateする - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/masakielastic/items/01a4fb691c572dd71a19&#34;&gt;Go で UTF-8 の文字列を扱う - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で取り扱う文字列の文字エンコーディングは UTF-8 が既定である。ソースコードがそもそも UTF-8 を要求しているし（つまりリテラルの文字列はかならず UTF-8 になる）， &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; と &lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; の相互変換も文字列が UTF-8 であることを前提にしている。しかし，実際には &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; の実体はただの byte 配列であり，中身が UTF-8 文字列であることを保証しているわけではない。通常は，未知の文字列についてはいったん byte 配列に格納しておいて，何らかの方法で UTF-8 に変換してから &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; にキャストするのが安全である（または各文字エンコーディング用の独自 type を作るか）。なお，文字エンコーディングの変換については&lt;a href=&#34;http://text.baldanders.info/golang/transform-character-encoding/&#34; title=&#34;文字エンコーディング変換&#34;&gt;別の記事&lt;/a&gt;で改めて紹介する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;ちなみに &lt;a href=&#34;http://golang.org/pkg/strings/&#34;&gt;&lt;code&gt;strings&lt;/code&gt;&lt;/a&gt; パッケージは内部で &lt;a href=&#34;http://golang.org/pkg/unicode/utf8/&#34;&gt;&lt;code&gt;unicode/utf8&lt;/code&gt;&lt;/a&gt; パッケージを使っているようだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
</feed>
