<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:cc="http://web.resource.org/cc/">
	<title>Character - text.Baldanders.info</title>
	<link rel="alternate" type="text/html" href="http://text.baldanders.info/tags/character/" />
	<link rel="self" type="application/atom+xml" href="http://text.baldanders.info/tags/character/index.xml" />
	<id>tag:text.Baldanders.info,2016-01-30:/</id>
	<updated>2016-01-30T04:05:52+09:00</updated>
	<subtitle>帰ってきた「しっぽのさきっちょ」</subtitle>
	<icon>http://text.baldanders.info//images/avatar.jpg</icon>
	<logo>http://text.baldanders.info//images/avatar.jpg</logo>
	<generator uri="http://gohugo.io/">Hugo 0.15</generator>

	
	<entry>
		<title>Go 言語と Unicode 正規化 - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/unicode-normalization/" />
		<id>tag:text.Baldanders.info,2016-01-30:/golang/unicode-normalization/</id>
		<published>2016-01-30T04:05:52+09:00</published>
		<updated>2016-01-30T04:05:52+09:00</updated>
		<summary>今回は少し目先を変えて「Unicode 正規化」のお話。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回は少し目先を変えて「Unicode 正規化（normalization）」のお話。&lt;/p&gt;

&lt;h2 id=&#34;2羽の-ペンギン:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;2羽の「ペンギン」&lt;/h2&gt;

&lt;p&gt;まず「ペンギン」という文字列を思い浮かべてみる。
この文字列を Unicode のコードポイントで表すと以下のようになる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ペ：U+30DA&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;li&gt;ギ：U+30AE&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ところでペンギンの「ペ」と「ギ」は半濁点および濁点を含む。
Unicode は「ペ」と「ギ」をそれぞれ2つの要素に分解できる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ペ：U+30D8 + U+309A&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;li&gt;ギ：U+30AD + U+3099&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;U+309A および U+3099 はそれぞれ半濁点と濁点を表す「結合文字（combining character）」である。
「ヘ」や「キ」のような「基底文字（base character）」に結合文字を1つ以上&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:cs&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:cs&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 付加した文字を「合成列（composite sequence）」と呼ぶ。
これに対して「ペ：U+30DA」や「ギ：U+30AE」のような文字を「事前合成形（precomposed）」と呼ぶ。&lt;/p&gt;

&lt;p&gt;つまり同じ文字を同じ文字集合&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:ccs&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:ccs&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; で表しているのにもかかわらず複数の符号化&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:ecd&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:ecd&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; が存在するわけだ。
これを「重複符号化」と言う。
文字集合に重複符号化があるというのは，はっきり言って「クソ仕様」である。&lt;/p&gt;

&lt;p&gt;もちろんこれは Unicode を作った連中がヘボいのではなく（いや，ヘボいのかもしれないが），いわゆる「歴史的経緯」というやつである&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:jis&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:jis&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。
だからこれはこういうものだと諦めるしかない。&lt;/p&gt;

&lt;p&gt;しかし情報処理を行う上では，この2羽の「ペンギン」が等価（equivalance）であることを示す手立てを考えなければならない。&lt;/p&gt;

&lt;h2 id=&#34;正規等価:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;正規等価&lt;/h2&gt;

&lt;p&gt;2羽の「ペンギン」が等価であることを示す一番簡単な方法は，文字列を事前合成形あるいは合成列のどちらかに統一（＝正規化）してしまえばいい。
これを「正規等価（canonical equivalance）」と呼ぶ。
このうち，事前合成形に正規化する方法を “NFC（Normalization Form Composition）”，合成列に正規化する方法を “NFD（Normalization Form Decomposition）” と呼ぶ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では &lt;code&gt;golang.org/x/text/unicode/&lt;/code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34; title=&#34;norm - GoDoc&#34;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; パッケージで Unicode 文字列を正規化できる。
まぁ，コードで書いたほうがはやいか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	penguin := &amp;quot;ペンギン&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFD.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin3 := string(norm.NFC.Bytes([]byte(penguin2)))
	for pos, runeValue := range penguin3 {
		fmt.Printf(&amp;quot;penguin3[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+30DA &#39;ペ&#39;
penguin[3] = U+30F3 &#39;ン&#39;
penguin[6] = U+30AE &#39;ギ&#39;
penguin[9] = U+30F3 &#39;ン&#39;
penguin2[0] = U+30D8 &#39;ヘ&#39;
penguin2[3] = U+309A &#39;゚&#39;
penguin2[6] = U+30F3 &#39;ン&#39;
penguin2[9] = U+30AD &#39;キ&#39;
penguin2[12] = U+3099 &#39;゙&#39;
penguin2[15] = U+30F3 &#39;ン&#39;
penguin3[0] = U+30DA &#39;ペ&#39;
penguin3[3] = U+30F3 &#39;ン&#39;
penguin3[6] = U+30AE &#39;ギ&#39;
penguin3[9] = U+30F3 &#39;ン&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NFC と NFD が交換可能であることがわかると思う。&lt;/p&gt;

&lt;h2 id=&#34;3羽目の-ペンギン-と互換等価:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;3羽目の「ペンギン」と互換等価&lt;/h2&gt;

&lt;p&gt;さてここで3羽目の「ペンギン」に登場してもらおう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ﾍ：U+FF8D&lt;/li&gt;
&lt;li&gt;ﾟ：U+FF9F&lt;/li&gt;
&lt;li&gt;ﾝ：U+FF9D&lt;/li&gt;
&lt;li&gt;ｷ：U+FF77&lt;/li&gt;
&lt;li&gt;ﾞ：U+FF9E&lt;/li&gt;
&lt;li&gt;ﾝ：U+FF9D&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これはいわゆる「半角カナ」である。
半角カナの濁点および半濁点は結合文字ではない。
そのためこの文字列を NFC で事前合成形に正規化しようとしても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	penguin := &amp;quot;ﾍﾟﾝｷﾞﾝ&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFC.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+FF8D &#39;ﾍ&#39;
penguin[3] = U+FF9F &#39;ﾟ&#39;
penguin[6] = U+FF9D &#39;ﾝ&#39;
penguin[9] = U+FF77 &#39;ｷ&#39;
penguin[12] = U+FF9E &#39;ﾞ&#39;
penguin[15] = U+FF9D &#39;ﾝ&#39;
penguin2[0] = U+FF8D &#39;ﾍ&#39;
penguin2[3] = U+FF9F &#39;ﾟ&#39;
penguin2[6] = U+FF9D &#39;ﾝ&#39;
penguin2[9] = U+FF77 &#39;ｷ&#39;
penguin2[12] = U+FF9E &#39;ﾞ&#39;
penguin2[15] = U+FF9D &#39;ﾝ&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何も変わらないことが分かるだろう。&lt;/p&gt;

&lt;p&gt;このような場合は半角の「ﾍﾟﾝｷﾞﾝ」と互換性のある文字列に正規化できるとよい。
これを「互換等価（compatibility equivalance）」と呼ぶ。
具体的には NFKC（Normalization Form Compatibility Composition）および NFKD（Normalization Form Compatibility Decomposition）の2つの正規化がある。&lt;/p&gt;

&lt;p&gt;早速 &lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34; title=&#34;norm - GoDoc&#34;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; パッケージを使ってコードを書いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	penguin := &amp;quot;ﾍﾟﾝｷﾞﾝ&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFKC.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+FF8D &#39;ﾍ&#39;
penguin[3] = U+FF9F &#39;ﾟ&#39;
penguin[6] = U+FF9D &#39;ﾝ&#39;
penguin[9] = U+FF77 &#39;ｷ&#39;
penguin[12] = U+FF9E &#39;ﾞ&#39;
penguin[15] = U+FF9D &#39;ﾝ&#39;
penguin2[0] = U+30DA &#39;ペ&#39;
penguin2[3] = U+30F3 &#39;ン&#39;
penguin2[6] = U+30AE &#39;ギ&#39;
penguin2[9] = U+30F3 &#39;ン&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり， NFC で正規化した「ペンギン」と等価であることがわかる。&lt;/p&gt;

&lt;p&gt;互換等価による正規化は応用範囲が広い。
たとえば「㈱」（U+3231）は「（株）」（U+0028 + U+682A + U+0029）に変換される。
文字列検索の前に互換等価による正規化を行っておくことで処理がやりやすくなるというのはあるかもしれない。
ただし， NFC と NFD は交換可能だが， NFKC や NFKD で正規化した文字列を元のオリジナルに戻す方法はないので注意が必要である&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:hw&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:hw&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;恐怖の-cjk-互換文字:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;恐怖の CJK 互換文字&lt;/h2&gt;

&lt;p&gt;正規等価については注意すべき点がある。
有名な「神」を例に挙げよう。
これを NFC / NFD で正規化する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

//神様の遊び
func main() {
	penguin := &amp;quot;神&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFKC.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin3 := string(norm.NFKD.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin3 {
		fmt.Printf(&amp;quot;penguin3[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+FA19 &#39;神&#39;
penguin2[0] = U+795E &#39;神&#39;
penguin3[0] = U+795E &#39;神&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり，NFC でも NFD でも違う文字になってしまった。
ちなみに「神」から「神」へ正規化する方法はない。
困ったね。&lt;/p&gt;

&lt;p&gt;実は「神」は「CJK 互換文字」と呼ばれるグループに属し，「神」とは異体字の関係にある。
故に「神」を「神」に正規化してしまったのである。&lt;/p&gt;

&lt;p&gt;しかし，これは明らかに仕様ミスである。
「神」と「神」のような異体字の関係は本来なら正規等価ではなく互換等価であるべきだからだ。&lt;/p&gt;

&lt;p&gt;&amp;hellip;やっぱり Unicode はクソ仕様だ。&lt;/p&gt;

&lt;p&gt;しかし，これが実際の場面で問題になることは少ないと思われる。
なぜなら，正規化を行うのは「2つの文字列が等価であるか？」を調べるための手段にすぎないからだ。
普通はね。&lt;/p&gt;

&lt;p&gt;ところが，普通でないことをする馬鹿がいるのである。&lt;/p&gt;

&lt;h3 id=&#34;独自路線に走る-apple:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;独自路線に走る Apple&lt;/h3&gt;

&lt;p&gt;Apple の OS X （iOS も？）のファイルシステムである HFS+ はファイル名を NFD 相当に正規化するという恐ろしい仕様になっている&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:fs&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:fs&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。
しかしそれでは，先ほどの例のように異体字に関しては正規化によって別の文字に変えられてしまうため困ったことになってしまう。&lt;/p&gt;

&lt;p&gt;そこで Apple は CJK 互換文字を含むいくつかの文字を正規化の対象から外すという蛮行に出た。
俗に “NFD-mac” などと呼ばれる独自路線に走ってしまったわけだ。&lt;/p&gt;

&lt;p&gt;これにより様々な（特にマルチプラットフォームな）アプリケーションが多大なる迷惑を被ることになるが&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:mac&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:mac&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;，深くはツッコむまい。&lt;/p&gt;

&lt;h2 id=&#34;unicode-正規化に関するまとめ:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;Unicode 正規化に関するまとめ&lt;/h2&gt;

&lt;p&gt;以上， Unicode 正規化の4つの方式をまとめると以下のようになる。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;Composing&lt;/th&gt;
    &lt;th&gt;Decomposing&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Canonical equivalence&lt;/th&gt;
    &lt;td&gt;NFC&lt;/td&gt;
    &lt;td&gt;NFD&lt;br&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Compatibility equivalence&lt;/th&gt;
    &lt;td&gt;NFKC&lt;/td&gt;
    &lt;td&gt;NFKD&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://blog.golang.org/normalization&#34;&gt;Text normalization in Go&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Unicode 文字列の等価属性を調べる際には是非参考にどうぞ。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://internet.watch.impress.co.jp/www/column/ogata/sp24.htm&#34;&gt;特別編24 JIS X 0213の改正は、文字コードにどんな未来をもたらすか（7）　番外編：改正JIS X 0213とUnicodeの等価属性／正規化について（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://internet.watch.impress.co.jp/www/column/ogata/sp25.htm&#34;&gt;特別編24 JIS X 0213の改正は、文字コードにどんな未来をもたらすか（7）　番外編：改正JIS X 0213とUnicodeの等価属性／正規化について（下）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nomenclator.la.coocan.jp/unicode/normalization.htm&#34;&gt;Unicode正規化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/normalization&#34;&gt;Text normalization in Go - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/masakielastic/items/01a4fb691c572dd71a19&#34;&gt;Go で UTF-8 の文字列を扱う - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tech.albert2005.co.jp/blog/2014/11/21/mco-normalize/&#34;&gt;文字コード地獄秘話 第3話：後戻りの効かないUnicode正規化 - ALBERT Engineer Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cpplover.blogspot.jp/2015/01/blog-post_14.html&#34;&gt;本の虫: Linus Torvalds、HFS+に激怒&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:cs&#34;&gt;ちなみに結合文字はひとつの基底文字に対して複数付加される場合もある。しかもこの場合に結合文字同士の順序は不定である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:cs&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:ccs&#34;&gt;正しくは「符号化文字集合（coded character set）」である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:ccs&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:ecd&#34;&gt;これは UTF-8 などの「文字エンコーディング」とは異なるものだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:ecd&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:jis&#34;&gt;日本の JIS 規格にも「歴史的経緯」による重複符号化がある。言わずと知れた「半角」「全角」文字である。異体字も一種の重複符号化と言える。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:jis&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:hw&#34;&gt;単に全角・半角変換ができればいいのなら &lt;code&gt;golang.org/x/text/&lt;/code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/width&#34; title=&#34;width - GoDoc&#34;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; パッケージをお勧めする。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:hw&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:fs&#34;&gt;ちなみに Windows のファイルシステムはフォルダ・ファイルの名前を正規化するとかいうアホなことはしない。事前合成形も合成列も受け入れる。見かけ同じ名前のフォルダ・ファイルが複数できる可能性はあるが，それはそれ。多分，ほとんどの OS のファイルシステムは名前の正規化なんてしてないはず。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:fs&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:mac&#34;&gt;たとえば Linus Torvalds は HFS+ に起因する git の脆弱性問題で&lt;a href=&#34;http://cpplover.blogspot.jp/2015/01/blog-post_14.html&#34;&gt;激怒&lt;/a&gt;している。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:mac&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Web フォントに関する覚え書き - remark</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/remark/2015/web-font-family/" />
		<id>tag:text.Baldanders.info,2015-10-21:/remark/2015/web-font-family/</id>
		<published>2015-10-21T21:41:45+09:00</published>
		<updated>2015-10-22T14:54:00+09:00</updated>
		<summary>このサイトの Web フォントまわりを整理したので，覚え書きとして残しておく。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="remark" label="remark" scheme="http://text.baldanders.info/remark" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;このサイトの Web フォントまわりを整理したので，覚え書きとして残しておく。&lt;/p&gt;

&lt;h2 id=&#34;google-noto-fonts:3dfd8bd3067ce5a96224e4168b8cdcd3&#34;&gt;Google Noto Fonts&lt;/h2&gt;

&lt;p&gt;このサイトの Web フォントを Google Noto Fonts で統一した&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3dfd8bd3067ce5a96224e4168b8cdcd3:a&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3dfd8bd3067ce5a96224e4168b8cdcd3:a&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;Google Noto Fonts は以下のサイトで取得できる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.google.com/fonts/&#34;&gt;Google Fonts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このサイトでは様々なフォントが選べるが “Noto” をキーワードに以下のフォントを選択する。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Noto Sans : Normal 400, Bold 700&lt;/li&gt;
&lt;li&gt;Noto Serif : Normal 400, Bold 700&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;またサブセットとして Latin を選択する。
これで，以下に示す書式で CSS ファイルを HTML の &lt;code&gt;head&lt;/code&gt; 要素内に指定すればよい&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3dfd8bd3067ce5a96224e4168b8cdcd3:aa&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3dfd8bd3067ce5a96224e4168b8cdcd3:aa&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link href=&#39;//fonts.googleapis.com/css?family=Noto+Sans:400,700|Noto+Serif:400,700&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bold が不要であればもっと軽くできる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3dfd8bd3067ce5a96224e4168b8cdcd3:b&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3dfd8bd3067ce5a96224e4168b8cdcd3:b&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link href=&#39;//fonts.googleapis.com/css?family=Noto+Sans|Noto+Serif&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS でフォントを指定する際は &lt;code&gt;&amp;quot;Noto Sans&amp;quot;&lt;/code&gt; や &lt;code&gt;&amp;quot;Noto Serif&amp;quot;&lt;/code&gt; で指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;body {
  font-family: &#39;Noto Serif&#39;, serif;
  font-weight: 400; /* normal */
  font-variant: normal;
  font-style: normal;
  font-size: medium;
  line-height: 1.4;
}
h1, h2, h3, h4, h5, h6, address, table th, dl &amp;gt; dt, em, strong, cite {
  font-family: &#39;Noto Sans&#39;, sans-serif;
  font-weight: inherit;
  font-variant: inherit;
  font-style: inherit;
  font-size: inherit;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;noto-sans-japanese:3dfd8bd3067ce5a96224e4168b8cdcd3&#34;&gt;Noto Sans Japanese&lt;/h3&gt;

&lt;p&gt;2014年， Noto Sans に Noto Sans CJK が加わった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.google.com/get/noto/help/cjk/&#34;&gt;Noto Sans CJK – Google Noto Fonts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://googledevjp.blogspot.jp/2014/07/noto.html&#34;&gt;オープンソースの美しい Noto フォントファミリーに日本語、中国語、韓国語が加わりました。 - Google Developer Japan Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Noto Sans CJK を Web フォントとして使用するなら以下のサイトが参考になる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.google.com/fonts/earlyaccess&#34;&gt;Google Fonts : Early Access&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;日本語であれば “Noto Sans Japanese” を導入すればよい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link href=&#39;//fonts.googleapis.com/earlyaccess/notosansjapanese.css&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フォント名は &lt;code&gt;&amp;quot;Noto Sans Japanese&amp;quot;&lt;/code&gt; で指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;body {
  font-family: &#39;Noto Serif&#39;, serif;
  font-weight: 400; /* normal */
  font-variant: normal;
  font-style: normal;
  font-size: medium;
  line-height: 1.4;
}
h1, h2, h3, h4, h5, h6, address, table th, dl &amp;gt; dt, em, strong, cite {
  font-family: &#39;Noto Sans&#39;, &#39;Noto Sans Japanese&#39;, sans-serif;
  font-weight: inherit;
  font-variant: inherit;
  font-style: inherit;
  font-size: inherit;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Noto Sans Japanese では JIS X 0208 の文字集合を収録しているため， JIS X 0213 第3第4水準漢字はサポートされていない模様。
これらの漢字が必要な場合は Noto Sans CJK の日本語フルセットが必要となる。&lt;/p&gt;

&lt;h3 id=&#34;inconsolata:3dfd8bd3067ce5a96224e4168b8cdcd3&#34;&gt;Inconsolata&lt;/h3&gt;

&lt;p&gt;プログラム・コードの表示用に Inconsolata を導入する。
Inconsolata は &lt;a href=&#34;https://www.google.com/fonts/&#34;&gt;Google Fonts&lt;/a&gt; を使って導入可能。
最終的に Google Fonts の書式は以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link href=&#39;//fonts.googleapis.com/css?family=Noto+Serif|Noto+Sans|Inconsolata:400,700&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&amp;gt;
&amp;lt;link href=&#39;//fonts.googleapis.com/earlyaccess/notosansjapanese.css&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また CSS の記述は以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;body {
  font-family: &#39;Noto Serif&#39;, serif;
  font-weight: 400; /* normal */
  font-variant: normal;
  font-style: normal;
  font-size: medium;
  line-height: 1.4;
}
h1, h2, h3, h4, h5, h6, address, table th, dl &amp;gt; dt, em, strong, cite {
  font-family: &#39;Noto Sans&#39;, &#39;Noto Sans Japanese&#39;, sans-serif;
  font-weight: inherit;
  font-variant: inherit;
  font-style: inherit;
  font-size: inherit;
}
pre, tt, code, var, kbd, samp {
  font-family: &#39;Inconsolata&#39;, &#39;Noto Sans Japanese&#39;, monospace;
  font-weight: inherit;
  font-variant: inherit;
  font-style: inherit;
  font-size: inherit;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;noto-serif-japanese-が欲しい:3dfd8bd3067ce5a96224e4168b8cdcd3&#34;&gt;Noto Serif Japanese が欲しい！&lt;/h3&gt;

&lt;p&gt;残念ながら，現時点では Noto Serif の日本語フォントは存在しない。
有料で明朝体 Web フォントを提供してくれるサービスはあるが，デザイン重視のサイトならともかく，うちのようにただ文字が多いだけのサイトでは「お金を払ってまでねぇ」という感じ。
そこで，いくつかオープンなフォントを探してみる。&lt;/p&gt;

&lt;h4 id=&#34;ipa-明朝:3dfd8bd3067ce5a96224e4168b8cdcd3&#34;&gt;IPA 明朝&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ipafont.ipa.go.jp/&#34;&gt;IPAexフォント/IPAフォント | IPAフォントのダウンロードサイトです&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;オープンなフォントといえば IPA フォントだよね。
&lt;a href=&#34;http://www.opensource.jp/osd/osd-japanese.html&#34;&gt;OSD (Open Source Definition)&lt;/a&gt; に準拠した&lt;a href=&#34;http://ipafont.ipa.go.jp/ipa_font_license_v1-html&#34;&gt;ライセンス&lt;/a&gt;で提供されているため扱いやすい&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3dfd8bd3067ce5a96224e4168b8cdcd3:c&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3dfd8bd3067ce5a96224e4168b8cdcd3:c&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;ただし IPA フォントは PDF 文書のようなものには向いてるけど， Web フォントには向いていない。
理由は以下の2つ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全体的に線が細く表示環境によっては文字がかすれてしまう。 ウェイトが1種類しかないのもマイナスポイント&lt;/li&gt;
&lt;li&gt;JIS X 0213 の文字集合を全て収録しているのはいいが，データサイズが大きくなってしまう。第1第2水準漢字のみのサブセットがあればいいのに&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;あおぞら明朝:3dfd8bd3067ce5a96224e4168b8cdcd3&#34;&gt;あおぞら明朝&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blueskis.wktk.so/AozoraMincho/&#34; title=&#34;ホーム | あおぞら明朝フォント&#34;&gt;あおぞら明朝フォント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IPA 明朝（厳密には IPA P明朝）からの fork で，7ウェイトをサポートしているのが特徴。
ライセンスも &lt;a href=&#34;http://ipafont.ipa.go.jp/ipa_font_license_v1-html&#34;&gt;IPA フォントライセンス&lt;/a&gt;を継承している。
欠点は以下のとおり。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ベースがプロポーショナル・フォントなので見た目が詰まった感じになってしまう&lt;/li&gt;
&lt;li&gt;IPA フォントと同じく JIS X 0213 の文字集合を全て収録しているのはいいが，データサイズが大きくなってしまう&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;やさしさアンチック:3dfd8bd3067ce5a96224e4168b8cdcd3&#34;&gt;やさしさアンチック&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.fontna.com/blog/1122/&#34;&gt;フリーフォントやさしさアンチック（漫画用書体・セリフフォント）のダウンロード | フォントな。無料日本語フリーフォント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;アンチック体あるいは「アンチゴチ」と呼ばれる書体で，漢字はゴシック体，かな文字等は明朝体で表現されるのが特徴。
IPA フォントおよび &lt;a href=&#34;https://mplus-fonts.osdn.jp/mplus-outline-fonts/&#34;&gt;M+ フォント&lt;/a&gt;がベースになっているため，ライセンスもこれらに準拠する形になっている。&lt;/p&gt;

&lt;p&gt;見出しや短文に向いている。
長文はちょっとしんどいか。
第1第2水準漢字までをサポートしており，サイズ的にも手頃といえる。&lt;/p&gt;

&lt;h3 id=&#34;もう-woff-でいいじゃない:3dfd8bd3067ce5a96224e4168b8cdcd3&#34;&gt;もう WOFF でいいじゃない&lt;/h3&gt;

&lt;p&gt;複製・再配布が自由なフォントであれば WOFF (Web Open Font Format) に変換&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3dfd8bd3067ce5a96224e4168b8cdcd3:d&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3dfd8bd3067ce5a96224e4168b8cdcd3:d&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; して Web フォントとして利用可能。
WOFF への変換には，以下のツールが使える。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://opentype.jp/woffconv.htm&#34;&gt;WOFFコンバータ&lt;/a&gt; （&lt;a href=&#34;http://opentype.jp/&#34;&gt;武蔵システム&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作成した WOFF ファイルを使って CSS 内に &lt;code&gt;@font-face&lt;/code&gt; を定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@font-face{
    font-family: &#39;aozora-m&#39;;
    src: local(&#39;AozoraMinchoMedium&#39;), url(&#39;/fonts/AozoraMinchoMedium.woff&#39;) format(&#39;woff&#39;);
    font-weight: 400;
    font-style: normal;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで定義したフォント名 &lt;code&gt;&amp;quot;aozora-m&amp;quot;&lt;/code&gt; を使って CSS に記述することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;body {
  font-family: &#39;Noto Serif&#39;, &amp;quot;aozora-m&amp;quot;, serif;
  font-weight: 400; /* normal */
  font-variant: normal;
  font-style: normal;
  font-size: medium;
  line-height: 1.4;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Web フォントの形式はいくつかあるが，少なくとも Modern browser であれば WOFF をサポートしている。
IE のことは忘れましょう（笑）&lt;/p&gt;

&lt;h2 id=&#34;その他の-web-フォント:3dfd8bd3067ce5a96224e4168b8cdcd3&#34;&gt;その他の Web フォント&lt;/h2&gt;

&lt;p&gt;Google Noto Fonts 以外で利用しているフォントを列挙しておく。&lt;/p&gt;

&lt;h3 id=&#34;font-awesome:3dfd8bd3067ce5a96224e4168b8cdcd3&#34;&gt;Font Awesome&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://fortawesome.github.io/Font-Awesome/&#34;&gt;Font Awesome, the iconic font and CSS toolkit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/FortAwesome/Font-Awesome&#34;&gt;FortAwesome/Font-Awesome&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;みんな大好き Font Awesome。
アイコンを文字として扱うことができる。
&lt;code&gt;head&lt;/code&gt; 要素に以下の記述を加える事で使えるようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使い方は簡単。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;i class=&amp;quot;fa fa-btc&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 1 ＝ &amp;lt;i class=&amp;quot;fa fa-jpy&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 31,246.5
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;i class=&#34;fa fa-btc&#34;&gt;&lt;/i&gt; 1 ＝ &lt;i class=&#34;fa fa-jpy&#34;&gt;&lt;/i&gt; 31,246.5
&lt;/blockquote&gt;

&lt;h3 id=&#34;creative-commons-icon-font:3dfd8bd3067ce5a96224e4168b8cdcd3&#34;&gt;Creative Commons Icon Font&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cc-icons.github.io/&#34;&gt;Creative Commons Icon Font&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cc-icons/cc-icons&#34;&gt;cc-icons/cc-icons&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CC License のアイコンやバナーを文字として扱うことができる。
&lt;code&gt;head&lt;/code&gt; 要素に以下の記述を加える事で使えるようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;//cdnjs.cloudflare.com/ajax/libs/cc-icons/1.2.1/css/cc-icons.min.css&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使い方は Font Awesome と同じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;i class=&amp;quot;cc cc-by cc-2x&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;amp;nbsp;&amp;lt;i class=&amp;quot;cc cc-sa cc-2x&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;i class=&#34;cc cc-by cc-2x&#34;&gt;&lt;/i&gt;&amp;nbsp;&lt;i class=&#34;cc cc-sa cc-2x&#34;&gt;&lt;/i&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;関連-するかもしれない-記事:3dfd8bd3067ce5a96224e4168b8cdcd3&#34;&gt;関連（するかもしれない）記事&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.baldanders.info/spiegel/log2/000750.shtml&#34;&gt;ちょこっと MathJax — Baldanders.info&lt;/a&gt; : MathJax で数式用の Web フォントを使用可能&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:3dfd8bd3067ce5a96224e4168b8cdcd3:a&#34;&gt;“Noto” は “No-Tofu” の意味らしい。昔はフォント・セットに該当文字がない場合に表示される「□」を「トーフ（豆腐）」と呼んでいた。つまり Noto Fonts は世界中のすべての文字を統一デザインで網羅するという壮大なプロジェクトである。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3dfd8bd3067ce5a96224e4168b8cdcd3:a&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3dfd8bd3067ce5a96224e4168b8cdcd3:aa&#34;&gt;&lt;a href=&#34;https://www.google.com/fonts/&#34;&gt;Google Fonts&lt;/a&gt; サイトでは &lt;code&gt;@import&lt;/code&gt; 文を使った書式や JavaScript による読み込みコードも例示されている。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3dfd8bd3067ce5a96224e4168b8cdcd3:aa&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3dfd8bd3067ce5a96224e4168b8cdcd3:b&#34;&gt;Modern browser では Bold や Italic がなくとも機械的に合成される（Italic は斜体（slant）で代用）。当然ながら綺麗ではない。 Bold や Italic を多用しないのであれば Web フォントから外す手はある。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3dfd8bd3067ce5a96224e4168b8cdcd3:b&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3dfd8bd3067ce5a96224e4168b8cdcd3:c&#34;&gt;「&lt;a href=&#34;http://www.gnu.org/licenses/license-list.ja.html&#34;&gt;さまざまなライセンスとそれらについての解説 - GNUプロジェクト&lt;/a&gt;」では &lt;a href=&#34;http://www.gnu.org/licenses/license-list.ja.html#IPAFONT&#34;&gt;IPA フォントライセンスは GPL とは両立しない&lt;/a&gt;とある。派生作品ではオリジナルの名前を含めてはいけない，という制限があるため。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3dfd8bd3067ce5a96224e4168b8cdcd3:c&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3dfd8bd3067ce5a96224e4168b8cdcd3:d&#34;&gt;機械的変換であれば翻案ではなく「逐語的コピー」とみなせる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3dfd8bd3067ce5a96224e4168b8cdcd3:d&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>文字エンコーディング変換 - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/transform-character-encoding/" />
		<id>tag:text.Baldanders.info,2015-09-23:/golang/transform-character-encoding/</id>
		<published>2015-09-23T20:04:00+09:00</published>
		<updated>2016-01-20T09:17:17+09:00</updated>
		<summary>文字エンコーディング変換に関してはあちこちに記事があるのだが，微妙に古い気がするので，メモとして書き記しておく。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/2e475b48226330aa5570&#34;&gt;Golang による文字エンコーディング変換 - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;文字エンコーディング変換に関してはあちこちに記事があるのだが，微妙に古い気がするので，メモとして書き記しておく。&lt;/p&gt;

&lt;h2 id=&#34;go-言語の文字エンコーディング変換:8c97bc776007d33febbab020a38c72f3&#34;&gt;Go 言語の文字エンコーディング変換&lt;/h2&gt;

&lt;p&gt;Go 言語では Unicode が既定となっている。
そもそもソースコードが UTF-8 前提になっているし，文字の単位である &lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; の実体は Unicode 符号点（code point）である&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8c97bc776007d33febbab020a38c72f3:a&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8c97bc776007d33febbab020a38c72f3:a&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;したがって UTF-8 以外の文字エンコーディングを扱う場合は何らかの変換処理を挟む必要がある。
そのためのパッケージが &lt;a href=&#34;https://godoc.org/golang.org/x/text/transform&#34; title=&#34;transform - GoDoc&#34;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; である。
また&lt;a href=&#34;https://godoc.org/golang.org/x/text/encoding&#34;&gt;エンコーディング&lt;/a&gt;についても各種そろっていて，日本語の場合は &lt;a href=&#34;https://godoc.org/golang.org/x/text/encoding/japanese&#34; title=&#34;japanese - GoDoc&#34;&gt;&lt;code&gt;encoding/japanese&lt;/code&gt;&lt;/a&gt; パッケージを使う。
&lt;a href=&#34;https://godoc.org/golang.org/x/text/encoding/japanese&#34; title=&#34;japanese - GoDoc&#34;&gt;&lt;code&gt;encoding/japanese&lt;/code&gt;&lt;/a&gt; パッケージでは Shift-JIS, EUC-JP, ISO-2202-JP を扱える。&lt;/p&gt;

&lt;h3 id=&#34;パッケージの導入:8c97bc776007d33febbab020a38c72f3&#34;&gt;パッケージの導入&lt;/h3&gt;

&lt;p&gt;日本語が必要なだけなら &lt;code&gt;golang.org/x/text/encoding/japanese&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8c97bc776007d33febbab020a38c72f3:b&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8c97bc776007d33febbab020a38c72f3:b&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; を &lt;code&gt;go get&lt;/code&gt; すれば全てインストールされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go get -v golang.org/x/text/encoding/japanese
Fetching https://golang.org/x/text/encoding/japanese?go-get=1
Parsing meta tags from https://golang.org/x/text/encoding/japanese?go-get=1 (status code 200)
get &amp;quot;golang.org/x/text/encoding/japanese&amp;quot;: found meta tag main.metaImport{Prefix:&amp;quot;golang.org/x/text&amp;quot;, VCS:&amp;quot;git&amp;quot;, RepoRoot:&amp;quot;https://go.googlesource.com/text&amp;quot;} at https://golang.org/x/text/encoding/japanese?go-get=1
get &amp;quot;golang.org/x/text/encoding/japanese&amp;quot;: verifying non-authoritative meta tag
Fetching https://golang.org/x/text?go-get=1
Parsing meta tags from https://golang.org/x/text?go-get=1 (status code 200)
golang.org/x/text (download)
golang.org/x/text/transform
golang.org/x/text/encoding/internal/identifier
golang.org/x/text/encoding
golang.org/x/text/encoding/internal
golang.org/x/text/encoding/japanese
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;変換ロジック-サンプルコード:8c97bc776007d33febbab020a38c72f3&#34;&gt;変換ロジック（サンプルコード）&lt;/h3&gt;

&lt;p&gt;変換ロジックのサンプルを以下に示す（thanks &lt;a href=&#34;http://qiita.com/mattn&#34;&gt;@mattn&lt;/a&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;golang.org/x/text/encoding/japanese&amp;quot;
	&amp;quot;golang.org/x/text/transform&amp;quot;
)

func main() {
	reader := NewDecoder(os.Stdin)
	writer := NewEncoder(os.Stdout)
	if _, err := io.Copy(writer, reader); err != nil {
		fmt.Fprintln(os.Stderr, err)
	}
}

func NewDecoder(reader io.Reader) *transform.Reader {
	return transform.NewReader(reader, japanese.ShiftJIS.NewDecoder())
}

func NewEncoder(writer io.Writer) *transform.Writer {
	return transform.NewWriter(writer, japanese.EUCJP.NewEncoder())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UTF-8 以外の文字エンコーディングから UTF-8 への変換は decode と呼ばれている。
一方， UTF-8 から UTF-8 以外の文字エンコーディングへの変換は encode と呼ばれている。&lt;/p&gt;

&lt;p&gt;上のサンプルでは Shift-JIS →（Decoder）→ UTF-8 →（Encoder）→ EUC-JP の手順で変換していることがお分かりであろうか。
では実際に動かしてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;echo Go言語で行こう | go run transform.go &amp;gt; euc.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで &lt;code&gt;euc.txt&lt;/code&gt; に「Go言語で行こう」と EUC-JP で書き込まれていたら成功である&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8c97bc776007d33febbab020a38c72f3:c&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8c97bc776007d33febbab020a38c72f3:c&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
今回は標準入出力を使ったが， Reader/Writer の stream で表せるものなら同様の処理でできるはずである。&lt;/p&gt;

&lt;h2 id=&#34;文字エンコーディング変換に関する注意点:8c97bc776007d33febbab020a38c72f3&#34;&gt;文字エンコーディング変換に関する注意点&lt;/h2&gt;

&lt;p&gt;Shift-JIS/EUC-JP と UTF-8/UTF-32 ではベースとなっている文字集合（文字エンコーディングではない）が異なる。
Shift-JIS/EUC-JP の文字集合は基本的に JIS 規格だが UTF-8/UTF-32 は Unicode であり，両者は非対称の関係である。
このため，今回のような異なる文字集合を跨ぐ変換を行うと変換が正しく行われない場合もあり得る（要検証&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8c97bc776007d33febbab020a38c72f3:d&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8c97bc776007d33febbab020a38c72f3:d&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;）。&lt;/p&gt;

&lt;p&gt;更に困ったことに，歴史的経緯（便利な言葉だw）から Shift-JIS や EUC-JP の実装にはいくつかバリエーションがあるため，実装間の差異が問題になる場合もある。
&lt;a href=&#34;https://godoc.org/golang.org/x/text/encoding/japanese&#34; title=&#34;japanese - GoDoc&#34;&gt;&lt;code&gt;encoding/japanese&lt;/code&gt;&lt;/a&gt; パッケージはこの実装上の差異を考慮してはいないようである。&lt;/p&gt;

&lt;p&gt;更に更に言えば，汎用機などは旧JIS＋外字の構成になっていることが多く，このような需要に応えるなら独自の変換ロジックを開発するしかない。&lt;/p&gt;

&lt;h3 id=&#34;変換ロジックの別解:8c97bc776007d33febbab020a38c72f3&#34;&gt;変換ロジックの別解&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/transform&#34; title=&#34;transform - GoDoc&#34;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; を使った変換でうまくいかない場合は &lt;a href=&#34;https://github.com/djimenez/iconv-go&#34; title=&#34;djimenez/iconv-go&#34;&gt;&lt;code&gt;djimenez/iconv-go&lt;/code&gt;&lt;/a&gt; パッケージを使う手もある。
ただし， &lt;a href=&#34;https://github.com/djimenez/iconv-go&#34; title=&#34;djimenez/iconv-go&#34;&gt;&lt;code&gt;djimenez/iconv-go&lt;/code&gt;&lt;/a&gt; パッケージのビルドには &lt;code&gt;libiconv&lt;/code&gt; および &lt;code&gt;glibc&lt;/code&gt; が必要である（クロス環境では注意）。
このパッケージを使うことで &lt;code&gt;iconv&lt;/code&gt; 相当の処理が可能になる。&lt;/p&gt;

&lt;p&gt;（別の変換パッケージとして &lt;a href=&#34;https://godoc.org/code.google.com/p/mahonia&#34;&gt;&lt;code&gt;mahonia&lt;/code&gt;&lt;/a&gt; を紹介しているところがいくつか見られたが，ドキュメントを見る限り DEPRECATED となっていて使えないようだ。また repository にもアクセスできない）&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:8c97bc776007d33febbab020a38c72f3&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/uchiko/items/1810ddacd23fd4d3c934&#34;&gt;golang - Go言語で文字コード変換 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ja.stackoverflow.com/questions/6120/go%E3%81%A7byte%E3%82%92shift-jis%E3%81%AE%E6%96%87%E5%AD%97%E5%88%97%E3%81%AB%E5%A4%89%E6%8F%9B%E3%81%99%E3%82%8B&#34;&gt;go - Goで[]byteをshift-jisの文字列に変換する - スタック・オーバーフロー&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/irugo/items/390bd187871c7716a1e1&#34;&gt;GO言語で文字コードを扱うライブラリの使用例 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/nobuhito/items/ff782f64e32f7ed95e43&#34;&gt;Golangで文字コード判定 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:8c97bc776007d33febbab020a38c72f3:a&#34;&gt;「&lt;a href=&#34;http://text.baldanders.info/golang/string-and-rune/&#34;&gt;String と Rune&lt;/a&gt;」参照。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8c97bc776007d33febbab020a38c72f3:a&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8c97bc776007d33febbab020a38c72f3:b&#34;&gt;かつてパッケージの場所は &lt;code&gt;code.google.com/p/go.text/transform&lt;/code&gt; および &lt;code&gt;code.google.com/p/go.text/encoding/japanese&lt;/code&gt; だったが，ここの repository は今は存在しないので注意。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8c97bc776007d33febbab020a38c72f3:b&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8c97bc776007d33febbab020a38c72f3:c&#34;&gt;もちろんこれは Windows のコマンドプロンプトで動かした場合の話。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8c97bc776007d33febbab020a38c72f3:c&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8c97bc776007d33febbab020a38c72f3:d&#34;&gt;たとえば「&lt;a href=&#34;http://qiita.com/kawasima/items/41632dbd423dc0445e14&#34;&gt;Shift_JIS文化からUTF-8への移行ガイド - Qiita&lt;/a&gt;」などが参考になる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8c97bc776007d33febbab020a38c72f3:d&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>String と Rune - golang</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/string-and-rune/" />
		<id>tag:text.Baldanders.info,2015-09-19:/golang/string-and-rune/</id>
		<published>2015-09-19T23:45:56+09:00</published>
		<updated>2016-01-20T09:18:21+09:00</updated>
		<summary>今回は文字列について。短めにさくっと。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/556166b6631c0369754f&#34;&gt;はじめての Go 言語 (on Windows) その4 - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;文字列を示す &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; は不変（immutable）なオブジェクトだが，中身は byte 配列である。
したがって以下のように&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;
	size := len(nihongo)

	fmt.Printf(&amp;quot;nihongo = %d bytes :&amp;quot;, size)
	for i := 0; i &amp;lt; size; i++ {
		fmt.Printf(&amp;quot; %x&amp;quot;, nihongo[i])
	}
	fmt.Print(&amp;quot;\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; をダンプすると以下の結果になる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:22aba2fd29e0e069728fb8201971f262:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:22aba2fd29e0e069728fb8201971f262:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run string01.go
nihongo = 9 bytes : e6 97 a5 e6 9c ac e8 aa 9e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; なんて名前なのに）文字単位で情報を保持しているわけではないため，最初の2文字を取り出すつもりでうっかり&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;

	fmt.Printf(&amp;quot;nihongo = %s\n&amp;quot;, nihongo)
	fmt.Printf(&amp;quot;nippon = %s\n&amp;quot;, nihongo[:2])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんてなコードを書くと以下の結果になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run string02.go
nihongo = 日本語
nippon = ��
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文字列を文字単位で扱うには &lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; を使う。
いや，ルーンってどんだけ厨二&amp;hellip; ゲフンゲフン。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;
	nihongoRune := []rune(nihongo)
	size := len(nihongoRune)

	fmt.Printf(&amp;quot;nihongo = %d characters : &amp;quot;, size)
	for i := 0; i &amp;lt; size; i++ {
		fmt.Printf(&amp;quot;%#U &amp;quot;, nihongoRune[i])
	}
	fmt.Printf(&amp;quot;\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:&amp;gt;go run string03.go
nihongo = 3 characters : U+65E5 &#39;日&#39; U+672C &#39;本&#39; U+8A9E &#39;語&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;または， &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; に対して &lt;a href=&#34;http://golang.org/ref/spec#For_statements&#34;&gt;for range 構文&lt;/a&gt;を使ってループを回すと文字（&lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt;）単位で取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;

	for pos, runeValue := range nihongo {
		fmt.Printf(&amp;quot;%#U starts at byte position %d\n&amp;quot;, runeValue, pos)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:&amp;gt;go run string03b.go
U+65E5 &#39;日&#39; starts at byte position 0
U+672C &#39;本&#39; starts at byte position 3
U+8A9E &#39;語&#39; starts at byte position 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; の実体は int32 で，内部表現は Unicode の符号点（code point）になっている。
&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; と &lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; 配列は相互変換できるので，文字列を切り取る場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	nihongo := &amp;quot;日本語&amp;quot;

	fmt.Printf(&amp;quot;nihongo = %s\n&amp;quot;, nihongo)
	fmt.Printf(&amp;quot;nippon = %s\n&amp;quot;, string([]rune(nihongo)[:2]))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; → []&lt;a href=&#34;http://blog.golang.org/strings&#34; title=&#34;Strings, bytes, runes and characters in Go - The Go Blog&#34;&gt;rune&lt;/a&gt; → &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; と変換していけば安全に処理できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt;go run string02b.go
nihongo = 日本語
nippon = 日本
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう少し細かい処理が必要なら &lt;a href=&#34;http://golang.org/pkg/unicode/utf8/&#34;&gt;&lt;code&gt;unicode/utf8&lt;/code&gt;&lt;/a&gt; パッケージを使う手もある&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:22aba2fd29e0e069728fb8201971f262:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:22aba2fd29e0e069728fb8201971f262:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:22aba2fd29e0e069728fb8201971f262&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.golang.org/strings&#34;&gt;Strings, bytes, runes and characters in Go - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://knightso.hateblo.jp/entry/2014/06/24/090719&#34;&gt;Go言語のstring, runeの正体とは？ - golang - The Round&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/hokaccha/items/3d3f45b5927b4584dbac&#34;&gt;Goでマルチバイトが混在した文字列をtruncateする - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/masakielastic/items/01a4fb691c572dd71a19&#34;&gt;Go で UTF-8 の文字列を扱う - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:22aba2fd29e0e069728fb8201971f262:1&#34;&gt;ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で取り扱う文字列の文字エンコーディングは UTF-8 が既定である。他の文字エンコーディングで書かれた文字列を扱うには，一度 UTF-8 に変換する処理が必要になる。文字エンコーディングの変換については&lt;a href=&#34;http://text.baldanders.info/golang/transform-character-encoding/&#34;&gt;別の記事&lt;/a&gt;で改めて紹介する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:22aba2fd29e0e069728fb8201971f262:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:22aba2fd29e0e069728fb8201971f262:2&#34;&gt;ちなみに &lt;a href=&#34;http://golang.org/pkg/strings/&#34;&gt;&lt;code&gt;strings&lt;/code&gt;&lt;/a&gt; パッケージは内部で &lt;a href=&#34;http://golang.org/pkg/unicode/utf8/&#34;&gt;&lt;code&gt;unicode/utf8&lt;/code&gt;&lt;/a&gt; パッケージを使っているようだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:22aba2fd29e0e069728fb8201971f262:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
</feed>
