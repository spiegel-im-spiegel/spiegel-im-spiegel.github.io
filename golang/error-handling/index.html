<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Hugo 0.16" />
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel='stylesheet' href='//fonts.googleapis.com/css?family=Noto+Serif%7cNoto+Sans%3a400,700%7cInconsolata%3a400,700' type='text/css'>
<link rel='stylesheet' href='//fonts.googleapis.com/earlyaccess/notosansjapanese.css' type='text/css'>
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/cc-icons/1.2.1/css/cc-icons.min.css">
<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/text-baldanders.css">
<link rel="alternate" href="http://text.baldanders.info/index.xml" type="application/rss+xml" title="text.Baldanders.info">
<meta name="google-site-verification" content="jTjBCslPtf8gwVatiY-GDgGv7pV5csa8aUOw1MRPUD4">
<link rel="stylesheet" href="/fonts/ipa-aozora.css">
<link rel="stylesheet" href="/css/addon.css">
<link rel="stylesheet" href="/highlightjs/styles/github.css">
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;locale=ja"></script>
<script>
  MathJax.Hub.Config({
    TeX: {
      extensions: ["autoload-all.js"],
      equationNumbers: { autoNumber: "all" }
    },
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    },
    "HTML-CSS": {
      matchFontHeight: false,
      preferredFont: null,
      webFont: "TeX"
    },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>
<title>エラー・ハンドリングについて（追記あり） — プログラミング言語 Go | text.Baldanders.info</title>
<meta name="description" content="C&#43;&#43; や Java のような言語圏から来た（私のような）人間にとって Go 言語の「オブジェクト指向」はかなり異質なのだが，慣れてみると逆にとても合理的に見えてくる。この最たるものが error 型である。（追記あり）">
<meta name="author" content="Spiegel">
<meta name="keywords" content="golang,error,exception,panic,interface">
<link rel='prev' href='http://text.baldanders.info/golang/gopath-pollution/' title='GOPATH 汚染問題' />
<link rel='next' href='http://text.baldanders.info/golang/package-visualization-tool/' title='パッケージの依存状況の視覚化' />
</head>
<body>

<div id='container'>
<header>
<div id="sitetitle"><a href="http://text.baldanders.info/">text.Baldanders.info</a> <a href='/index.xml' title='Feed'><i class='fa fa-rss'></i></a></div>
<p>帰ってきた「しっぽのさきっちょ」</p>
</header>


<main>
<article itemscope itemtype='http://schema.org/BlogPosting' itemref='maker'>
<h1 itemprop='name'>エラー・ハンドリングについて（追記あり） — <a href="/golang">プログラミング言語 Go</a></h1>
<nav class="tags">
<div><a href="/tags">Tags</a>: #<a href="/tags/error">error</a> #<a href="/tags/exception">exception</a> #<a href="/tags/golang">golang</a> #<a href="/tags/interface">interface</a> #<a href="/tags/panic">panic</a></div>
<div><a href="https://github.com/spiegel-im-spiegel/spiegel-im-spiegel.github.io/commits/master/golang/error-handling/index.html">History</a></div>
</nav>

<section>


<p>C++ や Java のような言語圏から来た（私のような）人間にとって <a href="https://golang.org/" title="The Go Programming Language">Go 言語</a>の「オブジェクト指向」はかなり異質なのだが，慣れてみると逆にとても合理的に見えてくる。
なんで C++ や Java はこのようなアプローチをとらなかったのか不思議なほどである。</p>

<p>この最たるものがエラー・ハンドリングだ。</p>

<h2 id="go-言語には-例外-がない">Go 言語には「例外」がない</h2>

<p>「例外（exception）」は本来の処理の流れをぶった切って「大域脱出」するための仕組みである。
でも考えてみれば例外というのはかなり微妙な言語仕様だ。</p>

<p>例外が抱える問題というのは本質的に <code>goto</code> 文の問題と同じ<sup class="footnote-ref" id="fnref:aa"><a rel="footnote" href="#fn:aa">1</a></sup>。
オブジェクトの状態ごと脱出するため，（脱出前ではなく）脱出後にオブジェクトの後始末を記述せざるを得ないし，記述するためには脱出前の状態（の可能性）を「知識」として知っていなければならない<sup class="footnote-ref" id="fnref:a"><a rel="footnote" href="#fn:a">2</a></sup>。
もし後始末をきちんとしないと，それがバグやリークやその他の脆弱性のもとになる。</p>

<p><a href="https://golang.org/" title="The Go Programming Language">Go 言語</a>はそんな面倒くさいことは考えない。
どうするかというと，普通に返り値に <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> を返す。</p>

<pre><code class="language-go">file, err := os.Open(filename)
</code></pre>

<p><a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> は無視することもできる<sup class="footnote-ref" id="fnref:0"><a rel="footnote" href="#fn:0">3</a></sup>。</p>

<pre><code class="language-go">file, _ := os.Open(filename)
</code></pre>

<p>検出した <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> はその場で処理して抜けてしまえばよい。</p>

<pre><code class="language-go">file, err := os.Open(filename)
if err != nil {
    fmt.Fprintln(os.Stderr, err)
    return false
}
</code></pre>

<p>開始処理と終了（後始末）処理が対になっている場合（<code>Open</code>/<code>Close</code> とは限らない）は <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Defer</a> 構文で終了処理を保証する<sup class="footnote-ref" id="fnref:c"><a rel="footnote" href="#fn:c">4</a></sup>。</p>

<pre><code class="language-go">file, err := os.Open(filename)
if err != nil {
    fmt.Fprintln(os.Stderr, err)
    return false
}
defer file.Close()
</code></pre>

<p>これが <a href="https://golang.org/" title="The Go Programming Language">Go 言語</a>の基本的な書き方。
特徴的なのは，ある処理に纏わる処理をセットで記述できる点である。
<code>try</code> と <code>catch</code> と <code>finally</code> の間で目線を行ったり来たりさせなくても，「そこ」だけを見れば把握できる。
ある意味でとても文芸的なコード<sup class="footnote-ref" id="fnref:b"><a rel="footnote" href="#fn:b">5</a></sup> であると言える<sup class="footnote-ref" id="fnref:bb"><a rel="footnote" href="#fn:bb">6</a></sup>。</p>

<h2 id="error">error</h2>

<p>ここで <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> について改めて説明しておく。
<a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> は以下の形式で表現できる <a href="https://golang.org/doc/effective_go.html#interfaces_and_types" title="Effective Go - The Go Programming Language">interface</a> 型のひとつである<sup class="footnote-ref" id="fnref:d"><a rel="footnote" href="#fn:d">7</a></sup>。</p>

<pre><code class="language-go">// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
type error interface {
	Error() string
}
</code></pre>

<p>つまり <code>Error()</code> 関数を持つオブジェクトなら <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> として使える。
これのいちばん簡単な実装が <a href="https://golang.org/pkg/errors/" title="errors - The Go Programming Language"><code>errors</code></a> パッケージである。
<a href="https://golang.org/pkg/errors/" title="errors - The Go Programming Language"><code>errors</code></a> パッケージの中身は以下のようになっている。</p>

<pre><code class="language-go">package errors

// New returns an error that formats as the given text.
func New(text string) error {
	return &amp;errorString{text}
}

// errorString is a trivial implementation of error.
type errorString struct {
	s string
}

func (e *errorString) Error() string {
	return e.s
}
</code></pre>

<p>これは実体として <a href="http://golang.org/ref/spec#String_types">string</a> 型の property がひとつだけあって <code>Error()</code> 関数で property をそのまま返すというものだ。
<a href="https://golang.org/" title="The Go Programming Language">Go 言語</a>の標準パッケージの多くはこの <a href="https://golang.org/pkg/errors/" title="errors - The Go Programming Language"><code>errors</code></a> パッケージを使って <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> を定義している。
たとえば <a href="https://golang.org/pkg/os/" title="os - The Go Programming Language"><code>os</code></a> パッケージの最下位の <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> は以下のように定義されている。</p>

<pre><code class="language-go">package os

import (
	&quot;errors&quot;
)

// Portable analogs of some common system call errors.
var (
	ErrInvalid    = errors.New(&quot;invalid argument&quot;)
	ErrPermission = errors.New(&quot;permission denied&quot;)
	ErrExist      = errors.New(&quot;file already exists&quot;)
	ErrNotExist   = errors.New(&quot;file does not exist&quot;)
)
</code></pre>

<p>もう少し複雑な <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> では，以下のように詳細情報を持つものもある。</p>

<pre><code class="language-go">// PathError records an error and the operation and file path that caused it.
type PathError struct {
	Op   string
	Path string
	Err  error
}

func (e *PathError) Error() string { return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error() }
</code></pre>

<h2 id="3つのエラー-ハンドリング">3つのエラー・ハンドリング</h2>

<p><a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> を判別する方法としては以下の3つがある。</p>

<ol>
<li><a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> インスタンスを比較する</li>
<li><a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> の型を判別する</li>
<li><code>Error()</code> 関数で出力される文字列を解釈する</li>
</ol>

<h3 id="インスタンスを比較する">インスタンスを比較する</h3>

<p>あらかじめ定義済みの <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> インスタンスがあれば，インスタンスの比較で判別できる。</p>

<pre><code class="language-go">if err != nil {
    switch err {
    case os.ErrInvalid:
        fmt.Fprintln(os.Stderr, &quot;引数が不正&quot;)
    case os.ErrPermission:
        fmt.Fprintln(os.Stderr, &quot;アクセスは許可できない&quot;)
    case os.ErrExist:
        fmt.Fprintln(os.Stderr, &quot;そのファイルは既にある&quot;)
    case os.ErrNotExist:
        fmt.Fprintln(os.Stderr, &quot;ファイルが存在しない&quot;)
    default:
        fmt.Fprintln(os.Stderr, err)
    }
    return
}
</code></pre>

<p>単純にエラーの種類が分かればいいのであれば，この方法が最もシンプル。</p>

<h3 id="型を判別する">型を判別する</h3>

<p><a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> は <a href="https://golang.org/doc/effective_go.html#interfaces_and_types" title="Effective Go - The Go Programming Language">interface</a> 型なので <a href="https://golang.org/ref/spec#Conversions" title="The Go Programming Language Specification - The Go Programming Language">Conversion</a> 構文で判別できる。</p>

<pre><code class="language-go">if err != nil {
    switch e := err.(type) {
    case *os.PathError:
        if errno, ok := e.Err.(syscall.Errno); ok {
            switch errno {
            case syscall.ENOENT:
                fmt.Fprintln(os.Stderr, &quot;ファイルが存在しない&quot;)
            case syscall.ENOTDIR:
                fmt.Fprintln(os.Stderr, &quot;ディレクトリが存在しない&quot;)
            default:
                fmt.Fprintln(os.Stderr, &quot;Errno =&quot;, errno)
            }
        } else {
            fmt.Fprintln(os.Stderr, &quot;その他の PathError&quot;)
        }
    default:
        fmt.Fprintln(os.Stderr, &quot;その他のエラー&quot;)
    }
    return
}
</code></pre>

<p><a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> に状態（status）を持たせる必要がある場合は，この方法を使うべき。</p>

<h3 id="文字列を比較する">文字列を比較する</h3>

<p>上述の方法で判別できない場合は <code>Error()</code> 関数で出力される文字列を解釈して処理するしかない。
<a href="http://0xcc.net/misc/bad-knowhow.html">バッドノウハウ</a>。</p>

<h2 id="エラー-ハンドリングの設計">エラー・ハンドリングの設計</h2>

<p>エラー・ハンドリングの方針としては，以下の2つのうちのどちらかだろう。</p>

<ol>
<li><a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> を下位ロジックから上位ロジックまで持ち回し，最上位ロジックで最終的な判定と処理を行う</li>
<li>下位ロジックの <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> をカプセル化した新たなインスタンスを生成し上位ロジックに渡す。上位ロジックは直近のロジックの <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> のみが見える</li>
</ol>

<p>最初のやり方は一見よさげだが，この方針では上位ロジックが下位ロジックの全ての <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> を把握している必要があり現実的でない。
またオブジェクト指向設計では “Don&rsquo;t talk to strangers” の原則があり，いわゆる「友達の友達」のことは知らないふりをするのがよい設計と言われている。</p>

<p>こう考えると文字列での比較は最も下策であると言える。
また，型を判別する場合でも，下位レイヤの状態を生のまま見せるのではなく，必要な情報のみを返す関数を実装するほうが上策と言えるだろう。</p>

<p>もうひとつ考慮すべき点としてエラー・メッセージの設計が挙げられるだろう。
<a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> に対するメッセージをどのように設計するかは（大規模アプリケーションでは特に）重要である。</p>

<h2 id="追記-panic-と-recover">【追記】 Panic と Recover</h2>

<p>たとえばゼロ除算を行った場合や配列などで領域外を参照・設定しようとした場合，あるいは allocation に失敗した場合など，致命的なエラーが発生する場合がある。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	f()
}

func f() {
	numbers := []int{0, 1, 2}

	fmt.Println(numbers[3])
}
</code></pre>

<p>これを実行すると</p>

<pre><code class="language-bash">C:\workspace\go-practice\src\panic01&gt;go run panic01.go
panic: runtime error: index out of range

goroutine 1 [running]:
main.f()
        C:/workspace/go-practice/src/panic01/panic01.go:12 +0x14a
main.main()
        C:/workspace/go-practice/src/panic01/panic01.go:6 +0x1b
exit status 2
</code></pre>

<p>となり，大域脱出させてアプリケーションを強制終了させているのが分かる。
この仕組みを <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Panic</a> と呼ぶ。</p>

<p><a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Panic</a> は意図的に発生させることもできる。</p>

<pre><code class="language-go">package main

func main() {
	f()
}

func f() {
	panic(&quot;Panic!&quot;)
}
</code></pre>

<p>これを実行すると</p>

<pre><code class="language-bash">C:\workspace\go-practice\src\panic02&gt;go run panic02.go
panic: Panic!

goroutine 1 [running]:
main.f()
        C:/workspace/go-practice/src/panic02/panic02.go:8 +0x6c
main.main()
        C:/workspace/go-practice/src/panic02/panic02.go:4 +0x1b
exit status 2
</code></pre>

<p>となる。</p>

<p>一方で， <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Panic</a> を <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Recover</a> することもできる<sup class="footnote-ref" id="fnref:e"><a rel="footnote" href="#fn:e">8</a></sup>。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	err := r()
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(&quot;Normal End.&quot;)
	}
}

func r() (err error) {
	defer func() {
		if rec := recover(); rec != nil {
			err = fmt.Errorf(&quot;Recovered from: %v&quot;, rec)
		}
	}()

	f()
	err = nil
	return
}

func f() {
	panic(&quot;Panic!&quot;)
}
</code></pre>

<p>これを実行すると</p>

<pre><code class="language-bash">C:\workspace\go-practice\src\panic03&gt;go run panic03.go
Recovered from: Panic!
</code></pre>

<p>となる。
<a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Panic</a> を <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Recover</a> で捕まえて通常の <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> として返しているのがお分かりだろうか。</p>

<p>一般的に <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Panic</a> はアプリケーション内で続行不可能な致命的エラーが発生した場合に投げられる。
例えばゼロ除算や領域外アクセスのようなエラーは <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Panic</a> が発生する前に回避するコードにすべきだ。
Allocation エラーのような回避不能かつアプリケーション続行不可能なエラーの場合は <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Panic</a> が投げられるのもやむを得ないが， <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Recover</a> することにほとんど意味はない。</p>

<p>例外的な使い方として <a href="https://golang.org/pkg/bytes/" title="bytes - The Go Programming Language"><code>bytes</code></a>.<code>Buffer</code> では，メモリ確保で panic が発生した際に <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Recover</a> で捕まえ， <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> インスタンスを入れ替えて <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Panic</a> を投げ直している。
このような用途で <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Recover</a> を使うことはあり得る。</p>

<pre><code class="language-go">// makeSlice allocates a slice of size n. If the allocation fails, it panics
// with ErrTooLarge.
func makeSlice(n int) []byte {
	// If the make fails, give a known error.
	defer func() {
		if recover() != nil {
			panic(ErrTooLarge)
		}
	}()
	return make([]byte, n)
}
</code></pre>

<p>また再帰処理中に続行不能なエラーが発生した場合に <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Panic</a> を投げてトップレベルの関数に一気に復帰するような使い方をすることもある。
この場合，トップレベルの関数は（続行不可能なら）改めて <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Panic</a> を投げるか（処理続行できる根拠があるのなら）通常の <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> を返すことになる<sup class="footnote-ref" id="fnref:f"><a rel="footnote" href="#fn:f">9</a></sup>。</p>

<p>いずれにしろ，いわゆる「例外処理」的なハンドリングを <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Panic</a>/<a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Recover</a> で行うべきではない。</p>

<h2 id="追記-error-の-nil-が-nil-にならない場合">【追記】 error の nil が nil にならない場合</h2>

<ul>
<li><a href="https://medium.com/@tucnak/why-go-is-a-poorly-designed-language-1cc04e5daf2#.ucutrogyz">Why Go is a poorly designed language — Medium</a> （<a href="http://postd.cc/why-go-is-a-poorly-designed-language/">日本語訳</a>）</li>
</ul>

<figure style='margin:0 auto;'>
<script src="https://gist.github.com/tucnak/eccdb53e7884084f5674.js"></script>
</figure>

<p>このコードの実行結果は “Hello, Mr. Pike!” を出力する。
このコードのポイントは <code>Generate()</code> 関数が <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> ではなく <code>*MagicError</code> 型を返している点にある。</p>

<p>実は <a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> を含む <a href="https://golang.org/doc/effective_go.html#interfaces_and_types" title="Effective Go - The Go Programming Language">interface</a> 型のインスタンスは値（への参照）と型情報をセットで保持っているため，上述のような形で nil を返しても受け取った側は「nil 状態を持つなにか」という評価になり，完全な nil にはならないのだ。
たとえば上のコードを以下のように書き換えると分かりやすいかもしれない。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type MagicError struct{}

func (m *MagicError) Error() string {
    return fmt.Sprintf(&quot;%#v&quot;, m)
}

func Generate() *MagicError {
	return nil
}

func Test() error {
	return Generate()
}

func main() {
	if err := Test(); err != nil {
		fmt.Println(err)
	}
}
</code></pre>

<p>このコードを実行すると “(*main.MagicError)(nil)” と出力する。
<code>Generate()</code> 関数が返す nil がどのように機能しているか分かると思う。
「<a href="/golang/object-oriented-programming/">Go 言語における「オブジェクト」</a>」で解説するが， <a href="https://golang.org/" title="The Go Programming Language">Go 言語</a>の型（<a href="https://golang.org/ref/spec#Properties_of_types_and_values" title="Properties of types and values">type</a>）は C++ や Java で言うところの class のように機能するため，このような動きになると思われる<sup class="footnote-ref" id="fnref:nil"><a rel="footnote" href="#fn:nil">10</a></sup>。</p>

<p>エラーハンドリングを行う際は結構ここがハマりどころになる。
ご注意を。</p>

<h2 id="ブックマーク">ブックマーク</h2>

<ul>
<li><a href="http://www.kaoriya.net/blog/2014/04/17/">または私は如何にして例外するのを止めて golang を愛するようになったか — KaoriYa</a></li>
<li><a href="http://mattn.kaoriya.net/software/lang/go/20140416212413.htm">Big Sky :: golang で複数のエラーをハンドリングする方法</a></li>
<li><a href="http://dsas.blog.klab.org/archives/go-errors.html">DSAS開発者の部屋:Go ではエラーを文字列比較する？という話について</a></li>
<li><a href="http://qiita.com/ruiu/items/ff98ded599d97cf6646e">panicはともかくrecoverに使いどころはほとんどない - Qiita</a></li>
<li><a href="http://qiita.com/stsn/items/73714caf8458b1d973f2">Golang: nil Pointer Receiverの話 - Qiita</a></li>
<li><a href="http://qiita.com/tienlen/items/5f2bcfe06eb83830ee55">echoのAPIサーバ実装とエラーハンドリングの落とし穴 - Qiita</a></li>
</ul>

<p><a href="http://text.baldanders.info/golang/bookmark/">Go 言語に関するブックマーク集はこちら</a>。</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:aa">ちなみに <a href="https://golang.org/" title="The Go Programming Language">Go 言語</a>の <code>goto</code> や ラベル付きの <code>break</code>, <code>continue</code> は<a href="https://golang.org/test/goto.go">飛び先に制約</a>があり，どこにでもジャンプできるわけではない。
 <a class="footnote-return" href="#fnref:aa"><sup>[return]</sup></a></li>
<li id="fn:a">例外を備える言語でこれを緩和する仕様はいくつかある。例えば Java は 1.7 から <a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">try-with-resources 構文</a>を導入した。もちろんこの構文を有効にするためには対象となるオブジェクトがこの構文に対応した作りになっていなければならない。
 <a class="footnote-return" href="#fnref:a"><sup>[return]</sup></a></li>
<li id="fn:0">いや，ファイル・オープンのエラーを無視したらダメです（笑）
 <a class="footnote-return" href="#fnref:0"><sup>[return]</sup></a></li>
<li id="fn:c"><a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Defer</a> 構文で指定された処理は <code>return</code> 時に起動することが保証される。したがって，エラー発生時にはその都度 <code>return</code> で抜けて問題ない。むしろ <code>goto</code> や <code>break</code> で強制的に処理を抜けるよりは処理を分割して <code>return</code> で安全に処理を抜ける方法がないか検討すべきである。なお <code>os.Exit()</code> などで強制終了した場合は， <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Defer</a> 構文で指定した処理は起動しないので注意。
 <a class="footnote-return" href="#fnref:c"><sup>[return]</sup></a></li>
<li id="fn:b">いわゆる「文芸的プログラミング」とは異なるけど。紛らわしくてゴメン。
 <a class="footnote-return" href="#fnref:b"><sup>[return]</sup></a></li>
<li id="fn:bb">これからのコードは「文芸的」であることが必要条件だと思う。何故ならエンジニアにとって最も信頼できる「設計書」は（動いている）コードだからだ。コードをひとりで考えてひとりで書いてひとりで使ってひとりでメンテナンスするなら（本人さえ理解していれば）文芸的である必要はないかもしれない。が，実用的なコードでそんな状況はもはやありえない。コードにおいても暗黙知をできるだけ排除していくことが重要。
 <a class="footnote-return" href="#fnref:bb"><sup>[return]</sup></a></li>
<li id="fn:d"><a href="http://blog.golang.org/error-handling-and-go" title="Error handling and Go - The Go Blog">error</a> は組み込み型。組み込み型や組み込み関数（<code>append()</code> とか）は <a href="https://golang.org/pkg/builtin/" title="builtin - The Go Programming Language"><code>builtin</code></a> パッケージに定義が記述されているが，実際にこのパッケージを import して使うわけではない。
 <a class="footnote-return" href="#fnref:d"><sup>[return]</sup></a></li>
<li id="fn:e"><a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Recover</a> は <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Defer</a> 構文とともに使用する。つまり <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Panic</a> 発生時でも <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Defer</a> 構文で予約された処理は実行される。
 <a class="footnote-return" href="#fnref:e"><sup>[return]</sup></a></li>
<li id="fn:f">これ以外にサーバ用途などでプロセスを落とせない場合に <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">Recover</a> で回避することもあるが，既に続行不可能な状態で無理やりプロセスを続行するのが正しい動きなのかどうかは疑問が残る。
 <a class="footnote-return" href="#fnref:f"><sup>[return]</sup></a></li>
<li id="fn:nil">それでもやっぱり nil は nil として扱ってほしいのだが。
 <a class="footnote-return" href="#fnref:nil"><sup>[return]</sup></a></li>
</ol>
</div>

</section>

</article>
</main>
<nav class="page-nav">
<div class="prev-page">&laquo; <a href="/golang/gopath-pollution/">GOPATH 汚染問題</a></div>
<div class="next-page"><a href="/golang/package-visualization-tool/">パッケージの依存状況の視覚化</a> &raquo;</div>
</nav>

<aside id='tech-terms'>
<style scoped>
#tech-terms h1 {
  border: solid thin gray;
  margin: 0 0 1rem 0;
  padding: 0 0.5rem 2px 2px;
}
</style>
<h1>Technical Terms</h1>
<div class="cloud" style="font-size:smaller;">
<script type="text/javascript" src="http://e-words.jp/embed.x?e=utf8"></script>
<p class="right">Powered by <a href="hhttp://e-words.jp/p/s-embed.html">e-Words</a></p>
</div>
</aside>
<aside id='feedback'>
<style scoped>
#feedback h1 {
  border: solid thin gray;
  margin: 0 0 1rem 0;
  padding: 0 0.5rem 2px 2px;
}
</style>
<h1>Feedback</h1>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'textbaldandersinfo';
    var disqus_identifier = 'http:\/\/text.baldanders.info\/golang\/error-handling\/';
    var disqus_title = 'エラー・ハンドリングについて（追記あり）';
    var disqus_url = 'http:\/\/text.baldanders.info\/golang\/error-handling\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</aside>

<footer>

	<div class="userinfo">
		<div class="userinfo-avater">
			
				<a href="http://www.baldanders.info/spiegel/profile/"><img src="/images/avatar.jpg" width="48" height="48" alt="avatar"></a>
			
		</div>
		<div class="userinfo-info" id="maker" itemprop='author' itemscope itemtype='http://schema.org/Person'>
			
				Written by <a href="http://www.baldanders.info/spiegel/profile/" rel="cc:attributionURL" property="cc:attributionName" itemprop='name'>Spiegel</a> in <time property='dc:dateCopyrighted'>2015-09-30</time> (revised in <time property='dc:modified'>2016-05-06</time>).
				
	<a rel='cc:license' href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><i class="cc cc-by"></i>&nbsp;<i class="cc cc-sa"></i></a>


			
			
	<ul class="social">
		<li><a href="https://github.com/spiegel-im-spiegel" target="_blank"><i class="fa fa-github"></i></a></li>
		<li><a href="https://twitter.com/spiegel_2007" target="_blank"><i class="fa fa-twitter"></i></a></li>
		<li><a href="https://medium.com/@spiegel" target="_blank"><i class="fa fa-medium"></i></a></li>
		
		<li><a href="http://instagram.com/spiegel_2007" target="_blank"><i class="fa fa-instagram"></i></a></li>
		
		<li><a href="https://www.facebook.com/spiegel.im.spiegel" target="_blank"><i class="fa fa-facebook"></i></a></li>
		<li><a href="https://jp.linkedin.com/in/spiegelimspiegel" target="_blank"><i class="fa fa-linkedin"></i></a></li>
		
	</ul>
	<ul class="social">
		<li><a href="http://www.facebook.com/share.php?u=http%3a%2f%2ftext.baldanders.info%2fgolang%2ferror-handling%2f" rel=”nofollow” target="_blank"><i class="fa fa-facebook-square fa-2x" aria-hidden="true"></i></a></li>
		<li><a href="http://twitter.com/share?text=%e3%82%a8%e3%83%a9%e3%83%bc%e3%83%bb%e3%83%8f%e3%83%b3%e3%83%89%e3%83%aa%e3%83%b3%e3%82%b0%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6%ef%bc%88%e8%bf%bd%e8%a8%98%e3%81%82%e3%82%8a%ef%bc%89&amp;url=http%3a%2f%2ftext.baldanders.info%2fgolang%2ferror-handling%2f" rel=”nofollow” target="_blank"><i class="fa fa-twitter-square fa-2x" aria-hidden="true"></i></a></li>
		<li><a href="https://flattr.com/submit/auto?user_id=spiegel&amp;url=http%3a%2f%2ftext.baldanders.info%2fgolang%2ferror-handling%2f&amp;title=%e3%82%a8%e3%83%a9%e3%83%bc%e3%83%bb%e3%83%8f%e3%83%b3%e3%83%89%e3%83%aa%e3%83%b3%e3%82%b0%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6%ef%bc%88%e8%bf%bd%e8%a8%98%e3%81%82%e3%82%8a%ef%bc%89" target="_blank"><img src="//button.flattr.com/flattr-badge-large.png" alt="Flattr this" title="Flattr this"></a></li>
	</ul>


		</div>
	</div>

<nav>
<ul class='cloud center'>
<li><a href='http://www.baldanders.info/'>Baldanders.info</a></li>
<li><a href='https://github.com/spiegel-im-spiegel/spiegel-im-spiegel.github.io'>Repository</a></li>
<li><a href='/reviews/'>Reviews</a></li>
<li><a href='/site-policy/'>Site Policy</a></li>
<li><a href='https://validator.w3.org/nu/?doc=http%3a%2f%2ftext.baldanders.info%2fgolang%2ferror-handling%2f&amp;showoutline=yes'>Debug</a></li>
</ul>
<ul class='cloud center'>
<li>Powered by <a href='http://gohugo.io/'>Hugo 0.16</a> and <a href="https://github.com/spiegel-im-spiegel/hugo-theme-text">Text</a>.</li>
</ul>
</nav>

</footer>

</div>
<script src="/highlightjs/highlight.pack.js"></script>
<script>
  hljs.configure({
    tabReplace: "    ",	
  });
  hljs.initHighlightingOnLoad();
</script>

</body>
</html>

