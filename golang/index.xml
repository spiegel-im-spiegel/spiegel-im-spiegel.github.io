<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:cc="http://web.resource.org/cc/">
	<title>プログラミング言語 Go — text.Baldanders.info</title>
	<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/index.xml" />
	<link rel="self" type="application/atom+xml" href="http://text.baldanders.info/golang/index.xml/index.xml" />
	<id>tag:text.Baldanders.info,2016-11-20:/hugo</id>
	<updated>2016-11-20T23:33:55+09:00</updated>
	<subtitle>帰ってきた「しっぽのさきっちょ」</subtitle>
	<icon>http://text.baldanders.info//images/avatar.jpg</icon>
	<logo>http://text.baldanders.info//images/avatar.jpg</logo>
	<generator uri="http://gohugo.io/">Hugo 0.18.1</generator>

	
	<entry>
		<title>モンテカルロ法による円周率の推定（その4 PRNG） — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/estimate-of-pi-4-prng/" />
		<id>tag:text.Baldanders.info,2016-11-20:/golang/estimate-of-pi-4-prng/</id>
		<published>2016-11-20T23:33:55+09:00</published>
		<updated>2016-11-22T10:08:25+09:00</updated>
		<summary>math/rand パッケージでは rand.Source interface を持つ別の擬似乱数生成器を使うことができる。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi/&#34;&gt;モンテカルロ法による円周率の推定（その1）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-2-cli/&#34;&gt;モンテカルロ法による円周率の推定（その2 CLI）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-3-gaussian/&#34;&gt;モンテカルロ法による円周率の推定（その3 Gaussian）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-4-prng/&#34;&gt;モンテカルロ法による円周率の推定（その4 PRNG）&lt;/a&gt; ← イマココ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;「モンテカルロ法による円周率の推定」もひととおり終わったので，今回は擬似乱数生成器（pseudo random number generator）の話。&lt;/p&gt;

&lt;h2 id=&#34;math-rand-の擬似乱数生成器&#34;&gt;math/rand の擬似乱数生成器&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では &lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; パッケージで擬似乱数を取り扱えることは「&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi/&#34; title=&#34;モンテカルロ法による円周率の推定（その1）&#34;&gt;その1&lt;/a&gt;」で紹介した通り。
&lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; パッケージに実装されている擬似乱数生成器はラグ付フィボナッチ法（Lagged Fibonacci Generator）のバリエーションらしい。&lt;/p&gt;

&lt;figure lang=&#34;en&#34;&gt;
&lt;blockquote&gt;
&lt;q&gt;If I am not mistaken again, the generator is an ALFG (Additive Lagged Fibonacci Generator, thats what Wikipedia calls it). Knuth describes the algorithm in Volume 2 of The art of computer programming in section 3.2.2 (around equation 7). Both Wikipedia and Knuth state the parameter combination 607,273 as possible combination with a period length of 2^(e-1)*(2^607-1) where e is the length of the random number in bits.&lt;br&gt;
I actually found a few references examining its properties and it seems to be a good rng so faar, but there is still seems to be a lack of mathematical background and it is fairly easy to get into trouble by not seeding properly.&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-nuts/RZ1G3_cxMcM&#34;&gt;[Announce] A rand package for high quality 64bit random numbers (possibly go2)&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;ラグ付フィボナッチ法は&lt;a href=&#34;#lcg&#34;&gt;線形合同法（後述）&lt;/a&gt;を改善することを目的としたものでフィボナッチ数の生成法を元にしている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Lagged_Fibonacci_generator&#34;&gt;Lagged Fibonacci generator - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ラグ付フィボナッチ法は以下の式で表される。&lt;/p&gt;

&lt;figure&gt;
&lt;blockquote&gt;
\[ \begin{array}{ll}
S_{n} \equiv S_{n-j} * S_{n-k} \pmod{m}, &amp; 0 \lt j \lt k
\end{array} \]
&lt;/blockquote&gt;

&lt;/figure&gt;

&lt;p&gt;ラグ付フィボナッチ法は $*$ 演算子によってバリエーションがあるが &lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; パッケージの実装では加算を使うため “&lt;strong&gt;Additive&lt;/strong&gt; Lagged Fibonacci Generator” ということらしい。
ソースコードで言うとこの部分かな。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Int63 returns a non-negative pseudo-random 63-bit integer as an int64.
func (rng *rngSource) Int63() int64 {
	rng.tap--
	if rng.tap &amp;lt; 0 {
		rng.tap += _LEN
	}

	rng.feed--
	if rng.feed &amp;lt; 0 {
		rng.feed += _LEN
	}

	x := (rng.vec[rng.feed] + rng.vec[rng.tap]) &amp;amp; _MASK
	rng.vec[rng.feed] = x
	return x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;擬似乱数生成器のバリエーション&#34;&gt;擬似乱数生成器のバリエーション&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; パッケージでは以下の &lt;a href=&#34;https://golang.org/doc/effective_go.html#interfaces_and_types&#34; title=&#34;Effective Go - The Go Programming Language&#34;&gt;interface&lt;/a&gt; を持つ別の擬似乱数生成器を使うことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// A Source represents a source of uniformly-distributed
// pseudo-random int64 values in the range [0, 1&amp;lt;&amp;lt;63).
type Source interface {
	Int63() int64
	Seed(seed int64)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下に2つほど紹介する。&lt;/p&gt;

&lt;h3 id=&#34;lcg&#34;&gt;線形合同法&lt;/h3&gt;

&lt;p&gt;線形合同法（Linear Congruential Generator）は昔の擬似乱数ライブラリでよく使われていたアルゴリズムで，以下の式で表される。&lt;/p&gt;

&lt;figure&gt;
&lt;blockquote&gt;
\[
X_{n+1} = (A \times X_{n} + B) \bmod M
\]
&lt;/blockquote&gt;

&lt;/figure&gt;

&lt;p&gt;定数 $A$ および $B$ の与え方により幾つかバリエーションがある。&lt;/p&gt;

&lt;p&gt;線形合同法のメリットは実装サイズが小さく計算量も少ない点だろうか。
一方デメリットとしては，多次元で疎に分布する性質があり，周期も小さいため乱数を大量に発生させる必要がある科学技術シミュレーションなどには向かないと言われている。
このためメモリサイズが限られるマイクロ・コントローラのようなものでもない限り線形合同法が使われることはなくなった。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;でわざわざ線形合同法を実装しているパッケージは少ないのだが，たとえば以下のパッケージがある&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:dgl&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:dgl&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/davidminor/gorand&#34;&gt;davidminor/gorand: Basic golang implementation of a permuted congruential generator for pseudorandom number generation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;mt&#34;&gt;Mersenne Twister&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/mt.html&#34; title=&#34;Mersenne Twister: A random number generator (since 1997/10)&#34;&gt;Mersenne Twister&lt;/a&gt; とは&lt;a href=&#34;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/&#34; title=&#34;Makoto Matsumoto Home Page&#34;&gt;松本眞&lt;/a&gt;・西村拓士両氏によって1996年に発表された擬似乱数生成アルゴリズムである。
他の擬似乱数生成アルゴリズムと比べて以下の特徴があるそうだ。
（「&lt;a href=&#34;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/what-is-mt.html&#34; title=&#34;What &amp;amp; how is MT?&#34;&gt;Mersenne Twister とは?&lt;/a&gt;」より）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;従来の様々な生成法の欠点を考慮して設計されています。&lt;/li&gt;
&lt;li&gt;従来にない長周期，高次元均等分布を持ちます。（周期が $2^{19937}-1$ で&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:mt1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:mt1&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;、623次元超立方体の中に 均等に分布することが証明されています。）&lt;/li&gt;
&lt;li&gt;生成速度がかなり速い。（処理系にもよりますが、パイプライン処理やキャッシュメモリ のあるシステムでは、Cの標準ライブラリの &lt;code&gt;rand()&lt;/code&gt; より高速なこと もあります。なお、開発当時には cokus 版は &lt;code&gt;rand()&lt;/code&gt; より4倍程度高速でしたが、その後 ANSI-C の &lt;code&gt;rand()&lt;/code&gt; が LCG 法から lagged-fibonacci に 変更されたこともあり、2002年現在 rand と MT の速度差はあまりありません。）&lt;/li&gt;
&lt;li&gt;メモリ効率が良い。（32ビット以上のマシン用に設計された &lt;code&gt;mt19937.c&lt;/code&gt; は、 624ワードのワーキングメモリを消費するだけです。 1ワードは32ビット長とします。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/mt.html&#34; title=&#34;Mersenne Twister: A random number generator (since 1997/10)&#34;&gt;Mersenne Twister&lt;/a&gt; の&lt;a href=&#34;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/license.html&#34; title=&#34;Mersenne Twisterの商用について&#34;&gt;オリジナル・コードは BSD ライセンスで提供&lt;/a&gt;されている。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/MersenneTwister-Lab&#34; title=&#34;MersenneTwister-Lab&#34;&gt;公式のリポジトリ&lt;/a&gt;には C/C++ による実装のみのようだが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で実装している人もいるようである。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/seehuhn/mt19937&#34;&gt;seehuhn/mt19937: An implementation of Takuji Nishimura&amp;rsquo;s and Makoto Matsumoto&amp;rsquo;s Mersenne Twister pseudo random number generator in Go.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/nutterts/randgen&#34;&gt;nutterts/randgen: Pseudo Random Number Generators implementing the Go(lang) math/rand.Source Interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/farces/mt19937_64&#34;&gt;farces/mt19937_64: Mersenne Twister (int64) for Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cuixin/goalg&#34;&gt;cuixin/goalg: golang algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cpmech/gosl&#34;&gt;cpmech/gosl: Go scientific library&lt;/a&gt; : &lt;a href=&#34;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/&#34; title=&#34;SIMD-oriented Fast Mersenne Twister&#34;&gt;SFMT&lt;/a&gt; や &lt;a href=&#34;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/TINYMT/&#34; title=&#34;Tiny Mersenne Twister&#34;&gt;TinyMT&lt;/a&gt; に対応。オリジナルのコードを &lt;a href=&#34;https://golang.org/cmd/cgo/&#34; title=&#34;cgo - The Go Programming Language&#34;&gt;cgo&lt;/a&gt; で結合しているのでクロス環境では注意&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;擬似乱数生成器を組み込む&#34;&gt;擬似乱数生成器を組み込む&lt;/h2&gt;

&lt;p&gt;では，先ほど紹介した擬似乱数生成器を今回のコードに組み込んでみることにしよう。
こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package gencmplx

import (
	&amp;quot;math/rand&amp;quot;

	&amp;quot;github.com/davidminor/gorand/lcg&amp;quot;
	&amp;quot;github.com/seehuhn/mt19937&amp;quot;
)

//RNGs is kind of RNG
type RNGs int

const (
	NULL RNGs = iota
	GO
	LCG
	MT
)

//NewRndSource returns Source of random numbers
func NewRndSource(rng RNGs, seed int64) rand.Source {
	switch rng {
	case LCG:
		return lcg.NewLcg64(uint64(seed))
	case MT:
		mt := mt19937.New()
		mt.Seed(seed)
		return mt
	default:
		return rand.NewSource(seed)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;gencmplx.NewRndSource()&lt;/code&gt; 関数で &lt;code&gt;rand.Source&lt;/code&gt; オブジェクトを生成する&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:pm&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:pm&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
これを「&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi/&#34; title=&#34;モンテカルロ法による円周率の推定（その1）&#34;&gt;その1&lt;/a&gt;」で作った &lt;code&gt;gencmplx.New()&lt;/code&gt; 関数に渡せばよい。&lt;/p&gt;

&lt;p&gt;CLI は以下のように調整してみた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go estmt --help
Estimate of Pi with Monte Carlo method.

Usage:
  pi estmt [flags]

Flags:
  -e, --ecount int   Count of estimate (default 100)

Global Flags:
  -p, --pcount int       Count of points (default 10000)
  -r, --rsource string   Source of RNG (GO/LCG/MT) (default &amp;quot;GO&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で，それぞれの擬似乱数生成器で評価を行ってみようと思ったのだが，今回のケースに限ってはあまり違いが出ないようである。&lt;/p&gt;

&lt;p&gt;まずは&lt;a href=&#34;#lcg&#34;&gt;線形合同法&lt;/a&gt;の場合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go estmt -e 10000 -p 100000 -r LCG &amp;gt; estmt100k-lcg.dat
random number generator: LCG
minimum value: 3.12204
maximum value: 3.16224
average value: 3.14164
standard deviation: 0.00524 (68.3%)
&lt;/code&gt;&lt;/pre&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/histogram-lcg.png&#34;&gt;&lt;img srcset=&#34;http://text.baldanders.info/images/histogram-lcg.png 611w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;&#34;&gt;&lt;/a&gt;

&lt;/figure&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/qq100k-plot-lcg.png&#34;&gt;&lt;img srcset=&#34;http://text.baldanders.info/images/qq100k-plot-lcg.png 611w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;&#34;&gt;&lt;/a&gt;

&lt;/figure&gt;

&lt;p&gt;次は &lt;a href=&#34;#mt&#34;&gt;Mersenne Twister&lt;/a&gt; の場合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go estmt -e 10000 -p 100000 -r MT &amp;gt; estmt100k-mt.dat
random number generator: MT
minimum value: 3.12380
maximum value: 3.16140
average value: 3.14165
standard deviation: 0.00517 (67.8%)
&lt;/code&gt;&lt;/pre&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/histogram-mt.png&#34;&gt;&lt;img srcset=&#34;http://text.baldanders.info/images/histogram-mt.png 611w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;&#34;&gt;&lt;/a&gt;

&lt;/figure&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/qq100k-plot-mt.png&#34;&gt;&lt;img srcset=&#34;http://text.baldanders.info/images/qq100k-plot-mt.png 611w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;&#34;&gt;&lt;/a&gt;

&lt;/figure&gt;

&lt;p&gt;もっと多次元だったりすると変わってくるのかなぁ。&lt;/p&gt;

&lt;h2 id=&#34;暗号技術用途の乱数生成器&#34;&gt;暗号技術用途の乱数生成器&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では暗号技術用途の乱数として &lt;a href=&#34;https://golang.org/pkg/crypto/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;crypto/rand&lt;/code&gt;&lt;/a&gt; パッケージが用意されている。
これは &lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; とは互換性がない。&lt;/p&gt;

&lt;p&gt;具体的には，UNIX 系のプラットフォームでは乱数生成に &lt;code&gt;/dev/urandom&lt;/code&gt; デバイスを参照している&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:dr&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:dr&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。
また Windows プラットフォームでは &lt;a href=&#34;https://technet.microsoft.com/ja-jp/library/cc734124.aspx&#34;&gt;CryptoAPI 2.0&lt;/a&gt; の &lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/windows/desktop/aa379942.aspx&#34; title=&#34;CryptGenRandom function&#34;&gt;&lt;code&gt;CryptGenRandom&lt;/code&gt;&lt;/a&gt; 関数を使っている&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:win&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:win&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;そもそも暗号技術用途の乱数生成器は科学技術シミュレーションやゲームで使う擬似乱数生成器とは要件が異なる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc4086&#34;&gt;RFC 4086 - Randomness Requirements for Security&lt;/a&gt; （&lt;a href=&#34;https://www.ipa.go.jp/security/rfc/RFC4086JA.html&#34; title=&#34;セキュリティのための乱雑性についての要件&#34;&gt;IPA による日本語訳&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&#34;http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf&#34;&gt;NIST Special Publication 800-90A Revision 1: Recommendation for Random Number Generation Using Deterministic Random Bit Generators&lt;sup&gt;&lt;i class=&#34;fa fa-file-pdf-o&#34;&gt;&lt;/i&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
&lt;blockquote&gt;
&lt;q&gt;従前の観点から統計的にテストされた乱雑性は、セキュリティ用途に要求される予測困難性と同等では&lt;strong&gt;ありません&lt;/strong&gt;。&lt;br&gt;
例えば、（CRC Standard Mathematical Tables からのランダムテーブルのような）広く利用可能な一定のシーケンスの利用は、攻撃者に対して非常に弱いです。これを学習したり、推測する攻撃者は、容易に（過去・未来を問わず）そのシーケンス [CRC] に基づいて、すべてのセキュリティを破ることができます。他の例として、AES を 1, 2, 3 ... のような連続した整数を暗号化する一定の鍵と共に使うことは、優れた統計的乱雑性をもつが予測可能な出力を作り出します。他方、6 面のサイコロを連続して転がして、その結果の値を ASCII にエンコードすることは、実質的に予測困難なコンポーネントをもちながらも「統計的に貧弱な出力」を作り出します。それゆえ、「統計的テストの合否は、『何かが予測不可能であるか否か、あるいは、予測可能であるか否か』を表さないこと」に注意してください。&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;https://www.ipa.go.jp/security/rfc/RFC4086JA.html&#34;&gt;RFC 4086 - セキュリティのための乱雑性についての要件&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;暗号技術用途の乱数生成器は，暗号分野においては中核技術のひとつであるが，一度に大量の乱数を生成させる必要のある科学技術シミュレーションなどの用途には向かない。
上手く使い分けてほしい。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/remark/2016/03/mersenne-twister/&#34;&gt;Mersenne Twister に関する覚え書き&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pcg-random.org/&#34;&gt;PCG, A Family of Better Random Number Generators | PCG, A Better Random Number Generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://news.mynavi.jp/news/2014/03/11/037/&#34;&gt;/dev/randomではなく/dev/urandomを使うべき理由? | マイナビニュース&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B015643CPE/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/51t6yHHVwEL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B015643CPE/baldandersinf-22/&#34;&gt;暗号技術入門 第3版　秘密の国のアリス&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;結城 浩 &lt;/dd&gt;&lt;dd&gt;SBクリエイティブ 2015-08-25&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B0148FQNVC/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B0148FQNVC.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;自作エミュレータで学ぶx86アーキテクチャ　コンピュータが動く仕組みを徹底理解！&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00W6NCLJM/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00W6NCLJM.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート/丸い三角関数&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00Y9EYOIW/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00Y9EYOIW.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート/微分を追いかけて&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B012BYBTZC/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B012BYBTZC.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;情報セキュリティ白書2015: サイバーセキュリティ新時代：あらゆる変化へ柔軟な対応を&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00W6NCLL0/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00W6NCLL0.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート/数列の広場&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;SHA-3 や Bitcoin/Blockchain など新しい知見や技術要素を大幅追加。暗号技術を使うだけならこれ1冊でとりあえず無問題。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2015-09-20&#34;&gt;2015-09-20&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:dgl&#34;&gt;ただし &lt;a href=&#34;https://github.com/davidminor/gorand&#34; title=&#34;davidminor/gorand: Basic golang implementation of a permuted congruential generator for pseudorandom number generation&#34;&gt;&lt;code&gt;github.com/davidminor/gorand&lt;/code&gt;&lt;/a&gt;&lt;code&gt;/lcg&lt;/code&gt; には不具合があって &lt;code&gt;Int63()&lt;/code&gt; 関数で負の値を出力する場合がある。とりあえず fork 版の &lt;a href=&#34;https://github.com/davidminor/gorand&#34; title=&#34;spiegel-im-spiegel/gorand: Basic golang implementation of a permuted congruential generator for pseudorandom number generation&#34;&gt;&lt;code&gt;github.com/spiegel-im-spiegel/gorand&lt;/code&gt;&lt;/a&gt;&lt;code&gt;/lcg&lt;/code&gt; で修正している。 Pull request も出したけど，古いコードだし，もうメンテしてないかなぁ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:dgl&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:mt1&#34;&gt;$2^{19937}-1$ はメルセンヌ素数で &lt;a href=&#34;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/mt.html&#34; title=&#34;Mersenne Twister: A random number generator (since 1997/10)&#34;&gt;Mersenne Twister&lt;/a&gt; の名前の由来になっている。 &lt;a href=&#34;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/mt.html&#34; title=&#34;Mersenne Twister: A random number generator (since 1997/10)&#34;&gt;Mersenne Twister&lt;/a&gt; では周期サイズごとに複数の実装があるが， $2^{19937}-1$ がポピュラーな実装として広く使われているようだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:mt1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:pm&#34;&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;におけるオブジェクトの多態性については「&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」&lt;/a&gt;」を参考にどうぞ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:pm&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:dr&#34;&gt;&lt;code&gt;/dev/urandom&lt;/code&gt; はハードウェア・デバイスから十分なエントロピー源が得られない場合は内部で疑似乱数生成器を使用する。このため一時は &lt;code&gt;/dev/urandom&lt;/code&gt; の脆弱性が疑われたが，現時点では事実上は問題ないとされている。一方で，スマートデバイスのような場合はハードウェア・デバイスからのエントロピー源だけでは外部から推測され易いため，性能のよい疑似乱数生成器を組み合わせるほうが有効になる場合もあるようだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:dr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:win&#34;&gt;&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/windows/desktop/aa379942.aspx&#34; title=&#34;CryptGenRandom function&#34;&gt;&lt;code&gt;CryptGenRandom&lt;/code&gt;&lt;/a&gt; 関数の内部実装は公開されていないが，やはりキーボードやマウス等のデバイスの挙動をエントロピー源とし， NIST の SP800-90 勧告に従った実装をしているようである。余談だが SP800-90 は乱数生成の一部のアルゴリズムで脆弱性が発見され（これがまた NSA 絡みだったものだから大騒ぎになった），現在は修正版の &lt;a href=&#34;http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf&#34; title=&#34;Recommendation for Random Number Generation Using Deterministic Random Bit Generators&#34;&gt;SP800-90A Revision 1&lt;/a&gt;が発行されている。（参考：&lt;a href=&#34;http://www.cryptrec.go.jp/topics/cryptrec_20131106_dual_ec_drbg.html&#34;&gt;擬似乱数生成アルゴリズム Dual_EC_DRBG について&lt;/a&gt;）
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:win&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>モンテカルロ法による円周率の推定（その3 Gaussian） — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/estimate-of-pi-3-gaussian/" />
		<id>tag:text.Baldanders.info,2016-11-14:/golang/estimate-of-pi-3-gaussian/</id>
		<published>2016-11-14T20:50:56+09:00</published>
		<updated>2016-12-11T15:19:30+09:00</updated>
		<summary>さて，前回書いたコードを利用していよいよ円周率の推定結果を評価してみる。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi/&#34;&gt;モンテカルロ法による円周率の推定（その1）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-2-cli/&#34;&gt;モンテカルロ法による円周率の推定（その2 CLI）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-3-gaussian/&#34;&gt;モンテカルロ法による円周率の推定（その3 Gaussian）&lt;/a&gt; ← イマココ&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-4-prng/&#34;&gt;モンテカルロ法による円周率の推定（その4 PRNG）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;推定結果の分布&#34;&gt;推定結果の分布&lt;/h2&gt;

&lt;p&gt;さて，&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-2-cli/&#34; title=&#34;モンテカルロ法による円周率の推定（その2 CLI）&#34;&gt;前回&lt;/a&gt;書いたコードを利用して，いよいよ円周率の推定結果を評価してみる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/pi&#34;&gt;spiegel-im-spiegel/pi: Estimate of Pi with Monte Carlo method.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CLI はこんな感じになった。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go estmt --help
Estimate of Pi with Monte Carlo method.

Usage:
  pi estmt [flags]

Flags:
  -e, --ecount int   Count of estimate (default 100)
  -p, --pcount int   Count of points (default 10000)

Global Flags:
      --config string   config file (default is $HOME/.pi.yaml)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずは円周率の推定処理を10,000回繰り返してみる。
また推定処理のためのランダムな点の数 $n$ を1,000個，10,000個，100,000個と変えて実行してみようか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go estmt -e 10000 -p 1000 &amp;gt; estmt1k.dat
minimum value: 2.94800
maximum value: 3.31600
average value: 3.14199
standard deviation: 0.05104 (69.9%)

$ go run main.go estmt -e 10000 -p 10000 &amp;gt; estmt10k.dat
minimum value: 3.07240
maximum value: 3.20360
average value: 3.14178
standard deviation: 0.01654 (68.0%)

$ go run main.go estmt -e 10000 -p 100000 &amp;gt; estmt100k.dat
minimum value: 3.12360
maximum value: 3.16184
average value: 3.14163
standard deviation: 0.00518 (68.3%)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後のはさすがに時間がかかるので，お茶でも飲みながら優雅に待ちましょう（笑）&lt;/p&gt;

&lt;p&gt;標準エラー出力に最小値，最大値，平均値（$E$），標準偏差（$\sigma$）を出力してみた。
標準偏差の後ろの括弧は $\left[ E-\sigma, E+\sigma \right]$ の範囲にある推定値の割合を示したものだ。&lt;/p&gt;

&lt;p&gt;円周率の推定処理の試行回数が十分大きいなら推定値の分布は正規分布（またはガウス分布）に近似できる筈である。
（以下の&lt;a href=&#34;https://commons.wikimedia.org/wiki/File:Standard_deviation_diagram.svg&#34; title=&#34;File:Standard deviation diagram.svg - Wikimedia Commons&#34;&gt;図は Wikimedia Commons のもの&lt;/a&gt;を拝借した。 &lt;a href=&#34;https://creativecommons.org/licenses/by/2.5/&#34; title=&#34;Creative Commons — Attribution 2.5 Generic — CC BY 2.5&#34;&gt;CC-BY-2.5 Generic&lt;/a&gt; で公開されている）
&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;https://commons.wikimedia.org/wiki/File:Standard_deviation_diagram.svg&#34;&gt;&lt;img srcset=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/8/8c/Standard_deviation_diagram.svg/640px-Standard_deviation_diagram.svg.png 640w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;normal distribution from Wikimedia&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://commons.wikimedia.org/wiki/File:Standard_deviation_diagram.svg&#34;&gt;normal distribution from Wikimedia&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;そこで $n=100,000$ のときの推定結果についてヒストグラムを描いてみる。
幸いなことに &lt;a href=&#34;http://www.gnuplot.info/&#34; title=&#34;gnuplot homepage&#34;&gt;gnuplot&lt;/a&gt; では簡単にヒストグラムを作図できる。
こんな感じ（階級幅を0.001としている）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;gnuplot&amp;gt; filter(x,y)=int(x/y)*y
gnuplot&amp;gt; plot &amp;quot;estmt100k.dat&amp;quot; u (filter($1,0.001)):(1) smooth frequency with boxes lc rgb &amp;quot;black&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.gnuplot.info/&#34; title=&#34;gnuplot homepage&#34;&gt;gnuplot&lt;/a&gt; の出力結果はこんな感じ。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/histogram.png&#34;&gt;&lt;img srcset=&#34;http://text.baldanders.info/images/histogram.png 640w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;&#34;&gt;&lt;/a&gt;

&lt;/figure&gt;

&lt;p&gt;んー。
まぁ正規分布っぽい？&lt;/p&gt;

&lt;p&gt;もうひとつ，正規確率の分布を調べてみよう。
これも &lt;a href=&#34;http://www.gnuplot.info/&#34; title=&#34;gnuplot homepage&#34;&gt;gnuplot&lt;/a&gt; で描こうと思ったけど，少し面倒そうなので，ズルして以下を参考に &lt;a href=&#34;https://www.libreoffice.org/&#34; title=&#34;Home | LibreOffice - Free Office Suite - Fun Project - Fantastic People&#34;&gt;LibreOffice&lt;/a&gt; の Calc で描くことにした&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:calc&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:calc&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://hitorimarketing.net/tools/normal-quantile-quantile-plot.html&#34;&gt;正規確率プロット（Normal Q-Q Plot）の作成 with Excel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とりあえず結果だけ。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/qq-plot.png&#34;&gt;&lt;img srcset=&#34;http://text.baldanders.info/images/qq-plot.png 653w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;&#34;&gt;&lt;/a&gt;

&lt;/figure&gt;

&lt;p&gt;プロットが直線状に並んでいれば正規分布であると言える。
図から見る限り，概ね正規分布になっているようである。&lt;/p&gt;

&lt;p&gt;しまった。
ここまで &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;が全然出てこなかった。
まぁ，いいや。
多分あと1回続きます。&lt;/p&gt;

&lt;h2 id=&#34;おまけ-誤差評価&#34;&gt;おまけ：誤差評価&lt;/h2&gt;

&lt;p&gt;モンテカルロ法を使ってどの程度の精度で円周率が求まるかの考察については以下が参考になる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ruby.kyoto-wu.ac.jp/info-com/NumericalModels/RandomProcess/estimateMCmodel.html&#34;&gt;モンテカルロ法の誤差を考える&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これも横着して結果だけを拝借すると， $n=100,000$ で推定を行った場合の値の分布は，中央値を $\pi$，99%信頼区間を $\frac{4.230}{\sqrt{100,000}} = 0.013$ として， $\left[ \pi - 0.013, \pi + 0.013 \right]$ の範囲になるようだ。&lt;/p&gt;

&lt;h2 id=&#34;おまけの追記-正規確率の分布図について&#34;&gt;おまけの追記： 正規確率の分布図について&lt;/h2&gt;

&lt;p&gt;正規確率の分布図（Q-Q プロット）を描くのに毎回 Excel や Calc を使うのもどうかという気がしたので，こちらのプログラム側であらかじめ計算して，結果のプロット・データを &lt;a href=&#34;http://www.gnuplot.info/&#34; title=&#34;gnuplot homepage&#34;&gt;gnuplot&lt;/a&gt; に食わせるよう考えてみる。&lt;/p&gt;

&lt;p&gt;まず &lt;code&gt;qq&lt;/code&gt; サブコマンドを追加し，この &lt;code&gt;qq&lt;/code&gt; サブコマンド時にデータファイルを読み込んで Q-Q プロットの計算を行うように CLI を変更する。（ついでに他のオプションも整理した）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go qq --help
make Q-Q plot data.

Usage:
  pi qq [data file] [flags]

Global Flags:
  -p, --pcount int   Count of points (default 10000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際の処理部分はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Execute output Q-Q plot data.
func Execute(cxt *Context) error {
	scanner := bufio.NewScanner(cxt.ui.Reader())
	pis := make([]float64, 0)
	for scanner.Scan() {
		pi, err := strconv.ParseFloat(scanner.Text(), 64)
		if err != nil {
			return errors.Wrap(err, &amp;quot;invalid data&amp;quot;)
		}
		pis = append(pis, pi)
	}
    ecf := float64(len(pis))

	sort.Float64s(pis)
	for i, pi := range pis {
		rank := (float64(i+1) - 0.5) / ecf
		cxt.ui.Outputln(fmt.Sprintf(&amp;quot;%v\t%v&amp;quot;, qnorm(rank), pi))
	}

	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;qnorm()&lt;/code&gt; 関数は標準正規分布に対する累積分布関数の逆関数の値を返すのだが（Excel の &lt;code&gt;NORM.S.INV&lt;/code&gt; 関数相当），&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で書かれた適当なパッケージが見つからなかったので（もしあれば誰か教えて）以下のページのコードを &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;用に書き直した。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://rangevoting.org/Qnorm.html&#34;&gt;RangeVoting.org - Java normal distribution calculator II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際にはこんな感じ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:const&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:const&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//qnorm function refers to http://rangevoting.org/Qnorm.html
// This function is licensed under GNU GPL version 3 or later.
func qnorm(p float64) float64 {
	const (
		split = 0.42
		a0    = 2.50662823884
		a1    = -18.61500062529
		a2    = 41.39119773534
		a3    = -25.44106049637
		b1    = -8.47351093090
		b2    = 23.08336743743
		b3    = -21.06224101826
		b4    = 3.13082909833
		c0    = -2.78718931138
		c1    = -2.29796479134
		c2    = 4.85014127135
		c3    = 2.32121276858
		d1    = 3.54388924762
		d2    = 1.63706781897
	)

	q := p - 0.5
	ppnd := float64(0)
	if math.Abs(q) &amp;lt;= split {
		r := q * q
		ppnd = q * (((a3*r+a2)*r+a1)*r + a0) / ((((b4*r+b3)*r+b2)*r+b1)*r + 1)
	} else {
		r := p
		if q &amp;gt; 0 {
			r = 1 - p
		}
		if r &amp;gt; 0 {
			r = math.Sqrt(-math.Log(r))
			ppnd = (((c3*r+c2)*r+c1)*r + c0) / ((d2*r+d1)*r + 1)
			if q &amp;lt; 0 {
				ppnd = -ppnd
			}
		}
	}
	return ppnd
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では早速動かしてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go qq estmt100k.dat &amp;gt; qq100k.dat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成した &lt;code&gt;qq100k.dat&lt;/code&gt; ファイルを &lt;a href=&#34;http://www.gnuplot.info/&#34; title=&#34;gnuplot homepage&#34;&gt;gnuplot&lt;/a&gt; に食わせる。
こんな感じでいいだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;gnuplot&amp;gt; unset key
gnuplot&amp;gt; set style line 1 pointsize 0.1 pointtype 7 linecolor rgb &amp;quot;black&amp;quot;
gnuplot&amp;gt; plot &amp;quot;qq100k.dat&amp;quot; linestyle 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果はこんな感じ。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/qq-plot2.png&#34;&gt;&lt;img srcset=&#34;http://text.baldanders.info/images/qq-plot2.png 640w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;&#34;&gt;&lt;/a&gt;

&lt;/figure&gt;

&lt;p&gt;ついでにこの分布図にフィットする直線 $y=ax+b$ の $a, b$ 値を調べてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;gnuplot&amp;gt; f(x)=a*x+b
gnuplot&amp;gt; fit f(x) &amp;quot;qq100k.dat&amp;quot; via a,b
iter      chisq       delta/lim  lambda   a             b            
   0 5.5761271099e+04  0.00e+00 1.00e+00  1.000000e+00  1.000000e+00
   1 6.0252530865e-04 -9.25e+12 1.00e-01  5.277253e-03  3.141418e+00
   2 4.5071534394e-05 -1.24e+06 1.00e-02  5.177775e-03  3.141632e+00
   3 4.5071534393e-05 -1.23e-06 1.00e-03  5.177775e-03  3.141632e+00
iter      chisq       delta/lim  lambda   a             b            

After 3 iterations the fit converged.
final sum of squares of residuals : 4.50715e-005
rel. change during last iteration : -1.23364e-011

degrees of freedom    (FIT_NDF)                        : 9998
rms of residuals      (FIT_STDFIT) = sqrt(WSSR/ndf)    : 6.71421e-005
variance of residuals (reduced chisquare) = WSSR/ndf   : 4.50806e-009

Final set of parameters            Asymptotic Standard Error
=======================            ==========================
a               = 0.00517777       +/- 6.715e-007   (0.01297%)
b               = 3.14163          +/- 6.714e-007   (2.137e-005%)

correlation matrix of the fit parameters:
                a      b      
a               1.000 
b               0.000  1.000 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで $a$ が標準偏差， $b$ が平均値にマッチしている点に注目。
分布図と上の直線を重ねあわせるとこうなる。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/qq-plot2b.png&#34;&gt;&lt;img srcset=&#34;http://text.baldanders.info/images/qq-plot2b.png 640w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;&#34;&gt;&lt;/a&gt;

&lt;/figure&gt;

&lt;p&gt;んー。
こんなもんかな。&lt;/p&gt;

&lt;p&gt;そうそう。
&lt;code&gt;qq&lt;/code&gt; サブコマンドは，フィルタとしても機能するので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go estmt -e 100 -p 10000 | go run main.go qq &amp;gt; qq.dat
minimum value: 3.09640
maximum value: 3.18600
average value: 3.14158
standard deviation: 0.01654 (68.0%)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といった感じにパイプでつなぐこともできる。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/iwiwi/items/4c7635d4c84bc785e47a&#34;&gt;gnuplot でヒストグラム（頻度分布図）を描画する - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/kenmatsu4/items/59605dc745707e8701e0&#34;&gt;【統計学】Q-Qプロットの仕組みをアニメーションで理解する。 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dsl4.eee.u-ryukyu.ac.jp/DOCS/gnuplot/node180.html&#34;&gt;簡単な例題&lt;/a&gt;：最小2乗法でデータに曲線や曲面をあてはめる&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.biwako.shiga-u.ac.jp/sensei/mnaka/ut/normdistinvtab.html&#34;&gt;付表：正規分布表　（ P から z を求める表） - 中川雅央（滋賀大学）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1FO/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/416jAxVU4NL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1FO/baldandersinf-22/&#34;&gt;数学ガール／乱択アルゴリズム&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;結城 浩 &lt;/dd&gt;&lt;dd&gt;SBクリエイティブ株式会社 2014-02-14&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1D6/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1D6.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／ゲーデルの不完全性定理&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1CM/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1CM.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／フェルマーの最終定理&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMK4/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00L0PDMK4.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／ガロア理論&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00EYXMA9I/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00EYXMA9I.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMIQ/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00L0PDMIQ.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／式とグラフ&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34; &gt;工学ガール，リサちゃん登場！&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#34;#maker&#34; class=&#34;reviewer&#34;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2015-04-19&#34;&gt;2015/04/19&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34;&gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MSJMKMW/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/41-A4q7tckL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MSJMKMW/baldandersinf-22/&#34;&gt;数学ガールの秘密ノート／やさしい統計&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;結城 浩 &lt;/dd&gt;&lt;dd&gt;SBクリエイティブ 2016-10-28&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01EL08HVS/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01EL08HVS.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／場合の数&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B018VE46YW/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B018VE46YW.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／ベクトルの真実&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01NCIV1N7/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01NCIV1N7.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;はじめての深層学習（ディープラーニング）プログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01NA96U1T/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01NA96U1T.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;ポートとソケットがわかればインターネットがわかる――TCP/IP・ネットワーク技術を学びたいあなたのために&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00W6NCLL0/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00W6NCLL0.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／数列の広場&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00Y9EYOIW/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00Y9EYOIW.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／微分を追いかけて&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMJ0/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00L0PDMJ0.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／整数で遊ぼう&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00W6NCLJM/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00W6NCLJM.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／丸い三角関数&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01N66D7CV/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01N66D7CV.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;経済数学の直観的方法　確率・統計編 (ブルーバックス)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B01MXHLC6P/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B01MXHLC6P.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;速習 Python 3 上: プログラミングの基礎編&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;統計の本当に基礎の部分から。学業成績でよく聞く「偏差値」とは何を表していて何を意味しているのか。なんてなあたりから。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-12-11&#34;&gt;2016-12-11&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:calc&#34;&gt;Calc でも Excel の関数がそのまま使えるようだ。助かる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:calc&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:const&#34;&gt;余談だが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では untyped な定数を設定できる。型が評価されるのは，処理の中でその定数が使われた時点となる。数値の精度も使用時点で評価されるため，定義では大きい桁数の値を設定しても問題ない。（参考： &lt;a href=&#34;http://qiita.com/hkurokawa/items/a4d402d3182dff387674&#34;&gt;Go の定数の話 - Qiita&lt;/a&gt;）
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:const&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>モンテカルロ法による円周率の推定（その2 CLI） — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/estimate-of-pi-2-cli/" />
		<id>tag:text.Baldanders.info,2016-11-06:/golang/estimate-of-pi-2-cli/</id>
		<published>2016-11-06T17:57:37+09:00</published>
		<updated>2016-11-20T23:32:40+09:00</updated>
		<summary>さっそく推定結果について評価を行いたいところだが，その前に CLI (command-line interface) を整備する。今回は spf13/cobra パッケージを使うことにする。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi/&#34;&gt;モンテカルロ法による円周率の推定（その1）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-2-cli/&#34;&gt;モンテカルロ法による円周率の推定（その2 CLI）&lt;/a&gt; ← イマココ&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-3-gaussian/&#34;&gt;モンテカルロ法による円周率の推定（その3 Gaussian）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-4-prng/&#34;&gt;モンテカルロ法による円周率の推定（その4 PRNG）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;コマンドライン-インタフェース&#34;&gt;コマンドライン・インタフェース&lt;/h2&gt;

&lt;p&gt;さっそく推定結果について評価を行いたいところだが，その前に CLI (command-line interface) を整備する。
どういうことかというと，&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi/&#34; title=&#34;モンテカルロ法による円周率の推定（その1）&#34;&gt;前回&lt;/a&gt;作った2つの &lt;code&gt;main()&lt;/code&gt; 関数の処理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/pi/gencmplx&amp;quot;
)

func main() {
	c := gencmplx.New(rand.NewSource(time.Now().UnixNano()), int64(10000))
	for p := range c {
		fmt.Printf(&amp;quot;%v\t%v\n&amp;quot;, real(p), imag(p))
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/cmplx&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/pi/gencmplx&amp;quot;
)

func main() {
	c := gencmplx.New(rand.NewSource(time.Now().UnixNano()), int64(100000))
	n := int64(0) // total
	m := int64(0) // plot in circle
	for p := range c {
		n++
		if cmplx.Abs(p) &amp;lt;= float64(1) {
			m++
		}
	}
	fmt.Printf(&amp;quot;n = %v, m = %v, 4m/n = %v\n&amp;quot;, n, m, float64(4*m)/float64(n))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをひとつの CLI で呼び出せるよう統合してしまおうというわけ。&lt;/p&gt;

&lt;p&gt;CLI については以前に解説した。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/cli-and-facade-pattern/&#34;&gt;コマンドライン・インタフェースとファサード・パターン&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このときは &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;&lt;code&gt;mitchellh/cli&lt;/code&gt;&lt;/a&gt; を紹介したが，今回は &lt;a href=&#34;https://github.com/spf13/cobra&#34; title=&#34;spf13/cobra: A Commander for modern Go CLI interactions&#34;&gt;&lt;code&gt;spf13/cobra&lt;/code&gt;&lt;/a&gt; を使うことにする。&lt;/p&gt;

&lt;h3 id=&#34;spf13-cobra-パッケージ&#34;&gt;spf13/cobra パッケージ&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34; title=&#34;spf13/cobra: A Commander for modern Go CLI interactions&#34;&gt;&lt;code&gt;spf13/cobra&lt;/code&gt;&lt;/a&gt; パッケージの作者 &lt;a href=&#34;https://github.com/spf13&#34;&gt;spf13 (Steve Francia)&lt;/a&gt; さんは &lt;a href=&#34;https://www.linkedin.com/in/stevefrancia&#34; title=&#34;Steven Francia | LinkedIn&#34;&gt;Docker の中の人&lt;/a&gt;で &lt;a href=&#34;http://gohugo.io/&#34; title=&#34;Hugo :: A fast and modern static website engine&#34;&gt;Hugo&lt;/a&gt; の作者としても有名な方。
もちろん &lt;a href=&#34;http://gohugo.io/&#34; title=&#34;Hugo :: A fast and modern static website engine&#34;&gt;Hugo&lt;/a&gt; の CLI にも &lt;a href=&#34;https://github.com/spf13/cobra&#34; title=&#34;spf13/cobra: A Commander for modern Go CLI interactions&#34;&gt;&lt;code&gt;spf13/cobra&lt;/code&gt;&lt;/a&gt; が使われている。&lt;/p&gt;

&lt;p&gt;さらにありがたいことに &lt;a href=&#34;https://github.com/spf13/cobra&#34; title=&#34;spf13/cobra: A Commander for modern Go CLI interactions&#34;&gt;&lt;code&gt;spf13/cobra&lt;/code&gt;&lt;/a&gt; にはテンプレートコードを出力する CLI も用意されている。
インストールは &lt;code&gt;go get&lt;/code&gt; コマンドで行う。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go get -v github.com/spf13/cobra/cobra
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで &lt;a href=&#34;https://github.com/spf13/cobra&#34; title=&#34;spf13/cobra: A Commander for modern Go CLI interactions&#34;&gt;&lt;code&gt;spf13/cobra&lt;/code&gt;&lt;/a&gt; パッケージ本体と CLI がインストールされる。
テンプレートコードの生成は以下のコマンドを叩く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ cobra init github.com/spiegel-im-spiegel/pi
Your Cobra application is ready at
C:\workspace\pi\src\github.com\spiegel-im-spiegel\pi
Give it a try by going there and running `go run main.go`
Add commands to it by running `cobra add [cmdname]`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既にパッケージ用のフォルダが作られている場合は，そのフォルダまで降りて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ cobra init .
Your Cobra application is ready at
C:\workspace\pi\src\github.com\spiegel-im-spiegel\pi
Give it a try by going there and running `go run main.go`
Add commands to it by running `cobra add [cmdname]`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でもよい。&lt;/p&gt;

&lt;p&gt;この時点で &lt;code&gt;main.go&lt;/code&gt; と &lt;code&gt;cmd/root.go&lt;/code&gt; のふたつが生成される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 NAME HERE &amp;lt;EMAIL ADDRESS&amp;gt;
//
// Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import &amp;quot;github.com/spiegel-im-spiegel/pi/cmd&amp;quot;

func main() {
	cmd.Execute()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 NAME HERE &amp;lt;EMAIL ADDRESS&amp;gt;
//
// Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;github.com/spf13/cobra&amp;quot;
	&amp;quot;github.com/spf13/viper&amp;quot;
)

var cfgFile string

// RootCmd represents the base command when called without any subcommands
var RootCmd = &amp;amp;cobra.Command{
	Use:   &amp;quot;pi&amp;quot;,
	Short: &amp;quot;A brief description of your application&amp;quot;,
	Long: `A longer description that spans multiple lines and likely contains
examples and usage of using your application. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
// Uncomment the following line if your bare application
// has an action associated with it:
//	Run: func(cmd *cobra.Command, args []string) { },
}

// Execute adds all child commands to the root command sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	if err := RootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(-1)
	}
}

func init() {
	cobra.OnInitialize(initConfig)

	// Here you will define your flags and configuration settings.
	// Cobra supports Persistent Flags, which, if defined here,
	// will be global for your application.

	RootCmd.PersistentFlags().StringVar(&amp;amp;cfgFile, &amp;quot;config&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;config file (default is $HOME/.pi.yaml)&amp;quot;)
	// Cobra also supports local flags, which will only run
	// when this action is called directly.
	RootCmd.Flags().BoolP(&amp;quot;toggle&amp;quot;, &amp;quot;t&amp;quot;, false, &amp;quot;Help message for toggle&amp;quot;)
}

// initConfig reads in config file and ENV variables if set.
func initConfig() {
	if cfgFile != &amp;quot;&amp;quot; { // enable ability to specify config file via flag
		viper.SetConfigFile(cfgFile)
	}

	viper.SetConfigName(&amp;quot;.pi&amp;quot;) // name of config file (without extension)
	viper.AddConfigPath(&amp;quot;$HOME&amp;quot;)  // adding home directory as first search path
	viper.AutomaticEnv()          // read in environment variables that match

	// If a config file is found, read it in.
	if err := viper.ReadInConfig(); err == nil {
		fmt.Println(&amp;quot;Using config file:&amp;quot;, viper.ConfigFileUsed())
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この状態でいきなり動かしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go
A longer description that spans multiple lines and likely contains
examples and usage of using your application. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RootCmd&lt;/code&gt; で定義した説明が表示されているのがわかると思う。&lt;/p&gt;

&lt;p&gt;次にサブコマンドを定義する。
名前は &lt;code&gt;plot&lt;/code&gt; と &lt;code&gt;estmt&lt;/code&gt; としようか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ cobra add plot
plot created at C:\workspace\pi\src\github.com\spiegel-im-spiegel\pi\cmd\plot.go

$ cobra add estmt
estmt created at C:\workspace\pi\src\github.com\spiegel-im-spiegel\pi\cmd\estmt.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで &lt;code&gt;cmd/plot.go&lt;/code&gt; と &lt;code&gt;cmd/estmt.go&lt;/code&gt; のふたつが生成された。
&lt;code&gt;cmd/plot.go&lt;/code&gt; の中身を見てみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright Â© 2016 NAME HERE &amp;lt;EMAIL ADDRESS&amp;gt;
//
// Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/spf13/cobra&amp;quot;
)

// plotCmd represents the plot command
var plotCmd = &amp;amp;cobra.Command{
	Use:   &amp;quot;plot&amp;quot;,
	Short: &amp;quot;A brief description of your command&amp;quot;,
	Long: `A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
	Run: func(cmd *cobra.Command, args []string) {
		// TODO: Work your own magic here
		fmt.Println(&amp;quot;plot called&amp;quot;)
	},
}

func init() {
	RootCmd.AddCommand(plotCmd)

	// Here you will define your flags and configuration settings.

	// Cobra supports Persistent Flags which will work for this command
	// and all subcommands, e.g.:
	// plotCmd.PersistentFlags().String(&amp;quot;foo&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;A help for foo&amp;quot;)

	// Cobra supports local flags which will only run when this command
	// is called directly, e.g.:
	// plotCmd.Flags().BoolP(&amp;quot;toggle&amp;quot;, &amp;quot;t&amp;quot;, false, &amp;quot;Help message for toggle&amp;quot;)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34; title=&#34;spf13/cobra: A Commander for modern Go CLI interactions&#34;&gt;&lt;code&gt;spf13/cobra&lt;/code&gt;&lt;/a&gt; パッケージで特徴的なのは，サブコマンドを追加する際に &lt;code&gt;cmd/root.go&lt;/code&gt; を変更する必要が無いことである。
サブコマンドの組み込みは &lt;code&gt;cmd&lt;/code&gt; パッケージ内の各ファイルに定義されている &lt;code&gt;init()&lt;/code&gt; 関数によって &lt;code&gt;main()&lt;/code&gt; 起動前に行われる。&lt;/p&gt;

&lt;p&gt;この状態で動かしてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go
A longer description that spans multiple lines and likely contains
examples and usage of using your application. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.

Usage:
  pi [command]

Available Commands:
  estmt       A brief description of your command
  plot        A brief description of your command

Flags:
      --config string   config file (default is $HOME/.pi.yaml)
  -t, --toggle          Help message for toggle

Use &amp;quot;pi [command] --help&amp;quot; for more information about a command.

$ go run main.go plot --help
A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.

Usage:
  pi plot [flags]

Global Flags:
      --config string   config file (default is $HOME/.pi.yaml)

$ go run main.go plot
plot called
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;問題なくサブコマンドが組み込まれていることがわかる。&lt;/p&gt;

&lt;h2 id=&#34;cli-の作成&#34;&gt;CLI の作成&lt;/h2&gt;

&lt;p&gt;では，生成されたテンプレートをベースに機能を組み込んでいく。 &amp;hellip;というわけで，出来上がりが以下の repository にある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/pi&#34;&gt;spiegel-im-spiegel/pi: Estimate of Pi with Monte Carlo method.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;フォルダ構成は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;github.com/spiegel-im-spiegel/pi
|   .editorconfig
|   .gitignore
|   glide.lock
|   glide.yaml
|   LICENSE
|   main.go
|   README.md
|
+---cmd
|       estmt.go
|       plot.go
|       root.go
|
+---estmt
|       estmt.go
|
+---gencmplx
|       gencmplx.go
|
+---genpi
|       genpi.go
|
\---plot
        plot.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして各パッケージの構成は以下のようになっている。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/estimate-of-pi.svg&#34;&gt;&lt;img srcset=&#34;http://text.baldanders.info/images/estimate-of-pi.svg 640w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;パッケージ構成&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;http://text.baldanders.info/images/estimate-of-pi.svg&#34;&gt;パッケージ構成&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi/&#34; title=&#34;モンテカルロ法による円周率の推定（その1）&#34;&gt;前回&lt;/a&gt;と変わったところは &lt;code&gt;genpi&lt;/code&gt; パッケージを追加したことだろうか。
こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package genpi

import (
	&amp;quot;math/cmplx&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/pi/gencmplx&amp;quot;
)

//New returns generator of Pi
func New(pc, ec int64) &amp;lt;-chan float64 {
	ch := make(chan float64)
	pcf := float64(pc)
	go func(pc, ec int64) {
		for i := int64(0); i &amp;lt; ec; i++ {
			c := gencmplx.New(rand.NewSource(time.Now().UnixNano()), pc)
			m := int64(0) // plot in circle
			for p := range c {
				if cmplx.Abs(p) &amp;lt;= float64(1) {
					m++
				}
			}
			ch &amp;lt;- float64(4*m) / pcf
		}
		close(ch)
	}(pc, ec)

	return ch
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定した回数だけ推定処理を行い，結果を &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; &lt;code&gt;ch&lt;/code&gt; に渡している。
たとえば100,000個の点から円周率を推定する処理を10回をしたければ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go estmt -e 10 -p 100000
3.14576
3.1422
3.13716
3.14648
3.14852
3.13952
3.14824
3.13828
3.14532
3.14312
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすればよい。&lt;/p&gt;

&lt;p&gt;これでようやく評価のための準備が整った。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://lab.flama.co.jp/archives/1536/&#34;&gt;GolangでCLIの場合にcobraを使うことにした件 | FLAMA技術Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/astronoka/items/aa2f271d280863cedf5e&#34;&gt;packageに複数のinitがあるときの挙動 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>モンテカルロ法による円周率の推定（その1） — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/estimate-of-pi/" />
		<id>tag:text.Baldanders.info,2016-11-05:/golang/estimate-of-pi/</id>
		<published>2016-11-05T23:26:29+09:00</published>
		<updated>2016-11-20T23:32:40+09:00</updated>
		<summary>乱数（random number）についていい例題がないかなぁ，と考えて「円周率をモンテカルロ法で求めるやつやればいいぢゃん」と思いついた。ので早速試してみる。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;乱数（random number）についていい例題がないかなぁ，と考えて「円周率をモンテカルロ法で求めるやつやればいいぢゃん」と思いついた。
ので早速試してみる。
ちなみに「モンテカルロ法」というのは数値計算やシミュレーションに乱数を用いる手法をさす。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi/&#34;&gt;モンテカルロ法による円周率の推定（その1）&lt;/a&gt; ← イマココ&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-2-cli/&#34;&gt;モンテカルロ法による円周率の推定（その2 CLI）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-3-gaussian/&#34;&gt;モンテカルロ法による円周率の推定（その3 Gaussian）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-4-prng/&#34;&gt;モンテカルロ法による円周率の推定（その4 PRNG）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;モンテカルロ法による円周率の推定&#34;&gt;モンテカルロ法による円周率の推定&lt;/h2&gt;

&lt;p&gt;では乱数を使ってどうやって円周率を求めるのか。
まずは以下のように原点を中心とした半径 $1$ の円を考える。
ただしここでは第一象限のみを対象とする。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/circle.png&#34;&gt;&lt;img srcset=&#34;http://text.baldanders.info/images/circle.png 500w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;&#34;&gt;&lt;/a&gt;

&lt;/figure&gt;

&lt;p&gt;そして $0 \le y \le 1$ および $0 \le y \le 1$ の範囲でランダムに点をプロットしていく。
（以下の&lt;a href=&#34;https://commons.wikimedia.org/wiki/File:Pi_30K.gif&#34; title=&#34;File:Pi 30K.gif - Wikimedia Commons&#34;&gt;図は Wikimedia Commons のもの&lt;/a&gt;を拝借した。 &lt;a href=&#34;https://creativecommons.org/licenses/by/3.0/&#34; title=&#34;Creative Commons — Attribution 3.0 Unported — CC BY 3.0&#34;&gt;CC-BY-3.0&lt;/a&gt; で公開されている）&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;https://commons.wikimedia.org/wiki/File:Pi_30K.gif&#34;&gt;&lt;img srcset=&#34;https://upload.wikimedia.org/wikipedia/commons/8/84/Pi_30K.gif 500w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;From Wikimedia Commons&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://commons.wikimedia.org/wiki/File:Pi_30K.gif&#34;&gt;From Wikimedia Commons&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;全ての点 $n$ が領域内に均等にプロットされていれば，円の内側に入る点の数 $m$ は，面積比から，以下の式のようになると期待できる。&lt;/p&gt;

&lt;figure&gt;
&lt;blockquote&gt;
\[
m \simeq \frac{1}{4}{\pi}n
\]
&lt;/blockquote&gt;

&lt;/figure&gt;

&lt;p&gt;この式を $\pi$ を求める形に変形すると&lt;/p&gt;

&lt;figure&gt;
&lt;blockquote&gt;
\[
\pi \simeq \frac{4m}{n}
\]
&lt;/blockquote&gt;

&lt;/figure&gt;

&lt;p&gt;となる。
プロットした点が円の内側かどうかは原点からの距離で判定できる。
すなわち&lt;/p&gt;

&lt;figure&gt;
&lt;blockquote&gt;
\[
\sqrt{x^2 + y^2} \le 1
\]
&lt;/blockquote&gt;

&lt;/figure&gt;

&lt;p&gt;を満たしていればよい。&lt;/p&gt;

&lt;h2 id=&#34;math-rand-パッケージ&#34;&gt;math/rand パッケージ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt; にはコア・パッケージとして &lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; が用意されていて，このパッケージを使って擬似乱数を発生させることができる。
今回は $0 \le r \le 1.0$ の範囲で乱数を発生させればいいのだが，生憎そのものズバリな関数が用意されていない。
たとえば &lt;code&gt;rand.Float64()&lt;/code&gt; が吐く値の範囲は $0 \le r \lt 1.0$ なのでそのままでは使えないのだ。&lt;/p&gt;

&lt;p&gt;そこで，こんなコードを考えてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	rand.Seed(time.Now().UnixNano())
	for i := 0; i &amp;lt; 10; i++ {
		fmt.Println(float64(rand.Int63n(10000001)) / float64(10000000))
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rand.Int63n(n)&lt;/code&gt; 関数は $0 \le i \lt n$ の範囲で整数を吐く。
$n=10,000,001$ なら $0 \le i \le 10,000,000$ の範囲になる。
これを $10,000,000$ で割って $0 \le r \le 1.0$ の範囲の乱数を作るのである。&lt;/p&gt;

&lt;p&gt;実際には2次元座標なので複素数（&lt;a href=&#34;https://golang.org/ref/spec#Complex_numbers&#34; title=&#34;Manipulating complex numbers&#34;&gt;complex&lt;/a&gt;）表現にして&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/cmplx&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	rand.Seed(time.Now().UnixNano())
	for i := 0; i &amp;lt; 10; i++ {
		c := complex(float64(rand.Int63n(10000001))/float64(10000000), float64(rand.Int63n(10000001))/float64(10000000))
		fmt.Printf(&amp;quot;%v (%v)\n&amp;quot;, c, cmplx.Abs(c))
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすればよい。
ちなみに &lt;code&gt;cmplx.Abs()&lt;/code&gt; 関数は複素数の絶対値を取るもので， $\sqrt{x^2 + y^2}$ と同じである。&lt;/p&gt;

&lt;p&gt;では，以上を踏まえてランダムな点を生成する &lt;code&gt;gencmplx&lt;/code&gt; パッケージを作ってみよう。
&lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; と &lt;a href=&#34;http://golang.org/ref/spec#Go_statements&#34;&gt;goroutine&lt;/a&gt; を使ってこんな感じにするかな。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package gencmplx

import &amp;quot;math/rand&amp;quot;

//New returns generator of random complex number
func New(s rand.Source, count int64) &amp;lt;-chan complex128 {
	ch := make(chan complex128)
	r := rand.New(s)
	go func(r *rand.Rand, count int64) {
		for i := int64(0); i &amp;lt; count; i++ {
			ch &amp;lt;- complex(float64(r.Int63n(10000001))/float64(10000000), float64(r.Int63n(10000001))/float64(10000000))
		}
		close(ch)
	}(r, count)
	return ch
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;後々のことを考えて，乱数の &lt;code&gt;rand.Source&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:s&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; と生成する点の個数は引数で指定するようにした。&lt;/p&gt;

&lt;p&gt;いっぽう， &lt;code&gt;gencmplx&lt;/code&gt; パッケージの呼び出し側はこんな感じになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/pi/gencmplx&amp;quot;
)

func main() {
	c := gencmplx.New(rand.NewSource(time.Now().UnixNano()), int64(10000))
	for p := range c {
		fmt.Printf(&amp;quot;%v\t%v\n&amp;quot;, real(p), imag(p))
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは少なめに1万個の点を生成している。
&lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; &lt;code&gt;c&lt;/code&gt; からの値の取り出しは for-range 構文を使うと記述がシンプルになり &lt;code&gt;c&lt;/code&gt; が &lt;code&gt;close()&lt;/code&gt; するまでループしてくれる。&lt;/p&gt;

&lt;p&gt;早速これを動かしてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main.go &amp;gt; plot-1.dat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで1万個の点を &lt;code&gt;plot-1.dat&lt;/code&gt; に格納したことになる。
&lt;code&gt;plot-1.dat&lt;/code&gt; を &lt;a href=&#34;http://www.gnuplot.info/&#34; title=&#34;gnuplot homepage&#34;&gt;gnuplot&lt;/a&gt; に食わせてみるとこんな感じ。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;img srcset=&#34;http://text.baldanders.info/images/random-plot-1.png 500w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;&#34;&gt;

&lt;/figure&gt;

&lt;p&gt;うーん。
均等？ なのかなぁ。
まぁ，この辺の評価については「&lt;a href=&#34;http://text.baldanders.info/golang/estimate-of-pi-3-gaussian/&#34; title=&#34;モンテカルロ法による円周率の推定（その3 Gaussian）&#34;&gt;その3&lt;/a&gt;」以降で。&lt;/p&gt;

&lt;p&gt;最後に，生成した点の集合から円周率を推定するところまでやってみよう。
&lt;code&gt;main()&lt;/code&gt; 関数はこのように変える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/cmplx&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/pi/gencmplx&amp;quot;
)

func main() {
	c := gencmplx.New(rand.NewSource(time.Now().UnixNano()), int64(100000))
	n := int64(0) // total
	m := int64(0) // plot in circle
	for p := range c {
		n++
		if cmplx.Abs(p) &amp;lt;= float64(1) {
			m++
		}
	}
	fmt.Printf(&amp;quot;n = %v, m = %v, 4m/n = %v\n&amp;quot;, n, m, float64(4*m)/float64(n))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;点の数は10万個まで増やしている。
実行結果は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main2.go
n = 100000, m = 78397, 4m/n = 3.13588
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と，まぁそれっぽい値が出てきた。&lt;/p&gt;

&lt;p&gt;今回はここまで。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ruby.kyoto-wu.ac.jp/info-com/NumericalModels/RandomProcess/montecarlo.html&#34;&gt;モンテカルロ法入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/intelfike/items/039eccffd422321ec6dd&#34;&gt;golang complex(複素数)型を使う - Qiita&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/intelfike/items/f92f5c9ff2e515e16d47&#34;&gt;golang complex(複素数)型の計算をする - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cse.kyoto-su.ac.jp/~oomoto/lecture/program/gnuplot/gnuplot.html&#34;&gt;GNUPLOTを用いたグラフ作成&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1FO/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/416jAxVU4NL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1FO/baldandersinf-22/&#34;&gt;数学ガール／乱択アルゴリズム&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;結城 浩 &lt;/dd&gt;&lt;dd&gt;SBクリエイティブ株式会社 2014-02-14&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1D6/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1D6.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／ゲーデルの不完全性定理&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1CM/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1CM.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／フェルマーの最終定理&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMK4/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00L0PDMK4.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール／ガロア理論&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00EYXMA9I/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00EYXMA9I.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガール&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00L0PDMIQ/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00L0PDMIQ.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;数学ガールの秘密ノート／式とグラフ&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34; &gt;工学ガール，リサちゃん登場！&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#34;#maker&#34; class=&#34;reviewer&#34;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2015-04-19&#34;&gt;2015/04/19&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34;&gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:s&#34;&gt;&lt;code&gt;rand.Source&lt;/code&gt; は &lt;a href=&#34;https://golang.org/doc/effective_go.html#interfaces_and_types&#34; title=&#34;Effective Go - The Go Programming Language&#34;&gt;interface&lt;/a&gt; として定義されていて，これを満たす &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; であれば他の擬似乱数アルゴリズムも使えるようになっている。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Error の構造化 — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/error-handling2/" />
		<id>tag:text.Baldanders.info,2016-11-03:/golang/error-handling2/</id>
		<published>2016-11-03T20:51:00+09:00</published>
		<updated>2016-11-08T20:41:58+09:00</updated>
		<summary>エラーハンドリングのために error を構造化する手段として github.com/pkg/errors というパッケージがあるそうだ。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回は「&lt;a href=&#34;http://text.baldanders.info/golang/error-handling/&#34;&gt;エラー・ハンドリングについて&lt;/a&gt;」の続き。
とりあえず，エラーハンドリングのデモ用にこんなパッケージを考える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package errdemo1

import &amp;quot;os&amp;quot;

// F returns error.
func F() error {
	file, err := os.Open(&amp;quot;not-exist.txt&amp;quot;)
	if err != nil {
		return err
	}
	defer file.Close()

	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呼び出し側の &lt;code&gt;main()&lt;/code&gt; 関数では，このパッケージを以下のようにハンドリングする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;errdemo/errdemo1&amp;quot;
)

func main() {
	if err := errdemo1.F(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}

	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;not-exist.txt&lt;/code&gt; が存在しない場合，実行結果は以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main1.go
open not-exist.txt: The system cannot find the file specified.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まぁハンドリングというか &lt;code&gt;Error()&lt;/code&gt; 関数が吐くエラー内容（文字列）を垂れ流してるだけだけど。
もし &lt;code&gt;errdemo1.F()&lt;/code&gt; 関数が返す &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; の &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; を知りたければ &lt;a href=&#34;https://golang.org/ref/spec#Conversions&#34; title=&#34;The Go Programming Language Specification - The Go Programming Language&#34;&gt;Conversion&lt;/a&gt; 構文を使って&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;errdemo/errdemo1&amp;quot;
)

func main() {
	if err := errdemo1.F(); err != nil {
		switch err.(type) {
		case *os.PathError:
			fmt.Fprintln(os.Stderr, &amp;quot;*os.PathError&amp;quot;)
		default:
		}
        fmt.Fprintln(os.Stderr, err)
		return
	}

	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように書ける&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
実行結果は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main2.go
*os.PathError
open not-exist.txt: The system cannot find the file specified.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。&lt;/p&gt;

&lt;p&gt;この方法の欠点は大元の &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を吐いた位置と &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; の伝達経路が分かりにくい点である。
&lt;code&gt;errdemo1.F()&lt;/code&gt; 関数で &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を拾ったら &lt;code&gt;errdemo1&lt;/code&gt; パッケージ専用の &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; に差し替えて呼び出し側に返す方法もあるが，単に &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を差し替えただけでは大元の &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; 情報が消失してしまう。
このようなことが起きるのは &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; 情報が構造化されていないことに原因がある。&lt;/p&gt;

&lt;p&gt;エラーハンドリングのために &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を構造化する手段として &lt;a href=&#34;https://github.com/pkg/errors&#34; title=&#34;pkg/errors: Simple error handling primitives&#34;&gt;&lt;code&gt;github.com/pkg/errors&lt;/code&gt;&lt;/a&gt; というパッケージがあるそうだ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2016/04/25/go-pkg-errors/&#34;&gt;Golangのエラー処理とpkg/errors | SOTA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/pkg/errors&#34; title=&#34;pkg/errors: Simple error handling primitives&#34;&gt;&lt;code&gt;github.com/pkg/errors&lt;/code&gt;&lt;/a&gt; パッケージは &lt;code&gt;go get&lt;/code&gt; コマンドで導入できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go get -v github.com/pkg/errors
github.com/pkg/errors (download)
github.com/pkg/errors
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるパッケージで大元の &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; 情報を含んだ &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; をセットする場合は &lt;code&gt;errors.Wrap()&lt;/code&gt; 関数を使う&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package errdemo2

import (
	&amp;quot;os&amp;quot;

	&amp;quot;github.com/pkg/errors&amp;quot;
)

// F returns error.
func F() error {
	file, err := os.Open(&amp;quot;not-exist.txt&amp;quot;)
	if err != nil {
		return errors.Wrap(err, &amp;quot;Error by F() function&amp;quot;)
	}
	defer file.Close()

	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この &lt;code&gt;errdemo2&lt;/code&gt; パッケージを呼び出す側を以下のように書けば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;errdemo/errdemo2&amp;quot;
)

func main() {
	if err := errdemo2.F(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}

	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main3.go
Error by F() function: open not-exist.txt: The system cannot find the file specified.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また大元の &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を取得したければ &lt;code&gt;errors.Cause()&lt;/code&gt; 関数を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;errdemo/errdemo2&amp;quot;

	&amp;quot;github.com/pkg/errors&amp;quot;
)

func main() {
	if err := errdemo2.F(); err != nil {
		switch errors.Cause(err).(type) {
		case *os.PathError:
			fmt.Fprintln(os.Stderr, &amp;quot;*os.PathError&amp;quot;)
		default:
		}
		fmt.Fprintln(os.Stderr, err)
		return
	}

	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合の実行結果は以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go run main4.go
*os.PathError
Error by F() function: open not-exist.txt: The system cannot find the file specified.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに &lt;code&gt;errors.Cause()&lt;/code&gt; 関数の中身はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Cause returns the underlying cause of the error, if possible.
// An error value has a cause if it implements the following
// interface:
//
//     type causer interface {
//            Cause() error
//     }
//
// If the error does not implement Cause, the original error will
// be returned. If the error is nil, nil will be returned without further
// investigation.
func Cause(err error) error {
	type causer interface {
		Cause() error
	}

	for err != nil {
		cause, ok := err.(causer)
		if !ok {
			break
		}
		err = cause.Cause()
	}
	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり &lt;code&gt;Cause()&lt;/code&gt; 関数を持つ &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; インスタンスであれば &lt;code&gt;Cause()&lt;/code&gt; 関数を辿って大元の &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; インスタンスを返すが， &lt;code&gt;Cause()&lt;/code&gt; 関数がない場合はそのまま引数の &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; インスタンスを返す。&lt;/p&gt;

&lt;p&gt;このように &lt;a href=&#34;https://github.com/pkg/errors&#34; title=&#34;pkg/errors: Simple error handling primitives&#34;&gt;&lt;code&gt;github.com/pkg/errors&lt;/code&gt;&lt;/a&gt; パッケージを使えば &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を構造的に，かつ手軽に扱うことができる。
とても便利なパッケージなので是非活用したいところである。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/deeeet/items/dacc71932393ab35d9f8&#34;&gt;Golangでエラー時にスタックトレースを表示する - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/410V3ulwP5L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go (ADDISON-WESLEY PROFESSIONAL COMPUTING SERIES)&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-20&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;5&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-5-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4798142417/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4798142417.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;スターティングGo言語 (CodeZine BOOKS)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4865940391/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4865940391.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Kotlinスタートブック -新しいAndroidプログラミング&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4839959234/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4839959234.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Docker実戦活用ガイド&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4274218961/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4274218961.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;グッド・マス ギークのための数・論理・計算機科学&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-07-13&#34;&gt;2016-07-13&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;実際にはこのような &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; の判別はパッケージ側で提供すべきなのだろうが，今回はコードの比較のためにこんな書き方をしている。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;追加する文字列部分を書式文字列とパラメータで指定する &lt;code&gt;errors.Wrapf()&lt;/code&gt; 関数も用意されている。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>関数とポインタ — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/function-and-pointer/" />
		<id>tag:text.Baldanders.info,2016-03-29:/golang/function-and-pointer/</id>
		<published>2016-03-29T22:16:41+09:00</published>
		<updated>2016-11-08T20:41:58+09:00</updated>
		<summary>Go 言語の引数は基本的に「値渡し（call by value）」である。「参照渡し（call by reference）」にしたい場合はポインタを使う。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;いまさらな内容なのだが覚え書きとして記しておく。&lt;/p&gt;

&lt;h2 id=&#34;go-言語における-calling-sequence&#34;&gt;Go 言語における Calling Sequence&lt;/h2&gt;

&lt;p&gt;まずは簡単な足し算の関数を定義してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x int, y int) int {
	return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;add&lt;/code&gt; に続く括弧内が引数を定義していて，括弧の後ろの &lt;code&gt;int&lt;/code&gt; は返り値の型&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:t&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:t&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; を示している。
&lt;code&gt;add()&lt;/code&gt; 関数を呼び出すには以下のように記述する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func add(x, y int) int {
	return x + y
}

func main() {
	ans := add(42, 13)
	fmt.Println(ans)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は同じ int 型なので以下のように記述することもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y int) int {
	return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値として複数の値を定義することもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func split(sum int) (int, int) {
	x = sum * 4 / 9
	y = sum - x
	return x, y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また返り値は以下のように名前をつけることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y int) (ans int) {
	ans = x + y
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の &lt;code&gt;return&lt;/code&gt; がないとコンパイル・エラーになるので注意。
この書き方は &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;defer&lt;/a&gt; 構文と組み合わせるときに威力を発揮する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	err := r()
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(&amp;quot;Normal End.&amp;quot;)
	}
}

func r() (err error) {
	defer func() {
		if rec := recover(); rec != nil {
			err = fmt.Errorf(&amp;quot;Recovered from: %v&amp;quot;, rec)
		}
	}()

	f()
	err = nil
	return
}

func f() {
	panic(&amp;quot;Panic!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコード&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:p&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:p&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; では &lt;code&gt;r()&lt;/code&gt; 関数内で &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を捕まえ， 返り値の &lt;code&gt;err&lt;/code&gt; に値をセットしなおしている。&lt;/p&gt;

&lt;h3 id=&#34;go-言語の引数は-値渡し&#34;&gt;Go 言語の引数は「値渡し」&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の引数は基本的に「値渡し（call by value）」である。
たとえば先程の足し算を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y int) int {
	x += y
	return x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義した場合でも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func add(x, y int) int {
	x += y
	return x
}

func main() {
    x := 42
    y := 13
	ans := add(x, y)
	fmt.Printf(&amp;quot;%d + %d = %d\n&amp;quot;, x, y, ans) //output: 42 + 13 = 55
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呼び出し元で &lt;code&gt;add()&lt;/code&gt; 関数の引数に渡した instance は関数実行後も変化しない。
このため「値渡し」は thread safe なコードに向いている。
たとえば value object を構成する際には関連する関数は「値渡し」のほうが安全である。
ただし関数呼び出し時に instance の値が常にコピーされるため&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:copy&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:copy&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，サイズの大きな instance の場合は呼び出し時のコストが高くなる。&lt;/p&gt;

&lt;p&gt;引数を「参照渡し（call by reference）」にしたい場合はポインタを使う。
つまり instance のポインタ値を渡すのである。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func add(x, y *int) int {
	*x += *y
	return *x
}

func main() {
	x := 42
	y := 13
	ans := add(&amp;amp;x, &amp;amp;y)
	fmt.Printf(&amp;quot;%d + %d = %d\n&amp;quot;, x, y, ans) //output: 55 + 13 = 55
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードでは &lt;code&gt;add()&lt;/code&gt; 関数実行後の &lt;code&gt;x&lt;/code&gt; の値が変更されている。
内部状態を持つ instance を引数に指定する場合は参照渡しにする必要がある。
しかし引数を参照渡しにすると関数実行が thread safe でなくなる可能性がある。
また引数の値が nil の場合も考慮する必要がある。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では通常の方法ではポインタ演算ができない。
たとえば，ついうっかり&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y *int) int {
	x += y
	return *x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とか書いてしまっても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;invalid operation: x += y (operator + not defined on pointer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とコンパイル・エラーになる。
ポインタ演算が必要な場合は &lt;a href=&#34;https://golang.org/pkg/unsafe/&#34; title=&#34;unsafe - The Go Programming Language&#34;&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; パッケージを使う。&lt;/p&gt;

&lt;h3 id=&#34;slice-map-channel-は常に-参照渡し&#34;&gt;Slice, Map, Channel は常に「参照渡し」&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Map_types&#34;&gt;map&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; は組み込み型だが内部状態を持つ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:make&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:make&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。
したがって，これらの型の instance を引数に渡す場合はつねに「参照渡し」になる（つまり instance のコピーは発生しない）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func setItem(ary map[int]int, index, item int) {
	ary[index] = item
}

func main() {
    ary := map[int]int{0: 0}
	fmt.Println(ary) //output: map[0:0]
	setItem(ary, 0, 1)
	fmt.Println(ary) //output: map[0:1]
	setItem(ary, 10, 10)
	fmt.Println(ary) //output: map[0:1 10:10]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし固定の配列や &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:str&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:str&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; の instance は「値」として振る舞うため&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:n&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:n&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;，引数に指定した場合も「値渡し」になる。
&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; とは挙動が異なるためテキトーなコードを書いていると混乱しやすい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func setItem(ary [4]int, index, item int) {
	ary[index] = item
}

func main() {
	ary := [4]int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	setItem(ary, 1, 10)
	fmt.Println(ary) //output: [0 1 2 3]
	ary[2] = 200
	fmt.Println(ary) //output: [0 1 200 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;固定配列や &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型を「参照渡し」にしたい場合はやはりポインタ値を渡す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func setItem(ary *[4]int, index, item int) {
	(*ary)[index] = item
}

func main() {
	ary := [4]int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	setItem(&amp;amp;ary, 1, 10)
	fmt.Println(ary) //output: [0 10 2 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際には &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型の instance は「不変（immutable）」なので「参照渡し」が必要な局面はほとんど無いと思われる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:s&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;。
固定配列は不変ではないが，配列を操作するのであれば固定配列ではなく &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; のほうが扱いやすい。
たとえば上のコードでは &lt;code&gt;ary := []int{0, 1, 2, 3}&lt;/code&gt; と初期化すれば &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; として扱える。&lt;/p&gt;

&lt;h2 id=&#34;method-receiver&#34;&gt;Method Receiver&lt;/h2&gt;

&lt;p&gt;ある型に関数を関連付ける場合は method receiver を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Vertex struct {
	X int
	Y int
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(v Vertex)&lt;/code&gt; の部分が method receiver である。
&lt;code&gt;Add()&lt;/code&gt; 関数を呼び出すには以下のように記述する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := Vertex{X: 1, Y: 2}
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)  //output: X = 1, Y = 2
	fmt.Println(vv) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数の calling sequence としては &lt;code&gt;v.Add(dv)&lt;/code&gt; と &lt;code&gt;Vertex.Add(v, dv)&lt;/code&gt; は等価である。
つまり &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;Add()&lt;/code&gt; 関数の0番目の引数として振る舞い，「値渡し」でセットされる。&lt;/p&gt;

&lt;p&gt;Method receiver の型をポインタ型にすれば「参照渡し」にできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := &amp;amp;Vertex{X: 1, Y: 2}
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合も calling sequence としては &lt;code&gt;v.Add(dv)&lt;/code&gt; と &lt;code&gt;(*Vertex).Add(v, dv)&lt;/code&gt; は等価である。&lt;/p&gt;

&lt;h3 id=&#34;method-receiver-の暗黙的変換&#34;&gt;Method Receiver の暗黙的変換&lt;/h3&gt;

&lt;p&gt;Method receiver を「値渡し」にした場合，呼び出し元の instance がポインタ型であっても暗黙的に「値渡し」に変換される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := &amp;amp;Vertex{X: 1, Y: 2} //pointer
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)  //output: X = 1, Y = 2
	fmt.Println(vv) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Method receiver を「参照渡し」にした場合も暗黙的に「参照渡し」に変換される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := Vertex{X: 1, Y: 2} //not pointer
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;method-receiver-の値が-nil-の場合&#34;&gt;Method Receiver の値が nil の場合&lt;/h3&gt;

&lt;p&gt;Method receiver の値が nil の場合はどうなるか。
まずは「値渡し」の場合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := (*Vertex)(nil) //nil
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)
	fmt.Println(vv)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合は &lt;code&gt;Add()&lt;/code&gt; 関数呼び出し時に &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; になる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;panic: runtime error: invalid memory address or nil pointer dereference
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まぁこれは分かりやすいよね。
では「参照渡し」の場合はどうなるか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := (*Vertex)(nil) //nil
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: &amp;lt;nil&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は &lt;code&gt;Add()&lt;/code&gt; 関数呼び出し時点では &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; にはならない。
上のコードでは &lt;code&gt;v&lt;/code&gt; に nil が渡される。
したがって &lt;code&gt;Add()&lt;/code&gt; 関数内の条件文を削除すると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (v *Vertex) Add(dv Vertex) {
	v.X += dv.X
	v.Y += dv.Y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;v&lt;/code&gt; 内の要素を参照としたところで &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; になる。
Method receiver を「参照渡し」にする場合は nil 値に注意する必要がある。&lt;/p&gt;

&lt;h2 id=&#34;for-range-構文も-値渡し&#34;&gt;for-range 構文も「値渡し」&lt;/h2&gt;

&lt;p&gt;余談だが for-range 構文も「値渡し」（つまりコピーが発生する）なので注意が必要である。
たとえば以下のコードで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	ary := []int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	for _, item := range ary {
		item += 10
	}
	fmt.Println(ary) //output: [0 1 2 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for-range 構文内の &lt;code&gt;item&lt;/code&gt; は &lt;code&gt;ary&lt;/code&gt; 内の要素を指すのではなく要素のコピーである。
したがって &lt;code&gt;item&lt;/code&gt; を操作しても &lt;code&gt;ary&lt;/code&gt; には影響しない。
&lt;code&gt;ary&lt;/code&gt; 内の要素を操作するのであれば素朴に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	ary := []int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	for i := 0; i &amp;lt; len(ary); i++ {
		ary[i] += 10
	}
	fmt.Println(ary) //output: [10 11 12 13]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするしかない。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://skatsuta.github.io/2015/12/29/value-receiver-pointer-receiver/&#34;&gt;Go 言語の値レシーバとポインタレシーバ | Step by Step&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:t&#34;&gt;型については「&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」&lt;/a&gt;」を参照のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:t&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:p&#34;&gt;このコードについては「&lt;a href=&#34;http://text.baldanders.info/golang/error-handling/&#34;&gt;エラー・ハンドリングについて&lt;/a&gt;」で解説している。ちなみに &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を潰して error を返すのはエラー・ハンドリングとしてはいいやり方ではない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:p&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:copy&#34;&gt;値がどこにコピーされるかは型によって異なる。 &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 以外の基本型は値がスタックに積まれる。 &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; および基本型以外はヒープ領域に値がコピーされそのポインタがスタックに積まれる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:copy&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:make&#34;&gt;&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Map_types&#34;&gt;map&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; は内部状態を持つため &lt;code&gt;new()&lt;/code&gt; 関数ではなく &lt;code&gt;make()&lt;/code&gt; 関数で instance を生成する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:make&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:str&#34;&gt;&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型の実体は &lt;code&gt;[]byte&lt;/code&gt; 型である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:str&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:n&#34;&gt;たとえば固定の配列や &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型の instance は nil 値を持たない。 &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型のゼロ値は空文字列である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:n&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:s&#34;&gt;このような需要としては文字列操作で「NULL 状態」が必要な場合であろう。たとえば DBMS にアクセスする場合は NULL 状態を扱う必要がある。なお &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のコア・パッケージには &lt;a href=&#34;https://golang.org/pkg/database/sql/&#34; title=&#34;sql - The Go Programming Language&#34;&gt;&lt;code&gt;database/sql&lt;/code&gt;&lt;/a&gt; があり &lt;code&gt;NullString&lt;/code&gt; を使うことにより NULL 状態を扱える。このように NULL 状態を扱う必要がある場合は，直にポインタ操作するのではなく，何らかの value object を用意してカプセル化するほうが安全である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>「ズンドコチェック」なるものが流行っているらしい — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/zundoko-choir/" />
		<id>tag:text.Baldanders.info,2016-03-12:/golang/zundoko-choir/</id>
		<published>2016-03-12T22:12:53+09:00</published>
		<updated>2016-03-16T17:35:35+09:00</updated>
		<summary>というわけで Go 言語で実装することを考えてみる。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Javaの講義、試験が「自作関数を作り記述しなさい」って問題だったから&lt;br&gt;「ズン」「ドコ」のいずれかをランダムで出力し続けて「ズン」「ズン」「ズン」「ズン」「ドコ」の配列が出たら「キ・ヨ・シ！」って出力した後終了って関数作ったら満点で単位貰ってた&lt;/p&gt;&amp;mdash; てくも (@kumiromilk) &lt;a href=&#34;https://twitter.com/kumiromilk/status/707437861881180160&#34;&gt;2016年3月9日&lt;/a&gt;&lt;/blockquote&gt;


&lt;/figure&gt;

&lt;p&gt;「習作（study）」としてはなかなか秀逸なアイデアだと思う。
これで満点くれる教官も流石だが（笑） 巷では「ズンドコキヨシ」とか「キヨシチェック」とか「ズンドコチェック」とか呼ばれているらしい。&lt;/p&gt;

&lt;p&gt;というわけで&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;「ズン」「ドコ」のいずれかをランダムで出力し続けて「ズン」「ズン」「ズン」「ズン」「ドコ」の配列が出たら「キ・ヨ・シ！」って出力した後終了って関数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;を &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で実装することを考えてみる。
私はコレを「ズンドコ・コール（zundoko-choir）」と呼ぶことにする。&lt;/p&gt;

&lt;p&gt;とはいえ，ズンドコ・コールを実装する事自体はそう難しくない。
たとえばこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;
)

const (
	zun     = &amp;quot;ズン&amp;quot;
	doko    = &amp;quot;ドコ&amp;quot;
	kiyoshi = &amp;quot;キ・ヨ・シ！&amp;quot;
)

func generate() chan string {
	ch := make(chan string)
	go func() {
		var zundoko = [2]string{zun, doko}
		rand.Seed(time.Now().UnixNano())
		for {
			ch &amp;lt;- zundoko[rand.Intn(2)]
		}
	}()
	return ch
}

func main() {
	zundoko := generate()
	zcount := 0
	for {
		zd := &amp;lt;-zundoko
		fmt.Print(zd)
		if zd == zun {
			zcount++
		} else if zcount &amp;gt;= 4 {
			break
		} else {
			zcount = 0
		}
	}
	fmt.Print(kiyoshi)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「ズン」および「ドコ」をランダムに生成する部分は &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; と &lt;a href=&#34;http://golang.org/ref/spec#Go_statements&#34;&gt;goroutine&lt;/a&gt; を使えばいいだろう（&lt;code&gt;generate()&lt;/code&gt; 関数内の処理）。
擬似乱数は厳密でなくてもいいので安直に &lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; を使うことにした&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:rand&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:rand&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
さらに「ズン」「ズン」「ズン」「ズン」「ドコ」の配列パターンのチェックだが，「ズン」が4回以上連続で来た直後に「ドコ」が来たら OK としてみた。
まぁ，これがもっとも素朴な実装でパフォーマンスとしてもそれほど遜色ない筈。&lt;/p&gt;

&lt;p&gt;と，ここまで考えてハタと気づいた。
問題は「自作関数を作り記述しなさい」なんだからメイン関数にロジック書いたらアカンやん！&lt;/p&gt;

&lt;p&gt;というわけでまたもゴリゴリとコードを書いてパッケージにしてしまった。
アホだ，私（笑）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/zundoko&#34;&gt;spiegel-im-spiegel/zundoko: Zundoko-choirs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;出力は標準出力に直書きするのではなく &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; の &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; に &lt;code&gt;append()&lt;/code&gt; することで実現する。
この出力先を &lt;code&gt;Choirs&lt;/code&gt; 型として定義した。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Choirs - zundoko-choirs list
type Choirs struct {
	c []string
}

//Push is append choirs
func (c *Choirs) Push(s string) {
	c.c = append(c.c, s) //maybe panic if c is nil.
}

func (c *Choirs) String() string {
	if c == nil {
		return &amp;quot;&amp;quot;
	}
	content := make([]byte, 0, 128)
	for _, s := range c.c {
		content = append(content, s...)
	}
	return string(content)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに文字列の連結は &lt;a href=&#34;https://golang.org/pkg/strings/&#34; title=&#34;strings - The Go Programming Language&#34;&gt;&lt;code&gt;strings&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Join()&lt;/code&gt; 関数は使わず「&lt;a href=&#34;http://text.baldanders.info/golang/join-strings/&#34; title=&#34;文字列連結はどれが速い？ — プログラミング言語 Go&#34;&gt;文字列連結はどれが速い？&lt;/a&gt;」で紹介した方法を使っている。&lt;/p&gt;

&lt;p&gt;これで最初のコードは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func generate() chan string {
	ch := make(chan string)
	go func() {
		var zd = [2]string{Zun, Doko}
		rand.Seed(time.Now().UnixNano())
		for {
			ch &amp;lt;- zd[rand.Intn(2)]
		}
	}()
	return ch
}

//Run zundoko-choirs
func Run() *Choirs {
	zd := generate()
	c := &amp;amp;Choirs{make([]string, 0)}
	zcount := 0
	for {
		s := &amp;lt;-zd
		c.Push(s)
		if s == Zun {
			zcount++
		} else if zcount &amp;gt;= 4 {
			break
		} else {
			zcount = 0
		}
	}
	c.Push(Kiyoshi)
	return c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書き換えることができる。
このパッケージを呼び出すメイン側は例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/zundoko&amp;quot;
)

func main() {
	c := zundoko.Run()
	fmt.Println(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書けばいい。&lt;/p&gt;

&lt;p&gt;ところで「ズン」「ドコ」の出力は &lt;code&gt;Choirs&lt;/code&gt; 型で保持られているので，末尾の5要素のパターンを調べる別の方法もあると気づく。
たとえばこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var matchingPattern = []string{Zun, Zun, Zun, Zun, Doko}

func (c *Choirs) match() bool {
	if c == nil {
		return false
	}
	if len(c.c) &amp;lt; 5 {
		return false
	}
	return reflect.DeepEqual(c.c[len(c.c)-5:], matchingPattern)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この関数を使えば &lt;code&gt;Run()&lt;/code&gt; 関数は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Run2 zundoko-choirs (another logic)
func Run2() *Choirs {
	zd := generate()
	c := &amp;amp;Choirs{make([]string, 0)}
	for {
		s := &amp;lt;-zd
		c.Push(s)
		if c.match() {
			break
		}
	}
	c.Push(Kiyoshi)
	return c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり随分すっきりする。
ただこれコストが高くつきそうである。
というわけで，これも調べてみた。
まず以下のベンチマークを書く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package zundoko

import &amp;quot;testing&amp;quot;

func BenchmarkRun1(b *testing.B) {
	for i := 0; i &amp;lt; b.N; i++ {
		Run()
	}
}

func BenchmarkRun2(b *testing.B) {
	for i := 0; i &amp;lt; b.N; i++ {
		Run2()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;BenchmarkRun1&lt;/code&gt; が従来のもの， &lt;code&gt;BenchmarkRun2&lt;/code&gt; が先程の &lt;code&gt;match()&lt;/code&gt; 関数を使ったバージョンである。
結果は以下のとおり。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go test -bench Run -benchmem
testing: warning: no tests to run
PASS
BenchmarkRun1-4    50000     28141 ns/op    1800 B/op     9 allocs/op
BenchmarkRun2-4    30000     40102 ns/op    3912 B/op   115 allocs/op
ok      github.com/spiegel-im-spiegel/zundoko   4.261s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;乱数の要素が絡むので毎回同じ値ではないが，傾向としてはこんな感じ。
&lt;code&gt;BenchmarkRun2&lt;/code&gt; のほうが allocation 回数が圧倒的に多いのが分かるだろう。
これがスピードにもダイレクトに反映されている感じである。&lt;/p&gt;

&lt;p&gt;今回は「「ズン」が4回以上連続で来た直後に「ドコ」が来たら OK」という単純なロジックだったが，もっと複雑なパターンが要求される場合は工夫が必要かもしれない&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:lr&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:lr&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;「ズン」と「ドコ」の出現回数を数える関数も作ってみた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//CountZunDoko returns count of &amp;quot;ZUN&amp;quot; and &amp;quot;DOKO&amp;quot; choirs
func (c *Choirs) CountZunDoko() (int, int) {
	z := 0
	d := 0
	if c == nil {
		return z, d
	}
	for _, s := range c.c {
		switch s {
		case Zun:
			z++
		case Doko:
			d++
		}
	}
	return z, d
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;たとえば &lt;code&gt;generate()&lt;/code&gt; 関数内で使っている擬似乱数パッケージを別のものに換えた時に統計処理で簡単な性能評価ができるかもしれない。
今回はそこまではしなけど（擬似乱数の話はいずれやりたい）。&lt;/p&gt;

&lt;p&gt;こうやって手遊びでコードを弄るのは楽しいものである。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/shunsugai@github/items/971a15461de29563bf90&#34;&gt;ズンドコキヨシまとめ - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/shinderuman@github/items/2ff67c2404647d2b7ea6&#34;&gt;ズンドコキヨシ with Go (n番煎じ) - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/Rompei/items/bfa03fbc9a94a37703bb&#34;&gt;ズンドコキヨシGolang並列版 - Qiita&lt;/a&gt; : 「ズン」「ドコ」の生成部分を CPU の数だけ並列処理で行わせてひとつの &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; に入力するというユニークな実装&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/6a5bc07dbfa46a328e26&#34;&gt;「ズンドコキヨシ」と擬似乱数 - Qiita&lt;/a&gt; : Qiita で擬似乱数について簡単にまとめてみた。整理できたらこちらでも記事にするかも&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/41aCueik45L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-15&lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117607/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117607.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;マイクロサービスアーキテクチャ&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117402/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117402.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;ハイパフォーマンスPython&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/0134190440/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/0134190440.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;The Go Programming Language (Addison-Wesley Professional Computing Series)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4774166340/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4774166340.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Vim script テクニックバイブル ~Vim使いの魔法の杖&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。買おうかどうか悩み中。目次があればなぁ。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-03-12&#34;&gt;2016-03-12&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:rand&#34;&gt;&lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; の乱数生成アルゴリズムの既定は線形合同法らしい。&lt;a href=&#34;http://www001.upp.so-net.ne.jp/isaku/rand.html&#34; title=&#34;良い乱数・悪い乱数&#34;&gt;線形合同法は性能が良くなく&lt;/a&gt;ゲームや暗号等では使えない。&lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; の乱数生成アルゴリズムは他のものに入れ替えることができる。たとえば &lt;a href=&#34;https://github.com/seehuhn/mt19937&#34; title=&#34;seehuhn/mt19937: An implementation of Takuji Nishimura&#39;s and Makoto Matsumoto&#39;s Mersenne Twister pseudo random number generator in Go.&#34;&gt;&lt;code&gt;seehuhn/mt19937&lt;/code&gt;&lt;/a&gt; パッケージが使える。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:rand&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:lr&#34;&gt;たとえば &lt;a href=&#34;https://golang.org/pkg/container/list/&#34; title=&#34;list - The Go Programming Language&#34;&gt;&lt;code&gt;container/list&lt;/code&gt;&lt;/a&gt; や &lt;a href=&#34;https://golang.org/pkg/container/ring/&#34; title=&#34;ring - The Go Programming Language&#34;&gt;&lt;code&gt;container/ring&lt;/code&gt;&lt;/a&gt; といったパッケージを使う手がある。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:lr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Interface の謎 — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/interface/" />
		<id>tag:text.Baldanders.info,2016-02-22:/golang/interface/</id>
		<published>2016-02-22T19:22:33+09:00</published>
		<updated>2016-02-22T20:53:30+09:00</updated>
		<summary>Interface には落とし穴がある。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回も軽めの小ネタで。&lt;/p&gt;

&lt;p&gt;まず，文字列の配列を表示するだけの単純なコードを書いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	strlist := []string{&amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;gamma&amp;quot;}
	fmt.Println(strlist)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;[alpha beta gamma]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。
配列&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:s&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; の中身をそのままダンプ出力しているだけなので，まぁ当たり前っちゃあ当たり前。
では，配列のダンプではなくきちんと項目を列挙したいとしよう。
やり方は色々あるが簡単に &amp;ldquo;&lt;code&gt;...&lt;/code&gt;” トークンを使って&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	strlist := []string{&amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;gamma&amp;quot;}
	fmt.Println(strlist...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と配列を展開すればいんじゃね？ って思うよね，普通。
&lt;a href=&#34;https://golang.org/pkg/fmt/&#34; title=&#34;fmt - The Go Programming Language&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Println()&lt;/code&gt; 関数の定義を見ても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Println(a ...interface{}) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっているし，問題ないように見える。&lt;/p&gt;

&lt;p&gt;でもこれはうまくいかない。
これを実行しようとすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;prog.go:7: cannot use strlist (type []string) as type []interface {} in argument to fmt.Println
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とエラーになる。&lt;/p&gt;

&lt;p&gt;実は &lt;code&gt;[]string&lt;/code&gt; 型の &lt;code&gt;strlist&lt;/code&gt; は &lt;a href=&#34;https://golang.org/pkg/fmt/&#34; title=&#34;fmt - The Go Programming Language&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Println()&lt;/code&gt; 関数に渡す際に &lt;code&gt;[]interface{}&lt;/code&gt; 型ではなく &lt;code&gt;interface{}&lt;/code&gt; 型に&lt;strong&gt;必ず&lt;/strong&gt;キャストされる。
だから &lt;code&gt;strlist...&lt;/code&gt; と展開しようとしても「そりゃあ無理（←超意訳）」と怒られてしまうわけだ。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の型（&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt;）は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Msg []string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように配列やポインタも型として定義できてしまうことを&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;思い出して&lt;/a&gt;欲しい。&lt;/p&gt;

&lt;p&gt;じゃあ，明示的なキャストならいけるのかと思ったが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Msg []string

func main() {
	strlist := []string{&amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;gamma&amp;quot;}
	fmt.Println(([]interface{})(strlist)...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;prog.go:9: cannot convert strlist (type []string) to type []interface {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と，これもエラーになった。&lt;/p&gt;

&lt;p&gt;ではどうすればいいのかというと &lt;code&gt;[]interface{}&lt;/code&gt; 型の配列を用意してそこに値をコピーする。
先程のコードであれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Msg []string

func main() {
	strlist := []string{&amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;gamma&amp;quot;}
	var list = make([]interface{}, 0)
	for _, str := range strlist {
		list = append(list, str)
	}
	fmt.Println(list...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;alpha beta gamma
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにめでたく列挙される。
この問題は &lt;a href=&#34;https://golang.org/pkg/fmt/&#34; title=&#34;fmt - The Go Programming Language&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Println()&lt;/code&gt; 関数だけじゃなく，ある型の配列を &lt;code&gt;[]interface{}&lt;/code&gt; 型にキャストしようとする際は必ず発生するようだ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:c&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:c&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;いや，「“&lt;code&gt;cannot use strlist (type []string) as type []interface {} in argument to fmt.Println&lt;/code&gt;” なんてコンパイルエラーを出せるならコンパイラ側でなんとかしてよ」と思うのだが，どうも無理らしい。&lt;/p&gt;

&lt;p&gt;やれやれ。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@tucnak/why-go-is-a-poorly-designed-language-1cc04e5daf2#.ucutrogyz&#34;&gt;Why Go is a poorly designed language — Medium&lt;/a&gt; （&lt;a href=&#34;http://postd.cc/why-go-is-a-poorly-designed-language/&#34;&gt;日本語訳&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/wiki/InterfaceSlice&#34;&gt;InterfaceSlice · golang/go Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:s&#34;&gt;厳密には &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;。分かってますよ，もちろん。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:c&#34;&gt;例えば &lt;code&gt;list&lt;/code&gt; に &lt;code&gt;strlist&lt;/code&gt; の内容をコピーする際に for 文で回すのではなく &lt;code&gt;list = append(list, strlist...)&lt;/code&gt; でできるかどうか試してみればいい。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:c&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Travis CI でクロス・コンパイル — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/cross-compiling-in-travis-ci/" />
		<id>tag:text.Baldanders.info,2016-02-13:/golang/cross-compiling-in-travis-ci/</id>
		<published>2016-02-13T19:37:11+09:00</published>
		<updated>2016-02-25T09:39:28+09:00</updated>
		<summary>今回は Travis CI から GitHub へ mitchellh/gox で生成した実行バイナリを deploy することを考える。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;h2 id=&#34;gox-でまとめてクロス-コンパイル&#34;&gt;Gox でまとめてクロス・コンパイル&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の特徴のひとつにクロス・コンパイルの容易さがあるが，複数プラットフォームのビルドをまとめて行う &lt;a href=&#34;https://github.com/mitchellh/gox&#34; title=&#34;mitchellh/gox: A dead simple, no frills Go cross compile tool&#34;&gt;mitchellh/gox&lt;/a&gt; を使うと便利である。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go get github.com/mitchellh/gox

$gox -h
Usage: gox [options] [packages]

  Gox cross-compiles Go applications in parallel.

  If no specific operating systems or architectures are specified, Gox
  will build for all pairs supported by your version of Go.

Options:

  -arch=&amp;quot;&amp;quot;            Space-separated list of architectures to build for
  -build-toolchain    Build cross-compilation toolchain
  -cgo                Sets CGO_ENABLED=1, requires proper C toolchain (advanced)
  -gcflags=&amp;quot;&amp;quot;         Additional &#39;-gcflags&#39; value to pass to go build
  -ldflags=&amp;quot;&amp;quot;         Additional &#39;-ldflags&#39; value to pass to go build
  -tags=&amp;quot;&amp;quot;            Additional &#39;-tags&#39; value to pass to go build
  -os=&amp;quot;&amp;quot;              Space-separated list of operating systems to build for
  -osarch=&amp;quot;&amp;quot;          Space-separated list of os/arch pairs to build for
  -osarch-list        List supported os/arch pairs for your Go version
  -output=&amp;quot;foo&amp;quot;       Output path template. See below for more info
  -parallel=-1        Amount of parallelism, defaults to number of CPUs
  -rebuild            Force rebuilding of package that were up to date
  -verbose            Verbose mode

Output path template:

  The output path for the compiled binaries is specified with the
  &amp;quot;-output&amp;quot; flag. The value is a string that is a Go text template.
  The default value is &amp;quot;{{.Dir}}_{{.OS}}_{{.Arch}}&amp;quot;. The variables and
  their values should be self-explanatory.

Platforms (OS/Arch):

  The operating systems and architectures to cross-compile for may be
  specified with the &amp;quot;-arch&amp;quot; and &amp;quot;-os&amp;quot; flags. These are space separated lists
  of valid GOOS/GOARCH values to build for, respectively. You may prefix an
  OS or Arch with &amp;quot;!&amp;quot; to negate and not build for that platform. If the list
  is made up of only negations, then the negations will come from the default
  list.

  Additionally, the &amp;quot;-osarch&amp;quot; flag may be used to specify complete os/arch
  pairs that should be built or ignored. The syntax for this is what you would
  expect: &amp;quot;darwin/amd64&amp;quot; would be a valid osarch value. Multiple can be space
  separated. An os/arch pair can begin with &amp;quot;!&amp;quot; to not build for that platform.

  The &amp;quot;-osarch&amp;quot; flag has the highest precedent when determing whether to
  build for a platform. If it is included in the &amp;quot;-osarch&amp;quot; list, it will be
  built even if the specific os and arch is negated in &amp;quot;-os&amp;quot; and &amp;quot;-arch&amp;quot;,
  respectively.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;オプションは色々あるが，とりあえずパッケージを指定して起動すれば全てのプラットフォームについてビルドを行う&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:bt&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:bt&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
私が今つくってる &lt;a href=&#34;https://github.com/spiegel-im-spiegel/gpgpdump&#34; title=&#34;spiegel-im-spiegel/gpgpdump: gpgpdump - OpenPGP packet visualizer&#34;&gt;gpgpdump&lt;/a&gt; を例にすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go get get github.com/spiegel-im-spiegel/gpgpdump

$ gox -output &amp;quot;goxdist/{{.OS}}_{{.Arch}}/{{.Dir}}&amp;quot; github.com/spiegel-im-spiegel/gpgpdump

--&amp;gt;      netbsd/arm: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;   windows/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;   freebsd/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;      darwin/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;    darwin/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;       linux/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     linux/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;       linux/arm: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     freebsd/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;      netbsd/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     freebsd/arm: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;    netbsd/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;   openbsd/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     openbsd/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     windows/386: github.com/spiegel-im-spiegel/gpgpdump

$ ls -l goxdist
drwx 0 2016-02-13 17:41 darwin_386/
drwx 0 2016-02-13 17:41 darwin_amd64/
drwx 0 2016-02-13 17:42 freebsd_386/
drwx 0 2016-02-13 17:41 freebsd_amd64/
drwx 0 2016-02-13 17:42 freebsd_arm/
drwx 0 2016-02-13 17:41 linux_386/
drwx 0 2016-02-13 17:41 linux_amd64/
drwx 0 2016-02-13 17:42 linux_arm/
drwx 0 2016-02-13 17:42 netbsd_386/
drwx 0 2016-02-13 17:42 netbsd_amd64/
drwx 0 2016-02-13 17:41 netbsd_arm/
drwx 0 2016-02-13 17:42 openbsd_386/
drwx 0 2016-02-13 17:42 openbsd_amd64/
drwx 0 2016-02-13 17:42 windows_386/
drwx 0 2016-02-13 17:41 windows_amd64/

$ ls -l goxdist/windows_amd64
-rw- 5712896 2016-02-13 17:41 gpgpdump.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といい感じに出力してくれる。&lt;/p&gt;

&lt;p&gt;OS を指定する場合は &lt;code&gt;-os &amp;quot;linux windows&amp;quot;&lt;/code&gt; のように指定する。
アーキテクチャは &lt;code&gt;-arch&lt;/code&gt; オプションを， OS とアーキテクチャを組み合わせる場合は &lt;code&gt;-osarch linux/arm&lt;/code&gt; などとする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-output&lt;/code&gt; オプションの &lt;code&gt;&amp;quot;goxdist/{{.OS}}_{{.Arch}}/{{.Dir}}&amp;quot;&lt;/code&gt; は出力先のテンプレートで &lt;code&gt;{{ }}&lt;/code&gt; で囲まれている部分に実際の値が埋め込まれる。
たとえば OS が windows でアーキテクチャが amd64 なら &lt;code&gt;goxdist/windows_amd64/gpgpdump&lt;/code&gt; と展開されるわけだ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:tpl&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:tpl&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;このようにクロス・コンパイルが非常に簡単なので &lt;a href=&#34;https://travis-ci.org/&#34; title=&#34;Travis CI - Test and Deploy Your Code with Confidence&#34;&gt;Travis CI&lt;/a&gt; などで複数プラットフォームのバイナリを生成するのも難しくない。&lt;/p&gt;

&lt;h2 id=&#34;ghr-を使って-github-に-deploy-する&#34;&gt;ghr を使って GitHub に Deploy する&lt;/h2&gt;

&lt;p&gt;今回は &lt;a href=&#34;https://travis-ci.org/&#34; title=&#34;Travis CI - Test and Deploy Your Code with Confidence&#34;&gt;Travis CI&lt;/a&gt; から &lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; へ &lt;a href=&#34;https://github.com/mitchellh/gox&#34; title=&#34;mitchellh/gox: A dead simple, no frills Go cross compile tool&#34;&gt;mitchellh/gox&lt;/a&gt; で生成した実行バイナリを deploy することを考える。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mitchellh/gox&#34; title=&#34;mitchellh/gox: A dead simple, no frills Go cross compile tool&#34;&gt;mitchellh/gox&lt;/a&gt; で生成した実行バイナリをそのままアップしてもいいのだが，ちょっと気持ち悪いので&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:s&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，まずは zip で固めてしまおう。
以下のような簡単な shell script を書いてみた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

DIR=`pwd`
mkdir ./goxdist/dist
for PLATFORM in $(find ./goxdist -mindepth 1 -maxdepth 1 -type d); do
    PLATFORM_NAME=$(basename ${PLATFORM})

    if [ ${PLATFORM_NAME} = &amp;quot;dist&amp;quot; ]; then
        continue
    fi

    cd ${PLATFORM}
    zip ${DIR}/goxdist/dist/${PLATFORM_NAME}.zip ./*
    cd ${DIR}
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先ほど &lt;code&gt;goxdist&lt;/code&gt; フォルダ以下に生成した各バイナリをひとつづつ zip 圧縮して &lt;code&gt;goxdist/dist&lt;/code&gt; フォルダに置くだけの簡単なお仕事。
これで &lt;code&gt;goxdist/dist&lt;/code&gt; フォルダの中身を &lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; に deploy すればよい。
&lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; への deploy には &lt;a href=&#34;https://github.com/tcnksm/ghr&#34; title=&#34;tcnksm/ghr: Create Github Release and upload artifacts in parallel&#34;&gt;tcnksm/ghr&lt;/a&gt; が便利である。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go get github.com/tcnksm/ghr

$ ghr -h

Usage: ghr [options] TAG PATH

  ghr is a tool to create Release on Github and upload your artifacts to
  it. ghr parallelizes upload multiple artifacts.

  You can use ghr on GitHub Enterprise. Change URL by GITHUB_API env var.

Options:

  --username, -u        GitHub username. By default, ghr extracts user
                        name from global gitconfig value.

  --repository, -r      GitHub repository name. By default, ghr extracts
                        repository name from current directory&#39;s .git/config
                        value.

  --token, -t           GitHub API Token. To use ghr, you will first need
                        to create a GitHub API token with an account which
                        has enough permissions to be able to create releases.
                        You can set this value via GITHUB_TOKEN env var.

  --parallel=-1         Parallelization factor. This option limit amount
                        of parallelism of uploading. By default, ghr uses
                        number of logic CPU of your PC.

  --delete              Delete release if it already created. If you want
                        to recreate release itself from begining, use
                        this. Just want to upload same artifacts to same
                        release again, use --replace option.

  --replace             Replace artifacts if it is already uploaded. Same
                        artifact measn, same release and same artifact
                        name.

  --stat=false          Show number of download of each release and quit.
                        This is special command.

Examples:

  $ ghr v1.0 dist/     Upload all artifacts which are in dist directory
                       with version v1.0.

  $ ghr --stat         Show download number of each relase and quit.

$ ghr --username spiegel-im-spiegel --token $GITHUB_TOKEN v0.1.2 goxdist/dist/
--&amp;gt; Uploading: windows_amd64_v0.1.2.zip
--&amp;gt; Uploading: linux_amd64_v0.1.2.zip
--&amp;gt; Uploading: darwin_386_v0.1.2.zip
--&amp;gt; Uploading: darwin_amd64_v0.1.2.zip
--&amp;gt; Uploading: freebsd_386_v0.1.2.zip
--&amp;gt; Uploading: freebsd_amd64_v0.1.2.zip
--&amp;gt; Uploading: freebsd_arm_v0.1.2.zip
--&amp;gt; Uploading: linux_386_v0.1.2.zip
--&amp;gt; Uploading: netbsd_arm_v0.1.2.zip
--&amp;gt; Uploading: linux_arm_v0.1.2.zip
--&amp;gt; Uploading: netbsd_386_v0.1.2.zip
--&amp;gt; Uploading: netbsd_amd64_v0.1.2.zip
--&amp;gt; Uploading: openbsd_amd64_v0.1.2.zip
--&amp;gt; Uploading: openbsd_386_v0.1.2.zip
--&amp;gt; Uploading: windows_386_v0.1.2.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;てな感じで deploy できる。
ちなみに &lt;code&gt;$GITHUB_TOKEN&lt;/code&gt; には &lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; の access token をセットする。
Access token は &lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; の &amp;ldquo;Settings” の &amp;ldquo;Personal access tokens” のページで取得できる。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a data-flickr-embed=&#34;true&#34; href=&#34;https://www.flickr.com/photos/spiegel/24367702843/&#34;&gt;&lt;img srcset=&#34;https://farm2.staticflickr.com/1626/24367702843_e72366313f.jpg 500w&#34; sizes=&#34;(min-width:600px) 500px, 80vw&#34; alt=&#34;Get access token in GitHub&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/24367702843/&#34;&gt;Get access token in GitHub&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;repo の権限を付けること。
この access token を &lt;a href=&#34;https://travis-ci.org/&#34; title=&#34;Travis CI - Test and Deploy Your Code with Confidence&#34;&gt;Travis CI&lt;/a&gt; で参照するには， &amp;ldquo;Settings” の &amp;ldquo;Environment Variables” でセットすればよい。
Build log にこの access token が表示されないようにすること。&lt;/p&gt;

&lt;p&gt;最終的な &lt;code&gt;.travis.yml&lt;/code&gt; の内容はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;language: go

go:
  - 1.5.3

branches:
  only: master

before_install:
  - go get -v github.com/mitchellh/gox
  - go get -v github.com/tcnksm/ghr

script:
  - go test -v ./...

after_success:
  - gox -output &amp;quot;goxdist/{{.OS}}_{{.Arch}}_`git tag | tail -1`/{{.Dir}}&amp;quot; -ldflags &amp;quot;-X main.Version=`git tag | tail -1`&amp;quot;
  - sh scripts/package.sh
  - ghr --username spiegel-im-spiegel --token $GITHUB_TOKEN `git tag | tail -1` goxdist/dist/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git tag | tail -1&lt;/code&gt; で最新のタグを取得して，そこに deploy するようにしている。
&lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; に何か push するたびにビルドが走るのはウザいので， master ブランチのみテスト &amp;amp; ビルドの対象とした。&lt;/p&gt;

&lt;p&gt;まっ，こんなもんかな。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/yanolab/items/5a6dfb3c07c94f7c760d&#34;&gt;Golang + Raspberry Pi + LPS331AP で気圧・温度を測定してみた - Qiita&lt;/a&gt; : arm アーキテクチャでいけるらしい&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/07/22/go1_5-cross-compile/&#34;&gt;Go1.5はクロスコンパイルがより簡単 | SOTA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/rerofumi/items/d6a8ba08270acb61b31c&#34;&gt;Raspberry PI ２ 用の consul を作る (201512版 - Qiita&lt;/a&gt; : Raspberry PI 上でビルドするより Linux のクロス環境を使ったほうが速いらしい&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2014/10/16/golang-in-ci-as-a-service/&#34;&gt;CI-as-a-ServiceでGo言語プロジェクトの最新ビルドを継続的に提供する | SOTA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/m0a/items/d933982293dcadd4998c&#34;&gt;RaspberryPi1(2とzeroも)で動かすgolang製アプリをクロスコンパイル(onMac) - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:bt&#34;&gt;ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の 1.4 までは &lt;a href=&#34;https://github.com/mitchellh/gox&#34; title=&#34;mitchellh/gox: A dead simple, no frills Go cross compile tool&#34;&gt;mitchellh/gox&lt;/a&gt; インストール後に &lt;code&gt;gox -build-toolchain&lt;/code&gt; でクロス環境を生成する必要があったが， 1.5 からは不要になった。めでたい！
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:bt&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:tpl&#34;&gt;&lt;code&gt;{{ }}&lt;/code&gt; でテンプレートをハンドリングするには &lt;a href=&#34;https://golang.org/pkg/text/template/&#34; title=&#34;template - The Go Programming Language&#34;&gt;&lt;code&gt;text/template&lt;/code&gt;&lt;/a&gt; パッケージを使う。静的サイト・ジェネレータの &lt;a href=&#34;http://gohugo.io/&#34; title=&#34;Hugo :: A fast and modern static website engine&#34;&gt;Hugo&lt;/a&gt; でもこのテンプレート・パッケージを使っている。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:tpl&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:s&#34;&gt;企業などのネット環境では Web から exe ファイルなどの実行バイナリを直接ダウンロードすることを禁止している場合もある。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>スタック追跡とパニック・ハンドリング — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/stack-trace-and-panic-handling/" />
		<id>tag:text.Baldanders.info,2016-02-13:/golang/stack-trace-and-panic-handling/</id>
		<published>2016-02-13T14:48:05+09:00</published>
		<updated>2016-11-21T20:48:03+09:00</updated>
		<summary>panic 時の出力をカスタマイズすることを考える。スタック情報を取得するには， panic を recover で捕まえた上で runtime.Caller() 関数を使う。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回は軽めの小ネタで。&lt;/p&gt;

&lt;p&gt;「&lt;a href=&#34;http://text.baldanders.info/golang/error-handling/&#34;&gt;エラー・ハンドリングについて&lt;/a&gt;」でも少し説明したが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では回復不能のエラー（ゼロ除算やメモリ不足など）が発生した場合には &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を投げる仕様になっている。
たとえば以下のコードでは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

func main() {
	os.Exit(run())
}

func run() int {
	f()
	return 0
}

func f() {
	numbers := []int{0, 1, 2}
	fmt.Println(numbers[3]) //panic!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のスタック情報が標準エラー出力に表示される&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:s&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
（&lt;a href=&#34;https://play.golang.org/&#34;&gt;The Go Playground&lt;/a&gt; での実行結果）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;panic: runtime error: index out of range

goroutine 1 [running]:
main.f()
	/tmp/sandbox269685094/main.go:19 +0x160
main.run(0x20300, 0x104000e0)
	/tmp/sandbox269685094/main.go:13 +0x20
main.main()
	/tmp/sandbox269685094/main.go:9 +0x20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まぁ必要な情報はあるのでこれでも構わないのだが，ファイル名がフルパスで表示されるのがアレな感じである。
また出力先が標準エラー出力で固定されているのも面白くない。&lt;/p&gt;

&lt;p&gt;そこで &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; 時の出力をカスタマイズすることを考える。
スタック情報を取得するには， &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;recover&lt;/a&gt; で捕まえた上で &lt;a href=&#34;https://golang.org/pkg/runtime/&#34; title=&#34;runtime - The Go Programming Language&#34;&gt;&lt;code&gt;runtime&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Caller()&lt;/code&gt; 関数を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;runtime&amp;quot;
)

func main() {
	os.Exit(run(os.Stderr))
}

func run(log io.Writer) (exit int) {
	defer func() {
		if r := recover(); r != nil {
			fmt.Fprintf(log, &amp;quot;Panic: %v\n&amp;quot;, r)
			for depth := 0; ; depth++ {
				pc, src, line, ok := runtime.Caller(depth)
				if !ok {
					break
				}
				fmt.Fprintf(log, &amp;quot; -&amp;gt; %d: %s: %s(%d)\n&amp;quot;, depth, runtime.FuncForPC(pc).Name(), src, line)
			}
			exit = 1
		}
	}()

	f()
    exit = 0
    return
}

func f() {
	numbers := []int{0, 1, 2}
	fmt.Println(numbers[3]) //panic!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで出力は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Panic: runtime error: index out of range
 -&amp;gt; 0: main.run.func1: /tmp/sandbox562252505/main.go(19)
 -&amp;gt; 1: runtime.call16: /usr/local/go/src/runtime/asm_amd64p32.s(390)
 -&amp;gt; 2: runtime.gopanic: /usr/local/go/src/runtime/panic.go(423)
 -&amp;gt; 3: runtime.panicindex: /usr/local/go/src/runtime/panic.go(12)
 -&amp;gt; 4: main.f: /tmp/sandbox562252505/main.go(36)
 -&amp;gt; 5: main.run: /tmp/sandbox562252505/main.go(29)
 -&amp;gt; 6: main.main: /tmp/sandbox562252505/main.go(11)
 -&amp;gt; 7: runtime.main: /usr/local/go/src/runtime/proc.go(111)
 -&amp;gt; 8: runtime.goexit: /usr/local/go/src/runtime/asm_amd64p32.s(1133)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。
ファイル名を出力したくないなら for 文の中を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for depth := 0; ; depth++ {
	pc, _, line, ok := runtime.Caller(depth)
	if !ok {
		break
	}
	fmt.Fprintf(log, &amp;quot; -&amp;gt; %d: %s: (%d)\n&amp;quot;, depth, runtime.FuncForPC(pc).Name(), line)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とする手もある。
コードを書いてる人はスタック追跡情報とファイルの行番号があれば大体あたりをつけられるので，これだけでもありがたい。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sgykfjsm.github.io/blog/2016/01/20/golang-function-tracing/&#34;&gt;Goでfunctionが実行された順番を追いかける - sgykfjsm.github.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/kitsuyui/items/d03a9de90330d8c275c8&#34;&gt;Go のバイナリには -ldflags &amp;lsquo;-w -s&amp;rsquo; でコンパイルしてもたくさんパスが埋め込まれていた - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:s&#34;&gt;ちなみにこの情報は &lt;code&gt;-s&lt;/code&gt; のリンクオプション（ビルド時に &lt;code&gt;-ldflags &amp;quot;-s&amp;quot;&lt;/code&gt; と指定する）でデバッグ用のシンボル情報を削除しても表示されるようだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
</feed>
