<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:cc="http://web.resource.org/cc/">
	<title>プログラミング言語 Go — text.Baldanders.info</title>
	<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/" />
	<link rel="self" type="application/atom+xml" href="http://text.baldanders.info/golang/index.xml" />
	<id>tag:text.Baldanders.info,2016-01-30:/hugo</id>
	<updated>2016-01-30T04:05:52+09:00</updated>
	<subtitle>帰ってきた「しっぽのさきっちょ」</subtitle>
	<icon>http://text.baldanders.info//images/avatar.jpg</icon>
	<logo>http://text.baldanders.info//images/avatar.jpg</logo>
	<generator uri="http://gohugo.io/">Hugo 0.15</generator>

	
	<entry>
		<title>Go 言語と Unicode 正規化 — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/unicode-normalization/" />
		<id>tag:text.Baldanders.info,2016-01-30:/golang/unicode-normalization/</id>
		<published>2016-01-30T04:05:52+09:00</published>
		<updated>2016-01-30T10:29:59+09:00</updated>
		<summary>今回は少し目先を変えて「Unicode 正規化」のお話。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回は少し目先を変えて「Unicode 正規化（normalization）」のお話。&lt;/p&gt;

&lt;h2 id=&#34;2羽の-ペンギン:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;2羽の「ペンギン」&lt;/h2&gt;

&lt;p&gt;まず「ペンギン」という文字列を思い浮かべてみる。
この文字列を Unicode のコードポイントで表すと以下のようになる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ペ：U+30DA&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;li&gt;ギ：U+30AE&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ところでペンギンの「ペ」と「ギ」は半濁点および濁点を含む。
Unicode は「ペ」と「ギ」をそれぞれ2つの要素に分解できる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ペ：U+30D8 + U+309A&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;li&gt;ギ：U+30AD + U+3099&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;U+309A および U+3099 はそれぞれ半濁点と濁点を表す「結合文字（combining character）」である。
「ヘ」や「キ」のような「基底文字（base character）」に結合文字を1つ以上&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:cs&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:cs&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 付加した文字を「合成列（composite sequence）」と呼ぶ。
これに対して「ペ：U+30DA」や「ギ：U+30AE」のような文字を「事前合成形（precomposed）」と呼ぶ。&lt;/p&gt;

&lt;p&gt;つまり同じ文字を同じ文字集合&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:ccs&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:ccs&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; で表しているのにもかかわらず複数の符号化&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:ecd&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:ecd&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; が存在するわけだ。
これを「重複符号化」と言う。
文字集合に重複符号化があるというのは，はっきり言って「クソ仕様」である。&lt;/p&gt;

&lt;p&gt;もちろんこれは Unicode を作った連中がヘボいのではなく（いや，ヘボいのかもしれないが），いわゆる「歴史的経緯」というやつである&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:jis&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:jis&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。
だからこれはこういうものだと諦めるしかない。&lt;/p&gt;

&lt;p&gt;しかし情報処理を行う上では，この2羽の「ペンギン」が等価（equivalance）であることを示す手立てを考えなければならない。&lt;/p&gt;

&lt;h2 id=&#34;正規等価:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;正規等価&lt;/h2&gt;

&lt;p&gt;2羽の「ペンギン」が等価であることを示す一番簡単な方法は，文字列を事前合成形あるいは合成列のどちらかに統一（＝正規化）してしまえばいい。
これを「正規等価（canonical equivalance）」と呼ぶ。
このうち，事前合成形に正規化する方法を “NFC（Normalization Form Composition）”，合成列に正規化する方法を “NFD（Normalization Form Decomposition）” と呼ぶ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では &lt;code&gt;golang.org/x/text/unicode/&lt;/code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34; title=&#34;norm - GoDoc&#34;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; パッケージで Unicode 文字列を正規化できる。
まぁ，コードで書いたほうがはやいか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	penguin := &amp;quot;ペンギン&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFD.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin3 := string(norm.NFC.Bytes([]byte(penguin2)))
	for pos, runeValue := range penguin3 {
		fmt.Printf(&amp;quot;penguin3[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+30DA &#39;ペ&#39;
penguin[3] = U+30F3 &#39;ン&#39;
penguin[6] = U+30AE &#39;ギ&#39;
penguin[9] = U+30F3 &#39;ン&#39;
penguin2[0] = U+30D8 &#39;ヘ&#39;
penguin2[3] = U+309A &#39;゚&#39;
penguin2[6] = U+30F3 &#39;ン&#39;
penguin2[9] = U+30AD &#39;キ&#39;
penguin2[12] = U+3099 &#39;゙&#39;
penguin2[15] = U+30F3 &#39;ン&#39;
penguin3[0] = U+30DA &#39;ペ&#39;
penguin3[3] = U+30F3 &#39;ン&#39;
penguin3[6] = U+30AE &#39;ギ&#39;
penguin3[9] = U+30F3 &#39;ン&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NFC と NFD が交換可能であることがわかると思う。&lt;/p&gt;

&lt;h2 id=&#34;3羽目の-ペンギン-と互換等価:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;3羽目の「ペンギン」と互換等価&lt;/h2&gt;

&lt;p&gt;さてここで3羽目の「ﾍﾟﾝｷﾞﾝ」に登場してもらおう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ﾍ：U+FF8D&lt;/li&gt;
&lt;li&gt;ﾟ：U+FF9F&lt;/li&gt;
&lt;li&gt;ﾝ：U+FF9D&lt;/li&gt;
&lt;li&gt;ｷ：U+FF77&lt;/li&gt;
&lt;li&gt;ﾞ：U+FF9E&lt;/li&gt;
&lt;li&gt;ﾝ：U+FF9D&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これはいわゆる「半角カナ」である。
半角カナの半濁点 U+FF9F および濁点 U+FF9E は結合文字の半濁点 U+309A および濁点 U+3099 と同等とみなされているが「ペ」や「ギ」に相当する半角カナの事前合成形は存在しないため NFC で事前合成形に正規化しようとしても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	penguin := &amp;quot;ﾍﾟﾝｷﾞﾝ&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFC.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+FF8D &#39;ﾍ&#39;
penguin[3] = U+FF9F &#39;ﾟ&#39;
penguin[6] = U+FF9D &#39;ﾝ&#39;
penguin[9] = U+FF77 &#39;ｷ&#39;
penguin[12] = U+FF9E &#39;ﾞ&#39;
penguin[15] = U+FF9D &#39;ﾝ&#39;
penguin2[0] = U+FF8D &#39;ﾍ&#39;
penguin2[3] = U+FF9F &#39;ﾟ&#39;
penguin2[6] = U+FF9D &#39;ﾝ&#39;
penguin2[9] = U+FF77 &#39;ｷ&#39;
penguin2[12] = U+FF9E &#39;ﾞ&#39;
penguin2[15] = U+FF9D &#39;ﾝ&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何も変わらないことが分かるだろう。
そもそも半角カナは「互換用文字（Compatibility Character）」として異なるコードポイントが割り当てられているため，このままでは3羽目の「ﾍﾟﾝｷﾞﾝ」が等価であることを示せない。&lt;/p&gt;

&lt;p&gt;このような場合は「ﾍﾟﾝｷﾞﾝ」と互換性のある別の文字列に正規化できるとよい。
これを「互換等価（compatibility equivalance）」と呼ぶ。
具体的には，事前合成形に正規化する NFKC（Normalization Form Compatibility Composition）と合成列に正規化する NFKD（Normalization Form Compatibility Decomposition）の2つがある。&lt;/p&gt;

&lt;p&gt;早速 &lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34; title=&#34;norm - GoDoc&#34;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; パッケージを使ってコードを書いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	penguin := &amp;quot;ﾍﾟﾝｷﾞﾝ&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFKC.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+FF8D &#39;ﾍ&#39;
penguin[3] = U+FF9F &#39;ﾟ&#39;
penguin[6] = U+FF9D &#39;ﾝ&#39;
penguin[9] = U+FF77 &#39;ｷ&#39;
penguin[12] = U+FF9E &#39;ﾞ&#39;
penguin[15] = U+FF9D &#39;ﾝ&#39;
penguin2[0] = U+30DA &#39;ペ&#39;
penguin2[3] = U+30F3 &#39;ン&#39;
penguin2[6] = U+30AE &#39;ギ&#39;
penguin2[9] = U+30F3 &#39;ン&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり， NFC で正規化した「ペンギン」と等価であることがわかる。&lt;/p&gt;

&lt;p&gt;互換等価による正規化は応用範囲が広い。
たとえば「㈱」（U+3231）は「(株)」（U+0028 + U+682A + U+0029）に変換される。
文字列検索の前に互換等価による正規化を行っておくことで処理がやりやすくなるというのはあるかもしれない。
ただし， NFC と NFD は交換可能だが（ただしオリジナル文字列が事前合成形と合成列が混在している場合は元に戻せないが）， NFKC や NFKD で正規化した文字列を元に戻す方法はないので注意が必要である&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:hw&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:hw&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;恐怖の-cjk-互換文字:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;恐怖の CJK 互換文字&lt;/h2&gt;

&lt;p&gt;正規等価については注意すべき点がある。
有名な「神」を例に挙げよう。
これを NFC / NFD で正規化する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

//神様の遊び
func main() {
	penguin := &amp;quot;神&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFKC.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin3 := string(norm.NFKD.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin3 {
		fmt.Printf(&amp;quot;penguin3[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+FA19 &#39;神&#39;
penguin2[0] = U+795E &#39;神&#39;
penguin3[0] = U+795E &#39;神&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり，NFC でも NFD でも違う文字になってしまった。
ちなみに「神」から「神」へ正規化する方法はない。
困ったね。&lt;/p&gt;

&lt;p&gt;実は「神」は「CJK 互換文字」と呼ばれるグループに属し，「神」とは異体字の関係にある。
故に「神」を「神」に正規化してしまったのである。&lt;/p&gt;

&lt;p&gt;これは明らかに仕様ミスである。
「神」と「神」のような異体字の関係は本来なら正規等価ではなく互換等価であるべきだからだ。&lt;/p&gt;

&lt;p&gt;&amp;hellip;やっぱり Unicode はクソ仕様だ。&lt;/p&gt;

&lt;p&gt;ただ，これが実際の場面で問題になることは少ないと思われる。
なぜなら，正規化を行うのは「2つの文字列が等価であるか？」を調べるための手段にすぎないからだ。
普通はね。&lt;/p&gt;

&lt;p&gt;ところが，普通でないことをする馬鹿がいるのである。&lt;/p&gt;

&lt;h3 id=&#34;独自路線に走る-apple:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;独自路線に走る Apple&lt;/h3&gt;

&lt;p&gt;Apple の OS X （iOS も？）のファイルシステムである HFS+ はファイル名を NFD 相当に正規化するという恐ろしい仕様になっている&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:fs&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:fs&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。
しかしそれでは，先ほどの例のように異体字に関しては正規化によって別の文字に変えられてしまうため困ったことになってしまう。&lt;/p&gt;

&lt;p&gt;そこで Apple は CJK 互換文字を含むいくつかの文字を正規化の対象から外すという蛮行に出た。
俗に “NFD-mac” などと呼ばれる独自路線に走ってしまったわけだ。&lt;/p&gt;

&lt;p&gt;これにより様々な（特にマルチプラットフォームな）アプリケーションが多大なる迷惑を被ることになるが&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:mac&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:mac&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;，深くはツッコむまい。&lt;/p&gt;

&lt;h2 id=&#34;unicode-正規化に関するまとめ:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;Unicode 正規化に関するまとめ&lt;/h2&gt;

&lt;p&gt;以上， Unicode 正規化の4つの方式をまとめると以下のようになる。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;Composing&lt;/th&gt;
    &lt;th&gt;Decomposing&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Canonical equivalence&lt;/th&gt;
    &lt;td&gt;NFC&lt;/td&gt;
    &lt;td&gt;NFD&lt;br&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Compatibility equivalence&lt;/th&gt;
    &lt;td&gt;NFKC&lt;/td&gt;
    &lt;td&gt;NFKD&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://blog.golang.org/normalization&#34;&gt;Text normalization in Go&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Unicode 文字列の等価属性を調べる際には是非参考にどうぞ。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://internet.watch.impress.co.jp/www/column/ogata/sp24.htm&#34;&gt;特別編24 JIS X 0213の改正は、文字コードにどんな未来をもたらすか（7）　番外編：改正JIS X 0213とUnicodeの等価属性／正規化について（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://internet.watch.impress.co.jp/www/column/ogata/sp25.htm&#34;&gt;特別編24 JIS X 0213の改正は、文字コードにどんな未来をもたらすか（7）　番外編：改正JIS X 0213とUnicodeの等価属性／正規化について（下）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nomenclator.la.coocan.jp/unicode/normalization.htm&#34;&gt;Unicode正規化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/normalization&#34;&gt;Text normalization in Go - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/masakielastic/items/01a4fb691c572dd71a19&#34;&gt;Go で UTF-8 の文字列を扱う - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tech.albert2005.co.jp/blog/2014/11/21/mco-normalize/&#34;&gt;文字コード地獄秘話 第3話：後戻りの効かないUnicode正規化 - ALBERT Engineer Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cpplover.blogspot.jp/2015/01/blog-post_14.html&#34;&gt;本の虫: Linus Torvalds、HFS+に激怒&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:cs&#34;&gt;結合文字はひとつの基底文字に対して複数付加される場合もある。しかもこの場合に結合文字同士の順序は不定である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:cs&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:ccs&#34;&gt;正しくは「符号化文字集合（coded character set）」である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:ccs&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:ecd&#34;&gt;これは UTF-8 などの「文字エンコーディング」とは異なるものだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:ecd&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:jis&#34;&gt;日本の JIS 規格にも「歴史的経緯」による重複符号化がある。言わずと知れた「半角」「全角」文字である。異体字も一種の重複符号化と言える。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:jis&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:hw&#34;&gt;単に全角・半角変換ができればいいのなら &lt;code&gt;golang.org/x/text/&lt;/code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/width&#34; title=&#34;width - GoDoc&#34;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; パッケージをお勧めする。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:hw&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:fs&#34;&gt;ちなみに Windows のファイルシステムはフォルダ・ファイルの名前を正規化するとかいうアホなことはしない。事前合成形も合成列も受け入れる。見かけ同じ名前のフォルダ・ファイルが複数できる可能性はあるが，それはそれ。多分，ほとんどの OS のファイルシステムは名前の正規化なんてしてないはず。この HFS+ による Unicode 正規化のおかげで他プラットフォームはかなりの迷惑を被ることになる。たとえば複数のプラットフォームをまたぐファイル交換（例えば Linux → OS X → Windows みたいな経路）を行った場合に OS X を経由した途端にフォルダ・ファイル名を書き換えられてしまうのだ。しかもユーザやアプリケーションは基本的に干渉できない。迷惑千万な話である。もっとも Windows ユーザは Windows ファイルシステムのダメさ加減が身に沁みてるので他所を嗤えないけど（笑）
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:fs&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:mac&#34;&gt;たとえば Linus Torvalds は HFS+ に起因する git の脆弱性問題で&lt;a href=&#34;http://cpplover.blogspot.jp/2015/01/blog-post_14.html&#34;&gt;激怒&lt;/a&gt;している。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:mac&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Go 言語の日付処理 — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/time-functions/" />
		<id>tag:text.Baldanders.info,2016-01-22:/golang/time-functions/</id>
		<published>2016-01-22T20:56:21+09:00</published>
		<updated>2016-01-22T20:56:21+09:00</updated>
		<summary>今回は日付処理の話。特にフォーマットの定義の仕方はよく忘れるので覚え書きとして記しておく。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回は日付処理の話。
特にフォーマットの定義の仕方はよく忘れるので覚え書きとして記しておく。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で日付処理を行うには &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; パッケージを使う。
よく使う型としては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Time&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Duration&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Location&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が挙げられるだろう。
&lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Time&lt;/code&gt; は時刻を， &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Duration&lt;/code&gt; は2時点間の時間を，そして &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Location&lt;/code&gt; は地球上の時差を表す型である。
たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	tz, err := time.LoadLocation(&amp;quot;Asia/Tokyo&amp;quot;)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	tm := time.Date(2006, 1, 2, 15, 4, 5, 0, tz)
	fmt.Println(tm)
	now := time.Now()
	fmt.Println(now)
	d := now.Sub(tm)
	fmt.Println(d)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書くと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2006-01-02 15:04:05 +0900 JST
2009-11-10 23:00:00 +0000 UTC
33808h55m55s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;てな感じになる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:c11a81a4a42bf05b71b8320d533680a9:m&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:c11a81a4a42bf05b71b8320d533680a9:m&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;時刻を任意のフォーマットで表示する場合は少し特殊な方法を使う。
たとえば &lt;a href=&#34;https://tools.ietf.org/html/rfc3339&#34;&gt;RFC 3339&lt;/a&gt; フォーマットに出力するなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	tz, err := time.LoadLocation(&amp;quot;Asia/Tokyo&amp;quot;)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	tm := time.Date(2015, 12, 31, 23, 59, 59, 0, tz)
	fmt.Println(tm.Format(&amp;quot;2006-01-02T15:04:05Z07:00&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-12-31T23:59:59+09:00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と出力される。
テンプレート文字列が &lt;code&gt;%Y&lt;/code&gt; とか &lt;code&gt;YYYY&lt;/code&gt; のような形式ではないのだ。
これは適当な文字列ではなく一応法則があって&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;月は &lt;code&gt;1&lt;/code&gt; （または &lt;code&gt;01&lt;/code&gt;, &lt;code&gt;Jan&lt;/code&gt;, &lt;code&gt;January&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;日は &lt;code&gt;2&lt;/code&gt; （または &lt;code&gt;02&lt;/code&gt;, &lt;code&gt;_2&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;時は &lt;code&gt;3&lt;/code&gt; （または &lt;code&gt;03&lt;/code&gt;, &lt;code&gt;15&lt;/code&gt;） ※ 午後3時を指す&lt;/li&gt;
&lt;li&gt;分は &lt;code&gt;4&lt;/code&gt; （または &lt;code&gt;04&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;秒は &lt;code&gt;5&lt;/code&gt; （または &lt;code&gt;05&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;年は &lt;code&gt;06&lt;/code&gt; （または &lt;code&gt;2006&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;時差は &lt;code&gt;-07&lt;/code&gt; （または &lt;code&gt;-0700&lt;/code&gt;, &lt;code&gt;-07:00&lt;/code&gt;, &lt;code&gt;Z07:00&lt;/code&gt;, &lt;code&gt;MST&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:c11a81a4a42bf05b71b8320d533680a9:tz&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:c11a81a4a42bf05b71b8320d533680a9:tz&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; など）&lt;/li&gt;
&lt;li&gt;曜日は &lt;code&gt;Mon&lt;/code&gt; （または &lt;code&gt;Monday&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;AM/PM は &lt;code&gt;PM&lt;/code&gt; （または &lt;code&gt;pm&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という感じに 1 からの連番になっている（曜日等は例外だけど）ので，まぁ覚えられるかな？ でもよく忘れるんだよなぁ。
&lt;code&gt;%Y&lt;/code&gt; みたいなのとどちらがいいかは微妙な気がするが，慣れの問題かもしれない。&lt;/p&gt;

&lt;p&gt;典型的なフォーマットは定数化されている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
	ANSIC       = &amp;quot;Mon Jan _2 15:04:05 2006&amp;quot;
	UnixDate    = &amp;quot;Mon Jan _2 15:04:05 MST 2006&amp;quot;
	RubyDate    = &amp;quot;Mon Jan 02 15:04:05 -0700 2006&amp;quot;
	RFC822      = &amp;quot;02 Jan 06 15:04 MST&amp;quot;
	RFC822Z     = &amp;quot;02 Jan 06 15:04 -0700&amp;quot; // RFC822 with numeric zone
	RFC850      = &amp;quot;Monday, 02-Jan-06 15:04:05 MST&amp;quot;
	RFC1123     = &amp;quot;Mon, 02 Jan 2006 15:04:05 MST&amp;quot;
	RFC1123Z    = &amp;quot;Mon, 02 Jan 2006 15:04:05 -0700&amp;quot; // RFC1123 with numeric zone
	RFC3339     = &amp;quot;2006-01-02T15:04:05Z07:00&amp;quot;
	RFC3339Nano = &amp;quot;2006-01-02T15:04:05.999999999Z07:00&amp;quot;
	Kitchen     = &amp;quot;3:04PM&amp;quot;
	// Handy time stamps.
	Stamp      = &amp;quot;Jan _2 15:04:05&amp;quot;
	StampMilli = &amp;quot;Jan _2 15:04:05.000&amp;quot;
	StampMicro = &amp;quot;Jan _2 15:04:05.000000&amp;quot;
	StampNano  = &amp;quot;Jan _2 15:04:05.000000000&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なので，先ほどのコードも出力部分を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(tm.Format(time.RFC3339))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば同じ結果が得られる。
時刻フォーマットは，いったんシステムの中で決めてしまえば同じものを使い回すことになると思うので，定数化してしまえば「フォーマットどうだっけ？」と煩わされることも少ないだろう。&lt;/p&gt;

&lt;p&gt;ところで現行（バージョン 1.5 系）の &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Parse()&lt;/code&gt; 関数は日付の解釈が寛容で，各月の末日を31日まで許容している。
たとえば閏年でない2月29日でも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	tm, err := time.Parse(time.RFC3339, &amp;quot;2015-02-29T23:59:59+09:00&amp;quot;)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	fmt.Println(tm)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;2015-03-01 23:59:59 +0900 +0900
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり，エラーとならずいい感じ（？）に加減してくれるのだが，バージョン 1.6 からは少し解釈が厳密になりエラーを返すようだ。&lt;/p&gt;

&lt;figure lang=&#34;en&#34;&gt;
&lt;blockquote&gt;
&lt;q&gt;The time package&#39;s Parse function has always rejected any day of month larger than 31, such as January 32. In Go 1.6, Parse now also rejects February 29 in non-leap years, February 30, February 31, April 31, June 31, September 31, and November 31.&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;https://tip.golang.org/doc/go1.6&#34;&gt;Go 1.6 Release Notes DRAFT - The Go Programming Language&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Date()&lt;/code&gt; 関数は更に寛容である。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	tz, err := time.LoadLocation(&amp;quot;Asia/Tokyo&amp;quot;)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	tm := time.Date(2015, 13, 32, 25, 60, 00, 0, tz)
	fmt.Println(tm)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;2016-02-03 02:00:00 +0900 JST
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ブックマーク:c11a81a4a42bf05b71b8320d533680a9&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ymotongpoo.hatenablog.com/entry/2015/12/22/000011&#34;&gt;Goで良い感じに日時をパースするライブラリdatemakiの話とGo 1.6 - YAMAGUCHI::weblog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/ushio_s/items/3e270933641710bbd88e&#34;&gt;golangのtime.Timeの当日00:00:00を取得する方法とベンチマーク - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:c11a81a4a42bf05b71b8320d533680a9:m&#34;&gt;厳密にいうと月の値は &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Month&lt;/code&gt; 型である。サンプル・コードのようにリテラルな数値なら気にする必要はないが，変数を &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Date()&lt;/code&gt; 関数にセットする場合は注意が必要である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:c11a81a4a42bf05b71b8320d533680a9:m&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:c11a81a4a42bf05b71b8320d533680a9:tz&#34;&gt;時差の MST は米国の山岳部時間（Mountain Standad Time）を指すらしい。ソルトレイクシティとかデンバーとかかな。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:c11a81a4a42bf05b71b8320d533680a9:tz&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>再帰呼び出しと関数テーブル — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/recursive-call-and-function-table/" />
		<id>tag:text.Baldanders.info,2016-01-18:/golang/recursive-call-and-function-table/</id>
		<published>2016-01-18T22:59:07+09:00</published>
		<updated>2016-01-19T21:50:44+09:00</updated>
		<summary>今回は再帰呼び出しの話。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回は再帰呼び出しの話。&lt;/p&gt;

&lt;p&gt;再帰呼び出しのサンプルとして典型的なのは&lt;a href=&#34;https://en.wikipedia.org/wiki/Fibonacci_number&#34; title=&#34;Fibonacci number - Wikipedia, the free encyclopedia&#34;&gt;フィボナッチ数&lt;/a&gt;かな。
&lt;a href=&#34;https://en.wikipedia.org/wiki/Fibonacci_number&#34; title=&#34;Fibonacci number - Wikipedia, the free encyclopedia&#34;&gt;フィボナッチ数&lt;/a&gt;の定義を愚直にコードにするとこんな感じになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func fibonacciNumber(n int) int {
	switch n {
	case 0:
		return 0
	case 1:
		return 1
	default:
		return fibonacciNumber(n-2) + fibonacciNumber(n-1)
	}
}

type ff func(int) int

var fib = fibonacciNumber

func main() {
	fmt.Println(fibonacciNumber(40))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般に手続き型言語は再帰呼び出しに弱いと言われている（関数型のほうが有利）。
特に &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の場合は &lt;a href=&#34;http://golang.org/ref/spec#Go_statements&#34;&gt;goroutine&lt;/a&gt; に最適化を割り振っている関係で，関数呼び出しやその戻り&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:90181bd94c22568ae136c2a2c4e81a10:r&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:90181bd94c22568ae136c2a2c4e81a10:r&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; のパフォーマンスが冷遇されているようだ。
したがって，再帰呼び出し部分のパフォーマンスを改善したければ，なるべく呼び出し回数を減らすようにするのがコツである。
たとえば上の&lt;a href=&#34;https://en.wikipedia.org/wiki/Fibonacci_number&#34; title=&#34;Fibonacci number - Wikipedia, the free encyclopedia&#34;&gt;フィボナッチ数&lt;/a&gt;の場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

var fibonacciNumbers = make(map[int]int)

func fibonacciNumber(n int) int {
	switch n {
	case 0:
		return 0
	case 1:
		return 1
	default:
		if fn, ok := fibonacciNumbers[n]; ok {
			return fn
		}
		fn := fibonacciNumber(n-2) + fibonacciNumber(n-1)
		fibonacciNumbers[n] = fn
		return fn
	}
}

func main() {
	fmt.Println(fibonacciNumber(40))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じに計算結果を保持っておくことでかなり改善する。&lt;/p&gt;

&lt;p&gt;ところで，再帰呼び出しで怖いのが無限呼び出しに陥るパターンである。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では関数値（function value）を介す場合であれば再帰呼び出しを禁止する。&lt;/p&gt;

&lt;p&gt;たとえば先ほどのコードを以下のように書き換えてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

var fibonacciNumbers = make(map[int]int)

func fibonacciNumber(n int) int {
	switch n {
	case 0:
		return 0
	case 1:
		return 1
	default:
		if fn, ok := fibonacciNumbers[n]; ok {
			return fn
		}
		fn := fib(n-2) + fib(n-1)
		fibonacciNumbers[n] = fn
		return fn
	}
}

type ff func(int) int

var fib ff = fibonacciNumber

func main() {
	fmt.Println(fib(40))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fibonacciNumber()&lt;/code&gt; を &lt;code&gt;fib()&lt;/code&gt; で別名定義しているだけだが，これを実行しようとすると以下のコンパイルエラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prog.go:25: initialization loop:
	prog.go:25 fib refers to
	prog.go:7 fibonacciNumber refers to
	prog.go:25 fib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数値 &lt;code&gt;fib&lt;/code&gt; の部分でエラーになっている点に注目してほしい。&lt;/p&gt;

&lt;p&gt;本当に「ついうっかり」再帰呼び出しになってしまう場合はエラーではじいてもらってありがたいのだが，そうでない場合もある。
あまり例示がうまくなくて申し訳ないのだが，以下の簡単なステート・マシンを考えてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func f0(evt int) int {
	fmt.Println(&amp;quot;processing f0&amp;quot;)
	return 1
}

func f1(evt int) int {
	fmt.Println(&amp;quot;processing f1&amp;quot;)
	return 2
}

func f2(evt int) int {
	fmt.Println(&amp;quot;processing f2&amp;quot;)
	return 3
}

func f3(evt int) int {
	fmt.Println(&amp;quot;processing f3&amp;quot;)
	return 0
}

type fn func(int) int

var fs = []fn{
	f0,
	f1,
	f2,
	f3,
}

func StateMachin(stat, evt int) int {
	return fs[stat](evt)
}

func main() {
	s := 0
	for e := 0; e &amp;lt; 10; e++ {
		s = StateMachin(s, e)
		if s == 0 {
			break
		}
	}
	fmt.Println(&amp;quot;end&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fs&lt;/code&gt; が関数テーブルになっていて，状態 &lt;code&gt;s&lt;/code&gt; とイベント &lt;code&gt;e&lt;/code&gt; に対する処理 &lt;code&gt;fs[s](e)&lt;/code&gt; を呼び出して処理後の状態を返してもらう。
一応 &lt;code&gt;StateMachine()&lt;/code&gt; 関数で詳細を隠蔽しているつもりである&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:90181bd94c22568ae136c2a2c4e81a10:b&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:90181bd94c22568ae136c2a2c4e81a10:b&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;ここで &lt;code&gt;StateMachine(3, evt)&lt;/code&gt; の処理に続けて &lt;code&gt;StateMachine(1, evt)&lt;/code&gt; の処理がしたくなり&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func f3(evt int) int {
    fmt.Println(&amp;quot;processing f3&amp;quot;)
    return StateMachin(1, evt)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと書いたらどうなるか。
もちろんこれもコンパイルエラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prog.go:32: initialization loop:
	prog.go:32 fs refers to
	prog.go:20 f3 refers to
	prog.go:34 StateMachin refers to
	prog.go:32 fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし実際には &lt;code&gt;f3&lt;/code&gt; を無限に呼び出しているわけではないので，このコンパイルエラーでは困ってしまう&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:90181bd94c22568ae136c2a2c4e81a10:a&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:90181bd94c22568ae136c2a2c4e81a10:a&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
このエラーを回避するには関数テーブル &lt;code&gt;fs&lt;/code&gt; を介さなければよい。
たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fs = []fn{
	f0,
	f1,
	f2,
	//f3,
}

func StateMachin(stat, evt int) int {
	if stat == 3 {
		return f3(evt)
	}
	return fs[stat](evt)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば，めでたく &lt;code&gt;f1&lt;/code&gt; → &lt;code&gt;f2&lt;/code&gt; → &lt;code&gt;f3&lt;/code&gt; → &lt;code&gt;f1&lt;/code&gt; とエンドレスにつながる。
ちなみにここでうっかり&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func f3(evt int) int {
	fmt.Println(&amp;quot;processing f3&amp;quot;)
	return StateMachin(3, evt)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと書くと，コンパイルエラーにもならず無限呼び出しが発生する。&lt;/p&gt;

&lt;p&gt;再帰呼び出しは計画的に。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:90181bd94c22568ae136c2a2c4e81a10&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ymotongpoo.hatenablog.com/entry/2015/02/23/165341&#34;&gt;Goで再帰使うと遅くなりますがそれが何だ - YAMAGUCHI::weblog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/zetamatta/items/cc0f29441b16d63472ed&#34;&gt;.\hoge.go:7: initialization loop - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:90181bd94c22568ae136c2a2c4e81a10:r&#34;&gt;再帰呼び出しが「末尾呼び出し（tail call）」の場合は，戻りの最適化でパフォーマンスの向上が期待できるが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のコンパイラはこの辺の最適化も行っていないらしい。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:90181bd94c22568ae136c2a2c4e81a10:r&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:90181bd94c22568ae136c2a2c4e81a10:b&#34;&gt;実際には別パッケージにしてちゃんとクラス設計すべきだろうけど色々端折っている。ゴメンペコン。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:90181bd94c22568ae136c2a2c4e81a10:b&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:90181bd94c22568ae136c2a2c4e81a10:a&#34;&gt;このコードに限れば &lt;code&gt;StateMachine(1, evt)&lt;/code&gt; ではなく &lt;code&gt;f1(evt)&lt;/code&gt; を呼び出せば済む話なのでこれは言いがかりであるが，「話の都合」ということで軽く流していただけるとありがたい。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:90181bd94c22568ae136c2a2c4e81a10:a&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>コマンドライン・インタフェースとファサード・パターン — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/cli-and-facade-pattern/" />
		<id>tag:text.Baldanders.info,2016-01-05:/golang/cli-and-facade-pattern/</id>
		<published>2016-01-05T22:06:41+09:00</published>
		<updated>2016-01-06T09:48:00+09:00</updated>
		<summary>ファサード・パターンは DDD (Domain-Driven Design) と相性がよい。普通は Web アプリケーションのような多様なサブシステムを持つシステムを設計する際に導入する考え方だが， CLI の場合でもサブコマンドを構成するのであればファサード・パターンがよいだろう。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;コンパイラには &lt;a href=&#34;https://golang.org/pkg/flag/&#34; title=&#34;flag - The Go Programming Language&#34;&gt;&lt;code&gt;flag&lt;/code&gt;&lt;/a&gt; パッケージが標準で提供されており，いわゆるコマンドライン・インタフェース（Command line interface; CLI）の操作はこれでまかなうことができる。
ただし &lt;a href=&#34;https://golang.org/pkg/flag/&#34; title=&#34;flag - The Go Programming Language&#34;&gt;&lt;code&gt;flag&lt;/code&gt;&lt;/a&gt; パッケージではサブコマンドをサポートしていないためサブコマンドを構成したい場合は少し工夫が必要となる。
ちなみにサブコマンドとは，以下のようなコマンドラインの構成になっているアプリケーションである。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ command [golabal options] &amp;lt;sub-command&amp;gt; [sub-options] [arguments]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;たとえば &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;コンパイラの &lt;code&gt;go run&lt;/code&gt; もサブコマンドだし， &lt;a href=&#34;https://git-scm.com/&#34; title=&#34;Git&#34;&gt;git&lt;/a&gt; の &lt;code&gt;git commit&lt;/code&gt; とかもサブコマンドである。&lt;/p&gt;

&lt;h2 id=&#34;コマンドライン-インタフェースと-unix-philosophy:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;コマンドライン・インタフェースと UNIX Philosophy&lt;/h2&gt;

&lt;p&gt;ところで CLI でよく引き合いに出されるのが “&lt;a href=&#34;http://www.ru.j-npcs.org/usoft/WWW/LJ/Articles/unixtenets.html&#34; title=&#34;Tenets of the UNIX Philosophy&#34;&gt;UNIX Philosophy&lt;/a&gt;” と呼ばれるアプリケーションを作る際の哲学というか指針のようなものである。
曰く&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Small is beautiful. （小さいものは美しい）&lt;/li&gt;
&lt;li&gt;Make each program do one thing well. （各プログラムが一つのことをうまくやるようにせよ）&lt;/li&gt;
&lt;li&gt;Build a prototype as soon as possible. （できる限り早くプロトタイプを作れ）&lt;/li&gt;
&lt;li&gt;Choose portability over efficiency. （効率よりも移植しやすさを選べ）&lt;/li&gt;
&lt;li&gt;Store data in flat text files. （単純なテキストファイルにデータを格納せよ）&lt;/li&gt;
&lt;li&gt;Use software leverage to your advantage. （ソフトウェアの効率を優位さとして利用せよ）&lt;/li&gt;
&lt;li&gt;Use shell scripts to increase leverage and portability. （効率と移植性を高めるためにシェルスクリプトを利用せよ）&lt;/li&gt;
&lt;li&gt;Avoid captive user interfaces. （拘束的なユーザーインターフェースは作るな）&lt;/li&gt;
&lt;li&gt;Make every program a Filter. （全てのプログラムはフィルタとして振る舞うようにせよ）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;の9項目&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:up&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:up&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
昨今は UNIX 互換環境でも GUI が普通になってきたので対話型のインタフェースも増えてきたが，それでも従来の CUI shell 上で動作するアプリケーションの需要が減ったわけではなく，サーバサイドではむしろ需要は大きくなっていると言ってもいい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で CLI アプリケーションを作る際に気をつける点としては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;他のツールと shell を介して連携できるよう標準入出力を使ったフィルタプログラムとする&lt;/li&gt;
&lt;li&gt;外部データの入出力は JSON, YAML, TOML といったテキストを用い UTF-8 文字エンコーディングに統一する&lt;/li&gt;
&lt;li&gt;コードの可搬性（または移植性）を考慮し，プラットフォーム依存を避けるようにする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といったところだろうか。
もともと &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;はクロスプラットフォーム開発に強いため，それほど難しい要件ではないはずである。&lt;/p&gt;

&lt;h2 id=&#34;サブコマンドとファサード-パターン:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;サブコマンドとファサード・パターン&lt;/h2&gt;

&lt;p&gt;サブコマンド方式は一見 “&lt;a href=&#34;http://www.ru.j-npcs.org/usoft/WWW/LJ/Articles/unixtenets.html&#34; title=&#34;Tenets of the UNIX Philosophy&#34;&gt;UNIX Philosophy&lt;/a&gt;” に反しているように見えるが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の場合は全てのパッケージをひとつの実行モジュールに結合してしまうため，関連する機能をサブコマンドとして組み込むのは悪くないやりかたである。&lt;/p&gt;

&lt;p&gt;サブコマンドを構成する場合は「ファサード・パターン（facade pattern）」で考えるとよい。
「ファサード」は「建物の正面」という意味だそうで，システム内の各サブシステムの窓口のように機能する&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:fcd&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:fcd&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/facade-pattern.svg&#34;&gt;&lt;img src=&#34;http://text.baldanders.info/images/facade-pattern.svg&#34; alt=&#34;Facade Pattern&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;http://text.baldanders.info/images/facade-pattern.svg&#34;&gt;Facade Pattern&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;この図のようにファサード・パターンは DDD (Domain-Driven Design) と相性がよい。
普通は Web アプリケーションのような多様なサブシステムを含むシステムを設計する際に導入する考え方だが， CLI の場合でもサブコマンドを構成するのであればファサード・パターンがよいだろう。&lt;/p&gt;

&lt;h2 id=&#34;mitchellh-cli-パッケージ:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;mitchellh/cli パッケージ&lt;/h2&gt;

&lt;p&gt;CLI をサポートするパッケージはいくつか公開されているのだが，この中で今回は &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; パッケージを紹介する。
&lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; はサブコマンドをファサード・パターンで実装するのに便利な機能を実装している。&lt;/p&gt;

&lt;h3 id=&#34;command-インタフェース:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;Command インタフェース&lt;/h3&gt;

&lt;p&gt;まずは &lt;code&gt;Command&lt;/code&gt; インタフェース。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// A command is a runnable sub-command of a CLI.
type Command interface {
	// Help should return long-form help text that includes the command-line
	// usage, a brief few sentences explaining the function of the command,
	// and the complete list of flags the command accepts.
	Help() string

	// Run should run the actual command with the given CLI instance and
	// command-line arguments. It should return the exit status when it is
	// finished.
	Run(args []string) int

	// Synopsis should return a one-line, short synopsis of the command.
	// This should be less than 50 characters ideally.
	Synopsis() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Command&lt;/code&gt; インタフェースはサブコマンドの context 情報を構成するのに使う。
&lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; は &lt;code&gt;Command&lt;/code&gt; インタフェースに適合する型（&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt;）のインスタンスを受け取ってサブコマンドの制御を行う&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:t&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:t&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
さらに以下の関数値（function value）を示す型 &lt;code&gt;CommandFactory&lt;/code&gt; も用意されている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// CommandFactory is a type of function that is a factory for commands.
// We need a factory because we may need to setup some state on the
// struct that implements the command itself.
type CommandFactory func() (Command, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように &lt;code&gt;Command&lt;/code&gt; 型のインスタンスを返す関数を型として定義し，この型のリストを作成するのである。&lt;/p&gt;

&lt;h3 id=&#34;cli-構造体:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;CLI 構造体&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; に渡す context 情報は &lt;code&gt;CLI&lt;/code&gt; 構造体にまとめられている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// CLI contains the state necessary to run subcommands and parse the
// command line arguments.
type CLI struct {
	// Args is the list of command-line arguments received excluding
	// the name of the app. For example, if the command &amp;quot;./cli foo bar&amp;quot;
	// was invoked, then Args should be []string{&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;}.
	Args []string

	// Commands is a mapping of subcommand names to a factory function
	// for creating that Command implementation. If there is a command
	// with a blank string &amp;quot;&amp;quot;, then it will be used as the default command
	// if no subcommand is specified.
	Commands map[string]CommandFactory

	// Name defines the name of the CLI.
	Name string

	// Version of the CLI.
	Version string

	// HelpFunc and HelpWriter are used to output help information, if
	// requested.
	//
	// HelpFunc is the function called to generate the generic help
	// text that is shown if help must be shown for the CLI that doesn&#39;t
	// pertain to a specific command.
	//
	// HelpWriter is the Writer where the help text is outputted to. If
	// not specified, it will default to Stderr.
	HelpFunc   HelpFunc
	HelpWriter io.Writer

	once           sync.Once
	isHelp         bool
	subcommand     string
	subcommandArgs []string
	topFlags       []string

	isVersion bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;構造体の中に &lt;code&gt;CommandFactory&lt;/code&gt; のリストが含まれていることがお分かりだろうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Commands map[string]CommandFactory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これによってサブコマンド名と対応する処理を関連付けている。&lt;/p&gt;

&lt;h3 id=&#34;ui-インタフェース:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;Ui インタフェース&lt;/h3&gt;

&lt;p&gt;入出力関数群を持つ &lt;code&gt;Ui&lt;/code&gt; インタフェースは以下のように定義されている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Ui is an interface for interacting with the terminal, or &amp;quot;interface&amp;quot;
// of a CLI. This abstraction doesn&#39;t have to be used, but helps provide
// a simple, layerable way to manage user interactions.
type Ui interface {
	// Ask asks the user for input using the given query. The response is
	// returned as the given string, or an error.
	Ask(string) (string, error)

	// AskSecret asks the user for input using the given query, but does not echo
	// the keystrokes to the terminal.
	AskSecret(string) (string, error)

	// Output is called for normal standard output.
	Output(string)

	// Info is called for information related to the previous output.
	// In general this may be the exact same as Output, but this gives
	// Ui implementors some flexibility with output formats.
	Info(string)

	// Error is used for any error messages that might appear on standard
	// error.
	Error(string)

	// Warn is used for any warning messages that might appear on standard
	// error.
	Warn(string)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更に &lt;code&gt;Ui&lt;/code&gt; の特化クラスとして &lt;code&gt;BasicUi&lt;/code&gt; や &lt;code&gt;PrefixedUi&lt;/code&gt; や &lt;code&gt;ColoredUi&lt;/code&gt; が定義されている。
&lt;code&gt;ColoredUi&lt;/code&gt; は出力をカラーにできるが，残念ながら Windows のコマンドプロンプトには対応していないようだ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Ui&lt;/code&gt; インタフェースは &lt;code&gt;Command&lt;/code&gt; インタフェースと組み合わせてサブコマンド側の context 情報を構成するのに使う。&lt;/p&gt;

&lt;h3 id=&#34;mitchellh-cli-パッケージのメリット:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;mitchellh/cli パッケージのメリット&lt;/h3&gt;

&lt;p&gt;上述したように &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; はサブコマンドをファサード・パターンで実装するのに便利な機能を実装している。
なおかつ &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; ではファサード・パターンを入れ子にすることができる。
たとえばサブコマンドのサブコマンドを構成することもできるのだ。&lt;/p&gt;

&lt;h2 id=&#34;mitchellh-cli-を使ってファサード-パターンを組んでみる:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;mitchellh/cli を使ってファサード・パターンを組んでみる&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; をファサード・パターンとして組みやすくするためのラッパーとして &lt;a href=&#34;https://github.com/spiegel-im-spiegel/gofacade&#34; title=&#34;spiegel-im-spiegel/gofacade&#34;&gt;spiegel-im-spiegel/gofacade&lt;/a&gt; パッケージを作ってみた&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:li&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:li&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;まず，入出力の Context を定義するためのクラスとして &lt;code&gt;Context&lt;/code&gt; 構造体を作った。
中身は &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;&lt;code&gt;cli&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;BasicUi&lt;/code&gt; 構造体を埋め込んでいるだけである&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:ebd1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:ebd1&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Context inheritance cli.BasicUi
type Context struct {
	//Embedded BasicUi
	*cli.BasicUi
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更に &lt;code&gt;Context&lt;/code&gt; 構造体を包含する &lt;code&gt;Facade&lt;/code&gt; 構造体を定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Facade is context of facade
type Facade struct {
	//UI defines user interface of the Cli
	Cxt *Context
	// commands is a mapping of subcommand names to a factory function
	commands map[string]cli.CommandFactory
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Facade&lt;/code&gt; 構造体には &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;&lt;code&gt;cli&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;CommandFactory&lt;/code&gt; のリストを含んでいる。
このリストに &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;&lt;code&gt;cli&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Command&lt;/code&gt; インタフェースに適合するインスタンスを追加するための関数がこれ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:cl&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:cl&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// AddCommand add command
func (f *Facade) AddCommand(name string, command cli.Command) {
	f.commands[name] = func() (cli.Command, error) {
		return command, nil
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際にファサードを実行するには以下の関数を起動する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Run facade
func (f *Facade) Run(appName, version string, args []string) (int, error) {
	c := cli.NewCLI(appName, version)
	c.Args = args
	c.Commands = f.commands
	c.HelpWriter = f.Cxt.Writer
	return c.Run()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他に細かい道具はあるが，まぁこんなもんだろう。&lt;/p&gt;

&lt;h3 id=&#34;spiegel-im-spiegel-gofacade-の実装例:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;spiegel-im-spiegel/gofacade の実装例&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/gofacade&#34; title=&#34;spiegel-im-spiegel/gofacade&#34;&gt;spiegel-im-spiegel/gofacade&lt;/a&gt; パッケージの実装例として &lt;a href=&#34;https://github.com/spiegel-im-spiegel/astrocalc&#34; title=&#34;spiegel-im-spiegel/astrocalc&#34;&gt;spiegel-im-spiegel/astrocalc&lt;/a&gt; パッケージに CLI ツールを追加してみた。
こんな感じのコマンドラインを構成してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ astrocalc [-v | -h] mjdn &amp;lt;year&amp;gt; &amp;lt;month&amp;gt; &amp;lt;day&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず &lt;code&gt;astrocalc mjdn&lt;/code&gt; サブコマンドを以下のように定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package mjdnCmd

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/astrocalc/mjdn&amp;quot;
	&amp;quot;github.com/spiegel-im-spiegel/gofacade&amp;quot;
)

// Name は mjdn コマンド名を定義する
const Name string = &amp;quot;mjdn&amp;quot;

// Context は mjdn コマンドのコンテキストを定義する
type Context struct {
	//Embedded gofacade.Context
	*gofacade.Context
	//AppName にはアプリケーション名を格納する
	AppName string
}

// Command は Context のインスタンスを返す
func Command(cxt *gofacade.Context, appName string) *Context {
	return &amp;amp;Context{Context: cxt, AppName: appName}
}

// Synopsis は mjdn コマンドの概要を返す
func (c Context) Synopsis() string {
	return &amp;quot;Calculation of Modified Julian Day&amp;quot;
}

// Help は mjdn コマンドのヘルプを返す
func (c Context) Help() string {
	helpText := `
Usage: astrocalc mjdn &amp;lt;year&amp;gt; &amp;lt;month&amp;gt; &amp;lt;day&amp;gt;
`
	return fmt.Sprintln(strings.TrimSpace(helpText))
}

// Run は mjdn コマンドを実行する
func (c Context) Run(args []string) int {
	flags := flag.NewFlagSet(Name, flag.ContinueOnError)
	flags.Usage = func() {
		c.Error(c.Help())
	}
	// Parse commandline flag
	if err := flags.Parse(args); err != nil {
		return gofacade.ExitCodeError
	}
	if flags.NArg() != 3 {
		c.Error(fmt.Sprintf(&amp;quot;年月日を指定してください\n\n%s&amp;quot;, c.Help()))
		return gofacade.ExitCodeError
	}
	argsStr := flags.Args()
	var ymd = make([]int, 3)
	for i, arg := range argsStr {
		num, err := strconv.Atoi(arg)
		if err != nil {
			c.Error(fmt.Sprintln(err))
			return gofacade.ExitCodeError
		}
		ymd[i] = num
	}
	tm := time.Date(ymd[0], time.Month(ymd[1]), ymd[2], 0, 0, 0, 0, time.UTC)
	c.Output(fmt.Sprint(mjdn.DayNumber(tm)))
	return gofacade.ExitCodeOK
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイントは &lt;code&gt;astrocalc mjdn&lt;/code&gt; サブコマンド用の context 情報として &lt;code&gt;Context&lt;/code&gt; 構造体を定義しているところ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Context は mjdn コマンドのコンテキストを定義する
type Context struct {
	//Embedded gofacade.Context
	*gofacade.Context
	//AppName にはアプリケーション名を格納する
	AppName string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/gofacade&#34; title=&#34;spiegel-im-spiegel/gofacade&#34;&gt;&lt;code&gt;gofacade&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Context&lt;/code&gt; 構造体を埋め込みフィールドで定義しているのがお分かりだろうか。
&lt;a href=&#34;https://github.com/spiegel-im-spiegel/gofacade&#34; title=&#34;spiegel-im-spiegel/gofacade&#34;&gt;&lt;code&gt;gofacade&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Context&lt;/code&gt; はさらに &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;&lt;code&gt;cli&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;BasicUi&lt;/code&gt; 構造体を埋め込んでいる。
また &lt;code&gt;Context&lt;/code&gt; 構造体は &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;&lt;code&gt;cli&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Command&lt;/code&gt; インタフェースの特化クラスとして実装している。&lt;/p&gt;

&lt;p&gt;では，この &lt;code&gt;Context&lt;/code&gt; 構造体を使ってアプリケーションの起動部分を書いてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/astrocalc/internal/mjdnCmd&amp;quot;
	&amp;quot;github.com/spiegel-im-spiegel/gofacade&amp;quot;
)

const (
	// Name はアプリケーション名を定義する
	Name string = &amp;quot;astrocalc&amp;quot;
	// Version はアプリケーションのバージョン番号を定義する
	Version string = &amp;quot;0.1.0&amp;quot;
)

func setupFacade(cxt *gofacade.Context) *gofacade.Facade {
	fcd := gofacade.NewFacade(cxt)
	fcd.AddCommand(mjdnCmd.Name, mjdnCmd.Command(cxt, Name))
	return fcd
}

func main() {
	cxt := gofacade.NewContext(os.Stdin, os.Stdout, os.Stderr)
	fcd := setupFacade(cxt)
	rtn, err := fcd.Run(Name, Version, os.Args[1:])
	if err != nil {
		cxt.Error(fmt.Sprintln(err))
	}
	os.Exit(rtn)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;setupFacade()&lt;/code&gt; 関数でファサードを作成し， &lt;code&gt;main()&lt;/code&gt; 関数で実行しているのが分かると思う。
では実際に compile &amp;amp; run してみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\astrocalc&amp;gt; pushd C:\workspace\astrocalc\src\github.com\spiegel-im-spiegel\astrocalc

C:\workspace\astrocalc\src\github.com\spiegel-im-spiegel\astrocalc&amp;gt; glide up
[INFO] Fetching updates for github.com/spiegel-im-spiegel/gofacade.
[INFO] Found glide.yaml in C:\workspace\astrocalc\src\github.com\spiegel-im-spiegel\astrocalc\vendor\github.com\spiegel-im-spiegel\gofacade/glide.yaml
[INFO] Fetching updates for github.com/mitchellh/cli.
[INFO] Scanning github.com/mitchellh/cli for dependencies.
[INFO] ==&amp;gt; Unknown github.com/bgentry/speakeasy (github.com/bgentry/speakeasy)
[INFO] ==&amp;gt; Unknown github.com/mattn/go-isatty (github.com/mattn/go-isatty)
[INFO] Fetching updates for github.com/bgentry/speakeasy.
[INFO] Fetching updates for github.com/mattn/go-isatty.
[INFO] Scanning github.com/bgentry/speakeasy for dependencies.
[INFO] Scanning github.com/mattn/go-isatty for dependencies.
[INFO] Project relies on 4 dependencies.
[INFO] Writing glide.lock file

C:\workspace\astrocalc\src\github.com\spiegel-im-spiegel\astrocalc&amp;gt; popd

C:\workspace\astrocalc&amp;gt; go install -v github.com/spiegel-im-spiegel/astrocalc
github.com/spiegel-im-spiegel/astrocalc/mjdn
github.com/spiegel-im-spiegel/astrocalc/vendor/github.com/bgentry/speakeasy
github.com/spiegel-im-spiegel/astrocalc/vendor/github.com/mattn/go-isatty
github.com/spiegel-im-spiegel/astrocalc/vendor/github.com/mitchellh/cli
github.com/spiegel-im-spiegel/astrocalc/vendor/github.com/spiegel-im-spiegel/gofacade
github.com/spiegel-im-spiegel/astrocalc/internal/mjdnCmd
github.com/spiegel-im-spiegel/astrocalc

C:\workspace\astrocalc&amp;gt; bin\astrocalc.exe -h
usage: astrocalc [--version] [--help] &amp;lt;command&amp;gt; [&amp;lt;args&amp;gt;]

Available commands are:
    mjdn    Calculation of Modified Julian Day

C:\workspace\astrocalc&amp;gt; bin\astrocalc.exe -h mjdn
Usage: astrocalc mjdn &amp;lt;year&amp;gt; &amp;lt;month&amp;gt; &amp;lt;day&amp;gt;

C:\workspace\astrocalc&amp;gt; bin\astrocalc.exe mjdn 2015 1 1
57023 (2015-01-01)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よしよし。
うまくいった。
なお &lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; については「&lt;a href=&#34;http://text.baldanders.info/golang/vendoring-with-glide/&#34;&gt;Glide で Vendoring&lt;/a&gt;」を参考にどうぞ。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://yuuki.hatenablog.com/entry/go-cli-unix&#34;&gt;Go言語によるCLIツール開発とUNIX哲学について - ゆううきブログ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tellme.tokyo/post/2015/06/23/unix_cli_tool_go/&#34;&gt;開発者から見た UNIX 哲学とコマンドラインツールと Go言語 - TELLME.TOKYO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ryochack.hatenablog.com/entry/2013/04/17/232753&#34;&gt;Go言語のflagパッケージを使う - uragami note&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/04/17/panicwrap/&#34;&gt;Go言語のCLIツールのpanicをラップしてクラッシュレポートをつくる | SOTA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/kumatch/items/258d7984c0270f6dd73a&#34;&gt;flag 並にシンプルでより強力な CLI パーサ kingpin の紹介 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;参考図書:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8ATHGW/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/41mh5r0NwLL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8ATHGW/baldandersinf-22/&#34;&gt;増補改訂版 Java言語で学ぶデザインパターン入門&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;結城 浩 &lt;/dd&gt;&lt;dd&gt;SBクリエイティブ 2004-06-18&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;4&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-4-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1BS/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1BS.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;増補改訂版 Java言語で学ぶデザインパターン入門 マルチスレッド編&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1EU/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1EU.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Java言語で学ぶリファクタリング入門&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00JEYPPOE/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00JEYPPOE.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Code Complete 第2版 上　完全なプログラミングを目指して&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B0197SZZZ0/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B0197SZZZ0.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;日経Linux（リナックス） 2016年 1月号 [雑誌]&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00V2WMQNE/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00V2WMQNE.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;改訂2版　パーフェクトJava&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;結城浩さんによる通称「デザパタ本」。 Java 以外でも使える優れもの。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-01-05&#34;&gt;2016-01-05&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:up&#34;&gt;翻訳は &lt;a href=&#34;https://ja.wikipedia.org/wiki/UNIX%E5%93%B2%E5%AD%A6&#34;&gt;Wikipedia の記事&lt;/a&gt;から拝借させてもらった。ちなみに &lt;a href=&#34;https://ja.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License&#34;&gt;Wikipedia のコンテンツは基本的には by-sa ライセンスで公開&lt;/a&gt;されている。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:up&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:fcd&#34;&gt;ファサード自身はサブシステムの詳細を知らず context 情報を渡して処理をキックするのみなのが特徴。サブシステム側はファサードに依存せず， context 情報さえあれば処理可能にするのがコツである。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:fcd&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:t&#34;&gt;型（&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt;）については「&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」&lt;/a&gt;」を参照のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:t&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:li&#34;&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/gofacade&#34; title=&#34;spiegel-im-spiegel/gofacade&#34;&gt;spiegel-im-spiegel/gofacade&lt;/a&gt; は &lt;a href=&#34;https://creativecommons.org/publicdomain/zero/1.0/&#34;&gt;CC0&lt;/a&gt; で公開している。個人的には実証コードの扱いなので，（著作権情報の書き換えも含めて）自由に利用して 構わない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:li&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:ebd1&#34;&gt;なんでこんな回りくどいことをしているかというと， &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; パッケージをカプセル化したかったから。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:ebd1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:cl&#34;&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では関数は全て関数閉包（closure）として機能する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:cl&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Go 言語における「オブジェクト」 — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/object-oriented-programming/" />
		<id>tag:text.Baldanders.info,2015-12-15:/golang/object-oriented-programming/</id>
		<published>2015-12-15T21:19:58+09:00</published>
		<updated>2016-01-20T09:15:48+09:00</updated>
		<summary>Go 言語がいわゆる「オブジェクト指向言語」と言えるかどうかについては色々とあるようだが，オブジェクト指向プログラミングを助けるための仕掛けはいくつか存在する。今回はその中の type キーワードを中心に解説していく。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;がいわゆる「オブジェクト指向言語」と言えるかどうかについては色々とあるようだが，オブジェクト指向プログラミングを助けるための仕掛けはいくつか存在する。
今回はその中の &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードを中心に解説していく。&lt;/p&gt;

&lt;p&gt;なお，今回のソースコードは “&lt;a href=&#34;https://tour.golang.org/&#34;&gt;A Tour of Go&lt;/a&gt;” のものをかなり流用しているため取り扱いに注意。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の公式ドキュメントは CC License の by 3.0，ソースコードは &lt;a href=&#34;https://golang.org/LICENSE&#34;&gt;BSD license&lt;/a&gt; で提供されている。&lt;/p&gt;

&lt;h2 id=&#34;go-言語の基本型:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;Go 言語の基本型&lt;/h2&gt;

&lt;p&gt;今さらだけど， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の基本型（basic type）は以下の通り。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bool&lt;/li&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;int, int8, int16, int32, int64&lt;/li&gt;
&lt;li&gt;uint, uint8, uint16, uint32, uint64&lt;/li&gt;
&lt;li&gt;uintptr&lt;/li&gt;
&lt;li&gt;byte&lt;/li&gt;
&lt;li&gt;rune&lt;/li&gt;
&lt;li&gt;float32, float64&lt;/li&gt;
&lt;li&gt;complex64, complex128&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このうち byte は uint8 の別名で rune&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:rn&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:rn&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; は int32 の別名である。
また int, uint, uintptr のサイズはプラットフォーム依存になっている。
string は不変（immutable）な値で，その実体は byte 配列である。
基本型は組み込み型であり，振る舞いを追加・変更することはできない。&lt;/p&gt;

&lt;p&gt;さらにこれらの基本型を集約した構造体 &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; を定義できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	vertex := struct {
		X int
		Y int
	}{X: 1, Y: 2}
	fmt.Println(vertex)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに構造体のフィールド（field）には構造体を含めることができ，入れ子構造にすることもできる。&lt;/p&gt;

&lt;p&gt;この他に配列（array/slice）や連想配列（map）あるいは関数値（function value）といったものもあるが，今回は踏み込まない&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:slc&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:slc&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;型に名前を付ける:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;型に名前を付ける&lt;/h2&gt;

&lt;p&gt;全ての型には &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードを使って名前を付けることができる。
例えば先ほどのコードは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func main() {
	vertex := Vertex{X: 1, Y: 2}
	fmt.Println(vertex)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書き直すことができる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードが使えるのは構造体だけではない。
上述の基本型も &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードを使って型を再定義できる。&lt;/p&gt;

&lt;p&gt;たとえば，2つの時点間の時間を表す &lt;a href=&#34;https://golang.org/pkg/time/&#34; title=&#34;time - The Go Programming Language&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Duration&lt;/code&gt; は以下のように定義されている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Duration int64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また，配列なども型として再定義できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Msgs []string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードを使って型に名前を付ける利点は3つある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;名前を付けることでコードの可読性を上げる（オブジェクト指向設計では名前がとても重要）&lt;/li&gt;
&lt;li&gt;再利用性の向上（特に構造体の場合）&lt;/li&gt;
&lt;li&gt;型に関数を関連付けることができる。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードによる名付けは単なる別名定義ではないということだ。&lt;/p&gt;

&lt;h2 id=&#34;型に関数を関連付ける:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;型に関数を関連付ける&lt;/h2&gt;

&lt;p&gt;型に関数を関連付けるには以下のように記述する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X =&amp;quot;, v.X, &amp;quot;, Y =&amp;quot;, v.Y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(v Vertex)&lt;/code&gt; の部分はメソッド・レシーバ（method receiver）と呼ばれ，これが型と関数を関連付ける役割を果たす。
内部処理としては&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func String(v Vertex) string {
	return fmt.Sprint(&amp;quot;X =&amp;quot;, v.X, &amp;quot;, Y =&amp;quot;, v.Y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と等価である&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:call&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:call&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
関数の呼び出し側は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X =&amp;quot;, v.X, &amp;quot;, Y =&amp;quot;, v.Y)
}

func main() {
	vertex := Vertex{X: 1, Y: 2}
	fmt.Println(vertex.String())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにピリオドで関数を連結して記述する&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:pr&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:pr&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;構造体そのものには関数を付与できない&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:mt&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:mt&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。
たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func (v struct{ X, Y int }) String() string {
	return fmt.Sprint(&amp;quot;X =&amp;quot;, v.X, &amp;quot;, Y =&amp;quot;, v.Y)
}

func main() {
	var vertex = struct {
		X int
		Y int
	}{X: 1, Y: 2}
	fmt.Println(vertex.String())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと書いても，コンパイル時に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;invalid receiver type struct { X int; Y int } (struct { X int; Y int } is an unnamed type)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と怒られる。
&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードによって型に名前が付けられていることが重要なのだ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;には class キーワードはないが， &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードを使うことで，名前と属性と操作を持つクラスを記述することができる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:cls&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:cls&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;汎化-特化と処理の委譲:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;汎化・特化と処理の委譲&lt;/h2&gt;

&lt;p&gt;オブジェクト指向設計においてクラス間の関係は大きく2つある。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;汎化・特化&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:c1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:c1&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;（継承または is-a 関係）&lt;/li&gt;
&lt;li&gt;関連&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:c2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:c2&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;（包含または has-a 関係）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;このうち関連についてはこれまで説明した方法で実現できるが，汎化・特化は表現できない。
そこで以下の機能を使って汎化・特化を実現する。&lt;/p&gt;

&lt;h3 id=&#34;振る舞いのみを定義した型:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;振る舞いのみを定義した型&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Interface_types&#34; title=&#34;Interface types&#34;&gt;interface&lt;/a&gt; を使うと振る舞いのみを定義した型を表現することができる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Interface_types&#34; title=&#34;Interface types&#34;&gt;interface&lt;/a&gt; で定義された型で最もよく目にするのは &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; だろう。
&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; は以下のように定義できる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:er1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:er1&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type error interface {
	Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; は「string 型を返す &lt;code&gt;Error()&lt;/code&gt; 関数」のみが定義されている。
逆に言うと「string 型を返す &lt;code&gt;Error()&lt;/code&gt; 関数」を持つ全ての型は &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; の一種（つまり is-a 関係）であると見なすことができる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:dt&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:dt&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package os

// PathError records an error and the operation and file path that caused it.
type PathError struct {
	Op   string
	Path string
	Err  error
}

func (e *PathError) Error() string { return e.Op + &amp;quot; &amp;quot; + e.Path + &amp;quot;: &amp;quot; + e.Err.Error() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義される &lt;a href=&#34;https://golang.org/pkg/os/&#34; title=&#34;os - The Go Programming Language&#34;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;PathError&lt;/code&gt; は &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; の一種である。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Interface_types&#34; title=&#34;Interface types&#34;&gt;interface&lt;/a&gt; も &lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt; キーワードで名前を付けることができ，他の型と同じように扱うことができる。
さらに &lt;a href=&#34;https://golang.org/ref/spec#Interface_types&#34; title=&#34;Interface types&#34;&gt;interface&lt;/a&gt; で定義した型は振る舞いのみで具体的な実装を含まないため，多態性を持たせた記述が可能になる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:if&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:if&#34;&gt;11&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h3 id=&#34;型の埋め込み:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;型の埋め込み&lt;/h3&gt;

&lt;p&gt;もうひとつの汎化・特化の機能が型の埋め込み（embedding）である。
構造体や &lt;a href=&#34;https://golang.org/ref/spec#Interface_types&#34; title=&#34;Interface types&#34;&gt;interface&lt;/a&gt; には別の型を埋め込むことができる。&lt;/p&gt;

&lt;p&gt;たとえば &lt;a href=&#34;https://golang.org/pkg/io/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;ReadWriter&lt;/code&gt; は以下のように &lt;code&gt;Reader&lt;/code&gt; および &lt;code&gt;Writer&lt;/code&gt; を埋め込んでいる。
（このときの &lt;code&gt;Reader&lt;/code&gt; および &lt;code&gt;Writer&lt;/code&gt; を「埋め込みインタフェース（embedding interface）」と呼ぶ）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package io

// Implementations must not retain p.
type Reader interface {
	Read(p []byte) (n int, err error)
}

// Implementations must not retain p.
type Writer interface {
	Write(p []byte) (n int, err error)
}

// ReadWriter is the interface that groups the basic Read and Write methods.
type ReadWriter interface {
	Reader
	Writer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これによって &lt;code&gt;ReadWriter&lt;/code&gt; は &lt;code&gt;Read()&lt;/code&gt; および &lt;code&gt;Write()&lt;/code&gt; を自身の振る舞いのように扱うことができる。
この場合も &lt;code&gt;ReadWriter&lt;/code&gt; は &lt;code&gt;Reader&lt;/code&gt; および &lt;code&gt;Writer&lt;/code&gt; の一種であると見なすことができる。&lt;/p&gt;

&lt;p&gt;同様に &lt;a href=&#34;https://golang.org/pkg/bufio/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;bufio&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;ReadWriter&lt;/code&gt; についても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package bufio

// ReadWriter stores pointers to a Reader and a Writer.
// It implements io.ReadWriter.
type ReadWriter struct {
	*Reader
	*Writer
}

// NewReadWriter allocates a new ReadWriter that dispatches to r and w.
func NewReadWriter(r *Reader, w *Writer) *ReadWriter {
	return &amp;amp;ReadWriter{r, w}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と実装されていて， &lt;a href=&#34;https://golang.org/pkg/bufio/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;bufio&lt;/code&gt;&lt;/a&gt; の &lt;code&gt;Reader&lt;/code&gt; および &lt;code&gt;Writer&lt;/code&gt; を埋め込み，これらの型の一種として実装されている（このときの &lt;code&gt;Reader&lt;/code&gt; および &lt;code&gt;Writer&lt;/code&gt; を「埋め込みフィールド（embedded field）」または「匿名フィールド（anonymous field）」と呼ぶ）。
なお， &lt;a href=&#34;https://golang.org/pkg/bufio/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;bufio&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;ReadWriter&lt;/code&gt; は &lt;a href=&#34;https://golang.org/pkg/io/&#34; title=&#34;io - The Go Programming Language&#34;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;ReadWriter&lt;/code&gt; の一種として機能している点にも注目してほしい。&lt;/p&gt;

&lt;h3 id=&#34;関数のオーバーライドと処理の委譲:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;関数のオーバーライドと処理の委譲&lt;/h3&gt;

&lt;p&gt;では，今まで述べたことを使って以下のコードを書いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type ErrorInfo interface {
	error
	Errno() int
}

type ErrorInfo1 struct{}

func (err *ErrorInfo1) Error() string {
	return fmt.Sprint(&amp;quot;Error Information: &amp;quot;, err.Errno())
}

func (err *ErrorInfo1) Errno() int {
	return 1
}

func Action() error {
	err := &amp;amp;ErrorInfo1{}
	return err
}

func main() {
    if err := Action(); err != nil {
		fmt.Println(err)
        return
	}
    fmt.Println(&amp;quot;Normal End&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; の拡張として &lt;code&gt;ErrorInfo&lt;/code&gt; を定義する。
&lt;code&gt;ErrorInfo&lt;/code&gt; では &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; を埋め込み，さらに &lt;code&gt;Errno()&lt;/code&gt; を追加している。
これを実装したのが &lt;code&gt;ErrorInfo1&lt;/code&gt; である。
したがって実行結果は “&lt;code&gt;Error Information: 1&lt;/code&gt;” が出力される。&lt;/p&gt;

&lt;p&gt;次に &lt;code&gt;ErrorInfo1&lt;/code&gt; のバリエーションとして &lt;code&gt;ErrorInfo2&lt;/code&gt; を追加してみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type ErrorInfo interface {
	error
	Errno() int
}

type ErrorInfo1 struct{}

func (err *ErrorInfo1) Error() string {
	return fmt.Sprint(&amp;quot;Error Information: &amp;quot;, err.Errno())
}

func (err *ErrorInfo1) Errno() int {
	return 1
}

type ErrorInfo2 struct {
	ErrorInfo1
}

func (err *ErrorInfo2) Errno() int {
	return 2
}

func Action() error {
	err := &amp;amp;ErrorInfo2{}
	return err
}

func main() {
    if err := Action(); err != nil {
		fmt.Println(err)
        return
	}
    fmt.Println(&amp;quot;Normal End&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ErrorInfo2&lt;/code&gt; では &lt;code&gt;Error()&lt;/code&gt; は &lt;code&gt;ErrorInfo1&lt;/code&gt; のものをそのまま使い回したいが &lt;code&gt;Errno()&lt;/code&gt; では異なる値を出力したい，と考えた。
実行結果として “&lt;code&gt;Error Information: 2&lt;/code&gt;” が出力されることを期待したが，実際には前回と同じ “&lt;code&gt;Error Information: 1&lt;/code&gt;” が出力される。&lt;/p&gt;

&lt;p&gt;埋め込みフィールド（&lt;code&gt;ErrorInfo1&lt;/code&gt;）の関数の名前が埋め込みを行った型（&lt;code&gt;ErrorInfo2&lt;/code&gt;）の名前と衝突する場合は埋め込みを行った型のほうが優先的される&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:ovr&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:ovr&#34;&gt;12&lt;/a&gt;&lt;/sup&gt; が，これは C++ や Java などにある仮想関数のオーバーライドとは少し異なる。&lt;/p&gt;

&lt;p&gt;上のコードでは &lt;code&gt;ErrorInfo2&lt;/code&gt; と直接関連付けられた &lt;code&gt;Error()&lt;/code&gt; がないため &lt;code&gt;ErrorInfo1&lt;/code&gt; の &lt;code&gt;Error()&lt;/code&gt; が呼ばれるが，その関数の中で呼ばれる &lt;code&gt;Errno()&lt;/code&gt; は &lt;code&gt;ErrorInfo2&lt;/code&gt; と関連付けられた関数ではなく &lt;code&gt;ErrorInfo1&lt;/code&gt; と関連付けられた関数になる。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/delegation.svg&#34;&gt;&lt;img src=&#34;http://text.baldanders.info/images/delegation.svg&#34; alt=&#34;delegation&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;http://text.baldanders.info/images/delegation.svg&#34;&gt;delegation&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;これは &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では埋め込みフィールドの関数呼び出しが「委譲」として機能しているためである&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:ef&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:ef&#34;&gt;13&lt;/a&gt;&lt;/sup&gt;。
たとえば C++ 言語では virtual 修飾子を付与して仮想関数化することで意図的にオーバーライドできるが&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:dlg&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:dlg&#34;&gt;14&lt;/a&gt;&lt;/sup&gt;， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;ではこのような仕掛けがないため，呼ばれた関数は常に委譲として機能する。&lt;/p&gt;

&lt;p&gt;上の例はクラス構成からして明らかにダメダメなのだが，今回のポイントはサブクラスである &lt;code&gt;ErrorInfo2&lt;/code&gt; から &lt;code&gt;Errno()&lt;/code&gt; 関数を上書きすることでスーパークラス &lt;code&gt;ErrorInfo1&lt;/code&gt; の &lt;code&gt;Error()&lt;/code&gt; 関数の処理を書き換えようとした点にある。
継承&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:374c32c25cfbe86872f0cdc7cd9ba174:ih&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:374c32c25cfbe86872f0cdc7cd9ba174:ih&#34;&gt;15&lt;/a&gt;&lt;/sup&gt; の実装で一番よくあるミスがこの「カプセル化の破れ」で， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の場合は敢えて移譲を強制することでこの手の不具合が発生するのを回避しようとしているように見える。&lt;/p&gt;

&lt;p&gt;また，他の言語では明示的に委譲を実装しようとすると冗長な記述になることが多いが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の場合は埋め込みを使うことでシンプルな記述で委譲を実装できる点がメリットと言える。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:374c32c25cfbe86872f0cdc7cd9ba174&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mattn.kaoriya.net/software/lang/go/20130919023425.htm&#34;&gt;Big Sky :: Go言語でインタフェースの変更がそれ程問題にならない理由&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/shibukawa/items/16acb36e94cfe3b02aa1&#34;&gt;オブジェクト指向言語としてGolangをやろうとするとハマること - Qiita&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/sona-tar/items/2b4b70694fd680f6297c&#34;&gt;オブジェクト指向言語としてGolangをやろうとするとハマる点を整理してみる - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://otiai10.hatenablog.com/entry/2014/01/15/220136&#34;&gt;Go言語に継承は無いんですか【golang】 - DRYな備忘録&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://otiai10.hatenablog.com/entry/2014/06/16/224109&#34;&gt;Go言語でジェネリクスっぽいことがしたいでござる【generics】【golang】 - DRYな備忘録&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:rn&#34;&gt;rune は Unicode 文字の符号点（code point）を示す型で文字そのものを表現する。 string と rune の関係については「&lt;a href=&#34;http://text.baldanders.info/golang/string-and-rune/&#34;&gt;String と Rune&lt;/a&gt;」を参照のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:rn&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:slc&#34;&gt;slice については「&lt;a href=&#34;http://text.baldanders.info/golang/search-prime-numbers/&#34;&gt;素数探索アルゴリズムで遊ぶ&lt;/a&gt;」で少し紹介している。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:slc&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:call&#34;&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の関数呼び出しでは，引数の渡し方は基本的に「値渡し」である。「参照渡し」にするにはポインタを使う。メソッド・レシーバについては値渡しで定義すれば値とポインタ両方のインスタンスに対して関数を呼び出せる。いわゆる value object についてはこれで問題ないだろう。バッファ操作のような内部状態を操作する関数についてはメソッド・レシーバを参照渡しにして定義するとよい。ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のポインタは C/C++ のようなポインタ演算はできないので注意（ポインタ演算をしたい場合は &lt;a href=&#34;https://golang.org/pkg/unsafe/&#34; title=&#34;unsafe - The Go Programming Language&#34;&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; パッケージを使う）。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:call&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:pr&#34;&gt;ちなみに &lt;a href=&#34;https://golang.org/pkg/fmt/&#34; title=&#34;time - The Go Programming Language&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Print&lt;/code&gt; などでは引数の型が &lt;code&gt;String()&lt;/code&gt; を持っていることを期待し，この関数の出力結果をデフォルト書式にしている。したがって &lt;code&gt;fmt.Println(vertex.String())&lt;/code&gt; と &lt;code&gt;fmt.Println(vertex)&lt;/code&gt; は同じ結果になる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:pr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:mt&#34;&gt;他にも基本型や他パッケージで定義されている型に関数を追加することはできない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:mt&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:cls&#34;&gt;クラスは名前と属性と操作の3つの要素で構成されている。名前は他クラスと識別できるものを1個。属性と操作は0個以上存在する。 &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では空のフィールドの &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; を定義することにより0個の属性を持つクラスを構成できる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:cls&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:c1&#34;&gt;言わずもがなだが，サブクラスから見たスーパークラスが「汎化」でその逆が「特化」である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:c1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:c2&#34;&gt;関連は更に集約と複合に分類できるが今回は踏み込まない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:c2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:er1&#34;&gt;&lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; は組み込み型なので，実際にこのような定義が標準パッケージにあるわけではない。 &lt;a href=&#34;http://blog.golang.org/error-handling-and-go&#34; title=&#34;Error handling and Go - The Go Blog&#34;&gt;error&lt;/a&gt; について詳しくは「&lt;a href=&#34;http://text.baldanders.info/golang/error-handling/&#34;&gt;エラー・ハンドリングについて&lt;/a&gt;」を参照のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:er1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:dt&#34;&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では Java の implement のような継承を明示するキーワードはない。記述された振る舞いからクラス関係を決定する方法を「&lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_typing&#34;&gt;ダック・タイピング（duck typing）&lt;/a&gt;」と呼ぶ。ダック・タイピングの由来は「&lt;a href=&#34;https://en.wikipedia.org/wiki/Duck_test&#34;&gt;ダック・テスト（duck test）&lt;/a&gt;」だそうで，ダック・テストとは “If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.” と帰納法的に対象を推測する手法を指すらしい。ダック・タイピングのメリットのひとつは多重継承で発生する様々な問題（名前の衝突や菱形継承など）を気にする必要がない点である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:dt&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:if&#34;&gt;たとえば &lt;code&gt;interface{}&lt;/code&gt; と記述すればあらゆる型を含むことになる。これを利用して &lt;a href=&#34;https://golang.org/pkg/fmt/&#34; title=&#34;time - The Go Programming Language&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Print&lt;/code&gt; は &lt;code&gt;func Print(a ...interface{}) (n int, err error) { ... }&lt;/code&gt; と定義されている。ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;にはいわゆる&lt;a href=&#34;https://golang.org/doc/faq#generics&#34;&gt;「総称型」はサポートされていない&lt;/a&gt;。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:if&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:ovr&#34;&gt;複数の型を埋め込んでいる場合，埋め込みフィールド間で名前が衝突しているフィールドや関数を使おうとするとコンパイルエラーになる。この場合は &lt;code&gt;err.ErrorInfo1.Error()&lt;/code&gt; のように型を明示して回避できる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:ovr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:ef&#34;&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;的には埋め込みフィールドはフィールドのバリエーションのひとつにすぎないため，動作も通常のフィールドが持つ関数を呼び出した場合と変わらない。そういう意味では構造体への埋め込みは，見かけ上は「is-a 関係」でも，実質的には「has-a 関係」に近いと言えるかもしれない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:ef&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:dlg&#34;&gt;逆に Java では関数は常に仮想関数として機能しオーバーライドされる可能性がある。これを抑止するためには final 修飾子を付加する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:dlg&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:374c32c25cfbe86872f0cdc7cd9ba174:ih&#34;&gt;ここで言う継承は設計時の「汎化・特化」のことではなく，言語機能などを使った実装上の継承のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:374c32c25cfbe86872f0cdc7cd9ba174:ih&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Glide で Vendoring — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/vendoring-with-glide/" />
		<id>tag:text.Baldanders.info,2015-12-07:/golang/vendoring-with-glide/</id>
		<published>2015-12-07T23:30:21+09:00</published>
		<updated>2015-12-23T12:59:00+09:00</updated>
		<summary>Go 言語 1.5 の vendoring 機能をサポートするツールが glide である。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;以前「&lt;a href=&#34;http://text.baldanders.info/golang/gopath-pollution/&#34;&gt;GOPATH 汚染問題&lt;/a&gt;」で &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt; 1.5 の vendoring 機能を紹介したが，この vendoring のヘルパ・ツールと言えるのが &lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; である。
&lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; では依存する外部パッケージの情報を YAML 形式の定義ファイルに記述し，この定義ファイルを基に外部パッケージの管理を行う。&lt;/p&gt;

&lt;p&gt;（&lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; 0.8 から挙動が少し変わった。
この記事では 0.8.2 を使っている）&lt;/p&gt;

&lt;h2 id=&#34;glide-のインストール:721380b38042a10816ac6a323733a866&#34;&gt;Glide のインストール&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; は自身も &lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; で外部パッケージを管理している。
なので最初は &lt;code&gt;go get&lt;/code&gt; ではなく &lt;a href=&#34;https://github.com/Masterminds/glide/releases&#34;&gt;Releases&lt;/a&gt; ページからビルド済みのものを取得することをお勧めする&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:721380b38042a10816ac6a323733a866:ins&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:721380b38042a10816ac6a323733a866:ins&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;既に &lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; が利用可能な状態なら，以下の要領でビルドできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\glide&amp;gt;SET GOPATH=C:\workspace\glide

C:\workspace\glide&amp;gt;SET GO15VENDOREXPERIMENT=1

C:\workspace\glide&amp;gt;git clone git@github.com:Masterminds/glide.git src\github.com\Masterminds\glide
Cloning into &#39;src\github.com\Masterminds\glide&#39;...
remote: Counting objects: 2292, done.
remote: Compressing objects: 100% (65/65), done.
remote: Total 2292 (delta 34), reused 0 (delta 0), pack-reused 2292
Receiving objects: 100% (2292/2292), 468.01 KiB | 397.00
Receiving objects: 100% (2292/2292), 537.97 KiB | 397.00 KiB/s, done.
Resolving deltas: 100% (1578/1578), done.
Checking connectivity... done.

C:\workspace\glide&amp;gt;pushd src\github.com\Masterminds\glide

C:\workspace\glide\src\github.com\Masterminds\glide&amp;gt;glide install
[INFO] Fetching updates for github.com/codegangsta/cli.
[INFO] Fetching updates for github.com/Masterminds/cookoo.
[INFO] Fetching updates for github.com/Masterminds/vcs.
[INFO] Fetching updates for gopkg.in/yaml.v2.
[INFO] Fetching updates for github.com/Masterminds/semver.
[INFO] Setting version for github.com/Masterminds/cookoo to 78aa11ce75e257c51be7ea945edb84cf19c4a6de.
[INFO] Setting version for github.com/Masterminds/semver to 6333b7bd29aad1d79898ff568fd90a8aa533ae82.
[INFO] Setting version for github.com/codegangsta/cli to b5232bb2934f606f9f27a1305f1eea224e8e8b88.
[INFO] Setting version for github.com/Masterminds/vcs to eaee272c8fa4514e1572e182faecff5be20e792a.
[INFO] Setting version for gopkg.in/yaml.v2 to f7716cbe52baa25d2e9b0d0da546fcf909fc16b4.

C:\workspace\glide\src\github.com\Masterminds\glide&amp;gt;popd

C:\workspace\glide&amp;gt;go install -v ./...
github.com/Masterminds/glide/vendor/github.com/Masterminds/cookoo/io
github.com/Masterminds/glide/msg
github.com/Masterminds/glide/gb
github.com/Masterminds/glide/vendor/gopkg.in/yaml.v2
github.com/Masterminds/glide/vendor/github.com/Masterminds/semver
github.com/Masterminds/glide/vendor/github.com/codegangsta/cli
github.com/Masterminds/glide/vendor/github.com/Masterminds/cookoo/safely
github.com/Masterminds/glide/vendor/github.com/Masterminds/vcs
github.com/Masterminds/glide/vendor/github.com/Masterminds/cookoo
github.com/Masterminds/glide/vendor/github.com/Masterminds/cookoo/cli
github.com/Masterminds/glide/vendor/github.com/Masterminds/cookoo/database/sql
github.com/Masterminds/glide/vendor/github.com/Masterminds/cookoo/database/active
github.com/Masterminds/glide/vendor/github.com/Masterminds/cookoo/convert
github.com/Masterminds/glide/vendor/github.com/Masterminds/cookoo/fmt
github.com/Masterminds/glide/vendor/github.com/Masterminds/cookoo/web
github.com/Masterminds/glide/vendor/github.com/Masterminds/cookoo/example
github.com/Masterminds/glide/vendor/github.com/Masterminds/cookoo/log
github.com/Masterminds/glide/vendor/github.com/Masterminds/cookoo/web/auth
github.com/Masterminds/glide/util
github.com/Masterminds/glide/vendor/github.com/Masterminds/cookoo/doc
github.com/Masterminds/glide/cfg
github.com/Masterminds/glide/dependency
github.com/Masterminds/glide/cmd
github.com/Masterminds/glide

C:\workspace\glide&amp;gt;bin\glide.exe -v
glide version dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡単な使い方は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:&amp;gt; glide -h
NAME:
   glide - The lightweight vendor package manager for your Go projects.

Each project should have a &#39;glide.yaml&#39; file in the project directory. Files
look something like this:

        package: github.com/Masterminds/glide
        imports:
                - package: github.com/Masterminds/cookoo
                  vcs: git
                  ref: 1.1.0
                  subpackages: **
                - package: github.com/kylelemons/go-gypsy
                  subpackages: yaml
                        flatten: true

NOTE: As of Glide 0.5, the commands &#39;in&#39;, &#39;into&#39;, &#39;gopath&#39;, &#39;status&#39;, and &#39;env&#39;
no longer exist.


USAGE:
   glide [global options] command [command options] [arguments...]

VERSION:
   0.8.2

COMMANDS:
   create, init Initialize a new project, creating a glide.yaml file
   get          Install one or more packages into `vendor/` and add dependency to glide.yaml.
   import       Import files from other dependency management systems.
   name         Print the name of this project.
   novendor, nv List all non-vendor paths in a directory.
   rebuild      Rebuild (&#39;go build&#39;) the dependencies
   install, i   Install a project&#39;s dependencies
   update, up   Update a project&#39;s dependencies
   tree         Tree prints the dependencies of this project as a tree.
   list         List prints all dependencies that Glide could discover.
   about        Learn about Glide
   help, h      Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --yaml, -y &amp;quot;glide.yaml&amp;quot;              Set a YAML configuration file.
   --quiet, -q                          Quiet (no info or debug messages)
   --debug                              Print Debug messages (verbose)
   --home &amp;quot;C:\Users\username\.glide&amp;quot;    The location of Glide files [$GLIDE_HOME]
   --no-color                           Turn off colored output for log messages
   --help, -h                           show help
   --version, -v                        print the version
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;開発環境の準備:721380b38042a10816ac6a323733a866&#34;&gt;開発環境の準備&lt;/h2&gt;

&lt;p&gt;動作検証用に「&lt;a href=&#34;http://text.baldanders.info/golang/gopath-pollution/&#34;&gt;GOPATH 汚染問題&lt;/a&gt;」で使ったコードを利用する。
まず，以下の環境を作る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:\workspace\vdemo2&amp;gt;SET GOPATH=C:\workspace\vdemo2

C:\workspace\vdemo2&amp;gt;SET GO15VENDOREXPERIMENT=1

C:\workspace\vdemo2&amp;gt;tree /f .
C:\WORKSPACE\VDEMO2
└─src
    └─julian-day
            julian-day.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;julian-day.go&lt;/code&gt; の内容は以下のとおりである。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;time&amp;quot;

    &amp;quot;github.com/spiegel-im-spiegel/astrocalc/modjulian&amp;quot;
)

func main() {
	//引数のチェック
	flag.Parse()
	argsStr := flag.Args()
	if len(argsStr) &amp;lt; 3 {
		fmt.Fprintln(os.Stderr, &amp;quot;年月日を指定してください&amp;quot;)
		return
	}
	args := make([]int, 3)
	for i := 0; i &amp;lt; 3; i++ {
		num, err := strconv.Atoi(argsStr[i])
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			return
		}
		args[i] = num
	}
	tm := time.Date(args[0], time.Month(args[1]), args[2], 0, 0, 0, 0, time.UTC)
	fmt.Printf(&amp;quot;%v\n&amp;quot;, tm)
	fmt.Printf(&amp;quot;MJD = %d日\n&amp;quot;, modjulian.DayNumber(tm))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然ながら，このままビルドしても外部パッケージがないため失敗する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\vdemo2&amp;gt;go install ./...
src\julian-day\julian-day.go:10:2: cannot find package &amp;quot;github.com/spiegel-im-spiegel/astrocalc/modjulian&amp;quot; in any of:
        C:\Go\src\github.com\spiegel-im-spiegel\astrocalc\modjulian (from $GOROOT)
        C:\workspace\vdemo2\src\github.com\spiegel-im-spiegel\astrocalc\modjulian (from $GOPATH)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;依存関係を定義する:721380b38042a10816ac6a323733a866&#34;&gt;依存関係を定義する&lt;/h2&gt;

&lt;p&gt;開発環境ができたら，パッケージのフォルダ（今回は &lt;code&gt;src/julian-day&lt;/code&gt;）に移動し， &lt;code&gt;glide create&lt;/code&gt; コマンドで依存関係を定義する &lt;code&gt;glide.yaml&lt;/code&gt; ファイルを生成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\vdemo2&amp;gt;pushd src\julian-day

C:\workspace\vdemo2\src\julian-day&amp;gt;glide create
[INFO] Generating a YAML configuration file and guessing the dependencies
[INFO] Attempting to import from other package managers (use --skip-import to skip)
[INFO] Found reference to github.com\spiegel-im-spiegel\astrocalc\modjulian

C:\workspace\vdemo2\src\julian-day&amp;gt;tree /f C:\workspace\vdemo2
C:\WORKSPACE\VDEMO2
└─src
    └─julian-day
            glide.yaml
            julian-day.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ソースコードを読んで &lt;code&gt;glide.yaml&lt;/code&gt; に必要な情報を推測して書いてくれているようだが&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:721380b38042a10816ac6a323733a866:cre&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:721380b38042a10816ac6a323733a866:cre&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，デリミタが “/” じゃなくて “\” になってる。
Windows 環境だからかな。
残念 orz&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;package: julian-day
import:
- package: github.com\spiegel-im-spiegel\astrocalc\modjulian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/astrocalc&#34; title=&#34;spiegel-im-spiegel/astrocalc&#34;&gt;astrocalc&lt;/a&gt;/modjulian パッケージのパスを修正して、更にバージョン情報を追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;package: julian-day
import:
- package: github.com/spiegel-im-spiegel/astrocalc/modjulian
  version: v0.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで &lt;code&gt;go get&lt;/code&gt; コマンドと同じように， &lt;code&gt;package&lt;/code&gt; のパスから自動的に repository を判別してパッケージを取得できる。
&lt;code&gt;go get&lt;/code&gt; コマンドと異なるのは， &lt;code&gt;glide.yaml&lt;/code&gt; ファイルで指定した &lt;code&gt;version&lt;/code&gt; 情報から適切な revision を選択できる点である&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:721380b38042a10816ac6a323733a866:semv&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:721380b38042a10816ac6a323733a866:semv&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;また，以下のように VCS (Version Control System) の種類&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:721380b38042a10816ac6a323733a866:vcs&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:721380b38042a10816ac6a323733a866:vcs&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; と URI を明示的に指定することもできる（&lt;code&gt;vcs&lt;/code&gt; と &lt;code&gt;repo&lt;/code&gt; は必ずセットで指定する）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;package: julian-day
import:
- package: github.com/spiegel-im-spiegel/astrocalc/modjulian
  vcs:     git
  repo:    git@github.com:spiegel-im-spiegel/astrocalc.git
  version: v0.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;たとえば，プライベートな bare repository からインポートする場合には，この方法が有効である。&lt;/p&gt;

&lt;h2 id=&#34;パッケージの取得とビルド:721380b38042a10816ac6a323733a866&#34;&gt;パッケージの取得とビルド&lt;/h2&gt;

&lt;p&gt;パッケージの取得には &lt;code&gt;glide update&lt;/code&gt; または &lt;code&gt;glide up&lt;/code&gt; コマンドを起動する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\vdemo2\src\julian-day&amp;gt;glide up
[INFO] Fetching updates for github.com/spiegel-im-spiegel/astrocalc.
[INFO] Setting version for github.com/spiegel-im-spiegel/astrocalc to v0.1.0.
[INFO] Scanning github.com/spiegel-im-spiegel/astrocalc for dependencies.
[INFO] Setting version for github.com/spiegel-im-spiegel/astrocalc to v0.1.0.
[INFO] Project relies on 1 dependencies.
[INFO] Writing glide.lock file
C:\workspace\vdemo2\src\julian-day&amp;gt;tree /f C:\workspace\vdemo2
C:\WORKSPACE\VDEMO2
└─src
    └─julian-day
        │  glide.lock
        │  glide.yaml
        │  julian-day.go
        │
        └─vendor
            └─github.com
                └─spiegel-im-spiegel
                    └─astrocalc
                        │  .editorconfig
                        │  .gitignore
                        │  .travis.yml
                        │  LICENSE
                        │  README.md
                        │
                        └─modjulian
                                example_test.go
                                LICENSE
                                modjulian.go
                                modjulian_test.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでビルドが可能になった。
ではビルドしようかな。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\vdemo2\src\julian-day&amp;gt;popd

C:\workspace\vdemo2&amp;gt;go install -v  ./...
julian-day/vendor/github.com/spiegel-im-spiegel/astrocalc/modjulian
julian-day

C:\workspace\vdemo2&amp;gt;bin\julian-day.exe 2015 1 1
2015-01-01 00:00:00 +0000 UTC
MJD = 57023日
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よーし，うむうむ，よーし。&lt;/p&gt;

&lt;h2 id=&#34;vendor-フォルダの管理:721380b38042a10816ac6a323733a866&#34;&gt;Vendor フォルダの管理&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;glide.lock&lt;/code&gt; ファイルには外部パッケージの状態が記述されている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;hash: b1eecd43769aa1225f7b8922a35566008561c64f4ce11180f299888ed153ad69
updated: 2015-12-23T10:47:22.4140434+09:00
imports:
- name: github.com/spiegel-im-spiegel/astrocalc
  version: 256cd3bd4dc63441d3f4759d761593a147d51d88
  subpackages:
  - modjulian
devImports: []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;glide.lock&lt;/code&gt; があれば &lt;code&gt;glide install&lt;/code&gt;（または &lt;code&gt;glide i&lt;/code&gt;）コマンドで &lt;code&gt;vendor&lt;/code&gt; フォルダ以下の状態を復元できる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; では外部パッケージを vendor フォルダ以下に repository 構造ごと展開する。
この場合，開発対象のパッケージも repository で管理しているのだから， repository が入れ子になり具合が悪い。
その辺，当の &lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; はどうしてるのかなぁと思ったら &lt;code&gt;.gitignore&lt;/code&gt; ファイルで &lt;code&gt;vendor/&lt;/code&gt; を除外対象にしていた。
なるほど，そりゃそうか。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;glide.yaml&lt;/code&gt; および &lt;code&gt;glide.lock&lt;/code&gt; ファイルの管理さえちゃんとしていれば &lt;code&gt;glide install&lt;/code&gt; コマンドでいつでも復元できるのだから &lt;code&gt;vendor&lt;/code&gt; フォルダ以下を除外しても問題ないわけだ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:721380b38042a10816ac6a323733a866:v&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:721380b38042a10816ac6a323733a866:v&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。
これは複数メンバで開発環境を共有する際には便利な機能である。&lt;/p&gt;

&lt;p&gt;また vendoring に対応していない（Go 1.4 以下の）環境や &lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; がない環境では &lt;code&gt;go get&lt;/code&gt; で外部パッケージを取ってくることで（revision 等の問題はあるけど）一応ビルドは通る。&lt;/p&gt;

&lt;p&gt;更に言うと， &lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; は &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の標準機能に準拠しているため，他のサポートツールとの相性がいいのも利点だろう。
たとえば， &lt;a href=&#34;http://text.baldanders.info/golang/golang-with-atom/&#34;&gt;ATOM ベースの開発環境&lt;/a&gt;は &lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; と相性がいい&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:721380b38042a10816ac6a323733a866:gov&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:721380b38042a10816ac6a323733a866:gov&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。
あと，（多少強引な手を使っているが&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:721380b38042a10816ac6a323733a866:tci&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:721380b38042a10816ac6a323733a866:tci&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;） &lt;a href=&#34;https://travis-ci.org/&#34;&gt;Travis CI&lt;/a&gt; のような CI (Continuous Integration) と組み合わせることも難しくない。&lt;/p&gt;

&lt;p&gt;こう考えると &lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; は&lt;a href=&#34;http://text.baldanders.info/golang/project-based-development/&#34;&gt;前に紹介&lt;/a&gt;した &lt;a href=&#34;http://getgb.io/&#34;&gt;gb&lt;/a&gt; よりも筋がいいツールといえるかもしれない。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:721380b38042a10816ac6a323733a866&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/tienlen/items/8e192e68d6b18bec3b4a&#34;&gt;glide - パッケージ管理のお困りの方へ - - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:721380b38042a10816ac6a323733a866:ins&#34;&gt;Mac 環境なら brew でインストールできるらしい。 Linux 等の環境であれば &lt;code&gt;make&lt;/code&gt; コマンドで各種プラットフォームの実行ファイルをビルドできる。一応 &lt;code&gt;go get&lt;/code&gt; でもビルドできるが， revision を制御できないので失敗する可能性もある（これは &lt;code&gt;make&lt;/code&gt; コマンドでビルドする場合でも同じだけど）。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:721380b38042a10816ac6a323733a866:ins&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:721380b38042a10816ac6a323733a866:cre&#34;&gt;&lt;code&gt;glide create&lt;/code&gt; 時の依存パッケージの推測を抑止するには &lt;code&gt;--skip-import&lt;/code&gt; オプションを付ける。のだが，効いてないな。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:721380b38042a10816ac6a323733a866:cre&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:721380b38042a10816ac6a323733a866:semv&#34;&gt;今回であれば repository の &lt;a href=&#34;https://github.com/spiegel-im-spiegel/astrocalc/releases/tag/v0.1.0&#34;&gt;&lt;code&gt;v0.1.0&lt;/code&gt;&lt;/a&gt; タグに対応する revision を選択する。バージョンの記述形式は &lt;code&gt;package.json&lt;/code&gt; と同じように記述でき，バージョンの解釈は &lt;a href=&#34;http://semver.org/&#34;&gt;Semantic Versioning&lt;/a&gt; に従っている。ちなみに revision ID を直接指定することもできる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:721380b38042a10816ac6a323733a866:semv&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:721380b38042a10816ac6a323733a866:vcs&#34;&gt;&lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; では &lt;a href=&#34;http://git-scm.com/&#34;&gt;git&lt;/a&gt; のほか svn (&lt;a href=&#34;http://subversion.apache.org/&#34;&gt;Subversion&lt;/a&gt;), hg (&lt;a href=&#34;http://mercurial.selenic.com/&#34;&gt;Mercurial&lt;/a&gt;), bzr (&lt;a href=&#34;http://bazaar.canonical.com/&#34;&gt;Bazaar&lt;/a&gt;) が利用可能である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:721380b38042a10816ac6a323733a866:vcs&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:721380b38042a10816ac6a323733a866:v&#34;&gt;&lt;code&gt;vendor&lt;/code&gt; フォルダ以下は外部パッケージなので通常はさわることはない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:721380b38042a10816ac6a323733a866:v&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:721380b38042a10816ac6a323733a866:gov&#34;&gt;残念ながら，「&lt;a href=&#34;http://text.baldanders.info/golang/package-visualization-tool/&#34;&gt;パッケージの依存状況の視覚化&lt;/a&gt;」ツールは vendoring 機能に対応していないため上手く表示できない。なお， &lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; では &lt;code&gt;glide list&lt;/code&gt; および &lt;code&gt;glide tree&lt;/code&gt; で依存パッケージを見ることができる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:721380b38042a10816ac6a323733a866:gov&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:721380b38042a10816ac6a323733a866:tci&#34;&gt;&lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; の &lt;a href=&#34;https://github.com/Masterminds/glide/blob/master/.travis.yml&#34;&gt;&lt;code&gt;.travis.yml&lt;/code&gt;&lt;/a&gt; や &lt;a href=&#34;https://github.com/Masterminds/glide/blob/master/Makefile&#34;&gt;&lt;code&gt;Makefile&lt;/code&gt;&lt;/a&gt; を参照。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:721380b38042a10816ac6a323733a866:tci&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Git.io から短縮 URL を取得するコード — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/get-shortened-url-from-gitio/" />
		<id>tag:text.Baldanders.info,2015-11-26:/golang/get-shortened-url-from-gitio/</id>
		<published>2015-11-26T20:29:30+09:00</published>
		<updated>2015-11-26T20:29:30+09:00</updated>
		<summary>これって curl で書けるんなら Go 言語で表現できるんじゃね？</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/042751d98e315e4e3382&#34;&gt;Git.io 短縮 URL を golang コードで取得してみる - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;h2 id=&#34;git-io-で短縮-url-が取得できるらしい:0223b5e2f12da4589f164146964cba22&#34;&gt;Git.io で短縮 URL が取得できるらしい&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/sotayamashita/items/1cf05f2a2be3d6fb3388&#34;&gt;Git・Githubに隠された便利な機能 | GitHub Cheat Sheet（日本語訳） - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを読んでたら後ろの方に &lt;a href=&#34;http://git.io/&#34; title=&#34;git.io&#34;&gt;Git.io&lt;/a&gt; の話が出ていた。
このサイトで短縮 URL を生成できるらしい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/blog/985-git-io-github-url-shortener&#34;&gt;Git.io: GitHub URL Shortener&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;API が &lt;a href=&#34;http://curl.haxx.se/&#34; title=&#34;curl and libcurl&#34;&gt;curl&lt;/a&gt; で掲載されていて，例えば私の &lt;a href=&#34;https://github.com/spiegel-im-spiegel&#34;&gt;https://github.com/spiegel-im-spiegel&lt;/a&gt; なら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -i &amp;quot;http://git.io&amp;quot; -F &amp;quot;url=https://github.com/spiegel-im-spiegel&amp;quot;
HTTP/1.1 201 Created
Server: Cowboy
Connection: keep-alive
Date: Sat, 08 Aug 2015 02:42:16 GMT
Status: 201 Created
Content-Type: text/html;charset=utf-8
Location: http://git.io/vOj52
Content-Length: 37
X-Xss-Protection: 1; mode=block
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-Runtime: 0.210952
X-Node: 871d903e-a8e0-46ff-a96f-ef424385e5ed
X-Revision: b1d9ce07ccb700fc90398edafd397beb8d3bd772
Via: 1.1 vegur

https://github.com/spiegel-im-spiegel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;てな感じで，ヘッダの Location 要素に短縮 URL が返ってくる仕組みらしい。
って，これって &lt;a href=&#34;http://curl.haxx.se/&#34; title=&#34;curl and libcurl&#34;&gt;curl&lt;/a&gt; で書けるんなら &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で表現できるんじゃね？&lt;/p&gt;

&lt;h2 id=&#34;curl-as-dsl:0223b5e2f12da4589f164146964cba22&#34;&gt;cURL as DSL&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://shibukawa.github.io/curl_as_dsl/&#34;&gt;cURL as DSL — cURL as DSL 1.0 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.shibu.jp/article/115602749.html&#34;&gt;Shibu&amp;rsquo;s Diary: cURL as DSLとは何だったのか。あるいは細かすぎて伝わらないcURL as DSL。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://shibukawa.github.io/curl_as_dsl/&#34; title=&#34;cURL as DSL — cURL as DSL 1.0 documentation&#34;&gt;cURL as DSL&lt;/a&gt; とは &lt;a href=&#34;http://curl.haxx.se/&#34; title=&#34;curl and libcurl&#34;&gt;curl&lt;/a&gt; の構文を任意のコード&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0223b5e2f12da4589f164146964cba22:a&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0223b5e2f12da4589f164146964cba22:a&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; に変換してくれるもので，どういうことかというと「&lt;a href=&#34;http://qiita.com/Hiraku/items/dfda2f8a5353b0742271&#34;&gt;Web API は curl で表現すればいいんじゃね？&lt;/a&gt;」ということらしい。&lt;/p&gt;

&lt;h2 id=&#34;さっそく-curl-を-go-言語に変換してみる:0223b5e2f12da4589f164146964cba22&#34;&gt;さっそく curl を Go 言語に変換してみる&lt;/h2&gt;

&lt;p&gt;では早速，上述の curl コマンドを &lt;a href=&#34;https://shibukawa.github.io/curl_as_dsl/&#34; title=&#34;cURL as DSL — cURL as DSL 1.0 documentation&#34;&gt;cURL as DSL&lt;/a&gt; を使って &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;に変換してみる（ただし &lt;code&gt;-i&lt;/code&gt; オプションは付けない）。
結果はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;mime/multipart&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func main() {
	var buffer bytes.Buffer
	writer := multipart.NewWriter(&amp;amp;buffer)
	writer.WriteField(&amp;quot;url&amp;quot;, &amp;quot;https://github.com/spiegel-im-spiegel&amp;quot;)
	writer.Close()

	resp, err := http.Post(&amp;quot;http://git.io&amp;quot;, &amp;quot;multipart/form-data; boundary=&amp;quot;+writer.Boundary(), &amp;amp;buffer)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	log.Print(string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出力のみちょっと弄って&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;mime/multipart&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func main() {
	var buffer bytes.Buffer
	writer := multipart.NewWriter(&amp;amp;buffer)
	writer.WriteField(&amp;quot;url&amp;quot;, &amp;quot;https://github.com/spiegel-im-spiegel&amp;quot;)
	writer.Close()

	resp, err := http.Post(&amp;quot;http://git.io&amp;quot;, &amp;quot;multipart/form-data; boundary=&amp;quot;+writer.Boundary(), &amp;amp;buffer)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	log.Println(&amp;quot;  Status: &amp;quot;, resp.Header.Get(&amp;quot;Status&amp;quot;))
	log.Println(&amp;quot;Location: &amp;quot;, resp.Header.Get(&amp;quot;Location&amp;quot;))
	log.Println(&amp;quot;    Body: &amp;quot;, string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:&amp;gt;go run gitio.go
2015/08/08 12:00:00   Status: 201 Created
2015/08/08 12:00:00 Location: http://git.io/vOj52
2015/08/08 12:00:00     Body: https://github.com/spiegel-im-spiegel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり，めでたく短縮 URL が取得できた。&lt;/p&gt;

&lt;p&gt;ちなみに最初の &lt;a href=&#34;http://curl.haxx.se/&#34; title=&#34;curl and libcurl&#34;&gt;curl&lt;/a&gt; コマンドの &lt;code&gt;-F&lt;/code&gt; を &lt;code&gt;-d&lt;/code&gt; に替えて &lt;a href=&#34;https://shibukawa.github.io/curl_as_dsl/&#34; title=&#34;cURL as DSL — cURL as DSL 1.0 documentation&#34;&gt;cURL as DSL&lt;/a&gt; にかけると&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0223b5e2f12da4589f164146964cba22:b&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0223b5e2f12da4589f164146964cba22:b&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;net/url&amp;quot;
)

func main() {
	values := url.Values{
		&amp;quot;url&amp;quot;: {&amp;quot;https://github.com/spiegel-im-spiegel&amp;quot;},
	}

	resp, err := http.PostForm(&amp;quot;http://git.io&amp;quot;, values)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	log.Print(string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように変換される。
&lt;a href=&#34;https://golang.org/pkg/net/http/&#34; title=&#34;http - The Go Programming Language&#34;&gt;&lt;code&gt;http&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Post()&lt;/code&gt; 関数から &lt;a href=&#34;https://golang.org/pkg/net/http/&#34; title=&#34;http - The Go Programming Language&#34;&gt;&lt;code&gt;http&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;PostForm()&lt;/code&gt; 関数に替わってかなりコードがすっきりした。
今回のような単純な request ならこちらの方がいいだろう。&lt;/p&gt;

&lt;h2 id=&#34;ついでにパッケージも作ってみた:0223b5e2f12da4589f164146964cba22&#34;&gt;ついでにパッケージも作ってみた&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/gitioapi&#34;&gt;spiegel-im-spiegel/gitioapi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを称して「他人の褌で相撲を取る」という&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0223b5e2f12da4589f164146964cba22:c&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0223b5e2f12da4589f164146964cba22:c&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
なるほど。
こうやって API を実装していくんだね。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:0223b5e2f12da4589f164146964cba22&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:0223b5e2f12da4589f164146964cba22:a&#34;&gt;今のところは &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のほかに Python3, PHP, JavaScript (node.js/XMLHttpRequest), Java, Objective-C (NSURL_Session/NSURLConnection), Vim Script (WebAPI-vim) に対応している。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0223b5e2f12da4589f164146964cba22:a&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:0223b5e2f12da4589f164146964cba22:b&#34;&gt;&lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/042751d98e315e4e3382&#34;&gt;初出の記事&lt;/a&gt;のコメントで &lt;a href=&#34;https://shibukawa.github.io/curl_as_dsl/&#34; title=&#34;cURL as DSL — cURL as DSL 1.0 documentation&#34;&gt;cURL as DSL&lt;/a&gt; の作者の方に教えていただいた。感謝！
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0223b5e2f12da4589f164146964cba22:b&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:0223b5e2f12da4589f164146964cba22:c&#34;&gt;実はジェネレータで生成したコードの著作権は誰に帰属するのか，とかいろいろ思うところはあるのだけど，それはまた別の機会に。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0223b5e2f12da4589f164146964cba22:c&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>ATOM で Go — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/golang-with-atom/" />
		<id>tag:text.Baldanders.info,2015-11-21:/golang/golang-with-atom/</id>
		<published>2015-11-21T14:19:02+09:00</published>
		<updated>2015-11-27T14:31:41+09:00</updated>
		<summary>ATOM Editor で Go 言語のコーディング環境を整える。 go-plus パッケージの導入について。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回もまた横道に逸れてツールの話。
&lt;a href=&#34;https://atom.io/&#34; title=&#34;Atom&#34;&gt;ATOM&lt;/a&gt; Editor で &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のコーディング環境を整える。
環境を作る度に「どうだったっけ」とあちこちサイトを巡るので，覚え書きとしてまとめておく。&lt;/p&gt;

&lt;p&gt;例によって Windows 環境を前提にしているので，他の環境の方は適当に脳内補完してください。&lt;/p&gt;

&lt;h2 id=&#34;開発支援ツールの導入:19f55614c00d490a9959ede6566335af&#34;&gt;開発支援ツールの導入&lt;/h2&gt;

&lt;p&gt;まずは &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;用の支援ツールを導入する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:&amp;gt; go get -v golang.org/x/tools/cmd/vet
C:&amp;gt; go get -v golang.org/x/tools/cmd/goimports
C:&amp;gt; go get -v golang.org/x/tools/cmd/oracle
C:&amp;gt; go get -v github.com/golang/lint/golint
C:&amp;gt; go get -v github.com/nsf/gocode
C:&amp;gt; go get -v github.com/rogpeppe/godef
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/lint&#34; title=&#34;golang/lint&#34;&gt;golint&lt;/a&gt; は，いわゆる lint ツール。
&lt;a href=&#34;https://golang.org/cmd/vet/&#34; title=&#34;vet - The Go Programming Language&#34;&gt;vet&lt;/a&gt; もコードの静的検査ツール。
両方あると幸せになれる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/tools/cmd/goimports&#34; title=&#34;goimports - GoDoc&#34;&gt;goimport&lt;/a&gt; はコード整形ツールで，標準の &lt;a href=&#34;https://golang.org/cmd/gofmt/&#34; title=&#34;gofmt - The Go Programming Language&#34;&gt;gofmt&lt;/a&gt; を置き換えることができ，かつ &lt;a href=&#34;https://golang.org/cmd/gofmt/&#34; title=&#34;gofmt - The Go Programming Language&#34;&gt;gofmt&lt;/a&gt; よりも若干かしこい。
&lt;a href=&#34;https://github.com/nsf/gocode&#34; title=&#34;nsf/gocode&#34;&gt;gocode&lt;/a&gt; は入力補完ツール。
&lt;a href=&#34;https://github.com/rogpeppe/godef&#34; title=&#34;rogpeppe/godef&#34;&gt;godef&lt;/a&gt; は指定したシンボルの定義定義元情報を出力するツール（出力を使って定義元へジャンプできる。実際には &lt;a href=&#34;https://godoc.org/golang.org/x/tools/cmd/oracle&#34; title=&#34;oracle - GoDoc&#34;&gt;oracle&lt;/a&gt; と併用するらしい）。
いずれも vim や emacs などでは有名だが &lt;a href=&#34;https://atom.io/&#34; title=&#34;Atom&#34;&gt;ATOM&lt;/a&gt; でも使える。&lt;/p&gt;

&lt;p&gt;言わずもがなだが，これらのツールには PATH を通しておくこと。
&lt;code&gt;%GOPATH%\bin&lt;/code&gt; フォルダにパスを通しておけばいいだろう。&lt;/p&gt;

&lt;h2 id=&#34;go-plus-パッケージの導入:19f55614c00d490a9959ede6566335af&#34;&gt;go-plus パッケージの導入&lt;/h2&gt;

&lt;p&gt;では，上述のツールを操作できる &lt;a href=&#34;https://atom.io/packages/go-plus&#34; title=&#34;go-plus&#34;&gt;go-plus&lt;/a&gt; パッケージを導入する。
やり方は Settings 画面（&lt;code&gt;ctrl+,&lt;/code&gt; で起動）で Install してもいいし &lt;code&gt;apm&lt;/code&gt; コマンドを使ってもよい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://text.baldanders.info/remark/2015/atom-editor/&#34;&gt;ATOM Editor に関するメモ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://atom.io/packages/go-plus&#34; title=&#34;go-plus&#34;&gt;go-plus&lt;/a&gt; には設定項目がいくつかあるが，ほとんど既定値のままで使える。
コマンドパレットから &lt;code&gt;golang&lt;/code&gt; をキーワードに検索すると山程機能があるのが分かるだろう。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a data-flickr-embed=&#34;true&#34; href=&#34;https://www.flickr.com/photos/spiegel/22710708563/&#34;&gt;&lt;img src=&#34;https://farm6.staticflickr.com/5794/22710708563_3d4aca2709.jpg&#34; alt=&#34;menu of go-plus (ATOM)&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/22710708563/&#34;&gt;menu of go-plus (ATOM)&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;既定ではソースファイルを保存する度にコード整形や lint 等が走る。
これを制御したい場合はパッケージの Setting で以下の項目を調整すればよい。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a data-flickr-embed=&#34;true&#34; href=&#34;https://www.flickr.com/photos/spiegel/22767398347/&#34;&gt;&lt;img src=&#34;https://farm1.staticflickr.com/735/22767398347_ed9329653a.jpg&#34; alt=&#34;settings for go-plus (ATOM)&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/22767398347/&#34;&gt;settings for go-plus (ATOM)&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;定義ファイルへのジャンプと復帰は &lt;code&gt;alt-cmd-g&lt;/code&gt; および &lt;code&gt;alt-shift-cmd-G&lt;/code&gt; にバインドされているが Windows 環境では動かないので（コマンドパレットから起動してもいいのだが）適当なキーに再割当てするといいだろう。
ファンクションキーは結構空いてるので，たとえば&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Keystroke&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Command&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Selector&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;f12&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;golang:godef&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;atom-text-editor[data-grammar=&amp;quot;source go&amp;quot;]:not(.mini)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;shift-f12&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;golang:godef-return&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;atom-text-editor[data-grammar=&amp;quot;source go&amp;quot;]:not(.mini)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;とアサインするなら &lt;code&gt;%USERPROFILE%\.atom\keymap.cson&lt;/code&gt; に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cson&#34;&gt;&#39;atom-text-editor[data-grammar=&amp;quot;source go&amp;quot;]:not(.mini)&#39;:
  &#39;f12&#39;: &#39;golang:godef&#39;
  &#39;shift-f12&#39;: &#39;golang:godef-return&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と設定すればいい。&lt;/p&gt;

&lt;p&gt;lint や定義ファイルのジャンプは &lt;code&gt;GOPATH&lt;/code&gt; や &lt;code&gt;GOROOT&lt;/code&gt; を見て外部パッケージを判断しているのだが， &lt;a href=&#34;http://getgb.io/&#34; title=&#34;gb - A project based build tool for Go&#34;&gt;gb&lt;/a&gt; のようなツールでは &lt;code&gt;GOPATH&lt;/code&gt; をコマンド内部で書き換えて実行するので lint ツールとは整合性が取れなくなる。
&lt;a href=&#34;https://atom.io/packages/go-plus&#34; title=&#34;go-plus&#34;&gt;go-plus&lt;/a&gt; の設定では &lt;code&gt;GOPATH&lt;/code&gt; を上書きすることも可能なので，とりあえずこれで回避する方法もある&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:19f55614c00d490a9959ede6566335af:a&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:19f55614c00d490a9959ede6566335af:a&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a data-flickr-embed=&#34;true&#34; href=&#34;https://www.flickr.com/photos/spiegel/23233956325/&#34;&gt;&lt;img src=&#34;https://farm6.staticflickr.com/5821/23233956325_0ddf55e61a.jpg&#34; alt=&#34;settings for go-plus (ATOM)&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/23233956325/&#34;&gt;settings for go-plus (ATOM)&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&#34;http://getgb.io/&#34; title=&#34;gb - A project based build tool for Go&#34;&gt;gb&lt;/a&gt; への対応は “Planned Features” に挙がってるので，将来的には小細工しなくても &lt;a href=&#34;http://getgb.io/&#34; title=&#34;gb - A project based build tool for Go&#34;&gt;gb&lt;/a&gt; ベースの開発ができるようになるかもしれない。
てか，なってほしい。&lt;/p&gt;

&lt;h2 id=&#34;language-go-パッケージは同梱済み:19f55614c00d490a9959ede6566335af&#34;&gt;language-go パッケージは同梱済み&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://atom.io/packages/language-go&#34; title=&#34;language-go&#34;&gt;language-go&lt;/a&gt; は Core パッケージに入っているためインストール時点で既に入っている&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:19f55614c00d490a9959ede6566335af:b&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:19f55614c00d490a9959ede6566335af:b&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。
&lt;a href=&#34;https://atom.io/packages/language-go&#34; title=&#34;language-go&#34;&gt;language-go&lt;/a&gt; の機能で目を引くのはやはり Snippets だろう。
以下はその一部（パッケージの Settings に一覧がある）。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a data-flickr-embed=&#34;true&#34; href=&#34;https://www.flickr.com/photos/spiegel/22712254763/&#34;&gt;&lt;img src=&#34;https://farm6.staticflickr.com/5675/22712254763_f8fb9f6735.jpg&#34; alt=&#34;Snippets for golang (ATOM)&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/22712254763/&#34;&gt;Snippets for golang (ATOM)&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;こんなよぅけ覚えれるか！ まぁとりあえず，よく使うものだけ覚えておけばいいのだろうけど。&lt;/p&gt;

&lt;p&gt;使い方は，トリガーとなる文字列を入力して tab キーを押す。
たとえば &lt;code&gt;func&lt;/code&gt; と入力して tab キーを押すと&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ()  {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と展開される。
&lt;code&gt;iferr&lt;/code&gt; なら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if err != nil {
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。&lt;/p&gt;

&lt;h2 id=&#34;go-find-references-パッケージが惜しい:19f55614c00d490a9959ede6566335af&#34;&gt;go-find-references パッケージが惜しい&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://atom.io/packages/go-find-references&#34; title=&#34;go-find-references&#34;&gt;go-find-references&lt;/a&gt; パッケージは &lt;a href=&#34;https://github.com/redefiance/go-find-references&#34;&gt;redefiance/go-find-references&lt;/a&gt; を使って指定したシンボルを参照しているファイルを列挙してくれる便利ツールだが， Windows 環境ではタグジャンプが上手く動かない。
どうやら &lt;code&gt;C:&lt;/code&gt; などのドライブレターを上手く処理できないようだ。
とほほ。&lt;/p&gt;

&lt;h2 id=&#34;bookmark:19f55614c00d490a9959ede6566335af&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/amanoiverse/items/fcd25db64f341ad2471f&#34;&gt;struct にアノテーションつけてたら go vet . すべき - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/osamingo/items/d5ec42fb8587d857310a&#34;&gt;これからGo言語を書く人への三種の神器 - Qiita&lt;/a&gt; : &lt;code&gt;go vet&lt;/code&gt;, &lt;code&gt;goimports&lt;/code&gt;, &lt;code&gt;golint&lt;/code&gt; で正しいコードを書きましょう。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:19f55614c00d490a9959ede6566335af:a&#34;&gt;&lt;code&gt;GOPATH&lt;/code&gt; を &lt;a href=&#34;https://atom.io/packages/go-plus&#34; title=&#34;go-plus&#34;&gt;go-plus&lt;/a&gt; の設定で上書きする場合は “Environment Overrides Config” を&lt;strong&gt;無効にする&lt;/strong&gt;こと。なんでかこれ，毎回ハマるんだよなぁ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:19f55614c00d490a9959ede6566335af:a&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:19f55614c00d490a9959ede6566335af:b&#34;&gt;&lt;code&gt;language&lt;/code&gt; でインストール済みパッケージを検索するとメジャーな言語は大抵入っているのが分かる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:19f55614c00d490a9959ede6566335af:b&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>パッケージ外部からの呼び出しを禁止する Internal Packages — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/internal-packages/" />
		<id>tag:text.Baldanders.info,2015-11-07:/golang/internal-packages/</id>
		<published>2015-11-07T10:38:20+09:00</published>
		<updated>2015-11-17T10:46:12+09:00</updated>
		<summary>Internal Packages の仕組みは 1.4 から存在したが標準パッケージのみの適用だった。 1.5 からは GOPATH 配下のパッケージまで拡張される。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;（初出： &lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/baa3671c7e1b8a6594a9&#34;&gt;そろそろ真面目に Golang 開発環境について考える — Internal Packages と Vendoring - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;「&lt;a href=&#34;http://text.baldanders.info/golang/gopath-pollution/&#34;&gt;GOPATH 汚染問題&lt;/a&gt;」で言及しそこねたので，今回は軽く。&lt;/p&gt;

&lt;p&gt;Internal Packages の仕組みは 1.4 から存在したが標準パッケージのみの適用だった。
1.5 からは &lt;code&gt;GOPATH&lt;/code&gt; 配下のパッケージまで拡張される。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/document/d/1e8kOo3r51b2BWtTs_1uADIA5djfXhPT36s6eHVRIvaU/edit&#34;&gt;Go 1.4 &amp;ldquo;Internal&amp;rdquo; Packages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要するに &lt;code&gt;internal&lt;/code&gt; フォルダ以下のパッケージは外部から参照できない。
例として &lt;a href=&#34;https://golang.org/pkg/net/&#34; title=&#34;net - The Go Programming Language&#34;&gt;&lt;code&gt;net&lt;/code&gt;&lt;/a&gt; パッケージを挙げてみる。
&lt;a href=&#34;https://golang.org/pkg/net/&#34; title=&#34;net - The Go Programming Language&#34;&gt;&lt;code&gt;net&lt;/code&gt;&lt;/a&gt; パッケージのソースコードの構成は以下のようになっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\Go\src\net&amp;gt; tree .
C:\GO\SRC\NET
├─http
│  ├─cgi
│  │  └─testdata
│  ├─cookiejar
│  ├─fcgi
│  ├─httptest
│  ├─httputil
│  ├─internal
│  ├─pprof
│  └─testdata
├─internal
│  └─socktest
├─mail
├─rpc
│  └─jsonrpc
├─smtp
├─testdata
├─textproto
└─url
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/net/http/internal/&#34;&gt;&lt;code&gt;net/http/internal&lt;/code&gt;&lt;/a&gt; パッケージには &lt;code&gt;chunked.go&lt;/code&gt; ファイルが含まれる。
&lt;code&gt;chunked.go&lt;/code&gt; は &lt;a href=&#34;https://en.wikipedia.org/wiki/Chunked_transfer_encoding&#34;&gt;chunked transfer encoding&lt;/a&gt; の仕組みを実装したもののようだが， &lt;a href=&#34;https://golang.org/pkg/net/http/&#34; title=&#34;http - The Go Programming Language&#34;&gt;&lt;code&gt;net/http&lt;/code&gt;&lt;/a&gt; およびその配下のパッケージ以外では使えない。
また &lt;code&gt;net/internal&lt;/code&gt; フォルダ以下には socket テスト用の &lt;a href=&#34;https://golang.org/pkg/net/internal/socktest/&#34; title=&#34;socktest - The Go Programming Language&#34;&gt;&lt;code&gt;net/internal/socktest&lt;/code&gt;&lt;/a&gt; パッケージがあるが，これも外部から再利用できない。&lt;/p&gt;

&lt;p&gt;これは再利用の難しいパッケージを配置する場合にはよい仕掛けである。
ビジネスロジックには再利用が難しいものが多いので，そういったものを &lt;code&gt;internal&lt;/code&gt; フォルダ以下に置けば，うっかり他所で使われるといったこともなく安全である。
なお， Internal Packages の制約から外すには &lt;code&gt;internal&lt;/code&gt; フォルダの外側にパッケージを再配置すればよい。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:8a2f576149aff665b4e8707fdb13643d&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>パッケージの依存状況の視覚化 — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/package-visualization-tool/" />
		<id>tag:text.Baldanders.info,2015-10-15:/golang/package-visualization-tool/</id>
		<published>2015-10-15T20:32:32+09:00</published>
		<updated>2015-10-15T20:32:32+09:00</updated>
		<summary>今回はちょっと横道にそれて，パッケージの依存状況を視覚化するツールをご紹介。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回はちょっと横道にそれて，パッケージの依存状況を視覚化するツールをご紹介。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hirokidaichi/goviz&#34; title=&#34;hirokidaichi/goviz&#34;&gt;hirokidaichi/goviz&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;goviz-のインストール:b1af6a3f08cda062ac6e4b6083ff30fb&#34;&gt;goviz のインストール&lt;/h2&gt;

&lt;p&gt;導入は &lt;code&gt;go get&lt;/code&gt; でOK。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:&amp;gt;go get -v github.com/hirokidaichi/goviz
github.com/hirokidaichi/goviz (download)
github.com/jessevdk/go-flags (download)
github.com/hirokidaichi/goviz/dotwriter
github.com/jessevdk/go-flags
github.com/hirokidaichi/goviz/goimport
github.com/hirokidaichi/goviz/metrics
github.com/hirokidaichi/goviz
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;パッケージ依存状況の視覚化:b1af6a3f08cda062ac6e4b6083ff30fb&#34;&gt;パッケージ依存状況の視覚化&lt;/h2&gt;

&lt;p&gt;では，早速動かしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:&amp;gt;goviz.exe -i github.com/hirokidaichi/goviz
digraph main{
	edge[arrowhead=vee]
	graph [rankdir=LR,compound=true,ranksep=1.0];
	/* plot github.com/hirokidaichi/goviz */
	&amp;quot;github.com/hirokidaichi/goviz&amp;quot;[shape=&amp;quot;record&amp;quot;,label=&amp;quot;main|github.com/hirokidaichi/goviz|goviz.go&amp;quot;,style=&amp;quot;solid&amp;quot;]
	&amp;quot;github.com/hirokidaichi/goviz&amp;quot; -&amp;gt; &amp;quot;github.com/hirokidaichi/goviz/dotwriter&amp;quot;[dir=forward]
	/* plot github.com/hirokidaichi/goviz/dotwriter */
	&amp;quot;github.com/hirokidaichi/goviz/dotwriter&amp;quot;[shape=&amp;quot;record&amp;quot;,label=&amp;quot;dotwriter|github.com/hirokidaichi/goviz/dotwriter|dotwriter.go&amp;quot;,style=&amp;quot;solid&amp;quot;]
	&amp;quot;github.com/hirokidaichi/goviz&amp;quot; -&amp;gt; &amp;quot;github.com/hirokidaichi/goviz/goimport&amp;quot;[dir=forward]
	/* plot github.com/hirokidaichi/goviz/goimport */
	&amp;quot;github.com/hirokidaichi/goviz/goimport&amp;quot;[shape=&amp;quot;record&amp;quot;,label=&amp;quot;goimport|github.com/hirokidaichi/goviz/goimport|import.go\nimport_factory.go\nsource.go&amp;quot;,style=&amp;quot;solid&amp;quot;]
	&amp;quot;github.com/hirokidaichi/goviz/goimport&amp;quot; -&amp;gt; &amp;quot;github.com/hirokidaichi/goviz/dotwriter&amp;quot;[dir=forward]
	&amp;quot;github.com/hirokidaichi/goviz&amp;quot; -&amp;gt; &amp;quot;github.com/hirokidaichi/goviz/metrics&amp;quot;[dir=forward]
	/* plot github.com/hirokidaichi/goviz/metrics */
	&amp;quot;github.com/hirokidaichi/goviz/metrics&amp;quot;[shape=&amp;quot;record&amp;quot;,label=&amp;quot;metrics|github.com/hirokidaichi/goviz/metrics|metrics.go&amp;quot;,style=&amp;quot;solid&amp;quot;]
	&amp;quot;github.com/hirokidaichi/goviz/metrics&amp;quot; -&amp;gt; &amp;quot;github.com/hirokidaichi/goviz/dotwriter&amp;quot;[dir=forward]
	&amp;quot;github.com/hirokidaichi/goviz&amp;quot; -&amp;gt; &amp;quot;github.com/jessevdk/go-flags&amp;quot;[dir=forward]
	/* plot github.com/jessevdk/go-flags */
	&amp;quot;github.com/jessevdk/go-flags&amp;quot;[shape=&amp;quot;record&amp;quot;,label=&amp;quot;flags|github.com/jessevdk/go-flags|arg.go\nclosest.go\ncommand.go\ncommand_private.go\ncompletion.go\nconvert.go\nerror.go\nflags.go\ngroup.go\ngroup_private.go\nhelp.go\nini.go\nini_private.go\nman.go\nmultitag.go\noption.go\noption_private.go\noptstyle_other.go\noptstyle_windows.go\nparser.go\nparser_private.go\ntermsize.go\ntermsize_linux.go\ntermsize_nosysioctl.go\ntermsize_other.go\ntermsize_unix.go&amp;quot;,style=&amp;quot;solid&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;おー。
なんだか凄いコードが出力されました。
じつはこれ &lt;a href=&#34;https://ja.wikipedia.org/wiki/DOT%E8%A8%80%E8%AA%9E&#34;&gt;DOT というデータ記述言語&lt;/a&gt;で書かれたものです。
なので，この出力を &lt;a href=&#34;http://www.graphviz.org/&#34; title=&#34;Graphviz | Graphviz - Graph Visualization Software&#34;&gt;Graphviz&lt;/a&gt; のツールに通すことで最終的な出力を得ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:&amp;gt;goviz.exe -i github.com/hirokidaichi/goviz | dot.exe -Tpng -o goviz.png
&lt;/code&gt;&lt;/pre&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a data-flickr-embed=&#34;true&#34; href=&#34;https://www.flickr.com/photos/spiegel/21563262573/&#34;&gt;&lt;img src=&#34;https://farm6.staticflickr.com/5782/21563262573_630b0eed8a.jpg&#34; alt=&#34;output by goviz &amp;#43; graphviz&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/21563262573/&#34;&gt;output by goviz &amp;#43; graphviz&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&#34;パッケージ依存度の評価:b1af6a3f08cda062ac6e4b6083ff30fb&#34;&gt;パッケージ依存度の評価&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;-m&lt;/code&gt; オプションを指定するとパッケージ依存度（結合度）の評価ができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:&amp;gt;goviz.exe -i github.com/hirokidaichi/goviz -m
Inst:1.000 Ca(  0) Ce(  4)      github.com/hirokidaichi/goviz
Inst:0.500 Ca(  1) Ce(  1)      github.com/hirokidaichi/goviz/goimport
Inst:0.500 Ca(  1) Ce(  1)      github.com/hirokidaichi/goviz/metrics
Inst:0.000 Ca(  3) Ce(  0)      github.com/hirokidaichi/goviz/dotwriter
Inst:0.000 Ca(  1) Ce(  0)      github.com/jessevdk/go-flags
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Inst&lt;/code&gt; は Instability， &lt;code&gt;Ca&lt;/code&gt; は Afferent Couplings， &lt;code&gt;Ce&lt;/code&gt; は Efferent Couplings かな。&lt;/p&gt;

&lt;p&gt;Afferent Couplings は，そのパッケージに依存しているパッケージがいくつあるか，を示すものです。
Efferent Couplings は，逆にそのパッケージが依存しているパッケージがいくつあるか，を示すものです。
Instability は $Inst = Ce / (Ce + Ca)$ で算出される値で，この値が大きいほど他パッケージへの依存度が高いと評価できます。
共通ライブラリとして運用したいパッケージはなるべく Instability を低く抑えたいところです。
またソースコードを読む場合は Instability の高いパッケージから優先的にみるといいかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;goviz-の起動オプション:b1af6a3f08cda062ac6e4b6083ff30fb&#34;&gt;goviz の起動オプション&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hirokidaichi/goviz&#34; title=&#34;hirokidaichi/goviz&#34;&gt;hirokidaichi/goviz&lt;/a&gt; のオプションは以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;C:&amp;gt;goviz.exe -h
Usage:
  goviz.exe [OPTIONS]

Application Options:
  /i, /input:    intput ploject name
  /o, /output:   output file (default: STDOUT)
  /d, /depth:    max plot depth of the dependency tree (default: 128)
  /f, /focus:    focus on the specific module
  /s, /search:   top directory of searching
  /l, /leaf      whether leaf nodes are plotted (default: false)
  /m, /metrics   display module metrics (default: false)

Help Options:
  /?             Show this help message
  /h, /help      Show this help message
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bookmark:b1af6a3f08cda062ac6e4b6083ff30fb&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/hirokidaichi/items/52fc6286c9e432792a07&#34;&gt;そろそろ理解しておきたいのでDockerのソースコードをビジュアルに読む！ - Qiita&lt;/a&gt; : &lt;a href=&#34;https://github.com/hirokidaichi/goviz&#34; title=&#34;hirokidaichi/goviz&#34;&gt;hirokidaichi/goviz&lt;/a&gt; : 作者による解説&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.showa-corp.jp/special/graphtools/graphviz.html&#34;&gt;データのビジュアル化を最少の労力で: Graphviz&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
</content>
	</entry>
	
</feed>
