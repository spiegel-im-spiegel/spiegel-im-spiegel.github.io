<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:cc="http://web.resource.org/cc/">
	<title>プログラミング言語 Go — text.Baldanders.info</title>
	<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/" />
	<link rel="self" type="application/atom+xml" href="http://text.baldanders.info/golang/index.xml" />
	<id>tag:text.Baldanders.info,2016-03-29:/hugo</id>
	<updated>2016-03-29T22:16:41+09:00</updated>
	<subtitle>帰ってきた「しっぽのさきっちょ」</subtitle>
	<icon>http://text.baldanders.info//images/avatar.jpg</icon>
	<logo>http://text.baldanders.info//images/avatar.jpg</logo>
	<generator uri="http://gohugo.io/">Hugo 0.15</generator>

	
	<entry>
		<title>関数とポインタ — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/function-and-pointer/" />
		<id>tag:text.Baldanders.info,2016-03-29:/golang/function-and-pointer/</id>
		<published>2016-03-29T22:16:41+09:00</published>
		<updated>2016-03-29T22:16:41+09:00</updated>
		<summary>Go 言語の引数は基本的に「値渡し（call by value）」である。「参照渡し（call by reference）」にしたい場合はポインタを使う。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;いまさらな内容なのだが覚え書きとして記しておく。&lt;/p&gt;

&lt;h2 id=&#34;go-言語における-calling-sequence:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;Go 言語における Calling Sequence&lt;/h2&gt;

&lt;p&gt;まずは簡単な足し算の関数を定義してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x int, y int) int {
	return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;add&lt;/code&gt; に続く括弧内が引数を定義していて，括弧の後ろの &lt;code&gt;int&lt;/code&gt; は返り値の型&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8182ac28bc68eb736cad9fff25d78d28:t&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8182ac28bc68eb736cad9fff25d78d28:t&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; を示している。
&lt;code&gt;add()&lt;/code&gt; 関数を呼び出すには以下のように記述する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func add(x, y int) int {
	return x + y
}

func main() {
	ans := add(42, 13)
	fmt.Println(ans)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は同じ int 型なので以下のように記述することもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y int) int {
	return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返り値として複数の値を定義することもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func split(sum int) (int, int) {
	x = sum * 4 / 9
	y = sum - x
	return x, y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また返り値は以下のように名前をつけることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y int) (ans int) {
	ans = x + y
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後の &lt;code&gt;return&lt;/code&gt; がないとコンパイル・エラーになるので注意。
この書き方は &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;defer&lt;/a&gt; 構文と組み合わせるときに威力を発揮する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	err := r()
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(&amp;quot;Normal End.&amp;quot;)
	}
}

func r() (err error) {
	defer func() {
		if rec := recover(); rec != nil {
			err = fmt.Errorf(&amp;quot;Recovered from: %v&amp;quot;, rec)
		}
	}()

	f()
	err = nil
	return
}

func f() {
	panic(&amp;quot;Panic!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコード&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8182ac28bc68eb736cad9fff25d78d28:p&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8182ac28bc68eb736cad9fff25d78d28:p&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; では &lt;code&gt;r()&lt;/code&gt; 関数内で &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を捕まえ， 返り値の &lt;code&gt;err&lt;/code&gt; に値をセットしなおしている。&lt;/p&gt;

&lt;h3 id=&#34;go-言語の引数は-値渡し:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;Go 言語の引数は「値渡し」&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の引数は基本的に「値渡し（call by value）」である。
たとえば先程の足し算を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y int) int {
	x += y
	return x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と定義した場合でも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func add(x, y int) int {
	x += y
	return x
}

func main() {
    x := 42
    y := 13
	ans := add(x, y)
	fmt.Printf(&amp;quot;%d + %d = %d\n&amp;quot;, x, y, ans) //output: 42 + 13 = 55
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;呼び出し元で &lt;code&gt;add()&lt;/code&gt; 関数の引数に渡した instance は関数実行後も変化しない。
このため「値渡し」は thread safe なコードに向いている。
たとえば value object を構成する際には関連する関数は「値渡し」のほうが安全である。
ただし関数呼び出し時に instance の値が常にコピーされるため&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8182ac28bc68eb736cad9fff25d78d28:copy&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8182ac28bc68eb736cad9fff25d78d28:copy&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，サイズの大きな instance の場合は呼び出し時のコストが高くなる。&lt;/p&gt;

&lt;p&gt;引数を「参照渡し（call by reference）」にしたい場合はポインタを使う。
つまり instance のポインタ値を渡すのである。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func add(x, y *int) int {
	*x += *y
	return *x
}

func main() {
	x := 42
	y := 13
	ans := add(&amp;amp;x, &amp;amp;y)
	fmt.Printf(&amp;quot;%d + %d = %d\n&amp;quot;, x, y, ans) //output: 55 + 13 = 55
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードでは &lt;code&gt;add()&lt;/code&gt; 関数実行後の &lt;code&gt;x&lt;/code&gt; の値が変更されている。
内部状態を持つ instance を引数に指定する場合は参照渡しにする必要がある。
しかし引数を参照渡しにすると関数実行が thread safe でなくなる可能性がある。
また引数の値が nil の場合も考慮する必要がある。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では通常の方法ではポインタ演算ができない。
たとえば，ついうっかり&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x, y *int) int {
	x += y
	return *x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とか書いてしまっても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;invalid operation: x += y (operator + not defined on pointer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とコンパイル・エラーになる。
ポインタ演算が必要な場合は &lt;a href=&#34;https://golang.org/pkg/unsafe/&#34; title=&#34;unsafe - The Go Programming Language&#34;&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; パッケージを使う。&lt;/p&gt;

&lt;h3 id=&#34;slice-map-channel-は常に-参照渡し:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;Slice, Map, Channel は常に「参照渡し」&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Map_types&#34;&gt;map&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; は組み込み型だが内部状態を持つ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8182ac28bc68eb736cad9fff25d78d28:make&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8182ac28bc68eb736cad9fff25d78d28:make&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。
したがって，これらの型の instance を引数に渡す場合はつねに「参照渡し」になる（つまり instance のコピーは発生しない）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func setItem(ary map[int]int, index, item int) {
	ary[index] = item
}

func main() {
    ary := map[int]int{0: 0}
	fmt.Println(ary) //output: map[0:0]
	setItem(ary, 0, 1)
	fmt.Println(ary) //output: map[0:1]
	setItem(ary, 10, 10)
	fmt.Println(ary) //output: map[0:1 10:10]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし固定の配列や &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8182ac28bc68eb736cad9fff25d78d28:str&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8182ac28bc68eb736cad9fff25d78d28:str&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; の instance は「値」として振る舞うため&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8182ac28bc68eb736cad9fff25d78d28:n&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8182ac28bc68eb736cad9fff25d78d28:n&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;，引数に指定した場合も「値渡し」になる。
&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; とは挙動が異なるためテキトーなコードを書いていると混乱しやすい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func setItem(ary [4]int, index, item int) {
	ary[index] = item
}

func main() {
	ary := [4]int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	setItem(ary, 1, 10)
	fmt.Println(ary) //output: [0 1 2 3]
	ary[2] = 200
	fmt.Println(ary) //output: [0 1 200 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;固定配列や &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型を「参照渡し」にしたい場合はやはりポインタ値を渡す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func setItem(ary *[4]int, index, item int) {
	(*ary)[index] = item
}

func main() {
	ary := [4]int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	setItem(&amp;amp;ary, 1, 10)
	fmt.Println(ary) //output: [0 10 2 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際には &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型の instance は「不変（immutable）」なので「参照渡し」が必要な局面はほとんど無いと思われる。
固定配列は不変ではないが，配列を操作するのであれば固定配列ではなく &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; のほうが扱いやすい。
たとえば上のコードでは &lt;code&gt;ary := []int{0, 1, 2, 3}&lt;/code&gt; と初期化すれば &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; として扱える。&lt;/p&gt;

&lt;h2 id=&#34;method-receiver:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;Method Receiver&lt;/h2&gt;

&lt;p&gt;ある型に関数を関連付ける場合は method receiver を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Vertex struct {
	X int
	Y int
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(v Vertex)&lt;/code&gt; の部分が method receiver である。
&lt;code&gt;Add()&lt;/code&gt; 関数を呼び出すには以下のように記述する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := Vertex{X: 1, Y: 2}
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)  //output: X = 1, Y = 2
	fmt.Println(vv) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数の calling sequence としては &lt;code&gt;v.Add(dv)&lt;/code&gt; と &lt;code&gt;Vertex.Add(v, dv)&lt;/code&gt; は等価である。
つまり &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;Add()&lt;/code&gt; 関数の0番目の引数として振る舞い，「値渡し」でセットされる。&lt;/p&gt;

&lt;p&gt;Method receiver の型をポインタ型にすれば「参照渡し」にできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := &amp;amp;Vertex{X: 1, Y: 2}
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合も calling sequence としては &lt;code&gt;v.Add(dv)&lt;/code&gt; と &lt;code&gt;(*Vertex).Add(v, dv)&lt;/code&gt; は等価である。&lt;/p&gt;

&lt;h3 id=&#34;method-receiver-の暗黙的変換:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;Method Receiver の暗黙的変換&lt;/h3&gt;

&lt;p&gt;Method receiver を「値渡し」にした場合，呼び出し元の instance がポインタ型であっても暗黙的に「値渡し」に変換される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := &amp;amp;Vertex{X: 1, Y: 2} //pointer
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)  //output: X = 1, Y = 2
	fmt.Println(vv) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Method receiver を「参照渡し」にした場合も暗黙的に「参照渡し」に変換される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := Vertex{X: 1, Y: 2} //not pointer
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: X = 4, Y = 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;method-receiver-の値が-nil-の場合:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;Method Receiver の値が nil の場合&lt;/h3&gt;

&lt;p&gt;Method receiver の値が nil の場合はどうなるか。
まずは「値渡し」の場合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := (*Vertex)(nil) //nil
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)
	fmt.Println(vv)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合は &lt;code&gt;Add()&lt;/code&gt; 関数呼び出し時に &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; になる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;panic: runtime error: invalid memory address or nil pointer dereference
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まぁこれは分かりやすいよね。
では「参照渡し」の場合はどうなるか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&amp;quot;X = &amp;quot;, v.X, &amp;quot;, Y = &amp;quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := (*Vertex)(nil) //nil
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: &amp;lt;nil&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実は &lt;code&gt;Add()&lt;/code&gt; 関数呼び出し時点では &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; にはならない。
上のコードでは &lt;code&gt;v&lt;/code&gt; に nil が渡される。
したがって &lt;code&gt;Add()&lt;/code&gt; 関数内の条件文を削除すると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (v *Vertex) Add(dv Vertex) {
	v.X += dv.X
	v.Y += dv.Y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;v&lt;/code&gt; 内の要素を参照としたところで &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; になる。
Method receiver を「参照渡し」にする場合は nil 値に注意する必要がある。&lt;/p&gt;

&lt;h2 id=&#34;for-range-構文も-値渡し:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;for-range 構文も「値渡し」&lt;/h2&gt;

&lt;p&gt;余談だが for-range 構文も「値渡し」（つまりコピーが発生する）なので注意が必要である。
たとえば以下のコードで&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	ary := []int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	for _, item := range ary {
		item += 10
	}
	fmt.Println(ary) //output: [0 1 2 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for-range 構文内の &lt;code&gt;item&lt;/code&gt; は &lt;code&gt;ary&lt;/code&gt; 内の要素を指すのではなく要素のコピーである。
したがって &lt;code&gt;item&lt;/code&gt; を操作しても &lt;code&gt;ary&lt;/code&gt; には影響しない。
&lt;code&gt;ary&lt;/code&gt; 内の要素を操作するのであれば素朴に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	ary := []int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	for i := 0; i &amp;lt; len(ary); i++ {
		ary[i] += 10
	}
	fmt.Println(ary) //output: [10 11 12 13]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするしかない。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:8182ac28bc68eb736cad9fff25d78d28&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://skatsuta.github.io/2015/12/29/value-receiver-pointer-receiver/&#34;&gt;Go 言語の値レシーバとポインタレシーバ | Step by Step&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:8182ac28bc68eb736cad9fff25d78d28:t&#34;&gt;型については「&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」&lt;/a&gt;」を参照のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8182ac28bc68eb736cad9fff25d78d28:t&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8182ac28bc68eb736cad9fff25d78d28:p&#34;&gt;このコードについては「&lt;a href=&#34;http://text.baldanders.info/golang/error-handling/&#34;&gt;エラー・ハンドリングについて&lt;/a&gt;」で解説している。ちなみに &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を潰して error を返すのはエラー・ハンドリングとしてはいいやり方ではない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8182ac28bc68eb736cad9fff25d78d28:p&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8182ac28bc68eb736cad9fff25d78d28:copy&#34;&gt;値がどこにコピーされるかは型によって異なる。 &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 以外の基本型は値がスタックに積まれる。 &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; および基本型以外はヒープ領域に値がコピーされそのポインタがスタックに積まれる。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8182ac28bc68eb736cad9fff25d78d28:copy&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8182ac28bc68eb736cad9fff25d78d28:make&#34;&gt;&lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Map_types&#34;&gt;map&lt;/a&gt;, &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; は内部状態を持つため &lt;code&gt;new()&lt;/code&gt; 関数ではなく &lt;code&gt;make()&lt;/code&gt; 関数で instance を生成する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8182ac28bc68eb736cad9fff25d78d28:make&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8182ac28bc68eb736cad9fff25d78d28:str&#34;&gt;&lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型の実体は &lt;code&gt;[]byte&lt;/code&gt; 型である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8182ac28bc68eb736cad9fff25d78d28:str&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8182ac28bc68eb736cad9fff25d78d28:n&#34;&gt;たとえば固定の配列や &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型の instance は nil 値を持たない。 &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; 型のゼロ値は空文字列である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8182ac28bc68eb736cad9fff25d78d28:n&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>「ズンドコチェック」なるものが流行っているらしい — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/zundoko-choir/" />
		<id>tag:text.Baldanders.info,2016-03-12:/golang/zundoko-choir/</id>
		<published>2016-03-12T22:12:53+09:00</published>
		<updated>2016-03-16T17:35:35+09:00</updated>
		<summary>というわけで Go 言語で実装することを考えてみる。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Javaの講義、試験が「自作関数を作り記述しなさい」って問題だったから&lt;br&gt;「ズン」「ドコ」のいずれかをランダムで出力し続けて「ズン」「ズン」「ズン」「ズン」「ドコ」の配列が出たら「キ・ヨ・シ！」って出力した後終了って関数作ったら満点で単位貰ってた&lt;/p&gt;&amp;mdash; てくも (@kumiromilk) &lt;a href=&#34;https://twitter.com/kumiromilk/status/707437861881180160&#34;&gt;2016年3月9日&lt;/a&gt;&lt;/blockquote&gt;


&lt;/figure&gt;

&lt;p&gt;「習作（study）」としてはなかなか秀逸なアイデアだと思う。
これで満点くれる教官も流石だが（笑） 巷では「ズンドコキヨシ」とか「キヨシチェック」とか「ズンドコチェック」とか呼ばれているらしい。&lt;/p&gt;

&lt;p&gt;というわけで&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;「ズン」「ドコ」のいずれかをランダムで出力し続けて「ズン」「ズン」「ズン」「ズン」「ドコ」の配列が出たら「キ・ヨ・シ！」って出力した後終了って関数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;を &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で実装することを考えてみる。
私はコレを「ズンドコ・コール（zundoko-choir）」と呼ぶことにする。&lt;/p&gt;

&lt;p&gt;とはいえ，ズンドコ・コールを実装する事自体はそう難しくない。
たとえばこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math/rand&amp;quot;
	&amp;quot;time&amp;quot;
)

const (
	zun     = &amp;quot;ズン&amp;quot;
	doko    = &amp;quot;ドコ&amp;quot;
	kiyoshi = &amp;quot;キ・ヨ・シ！&amp;quot;
)

func generate() chan string {
	ch := make(chan string)
	go func() {
		var zundoko = [2]string{zun, doko}
		rand.Seed(time.Now().UnixNano())
		for {
			ch &amp;lt;- zundoko[rand.Intn(2)]
		}
	}()
	return ch
}

func main() {
	zundoko := generate()
	zcount := 0
	for {
		zd := &amp;lt;-zundoko
		fmt.Print(zd)
		if zd == zun {
			zcount++
		} else if zcount &amp;gt;= 4 {
			break
		} else {
			zcount = 0
		}
	}
	fmt.Print(kiyoshi)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「ズン」および「ドコ」をランダムに生成する部分は &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; と &lt;a href=&#34;http://golang.org/ref/spec#Go_statements&#34;&gt;goroutine&lt;/a&gt; を使えばいいだろう（&lt;code&gt;generate()&lt;/code&gt; 関数内の処理）。
擬似乱数は厳密でなくてもいいので安直に &lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; を使うことにした&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ba7781b05a447c47fa6bc5c87477853e:rand&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ba7781b05a447c47fa6bc5c87477853e:rand&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
さらに「ズン」「ズン」「ズン」「ズン」「ドコ」の配列パターンのチェックだが，「ズン」が4回以上連続で来た直後に「ドコ」が来たら OK としてみた。
まぁ，これがもっとも素朴な実装でパフォーマンスとしてもそれほど遜色ない筈。&lt;/p&gt;

&lt;p&gt;と，ここまで考えてハタと気づいた。
問題は「自作関数を作り記述しなさい」なんだからメイン関数にロジック書いたらアカンやん！&lt;/p&gt;

&lt;p&gt;というわけでまたもゴリゴリとコードを書いてパッケージにしてしまった。
アホだ，私（笑）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/zundoko&#34;&gt;spiegel-im-spiegel/zundoko: Zundoko-choirs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;出力は標準出力に直書きするのではなく &lt;a href=&#34;http://golang.org/ref/spec#String_types&#34;&gt;string&lt;/a&gt; の &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt; に &lt;code&gt;append()&lt;/code&gt; することで実現する。
この出力先を &lt;code&gt;Choirs&lt;/code&gt; 型として定義した。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Choirs - zundoko-choirs list
type Choirs struct {
	c []string
}

//Push is append choirs
func (c *Choirs) Push(s string) {
	c.c = append(c.c, s) //maybe panic if c is nil.
}

func (c *Choirs) String() string {
	if c == nil {
		return &amp;quot;&amp;quot;
	}
	content := make([]byte, 0, 128)
	for _, s := range c.c {
		content = append(content, s...)
	}
	return string(content)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに文字列の連結は &lt;a href=&#34;https://golang.org/pkg/strings/&#34; title=&#34;strings - The Go Programming Language&#34;&gt;&lt;code&gt;strings&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Join()&lt;/code&gt; 関数は使わず「&lt;a href=&#34;http://text.baldanders.info/golang/join-strings/&#34; title=&#34;文字列連結はどれが速い？ — プログラミング言語 Go&#34;&gt;文字列連結はどれが速い？&lt;/a&gt;」で紹介した方法を使っている。&lt;/p&gt;

&lt;p&gt;これで最初のコードは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func generate() chan string {
	ch := make(chan string)
	go func() {
		var zd = [2]string{Zun, Doko}
		rand.Seed(time.Now().UnixNano())
		for {
			ch &amp;lt;- zd[rand.Intn(2)]
		}
	}()
	return ch
}

//Run zundoko-choirs
func Run() *Choirs {
	zd := generate()
	c := &amp;amp;Choirs{make([]string, 0)}
	zcount := 0
	for {
		s := &amp;lt;-zd
		c.Push(s)
		if s == Zun {
			zcount++
		} else if zcount &amp;gt;= 4 {
			break
		} else {
			zcount = 0
		}
	}
	c.Push(Kiyoshi)
	return c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書き換えることができる。
このパッケージを呼び出すメイン側は例えば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/zundoko&amp;quot;
)

func main() {
	c := zundoko.Run()
	fmt.Println(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書けばいい。&lt;/p&gt;

&lt;p&gt;ところで「ズン」「ドコ」の出力は &lt;code&gt;Choirs&lt;/code&gt; 型で保持られているので，末尾の5要素のパターンを調べる別の方法もあると気づく。
たとえばこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var matchingPattern = []string{Zun, Zun, Zun, Zun, Doko}

func (c *Choirs) match() bool {
	if c == nil {
		return false
	}
	if len(c.c) &amp;lt; 5 {
		return false
	}
	return reflect.DeepEqual(c.c[len(c.c)-5:], matchingPattern)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この関数を使えば &lt;code&gt;Run()&lt;/code&gt; 関数は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Run2 zundoko-choirs (another logic)
func Run2() *Choirs {
	zd := generate()
	c := &amp;amp;Choirs{make([]string, 0)}
	for {
		s := &amp;lt;-zd
		c.Push(s)
		if c.match() {
			break
		}
	}
	c.Push(Kiyoshi)
	return c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり随分すっきりする。
ただこれコストが高くつきそうである。
というわけで，これも調べてみた。
まず以下のベンチマークを書く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package zundoko

import &amp;quot;testing&amp;quot;

func BenchmarkRun1(b *testing.B) {
	for i := 0; i &amp;lt; b.N; i++ {
		Run()
	}
}

func BenchmarkRun2(b *testing.B) {
	for i := 0; i &amp;lt; b.N; i++ {
		Run2()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;BenchmarkRun1&lt;/code&gt; が従来のもの， &lt;code&gt;BenchmarkRun2&lt;/code&gt; が先程の &lt;code&gt;match()&lt;/code&gt; 関数を使ったバージョンである。
結果は以下のとおり。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go test -bench Run -benchmem
testing: warning: no tests to run
PASS
BenchmarkRun1-4    50000     28141 ns/op    1800 B/op     9 allocs/op
BenchmarkRun2-4    30000     40102 ns/op    3912 B/op   115 allocs/op
ok      github.com/spiegel-im-spiegel/zundoko   4.261s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;乱数の要素が絡むので毎回同じ値ではないが，傾向としてはこんな感じ。
&lt;code&gt;BenchmarkRun2&lt;/code&gt; のほうが allocation 回数が圧倒的に多いのが分かるだろう。
これがスピードにもダイレクトに反映されている感じである。&lt;/p&gt;

&lt;p&gt;今回は「「ズン」が4回以上連続で来た直後に「ドコ」が来たら OK」という単純なロジックだったが，もっと複雑なパターンが要求される場合は工夫が必要かもしれない&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ba7781b05a447c47fa6bc5c87477853e:lr&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ba7781b05a447c47fa6bc5c87477853e:lr&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;「ズン」と「ドコ」の出現回数を数える関数も作ってみた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//CountZunDoko returns count of &amp;quot;ZUN&amp;quot; and &amp;quot;DOKO&amp;quot; choirs
func (c *Choirs) CountZunDoko() (int, int) {
	z := 0
	d := 0
	if c == nil {
		return z, d
	}
	for _, s := range c.c {
		switch s {
		case Zun:
			z++
		case Doko:
			d++
		}
	}
	return z, d
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;たとえば &lt;code&gt;generate()&lt;/code&gt; 関数内で使っている擬似乱数パッケージを別のものに換えた時に統計処理で簡単な性能評価ができるかもしれない。
今回はそこまではしなけど（擬似乱数の話はいずれやりたい）。&lt;/p&gt;

&lt;p&gt;こうやって手遊びでコードを弄るのは楽しいものである。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:ba7781b05a447c47fa6bc5c87477853e&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/shunsugai@github/items/971a15461de29563bf90&#34;&gt;ズンドコキヨシまとめ - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/shinderuman@github/items/2ff67c2404647d2b7ea6&#34;&gt;ズンドコキヨシ with Go (n番煎じ) - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/Rompei/items/bfa03fbc9a94a37703bb&#34;&gt;ズンドコキヨシGolang並列版 - Qiita&lt;/a&gt; : 「ズン」「ドコ」の生成部分を CPU の数だけ並列処理で行わせてひとつの &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34;&gt;channel&lt;/a&gt; に入力するというユニークな実装&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/spiegel-im-spiegel/items/6a5bc07dbfa46a328e26&#34;&gt;「ズンドコキヨシ」と擬似乱数 - Qiita&lt;/a&gt; : Qiita で擬似乱数について簡単にまとめてみた。整理できたらこちらでも記事にするかも&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考図書:ba7781b05a447c47fa6bc5c87477853e&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/41aCueik45L._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4621300253/baldandersinf-22/&#34;&gt;プログラミング言語Go&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Alan A.A. Donovan Brian W. Kernighan 柴田 芳樹 &lt;/dd&gt;&lt;dd&gt;丸善出版 2016-06-15&lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117526/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117526.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Go言語によるWebアプリケーション開発&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117607/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117607.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;マイクロサービスアーキテクチャ&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4873117402/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4873117402.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;ハイパフォーマンスPython&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/0134190440/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/0134190440.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;The Go Programming Language (Addison-Wesley Professional Computing Series)&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/4774166340/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/4774166340.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Vim script テクニックバイブル ~Vim使いの魔法の杖&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;著者のひとりは（あの「バイブル」とも呼ばれる）通称 “K&amp;amp;R” の K のほうである。買おうかどうか悩み中。目次があればなぁ。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-03-12&#34;&gt;2016-03-12&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:ba7781b05a447c47fa6bc5c87477853e:rand&#34;&gt;&lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; の乱数生成アルゴリズムの既定は線形合同法らしい。&lt;a href=&#34;http://www001.upp.so-net.ne.jp/isaku/rand.html&#34; title=&#34;良い乱数・悪い乱数&#34;&gt;線形合同法は性能が良くなく&lt;/a&gt;ゲームや暗号等では使えない。&lt;a href=&#34;https://golang.org/pkg/math/rand/&#34; title=&#34;rand - The Go Programming Language&#34;&gt;&lt;code&gt;math/rand&lt;/code&gt;&lt;/a&gt; の乱数生成アルゴリズムは他のものに入れ替えることができる。たとえば &lt;a href=&#34;https://github.com/seehuhn/mt19937&#34; title=&#34;seehuhn/mt19937: An implementation of Takuji Nishimura&#39;s and Makoto Matsumoto&#39;s Mersenne Twister pseudo random number generator in Go.&#34;&gt;&lt;code&gt;seehuhn/mt19937&lt;/code&gt;&lt;/a&gt; パッケージが使える。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ba7781b05a447c47fa6bc5c87477853e:rand&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:ba7781b05a447c47fa6bc5c87477853e:lr&#34;&gt;たとえば &lt;a href=&#34;https://golang.org/pkg/container/list/&#34; title=&#34;list - The Go Programming Language&#34;&gt;&lt;code&gt;container/list&lt;/code&gt;&lt;/a&gt; や &lt;a href=&#34;https://golang.org/pkg/container/ring/&#34; title=&#34;ring - The Go Programming Language&#34;&gt;&lt;code&gt;container/ring&lt;/code&gt;&lt;/a&gt; といったパッケージを使う手がある。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ba7781b05a447c47fa6bc5c87477853e:lr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Interface の謎 — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/interface/" />
		<id>tag:text.Baldanders.info,2016-02-22:/golang/interface/</id>
		<published>2016-02-22T19:22:33+09:00</published>
		<updated>2016-02-22T20:53:30+09:00</updated>
		<summary>Interface には落とし穴がある。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回も軽めの小ネタで。&lt;/p&gt;

&lt;p&gt;まず，文字列の配列を表示するだけの単純なコードを書いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	strlist := []string{&amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;gamma&amp;quot;}
	fmt.Println(strlist)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;[alpha beta gamma]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。
配列&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a38e724b1dfc1725327e2aea22a2a689:s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a38e724b1dfc1725327e2aea22a2a689:s&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; の中身をそのままダンプ出力しているだけなので，まぁ当たり前っちゃあ当たり前。
では，配列のダンプではなくきちんと項目を列挙したいとしよう。
やり方は色々あるが簡単に &amp;ldquo;&lt;code&gt;...&lt;/code&gt;” トークンを使って&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	strlist := []string{&amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;gamma&amp;quot;}
	fmt.Println(strlist...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と配列を展開すればいんじゃね？ って思うよね，普通。
&lt;a href=&#34;https://golang.org/pkg/fmt/&#34; title=&#34;fmt - The Go Programming Language&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Println()&lt;/code&gt; 関数の定義を見ても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Println(a ...interface{}) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっているし，問題ないように見える。&lt;/p&gt;

&lt;p&gt;でもこれはうまくいかない。
これを実行しようとすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;prog.go:7: cannot use strlist (type []string) as type []interface {} in argument to fmt.Println
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とエラーになる。&lt;/p&gt;

&lt;p&gt;実は &lt;code&gt;[]string&lt;/code&gt; 型の &lt;code&gt;strlist&lt;/code&gt; は &lt;a href=&#34;https://golang.org/pkg/fmt/&#34; title=&#34;fmt - The Go Programming Language&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Println()&lt;/code&gt; 関数に渡す際に &lt;code&gt;[]interface{}&lt;/code&gt; 型ではなく &lt;code&gt;interface{}&lt;/code&gt; 型に&lt;strong&gt;必ず&lt;/strong&gt;キャストされる。
だから &lt;code&gt;strlist...&lt;/code&gt; と展開しようとしても「そりゃあ無理（←超意訳）」と怒られてしまうわけだ。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の型（&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt;）は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Msg []string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように配列やポインタも型として定義できてしまうことを&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;思い出して&lt;/a&gt;欲しい。&lt;/p&gt;

&lt;p&gt;じゃあ，明示的なキャストならいけるのかと思ったが&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Msg []string

func main() {
	strlist := []string{&amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;gamma&amp;quot;}
	fmt.Println(([]interface{})(strlist)...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;prog.go:9: cannot convert strlist (type []string) to type []interface {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と，これもエラーになった。&lt;/p&gt;

&lt;p&gt;ではどうすればいいのかというと &lt;code&gt;[]interface{}&lt;/code&gt; 型の配列を用意してそこに値をコピーする。
先程のコードであれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Msg []string

func main() {
	strlist := []string{&amp;quot;alpha&amp;quot;, &amp;quot;beta&amp;quot;, &amp;quot;gamma&amp;quot;}
	var list = make([]interface{}, 0)
	for _, str := range strlist {
		list = append(list, str)
	}
	fmt.Println(list...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;alpha beta gamma
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにめでたく列挙される。
この問題は &lt;a href=&#34;https://golang.org/pkg/fmt/&#34; title=&#34;fmt - The Go Programming Language&#34;&gt;&lt;code&gt;fmt&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Println()&lt;/code&gt; 関数だけじゃなく，ある型の配列を &lt;code&gt;[]interface{}&lt;/code&gt; 型にキャストしようとする際は必ず発生するようだ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a38e724b1dfc1725327e2aea22a2a689:c&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a38e724b1dfc1725327e2aea22a2a689:c&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;いや，「“&lt;code&gt;cannot use strlist (type []string) as type []interface {} in argument to fmt.Println&lt;/code&gt;” なんてコンパイルエラーを出せるならコンパイラ側でなんとかしてよ」と思うのだが，どうも無理らしい。&lt;/p&gt;

&lt;p&gt;やれやれ。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:a38e724b1dfc1725327e2aea22a2a689&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@tucnak/why-go-is-a-poorly-designed-language-1cc04e5daf2#.ucutrogyz&#34;&gt;Why Go is a poorly designed language — Medium&lt;/a&gt; （&lt;a href=&#34;http://postd.cc/why-go-is-a-poorly-designed-language/&#34;&gt;日本語訳&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/wiki/InterfaceSlice&#34;&gt;InterfaceSlice · golang/go Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:a38e724b1dfc1725327e2aea22a2a689:s&#34;&gt;厳密には &lt;a href=&#34;http://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;。分かってますよ，もちろん。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a38e724b1dfc1725327e2aea22a2a689:s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:a38e724b1dfc1725327e2aea22a2a689:c&#34;&gt;例えば &lt;code&gt;list&lt;/code&gt; に &lt;code&gt;strlist&lt;/code&gt; の内容をコピーする際に for 文で回すのではなく &lt;code&gt;list = append(list, strlist...)&lt;/code&gt; でできるかどうか試してみればいい。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a38e724b1dfc1725327e2aea22a2a689:c&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Travis CI でクロス・コンパイル — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/cross-compiling-in-travis-ci/" />
		<id>tag:text.Baldanders.info,2016-02-13:/golang/cross-compiling-in-travis-ci/</id>
		<published>2016-02-13T19:37:11+09:00</published>
		<updated>2016-02-25T09:39:28+09:00</updated>
		<summary>今回は Travis CI から GitHub へ mitchellh/gox で生成した実行バイナリを deploy することを考える。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;h2 id=&#34;gox-でまとめてクロス-コンパイル:fa953b67964726c338be9843a0c52e04&#34;&gt;Gox でまとめてクロス・コンパイル&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の特徴のひとつにクロス・コンパイルの容易さがあるが，複数プラットフォームのビルドをまとめて行う &lt;a href=&#34;https://github.com/mitchellh/gox&#34; title=&#34;mitchellh/gox: A dead simple, no frills Go cross compile tool&#34;&gt;mitchellh/gox&lt;/a&gt; を使うと便利である。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go get github.com/mitchellh/gox

$gox -h
Usage: gox [options] [packages]

  Gox cross-compiles Go applications in parallel.

  If no specific operating systems or architectures are specified, Gox
  will build for all pairs supported by your version of Go.

Options:

  -arch=&amp;quot;&amp;quot;            Space-separated list of architectures to build for
  -build-toolchain    Build cross-compilation toolchain
  -cgo                Sets CGO_ENABLED=1, requires proper C toolchain (advanced)
  -gcflags=&amp;quot;&amp;quot;         Additional &#39;-gcflags&#39; value to pass to go build
  -ldflags=&amp;quot;&amp;quot;         Additional &#39;-ldflags&#39; value to pass to go build
  -tags=&amp;quot;&amp;quot;            Additional &#39;-tags&#39; value to pass to go build
  -os=&amp;quot;&amp;quot;              Space-separated list of operating systems to build for
  -osarch=&amp;quot;&amp;quot;          Space-separated list of os/arch pairs to build for
  -osarch-list        List supported os/arch pairs for your Go version
  -output=&amp;quot;foo&amp;quot;       Output path template. See below for more info
  -parallel=-1        Amount of parallelism, defaults to number of CPUs
  -rebuild            Force rebuilding of package that were up to date
  -verbose            Verbose mode

Output path template:

  The output path for the compiled binaries is specified with the
  &amp;quot;-output&amp;quot; flag. The value is a string that is a Go text template.
  The default value is &amp;quot;{{.Dir}}_{{.OS}}_{{.Arch}}&amp;quot;. The variables and
  their values should be self-explanatory.

Platforms (OS/Arch):

  The operating systems and architectures to cross-compile for may be
  specified with the &amp;quot;-arch&amp;quot; and &amp;quot;-os&amp;quot; flags. These are space separated lists
  of valid GOOS/GOARCH values to build for, respectively. You may prefix an
  OS or Arch with &amp;quot;!&amp;quot; to negate and not build for that platform. If the list
  is made up of only negations, then the negations will come from the default
  list.

  Additionally, the &amp;quot;-osarch&amp;quot; flag may be used to specify complete os/arch
  pairs that should be built or ignored. The syntax for this is what you would
  expect: &amp;quot;darwin/amd64&amp;quot; would be a valid osarch value. Multiple can be space
  separated. An os/arch pair can begin with &amp;quot;!&amp;quot; to not build for that platform.

  The &amp;quot;-osarch&amp;quot; flag has the highest precedent when determing whether to
  build for a platform. If it is included in the &amp;quot;-osarch&amp;quot; list, it will be
  built even if the specific os and arch is negated in &amp;quot;-os&amp;quot; and &amp;quot;-arch&amp;quot;,
  respectively.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;オプションは色々あるが，とりあえずパッケージを指定して起動すれば全てのプラットフォームについてビルドを行う&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fa953b67964726c338be9843a0c52e04:bt&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fa953b67964726c338be9843a0c52e04:bt&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
私が今つくってる &lt;a href=&#34;https://github.com/spiegel-im-spiegel/gpgpdump&#34; title=&#34;spiegel-im-spiegel/gpgpdump: gpgpdump - OpenPGP packet visualizer&#34;&gt;gpgpdump&lt;/a&gt; を例にすると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go get get github.com/spiegel-im-spiegel/gpgpdump

$ gox -output &amp;quot;goxdist/{{.OS}}_{{.Arch}}/{{.Dir}}&amp;quot; github.com/spiegel-im-spiegel/gpgpdump

--&amp;gt;      netbsd/arm: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;   windows/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;   freebsd/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;      darwin/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;    darwin/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;       linux/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     linux/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;       linux/arm: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     freebsd/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;      netbsd/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     freebsd/arm: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;    netbsd/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;   openbsd/amd64: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     openbsd/386: github.com/spiegel-im-spiegel/gpgpdump
--&amp;gt;     windows/386: github.com/spiegel-im-spiegel/gpgpdump

$ ls -l goxdist
drwx 0 2016-02-13 17:41 darwin_386/
drwx 0 2016-02-13 17:41 darwin_amd64/
drwx 0 2016-02-13 17:42 freebsd_386/
drwx 0 2016-02-13 17:41 freebsd_amd64/
drwx 0 2016-02-13 17:42 freebsd_arm/
drwx 0 2016-02-13 17:41 linux_386/
drwx 0 2016-02-13 17:41 linux_amd64/
drwx 0 2016-02-13 17:42 linux_arm/
drwx 0 2016-02-13 17:42 netbsd_386/
drwx 0 2016-02-13 17:42 netbsd_amd64/
drwx 0 2016-02-13 17:41 netbsd_arm/
drwx 0 2016-02-13 17:42 openbsd_386/
drwx 0 2016-02-13 17:42 openbsd_amd64/
drwx 0 2016-02-13 17:42 windows_386/
drwx 0 2016-02-13 17:41 windows_amd64/

$ ls -l goxdist/windows_amd64
-rw- 5712896 2016-02-13 17:41 gpgpdump.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;といい感じに出力してくれる。&lt;/p&gt;

&lt;p&gt;OS を指定する場合は &lt;code&gt;-os &amp;quot;linux windows&amp;quot;&lt;/code&gt; のように指定する。
アーキテクチャは &lt;code&gt;-arch&lt;/code&gt; オプションを， OS とアーキテクチャを組み合わせる場合は &lt;code&gt;-osarch linux/arm&lt;/code&gt; などとする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-output&lt;/code&gt; オプションの &lt;code&gt;&amp;quot;goxdist/{{.OS}}_{{.Arch}}/{{.Dir}}&amp;quot;&lt;/code&gt; は出力先のテンプレートで &lt;code&gt;{{ }}&lt;/code&gt; で囲まれている部分に実際の値が埋め込まれる。
たとえば OS が windows でアーキテクチャが amd64 なら &lt;code&gt;goxdist/windows_amd64/gpgpdump&lt;/code&gt; と展開されるわけだ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fa953b67964726c338be9843a0c52e04:tpl&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fa953b67964726c338be9843a0c52e04:tpl&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;このようにクロス・コンパイルが非常に簡単なので &lt;a href=&#34;https://travis-ci.org/&#34; title=&#34;Travis CI - Test and Deploy Your Code with Confidence&#34;&gt;Travis CI&lt;/a&gt; などで複数プラットフォームのバイナリを生成するのも難しくない。&lt;/p&gt;

&lt;h2 id=&#34;ghr-を使って-github-に-deploy-する:fa953b67964726c338be9843a0c52e04&#34;&gt;ghr を使って GitHub に Deploy する&lt;/h2&gt;

&lt;p&gt;今回は &lt;a href=&#34;https://travis-ci.org/&#34; title=&#34;Travis CI - Test and Deploy Your Code with Confidence&#34;&gt;Travis CI&lt;/a&gt; から &lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; へ &lt;a href=&#34;https://github.com/mitchellh/gox&#34; title=&#34;mitchellh/gox: A dead simple, no frills Go cross compile tool&#34;&gt;mitchellh/gox&lt;/a&gt; で生成した実行バイナリを deploy することを考える。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mitchellh/gox&#34; title=&#34;mitchellh/gox: A dead simple, no frills Go cross compile tool&#34;&gt;mitchellh/gox&lt;/a&gt; で生成した実行バイナリをそのままアップしてもいいのだが，ちょっと気持ち悪いので&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:fa953b67964726c338be9843a0c52e04:s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:fa953b67964726c338be9843a0c52e04:s&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，まずは zip で固めてしまおう。
以下のような簡単な shell script を書いてみた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

DIR=`pwd`
mkdir ./goxdist/dist
for PLATFORM in $(find ./goxdist -mindepth 1 -maxdepth 1 -type d); do
    PLATFORM_NAME=$(basename ${PLATFORM})

    if [ ${PLATFORM_NAME} = &amp;quot;dist&amp;quot; ]; then
        continue
    fi

    cd ${PLATFORM}
    zip ${DIR}/goxdist/dist/${PLATFORM_NAME}.zip ./*
    cd ${DIR}
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先ほど &lt;code&gt;goxdist&lt;/code&gt; フォルダ以下に生成した各バイナリをひとつづつ zip 圧縮して &lt;code&gt;goxdist/dist&lt;/code&gt; フォルダに置くだけの簡単なお仕事。
これで &lt;code&gt;goxdist/dist&lt;/code&gt; フォルダの中身を &lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; に deploy すればよい。
&lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; への deploy には &lt;a href=&#34;https://github.com/tcnksm/ghr&#34; title=&#34;tcnksm/ghr: Create Github Release and upload artifacts in parallel&#34;&gt;tcnksm/ghr&lt;/a&gt; が便利である。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ go get github.com/tcnksm/ghr

$ ghr -h

Usage: ghr [options] TAG PATH

  ghr is a tool to create Release on Github and upload your artifacts to
  it. ghr parallelizes upload multiple artifacts.

  You can use ghr on GitHub Enterprise. Change URL by GITHUB_API env var.

Options:

  --username, -u        GitHub username. By default, ghr extracts user
                        name from global gitconfig value.

  --repository, -r      GitHub repository name. By default, ghr extracts
                        repository name from current directory&#39;s .git/config
                        value.

  --token, -t           GitHub API Token. To use ghr, you will first need
                        to create a GitHub API token with an account which
                        has enough permissions to be able to create releases.
                        You can set this value via GITHUB_TOKEN env var.

  --parallel=-1         Parallelization factor. This option limit amount
                        of parallelism of uploading. By default, ghr uses
                        number of logic CPU of your PC.

  --delete              Delete release if it already created. If you want
                        to recreate release itself from begining, use
                        this. Just want to upload same artifacts to same
                        release again, use --replace option.

  --replace             Replace artifacts if it is already uploaded. Same
                        artifact measn, same release and same artifact
                        name.

  --stat=false          Show number of download of each release and quit.
                        This is special command.

Examples:

  $ ghr v1.0 dist/     Upload all artifacts which are in dist directory
                       with version v1.0.

  $ ghr --stat         Show download number of each relase and quit.

$ ghr --username spiegel-im-spiegel --token $GITHUB_TOKEN v0.1.2 goxdist/dist/
--&amp;gt; Uploading: windows_amd64_v0.1.2.zip
--&amp;gt; Uploading: linux_amd64_v0.1.2.zip
--&amp;gt; Uploading: darwin_386_v0.1.2.zip
--&amp;gt; Uploading: darwin_amd64_v0.1.2.zip
--&amp;gt; Uploading: freebsd_386_v0.1.2.zip
--&amp;gt; Uploading: freebsd_amd64_v0.1.2.zip
--&amp;gt; Uploading: freebsd_arm_v0.1.2.zip
--&amp;gt; Uploading: linux_386_v0.1.2.zip
--&amp;gt; Uploading: netbsd_arm_v0.1.2.zip
--&amp;gt; Uploading: linux_arm_v0.1.2.zip
--&amp;gt; Uploading: netbsd_386_v0.1.2.zip
--&amp;gt; Uploading: netbsd_amd64_v0.1.2.zip
--&amp;gt; Uploading: openbsd_amd64_v0.1.2.zip
--&amp;gt; Uploading: openbsd_386_v0.1.2.zip
--&amp;gt; Uploading: windows_386_v0.1.2.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;てな感じで deploy できる。
ちなみに &lt;code&gt;$GITHUB_TOKEN&lt;/code&gt; には &lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; の access token をセットする。
Access token は &lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; の &amp;ldquo;Settings” の &amp;ldquo;Personal access tokens” のページで取得できる。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a data-flickr-embed=&#34;true&#34; href=&#34;https://www.flickr.com/photos/spiegel/24367702843/&#34;&gt;&lt;img src=&#34;https://farm2.staticflickr.com/1626/24367702843_e72366313f.jpg&#34; alt=&#34;Get access token in GitHub&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;https://www.flickr.com/photos/spiegel/24367702843/&#34;&gt;Get access token in GitHub&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;repo の権限を付けること。
この access token を &lt;a href=&#34;https://travis-ci.org/&#34; title=&#34;Travis CI - Test and Deploy Your Code with Confidence&#34;&gt;Travis CI&lt;/a&gt; で参照するには， &amp;ldquo;Settings” の &amp;ldquo;Environment Variables” でセットすればよい。
Build log にこの access token が表示されないようにすること。&lt;/p&gt;

&lt;p&gt;最終的な &lt;code&gt;.travis.yml&lt;/code&gt; の内容はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;language: go

go:
  - 1.5.3

branches:
  only: master

before_install:
  - go get -v github.com/mitchellh/gox
  - go get -v github.com/tcnksm/ghr

script:
  - go test -v ./...

after_success:
  - gox -output &amp;quot;goxdist/{{.OS}}_{{.Arch}}_`git tag | tail -1`/{{.Dir}}&amp;quot; -ldflags &amp;quot;-X main.Version=`git tag | tail -1`&amp;quot;
  - sh scripts/package.sh
  - ghr --username spiegel-im-spiegel --token $GITHUB_TOKEN `git tag | tail -1` goxdist/dist/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git tag | tail -1&lt;/code&gt; で最新のタグを取得して，そこに deploy するようにしている。
&lt;a href=&#34;https://github.com/&#34; title=&#34;GitHub&#34;&gt;GitHub&lt;/a&gt; に何か push するたびにビルドが走るのはウザいので， master ブランチのみテスト &amp;amp; ビルドの対象とした。&lt;/p&gt;

&lt;p&gt;まっ，こんなもんかな。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:fa953b67964726c338be9843a0c52e04&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/yanolab/items/5a6dfb3c07c94f7c760d&#34;&gt;Golang + Raspberry Pi + LPS331AP で気圧・温度を測定してみた - Qiita&lt;/a&gt; : arm アーキテクチャでいけるらしい&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/07/22/go1_5-cross-compile/&#34;&gt;Go1.5はクロスコンパイルがより簡単 | SOTA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/rerofumi/items/d6a8ba08270acb61b31c&#34;&gt;Raspberry PI ２ 用の consul を作る (201512版 - Qiita&lt;/a&gt; : Raspberry PI 上でビルドするより Linux のクロス環境を使ったほうが速いらしい&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2014/10/16/golang-in-ci-as-a-service/&#34;&gt;CI-as-a-ServiceでGo言語プロジェクトの最新ビルドを継続的に提供する | SOTA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/m0a/items/d933982293dcadd4998c&#34;&gt;RaspberryPi1(2とzeroも)で動かすgolang製アプリをクロスコンパイル(onMac) - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:fa953b67964726c338be9843a0c52e04:bt&#34;&gt;ちなみに &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の 1.4 までは &lt;a href=&#34;https://github.com/mitchellh/gox&#34; title=&#34;mitchellh/gox: A dead simple, no frills Go cross compile tool&#34;&gt;mitchellh/gox&lt;/a&gt; インストール後に &lt;code&gt;gox -build-toolchain&lt;/code&gt; でクロス環境を生成する必要があったが， 1.5 からは不要になった。めでたい！
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fa953b67964726c338be9843a0c52e04:bt&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:fa953b67964726c338be9843a0c52e04:tpl&#34;&gt;&lt;code&gt;{{ }}&lt;/code&gt; でテンプレートをハンドリングするには &lt;a href=&#34;https://golang.org/pkg/text/template/&#34; title=&#34;template - The Go Programming Language&#34;&gt;&lt;code&gt;text/template&lt;/code&gt;&lt;/a&gt; パッケージを使う。静的サイト・ジェネレータの &lt;a href=&#34;http://gohugo.io/&#34; title=&#34;Hugo :: A fast and modern static website engine&#34;&gt;Hugo&lt;/a&gt; でもこのテンプレート・パッケージを使っている。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fa953b67964726c338be9843a0c52e04:tpl&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:fa953b67964726c338be9843a0c52e04:s&#34;&gt;企業などのネット環境では Web から exe ファイルなどの実行バイナリを直接ダウンロードすることを禁止している場合もある。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:fa953b67964726c338be9843a0c52e04:s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>スタック追跡とパニック・ハンドリング — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/stack-trace-and-panic-handling/" />
		<id>tag:text.Baldanders.info,2016-02-13:/golang/stack-trace-and-panic-handling/</id>
		<published>2016-02-13T14:48:05+09:00</published>
		<updated>2016-02-13T14:48:05+09:00</updated>
		<summary>panic 時の出力をカスタマイズすることを考える。スタック情報を取得するには， panic を recover で捕まえた上で runtime.Caller() 関数を使う。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回は軽めの小ネタで。&lt;/p&gt;

&lt;p&gt;「&lt;a href=&#34;http://text.baldanders.info/golang/error-handling/&#34;&gt;エラー・ハンドリングについて&lt;/a&gt;」でも少し説明したが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では回復不能のエラー（ゼロ除算やメモリ不足など）が発生した場合には &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を投げる仕様になっている。
たとえば以下のコードでは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

func main() {
	os.Exit(run())
}

func run() int {
	f()
	return 0
}

func f() {
	numbers := []int{0, 1, 2}
	fmt.Println(numbers[3]) //panic!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のスタック情報が標準エラー出力に表示される&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4e4334940cfbd371abfb6e84384d704c:s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4e4334940cfbd371abfb6e84384d704c:s&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
（&lt;a href=&#34;https://play.golang.org/&#34;&gt;The Go Playground&lt;/a&gt; での実行結果）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;panic: runtime error: index out of range

goroutine 1 [running]:
main.f()
	/tmp/sandbox269685094/main.go:19 +0x160
main.run(0x20300, 0x104000e0)
	/tmp/sandbox269685094/main.go:13 +0x20
main.main()
	/tmp/sandbox269685094/main.go:9 +0x20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まぁ必要な情報はあるのでこれでも構わないのだが，ファイル名がフルパスで表示されるのがアレな感じである。
また出力先が標準エラー出力で固定されているのも面白くない。&lt;/p&gt;

&lt;p&gt;そこで &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; 時の出力をカスタマイズすることを考える。
スタック情報を取得するには， &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;panic&lt;/a&gt; を &lt;a href=&#34;http://blog.golang.org/defer-panic-and-recover&#34; title=&#34;Defer, Panic, and Recover - The Go Blog&#34;&gt;recover&lt;/a&gt; で捕まえた上で &lt;a href=&#34;https://golang.org/pkg/runtime/&#34; title=&#34;runtime - The Go Programming Language&#34;&gt;&lt;code&gt;runtime&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Caller()&lt;/code&gt; 関数を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;runtime&amp;quot;
)

func main() {
	os.Exit(run(os.Stderr))
}

func run(log io.Writer) (exit int) {
	defer func() {
		if r := recover(); r != nil {
			fmt.Fprintf(log, &amp;quot;Panic: %v\n&amp;quot;, r)
			for depth := 0; ; depth++ {
				pc, src, line, ok := runtime.Caller(depth)
				if !ok {
					break
				}
				fmt.Fprintf(log, &amp;quot; -&amp;gt; %d: %s: %s(%d)\n&amp;quot;, depth, runtime.FuncForPC(pc).Name(), src, line)
			}
			exit = 1
		}
	}()

	f()
    exit = 0
    return
}

func f() {
	numbers := []int{0, 1, 2}
	fmt.Println(numbers[3]) //panic!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで出力は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Panic: runtime error: index out of range
 -&amp;gt; 0: main.run.func1: /tmp/sandbox562252505/main.go(19)
 -&amp;gt; 1: runtime.call16: /usr/local/go/src/runtime/asm_amd64p32.s(390)
 -&amp;gt; 2: runtime.gopanic: /usr/local/go/src/runtime/panic.go(423)
 -&amp;gt; 3: runtime.panicindex: /usr/local/go/src/runtime/panic.go(12)
 -&amp;gt; 4: main.f: /tmp/sandbox562252505/main.go(36)
 -&amp;gt; 5: main.run: /tmp/sandbox562252505/main.go(29)
 -&amp;gt; 6: main.main: /tmp/sandbox562252505/main.go(11)
 -&amp;gt; 7: runtime.main: /usr/local/go/src/runtime/proc.go(111)
 -&amp;gt; 8: runtime.goexit: /usr/local/go/src/runtime/asm_amd64p32.s(1133)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となる。
ファイル名を出力したくないなら for 文の中を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for depth := 0; ; depth++ {
	pc, _, line, ok := runtime.Caller(depth)
	if !ok {
		break
	}
	fmt.Fprintf(log, &amp;quot; -&amp;gt; %d: %s: (%d)\n&amp;quot;, depth, runtime.FuncForPC(pc).Name(), line)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とする手もある。
コードを書いてる人はスタック追跡情報とファイルの行番号があれば大体あたりをつけられるので，これだけでもありがたい。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:4e4334940cfbd371abfb6e84384d704c&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sgykfjsm.github.io/blog/2016/01/20/golang-function-tracing/&#34;&gt;Goでfunctionが実行された順番を追いかける - sgykfjsm.github.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:4e4334940cfbd371abfb6e84384d704c:s&#34;&gt;ちなみにこの情報は &lt;code&gt;-s&lt;/code&gt; のリンクオプション（ビルド時に &lt;code&gt;-ldflags &amp;quot;-s&amp;quot;&lt;/code&gt; と指定する）でデバッグ用のシンボル情報を削除しても表示されるようだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4e4334940cfbd371abfb6e84384d704c:s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Struct タグについて — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/struct-tag/" />
		<id>tag:text.Baldanders.info,2016-02-05:/golang/struct-tag/</id>
		<published>2016-02-05T00:11:53+09:00</published>
		<updated>2016-03-26T09:40:17+09:00</updated>
		<summary>Struct で正規化できる情報であれば，タグを使うことでアプリケーション外部とのやり取りがずっと楽になる。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;たとえば &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; で構造化されている情報を特定のファイルやデータベースに出力したり，逆にファイルやデータベースの情報を &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; に流し込みたい場合に &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; の各フィールドに目印になる情報があると便利である。
この目印として機能するのが &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; タグである&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5fa302080eeba16361245078fe0e5ca6:an&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:5fa302080eeba16361245078fe0e5ca6:an&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; タグは以下のように記述する。&lt;/p&gt;

&lt;figure lang=&#34;en&#34;&gt;
&lt;blockquote&gt;
&lt;q&gt;By convention, tag strings are a concatenation of optionally space-separated key:&#34;value&#34; pairs. Each key is a non-empty string consisting of non-control characters other than space (U+0020 &#39; &#39;), quote (U+0022 &#39;&#34;&#39;), and colon (U+003A &#39;:&#39;). Each value is quoted using U+0022 &#39;&#34;&#39; characters and Go string literal syntax.&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;https://golang.org/pkg/reflect/#example_StructTag&#34;&gt;reflect - The Go Programming Language&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Server struct {
	Host      string `elem:&amp;quot;host&amp;quot;`
	IPAddress string `elem:&amp;quot;ip_address&amp;quot;`
	Port      int    `elem:&amp;quot;port&amp;quot;`
	Note      string `elem:&amp;quot;note&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このタグ情報を取得するには &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt; パッケージを使う。
たとえばこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;reflect&amp;quot;
)

type Server struct {
	Host      string `elem:&amp;quot;host&amp;quot;`
	IPAddress string `elem:&amp;quot;ip_address&amp;quot;`
	Port      int    `elem:&amp;quot;port&amp;quot;`
	Note      string `elem:&amp;quot;note&amp;quot;`
}

func main() {
	s := Server{}
	t := reflect.TypeOf(s)
	for i := 0; i &amp;lt; t.NumField(); i++ {
		field := t.Field(i)
		fmt.Printf(&amp;quot;Name=%s , tag(elem)=%s\n&amp;quot;, field.Name, field.Tag.Get(&amp;quot;elem&amp;quot;))
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行するとこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Name=Host , tag(elem)=host
Name=IPAddress , tag(elem)=ip_address
Name=Port , tag(elem)=port
Name=Note , tag(elem)=note
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際には &lt;a href=&#34;https://golang.org/pkg/reflect/&#34; title=&#34;reflect - The Go Programming Language&#34;&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt; を直接使う局面は少なく，既にあるパッケージを利用することが多い。
たとえば &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; による構造化データを &lt;a href=&#34;https://tools.ietf.org/html/rfc7159&#34; title=&#34;RFC 7159 - The JavaScript Object Notation (JSON) Data Interchange Format&#34;&gt;JSON&lt;/a&gt; 形式に出力する &lt;a href=&#34;https://golang.org/pkg/encoding/json/&#34; title=&#34;json - The Go Programming Language&#34;&gt;&lt;code&gt;encoding/json&lt;/code&gt;&lt;/a&gt; パッケージがある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
)

type Server struct {
	Host      string `json:&amp;quot;host&amp;quot;`
	IPAddress string `json:&amp;quot;ip_address&amp;quot;`
	Port      int    `json:&amp;quot;port&amp;quot;`
	Note      string `json:&amp;quot;note&amp;quot;`
}

func main() {
	s := Server{Host: &amp;quot;localhost&amp;quot;, IPAddress: &amp;quot;127.0.0.1&amp;quot;, Port: 8080, Note: &amp;quot;Web Application&amp;quot;}
	j, err := json.MarshalIndent(s, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		return
	}
	fmt.Println(string(j))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行するとこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
  &amp;quot;ip_address&amp;quot;: &amp;quot;127.0.0.1&amp;quot;,
  &amp;quot;port&amp;quot;: 8080,
  &amp;quot;note&amp;quot;: &amp;quot;Web Application&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Server&lt;/code&gt; の内容が &lt;a href=&#34;https://tools.ietf.org/html/rfc7159&#34; title=&#34;RFC 7159 - The JavaScript Object Notation (JSON) Data Interchange Format&#34;&gt;JSON&lt;/a&gt; 形式で出力されているのが分かるだろう。
&lt;a href=&#34;https://tools.ietf.org/html/rfc7159&#34; title=&#34;RFC 7159 - The JavaScript Object Notation (JSON) Data Interchange Format&#34;&gt;JSON&lt;/a&gt; の要素名がタグで指定した名前になっていることを確認してほしい。&lt;/p&gt;

&lt;p&gt;反対もやってみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
)

type Server struct {
	Host      string `json:&amp;quot;host&amp;quot;`
	IPAddress string `json:&amp;quot;ip_address&amp;quot;`
	Port      int    `json:&amp;quot;port&amp;quot;`
	Note      string `json:&amp;quot;note&amp;quot;`
}

func main() {
	svr := []byte(`{
  &amp;quot;host&amp;quot;: &amp;quot;localhost&amp;quot;,
  &amp;quot;ip_address&amp;quot;: &amp;quot;127.0.0.1&amp;quot;,
  &amp;quot;port&amp;quot;: 8080,
  &amp;quot;note&amp;quot;: &amp;quot;Web Application&amp;quot;
}`)
	var s Server
	if err := json.Unmarshal(svr, &amp;amp;s); err != nil {
		return
	}
	fmt.Println(s)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果はこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{localhost 127.0.0.1 8080 Web Application}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;きれいに &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; に値が入っているのが分かると思う。&lt;/p&gt;

&lt;p&gt;ちなみにタグの書式は &lt;code&gt;key:&amp;quot;value&amp;quot;&lt;/code&gt; だが，間違って記述しても単に無視されるだけでコンパイル時も実行時もエラーにならないので注意が必要である。
なおタグ書式の文法ミスについては，静的検査ツールの &lt;a href=&#34;https://golang.org/cmd/vet/&#34; title=&#34;vet - The Go Programming Language&#34;&gt;vet&lt;/a&gt; でチェックできる。&lt;/p&gt;

&lt;p&gt;タグは複数列挙することができる。
たとえばサンプルの構造体を &lt;a href=&#34;https://github.com/toml-lang/toml&#34; title=&#34;toml-lang/toml: Tom&#39;s Obvious, Minimal Language&#34;&gt;TOML&lt;/a&gt; にも対応させたいなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Server struct {
	Host      string `json:&amp;quot;host&amp;quot; toml:&amp;quot;host&amp;quot;`
	IPAddress string `json:&amp;quot;ip_address&amp;quot; toml:&amp;quot;ip_address&amp;quot;`
	Port      int    `json:&amp;quot;port&amp;quot; toml:&amp;quot;port&amp;quot;`
	Note      string `json:&amp;quot;note&amp;quot; toml:&amp;quot;note&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとする（デリミタは空白文字）。
じゃあ，先ほどと同じようにして &lt;a href=&#34;https://github.com/toml-lang/toml&#34; title=&#34;toml-lang/toml: Tom&#39;s Obvious, Minimal Language&#34;&gt;TOML&lt;/a&gt; で出力してみる。
&lt;a href=&#34;https://github.com/toml-lang/toml&#34; title=&#34;toml-lang/toml: Tom&#39;s Obvious, Minimal Language&#34;&gt;TOML&lt;/a&gt; を扱うには &lt;a href=&#34;https://github.com/BurntSushi/toml&#34;&gt;&lt;code&gt;github.com/BurntSushi/toml&lt;/code&gt;&lt;/a&gt; パッケージを使うとよい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/BurntSushi/toml&amp;quot;
)

type Server struct {
	Host      string `json:&amp;quot;host&amp;quot; toml:&amp;quot;host&amp;quot;`
	IPAddress string `json:&amp;quot;ip_address&amp;quot; toml:&amp;quot;ip_address&amp;quot;`
	Port      int    `json:&amp;quot;port&amp;quot; toml:&amp;quot;port&amp;quot;`
	Note      string `json:&amp;quot;note&amp;quot; toml:&amp;quot;note,omitempty&amp;quot;`
}

func main() {
	s := Server{Host: &amp;quot;localhost&amp;quot;, IPAddress: &amp;quot;127.0.0.1&amp;quot;, Port: 8080, Note: &amp;quot;&amp;quot;}
	t := new(bytes.Buffer)
	if err := toml.NewEncoder(t).Encode(s); err != nil {
		return
	}
	fmt.Println(t.String())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;host = &amp;quot;localhost&amp;quot;
ip_address = &amp;quot;127.0.0.1&amp;quot;
port = 8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;omitempty&lt;/code&gt; オプションはフィールドが空（&lt;code&gt;nil&lt;/code&gt; または空文字列）の場合に出力を省略できる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5fa302080eeba16361245078fe0e5ca6:oz&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:5fa302080eeba16361245078fe0e5ca6:oz&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。
このオプションは &lt;a href=&#34;https://golang.org/pkg/encoding/json/&#34; title=&#34;json - The Go Programming Language&#34;&gt;&lt;code&gt;encoding/json&lt;/code&gt;&lt;/a&gt; パッケージでも使える。&lt;/p&gt;

&lt;p&gt;ついでに反対もやってみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/BurntSushi/toml&amp;quot;
)

type Server struct {
	Host      string `json:&amp;quot;host&amp;quot; toml:&amp;quot;host&amp;quot;`
	IPAddress string `json:&amp;quot;ip_address&amp;quot; toml:&amp;quot;ip_address&amp;quot;`
	Port      int    `json:&amp;quot;port&amp;quot; toml:&amp;quot;port&amp;quot;`
	Note      string `json:&amp;quot;note&amp;quot; toml:&amp;quot;note,omitempty&amp;quot;`
}

func main() {
	svr := `
host = &amp;quot;localhost&amp;quot;
ip_address = &amp;quot;127.0.0.1&amp;quot;
port = 8080
note = &amp;quot;Web Application&amp;quot;
`
	var s Server
	if _, err := toml.Decode(svr, &amp;amp;s); err != nil {
		return
	}
	fmt.Println(s)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{localhost 127.0.0.1 8080 Web Application}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34; title=&#34;Struct types&#34;&gt;struct&lt;/a&gt; で正規化できる情報であれば，タグ機能を使うことでアプリケーション外部とのやり取りがだいぶ楽になる。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:5fa302080eeba16361245078fe0e5ca6&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://hiyosi.tumblr.com/post/100922038678/go-%E3%81%A7-struct-%E3%81%AE%E3%82%BF%E3%82%B0%E6%83%85%E5%A0%B1%E3%82%92%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B&#34;&gt;Go で struct のタグ情報を取得する - hiyosi&amp;rsquo;s blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/amanoiverse/items/fcd25db64f341ad2471f&#34;&gt;struct にアノテーションつけてたら go vet . すべき - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.restartr.com/2014/08/13/golang-json-marshal-unmarshal/&#34;&gt;Goのjson.Marshal/Unmarshalの仕様を整理してみる - I Will Survive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/reiki4040/items/6556d4eba797329e9f51&#34;&gt;BurntSushi/tomlを使ってハマったこと - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/hnakamur/items/ba363e82332d4dbdf34a&#34;&gt;GoでJSONの一部分を利用者が定義した構造体に読み込める便利な手法を見つけた - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:5fa302080eeba16361245078fe0e5ca6:an&#34;&gt;「アノテーション（annotation）」と呼ぶ人もいる。たぶん Java の annotation 機能を意識しているんだろう。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5fa302080eeba16361245078fe0e5ca6:an&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:5fa302080eeba16361245078fe0e5ca6:oz&#34;&gt;数値の場合は &lt;code&gt;omitzero&lt;/code&gt; オプションを付けると 0 のときに出力を省略できる。ただし &lt;a href=&#34;https://github.com/BurntSushi/toml&#34;&gt;&lt;code&gt;BurntSushi/toml&lt;/code&gt;&lt;/a&gt; パッケージでは &lt;a href=&#34;http://qiita.com/reiki4040/items/6556d4eba797329e9f51&#34;&gt;&lt;code&gt;Decode()&lt;/code&gt; がうまく動かない&lt;/a&gt;らしい。実は &lt;code&gt;omitempty&lt;/code&gt; オプションも &lt;code&gt;Decode()&lt;/code&gt; 時の挙動が怪しいんだよなぁ。 &lt;a href=&#34;https://github.com/toml-lang/toml&#34; title=&#34;toml-lang/toml: Tom&#39;s Obvious, Minimal Language&#34;&gt;TOML&lt;/a&gt; パーサの別実装としては &lt;a href=&#34;https://github.com/naoina/toml&#34;&gt;naoina/toml&lt;/a&gt; というのもある。これは最新の &lt;a href=&#34;https://github.com/toml-lang/toml&#34; title=&#34;toml-lang/toml: Tom&#39;s Obvious, Minimal Language&#34;&gt;TOML&lt;/a&gt; 仕様に追随しているようだが &lt;code&gt;omitzero&lt;/code&gt; オプションには対応していない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5fa302080eeba16361245078fe0e5ca6:oz&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Go 言語と Unicode 正規化 — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/unicode-normalization/" />
		<id>tag:text.Baldanders.info,2016-01-30:/golang/unicode-normalization/</id>
		<published>2016-01-30T04:05:52+09:00</published>
		<updated>2016-02-18T22:34:57+09:00</updated>
		<summary>今回は少し目先を変えて「Unicode 正規化」のお話。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回は少し目先を変えて「Unicode 正規化（normalization）」のお話。&lt;/p&gt;

&lt;h2 id=&#34;2羽の-ペンギン:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;2羽の「ペンギン」&lt;/h2&gt;

&lt;p&gt;まず「ペンギン」という文字列を思い浮かべてみる。
この文字列を Unicode のコードポイントで表すと以下のようになる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ペ：U+30DA&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;li&gt;ギ：U+30AE&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ところでペンギンの「ペ」と「ギ」は半濁点および濁点を含む。
Unicode は「ペ」と「ギ」をそれぞれ2つの要素に分解できる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ペ：U+30D8 + U+309A&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;li&gt;ギ：U+30AD + U+3099&lt;/li&gt;
&lt;li&gt;ン：U+30F3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;U+309A および U+3099 はそれぞれ半濁点と濁点を表す「結合文字（combining character）」である。
「ヘ」や「キ」のような「基底文字（base character）」に結合文字を1つ以上&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:cs&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:cs&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 付加した文字を「合成列（composite sequence）」と呼ぶ。
これに対して「ペ：U+30DA」や「ギ：U+30AE」のような文字を「事前合成形（precomposed）」と呼ぶ。&lt;/p&gt;

&lt;p&gt;つまり同じ文字を同じ文字集合&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:ccs&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:ccs&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; で表しているのにもかかわらず複数の符号化&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:ecd&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:ecd&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; が存在するわけだ。
これを「重複符号化」と言う。
文字集合に重複符号化があるというのは，はっきり言って「クソ仕様」である。&lt;/p&gt;

&lt;p&gt;もちろんこれは Unicode を作った連中がヘボいのではなく（いや，ヘボいのかもしれないが），いわゆる「歴史的経緯」というやつである&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:jis&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:jis&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。
だからこれはこういうものだと諦めるしかない。&lt;/p&gt;

&lt;p&gt;しかし情報処理を行う上では，この2羽の「ペンギン」が等価（equivalance）であることを示す手立てを考えなければならない。&lt;/p&gt;

&lt;h2 id=&#34;正規等価:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;正規等価&lt;/h2&gt;

&lt;p&gt;2羽の「ペンギン」が等価であることを示す一番簡単な方法は，文字列を事前合成形あるいは合成列のどちらかに統一（＝正規化）してしまえばいい。
これを「正規等価（canonical equivalance）」と呼ぶ。
このうち，事前合成形に正規化する方法を “NFC（Normalization Form Composition）”，合成列に正規化する方法を “NFD（Normalization Form Decomposition）” と呼ぶ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では &lt;code&gt;golang.org/x/text/unicode/&lt;/code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34; title=&#34;norm - GoDoc&#34;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; パッケージで Unicode 文字列を正規化できる。
まぁ，コードで書いたほうがはやいか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	penguin := &amp;quot;ペンギン&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFD.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin3 := string(norm.NFC.Bytes([]byte(penguin2)))
	for pos, runeValue := range penguin3 {
		fmt.Printf(&amp;quot;penguin3[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+30DA &#39;ペ&#39;
penguin[3] = U+30F3 &#39;ン&#39;
penguin[6] = U+30AE &#39;ギ&#39;
penguin[9] = U+30F3 &#39;ン&#39;
penguin2[0] = U+30D8 &#39;ヘ&#39;
penguin2[3] = U+309A &#39;゚&#39;
penguin2[6] = U+30F3 &#39;ン&#39;
penguin2[9] = U+30AD &#39;キ&#39;
penguin2[12] = U+3099 &#39;゙&#39;
penguin2[15] = U+30F3 &#39;ン&#39;
penguin3[0] = U+30DA &#39;ペ&#39;
penguin3[3] = U+30F3 &#39;ン&#39;
penguin3[6] = U+30AE &#39;ギ&#39;
penguin3[9] = U+30F3 &#39;ン&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NFC と NFD が交換可能であることがわかると思う。&lt;/p&gt;

&lt;h2 id=&#34;3羽目の-ペンギン-と互換等価:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;3羽目の「ペンギン」と互換等価&lt;/h2&gt;

&lt;p&gt;さてここで3羽目の「ﾍﾟﾝｷﾞﾝ」に登場してもらおう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ﾍ：U+FF8D&lt;/li&gt;
&lt;li&gt;ﾟ：U+FF9F&lt;/li&gt;
&lt;li&gt;ﾝ：U+FF9D&lt;/li&gt;
&lt;li&gt;ｷ：U+FF77&lt;/li&gt;
&lt;li&gt;ﾞ：U+FF9E&lt;/li&gt;
&lt;li&gt;ﾝ：U+FF9D&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これはいわゆる「半角カナ」である。
半角カナの半濁点 U+FF9F および濁点 U+FF9E は結合文字の半濁点 U+309A および濁点 U+3099 と同等とみなされているが「ペ」や「ギ」に相当する半角カナの事前合成形は存在しないため NFC で事前合成形に正規化しようとしても&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	penguin := &amp;quot;ﾍﾟﾝｷﾞﾝ&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFC.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+FF8D &#39;ﾍ&#39;
penguin[3] = U+FF9F &#39;ﾟ&#39;
penguin[6] = U+FF9D &#39;ﾝ&#39;
penguin[9] = U+FF77 &#39;ｷ&#39;
penguin[12] = U+FF9E &#39;ﾞ&#39;
penguin[15] = U+FF9D &#39;ﾝ&#39;
penguin2[0] = U+FF8D &#39;ﾍ&#39;
penguin2[3] = U+FF9F &#39;ﾟ&#39;
penguin2[6] = U+FF9D &#39;ﾝ&#39;
penguin2[9] = U+FF77 &#39;ｷ&#39;
penguin2[12] = U+FF9E &#39;ﾞ&#39;
penguin2[15] = U+FF9D &#39;ﾝ&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何も変わらないことが分かるだろう。
そもそも半角カナは「互換用文字（Compatibility Character）」として異なるコードポイントが割り当てられているため，このままでは3羽目の「ﾍﾟﾝｷﾞﾝ」が等価であることを示せない。&lt;/p&gt;

&lt;p&gt;このような場合は「ﾍﾟﾝｷﾞﾝ」と互換性のある別の文字列に正規化できるとよい。
これを「互換等価（compatibility equivalance）」と呼ぶ。
具体的には，事前合成形に正規化する NFKC（Normalization Form Compatibility Composition）と合成列に正規化する NFKD（Normalization Form Compatibility Decomposition）の2つがある。&lt;/p&gt;

&lt;p&gt;早速 &lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34; title=&#34;norm - GoDoc&#34;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; パッケージを使ってコードを書いてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	penguin := &amp;quot;ﾍﾟﾝｷﾞﾝ&amp;quot;
	for pos, runeValue := range penguin {
		fmt.Printf(&amp;quot;penguin[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	penguin2 := string(norm.NFKC.Bytes([]byte(penguin)))
	for pos, runeValue := range penguin2 {
		fmt.Printf(&amp;quot;penguin2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;penguin[0] = U+FF8D &#39;ﾍ&#39;
penguin[3] = U+FF9F &#39;ﾟ&#39;
penguin[6] = U+FF9D &#39;ﾝ&#39;
penguin[9] = U+FF77 &#39;ｷ&#39;
penguin[12] = U+FF9E &#39;ﾞ&#39;
penguin[15] = U+FF9D &#39;ﾝ&#39;
penguin2[0] = U+30DA &#39;ペ&#39;
penguin2[3] = U+30F3 &#39;ン&#39;
penguin2[6] = U+30AE &#39;ギ&#39;
penguin2[9] = U+30F3 &#39;ン&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり， NFC で正規化した「ペンギン」と等価であることがわかる。&lt;/p&gt;

&lt;p&gt;互換等価による正規化は応用範囲が広い。
たとえば「㈱」（U+3231）は「(株)」（U+0028 + U+682A + U+0029）に変換される。
文字列検索の前に互換等価による正規化を行っておくことで処理がやりやすくなるというのはあるかもしれない。
ただし， NFC と NFD は交換可能だが（ただしオリジナル文字列が事前合成形と合成列とで混在している場合は元に戻せないが）， NFKC や NFKD で正規化した文字列を元に戻す方法はないので注意が必要である&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:hw&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:hw&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;恐怖の-cjk-互換文字:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;恐怖の CJK 互換文字&lt;/h2&gt;

&lt;p&gt;正規等価については注意すべき点がある。
有名な「神」を例に挙げよう。
これを NFC / NFD で正規化する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/text/unicode/norm&amp;quot;
)

func main() {
	god := &amp;quot;神&amp;quot;
	for pos, runeValue := range god {
		fmt.Printf(&amp;quot;god[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	god2 := string(norm.NFC.Bytes([]byte(god)))
	for pos, runeValue := range god2 {
		fmt.Printf(&amp;quot;god2[%d] = %#U\n&amp;quot;, pos, runeValue)
	}

	god3 := string(norm.NFD.Bytes([]byte(god)))
	for pos, runeValue := range god3 {
		fmt.Printf(&amp;quot;god3[%d] = %#U\n&amp;quot;, pos, runeValue)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;god[0] = U+FA19 &#39;神&#39;
god2[0] = U+795E &#39;神&#39;
god3[0] = U+795E &#39;神&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり，NFC でも NFD でも違う文字になってしまった。
ちなみに「神」から「神」へ正規化する方法はない。
困ったね。&lt;/p&gt;

&lt;p&gt;実は「神」は「CJK 互換文字」と呼ばれるグループに属し，「神」とは異体字の関係にある。
故に「神」を「神」に正規化してしまったのである。&lt;/p&gt;

&lt;p&gt;これは明らかに仕様ミスである。
「神」と「神」のような異体字の関係は本来なら正規等価ではなく互換等価であるべきだからだ。&lt;/p&gt;

&lt;p&gt;&amp;hellip;やっぱり Unicode はクソ仕様だ。&lt;/p&gt;

&lt;p&gt;ただ，これが実際の場面で問題になることは少ないと思われる。
なぜなら，正規化を行うのは「2つの文字列が等価であるか？」を調べるための手段にすぎないからだ。
普通はね。&lt;/p&gt;

&lt;p&gt;ところが，普通でないことをする馬鹿がいるのである。&lt;/p&gt;

&lt;h3 id=&#34;独自路線に走る-apple:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;独自路線に走る Apple&lt;/h3&gt;

&lt;p&gt;Apple の OS X （iOS も？）のファイルシステムである HFS+ はファイル名を NFD 相当に正規化するという恐ろしい仕様になっている&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:fs&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:fs&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。
しかしそれでは先ほどの例のように異体字を別の文字に変えられてしまうため困ったことになってしまう。&lt;/p&gt;

&lt;p&gt;そこで Apple は CJK 互換文字を含むいくつかの文字を正規化の対象から外すという蛮行に出た。
俗に “NFD-mac” などと呼ばれる独自路線に走ってしまったわけだ。
クソの上塗りである。&lt;/p&gt;

&lt;p&gt;これにより様々な（特にマルチプラットフォームな）アプリケーションが多大なる迷惑を被ることになるが&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:751a772bc6e9a12c63d6df9ab1f95927:mac&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:751a772bc6e9a12c63d6df9ab1f95927:mac&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;，深くはツッコむまい。&lt;/p&gt;

&lt;h2 id=&#34;unicode-正規化に関するまとめ:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;Unicode 正規化に関するまとめ&lt;/h2&gt;

&lt;p&gt;以上， Unicode 正規化の4つの方式をまとめると以下のようになる。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;Composing&lt;/th&gt;
    &lt;th&gt;Decomposing&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th style=&#34;text-align:right;&#34;&gt;Canonical equivalence&lt;/th&gt;
    &lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34;&gt;norm&lt;/a&gt;.NFC&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34;&gt;norm&lt;/a&gt;.NFD&lt;/code&gt;&lt;br&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th style=&#34;text-align:right;&#34;&gt;Compatibility equivalence&lt;/th&gt;
    &lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34;&gt;norm&lt;/a&gt;.NFKC&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34;&gt;norm&lt;/a&gt;.NFKD&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;figcaption&gt;&lt;a href=&#34;https://blog.golang.org/normalization&#34;&gt;via “Text normalization in Go”&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;https://godoc.org/golang.org/x/text/unicode/norm&#34; title=&#34;norm - GoDoc&#34;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; パッケージでは “NFD-mac” なるローカル仕様には対応していないので，必要なら自作する必要がある。&lt;/p&gt;

&lt;p&gt;Unicode 文字列の等価属性を調べる際には是非参考にどうぞ。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:751a772bc6e9a12c63d6df9ab1f95927&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://internet.watch.impress.co.jp/www/column/ogata/sp24.htm&#34;&gt;特別編24 JIS X 0213の改正は、文字コードにどんな未来をもたらすか（7）　番外編：改正JIS X 0213とUnicodeの等価属性／正規化について（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://internet.watch.impress.co.jp/www/column/ogata/sp25.htm&#34;&gt;特別編24 JIS X 0213の改正は、文字コードにどんな未来をもたらすか（7）　番外編：改正JIS X 0213とUnicodeの等価属性／正規化について（下）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nomenclator.la.coocan.jp/unicode/normalization.htm&#34;&gt;Unicode正規化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/normalization&#34;&gt;Text normalization in Go - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/masakielastic/items/01a4fb691c572dd71a19&#34;&gt;Go で UTF-8 の文字列を扱う - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tech.albert2005.co.jp/blog/2014/11/21/mco-normalize/&#34;&gt;文字コード地獄秘話 第3話：後戻りの効かないUnicode正規化 - ALBERT Engineer Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cpplover.blogspot.jp/2015/01/blog-post_14.html&#34;&gt;本の虫: Linus Torvalds、HFS+に激怒&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:cs&#34;&gt;結合文字はひとつの基底文字に対して複数付加される場合もある。しかもこの場合に結合文字同士の順序は不定である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:cs&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:ccs&#34;&gt;正しくは「符号化文字集合（coded character set）」である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:ccs&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:ecd&#34;&gt;これは UTF-8 などの「文字エンコーディング」とは異なるものだ。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:ecd&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:jis&#34;&gt;日本の JIS 規格にも「歴史的経緯」による重複符号化がある。言わずと知れた「半角」「全角」文字である。異体字も一種の重複符号化と言える。もちろんこれは日本語圏だけの問題ではなく，大抵の言語圏は似たような重複符号化の問題を抱えている。そして Unicode はそうした仕様上の欠陥も含めて併呑してしてしまっているため，このような有様になっているわけだ。問題を先送りして更に酷いことになるという失敗例の典型ですな。この辺の「歴史的経緯」の一部については大昔に拙文「&lt;span&gt;&lt;a href=&#34;http://www.baldanders.info/spiegel/archive/charset-pdfa.pdf&#34;&gt;文字コードとその実装&lt;sup&gt;&lt;i class=&#34;fa fa-file-pdf-o&#34;&gt;&lt;/i&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;」で言及しているので参考にどうぞ。古すぎて一部使えない記述もあるけど。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:jis&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:hw&#34;&gt;単に全角・半角変換ができればいいのなら &lt;code&gt;golang.org/x/text/&lt;/code&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/text/width&#34; title=&#34;width - GoDoc&#34;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; パッケージをお勧めする。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:hw&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:fs&#34;&gt;ちなみに Windows のファイルシステムはフォルダ・ファイルの名前を正規化するとかいうアホなことはしない。事前合成形も合成列も受け入れる。見かけ同じ名前のフォルダ・ファイルが複数できる可能性はあるが，それはそれ。多分，ほとんどの OS のファイルシステムは名前の正規化なんてしてないはず。この HFS+ による Unicode 正規化のおかげで他プラットフォームはかなりの迷惑を被ることになる。たとえば複数のプラットフォームをまたぐファイル交換（例えば Linux → OS X → Windows みたいな経路）を行った場合に OS X を経由した途端にフォルダ・ファイル名を書き換えられてしまうのだ。しかもユーザやアプリケーションは基本的に干渉できない。迷惑千万な話である。もっとも Windows ユーザは Windows ファイルシステムのダメさ加減が身に沁みてるので他所を嗤えないけど（笑）
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:fs&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:751a772bc6e9a12c63d6df9ab1f95927:mac&#34;&gt;たとえば Linus Torvalds は HFS+ に起因する git の脆弱性問題で&lt;a href=&#34;http://cpplover.blogspot.jp/2015/01/blog-post_14.html&#34;&gt;激怒&lt;/a&gt;している。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:751a772bc6e9a12c63d6df9ab1f95927:mac&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>Go 言語の日付処理 — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/time-functions/" />
		<id>tag:text.Baldanders.info,2016-01-22:/golang/time-functions/</id>
		<published>2016-01-22T20:56:21+09:00</published>
		<updated>2016-05-21T10:27:41+09:00</updated>
		<summary>今回は日付処理の話。特にフォーマットの定義の仕方はよく忘れるので覚え書きとして記しておく。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回は日付処理の話。
特にフォーマットの定義の仕方はよく忘れるので覚え書きとして記しておく。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で日付処理を行うには &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; パッケージを使う。
よく使う型としては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Time&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Duration&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Location&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が挙げられるだろう。
&lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Time&lt;/code&gt; は時刻を， &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Duration&lt;/code&gt; は2時点間の時間を，そして &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Location&lt;/code&gt; は地球上の時差を表す型である。
たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	tz, err := time.LoadLocation(&amp;quot;Asia/Tokyo&amp;quot;)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	tm := time.Date(2006, 1, 2, 15, 4, 5, 0, tz)
	fmt.Println(tm)
	now := time.Now()
	fmt.Println(now)
	d := now.Sub(tm)
	fmt.Println(d)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書くと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2006-01-02 15:04:05 +0900 JST
2009-11-10 23:00:00 +0000 UTC
33808h55m55s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;てな感じになる&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:c11a81a4a42bf05b71b8320d533680a9:m&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:c11a81a4a42bf05b71b8320d533680a9:m&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;時刻を任意のフォーマットで表示する場合は少し特殊な方法を使う。
たとえば &lt;a href=&#34;https://tools.ietf.org/html/rfc3339&#34;&gt;RFC 3339&lt;/a&gt; フォーマットに出力するなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	tz, err := time.LoadLocation(&amp;quot;Asia/Tokyo&amp;quot;)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	tm := time.Date(2015, 12, 31, 23, 59, 59, 0, tz)
	fmt.Println(tm.Format(&amp;quot;2006-01-02T15:04:05Z07:00&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-12-31T23:59:59+09:00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と出力される。
テンプレート文字列が &lt;code&gt;%Y&lt;/code&gt; とか &lt;code&gt;YYYY&lt;/code&gt; のような形式ではないのだ。
これは適当な文字列ではなく一応法則があって&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;月は &lt;code&gt;1&lt;/code&gt; （または &lt;code&gt;01&lt;/code&gt;, &lt;code&gt;Jan&lt;/code&gt;, &lt;code&gt;January&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;日は &lt;code&gt;2&lt;/code&gt; （または &lt;code&gt;02&lt;/code&gt;, &lt;code&gt;_2&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;時は &lt;code&gt;3&lt;/code&gt; （または &lt;code&gt;03&lt;/code&gt;, &lt;code&gt;15&lt;/code&gt;） ※ 午後3時を指す&lt;/li&gt;
&lt;li&gt;分は &lt;code&gt;4&lt;/code&gt; （または &lt;code&gt;04&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;秒は &lt;code&gt;5&lt;/code&gt; （または &lt;code&gt;05&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;年は &lt;code&gt;06&lt;/code&gt; （または &lt;code&gt;2006&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;時差は &lt;code&gt;-07&lt;/code&gt; （または &lt;code&gt;-0700&lt;/code&gt;, &lt;code&gt;-07:00&lt;/code&gt;, &lt;code&gt;Z07:00&lt;/code&gt;, &lt;code&gt;MST&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:c11a81a4a42bf05b71b8320d533680a9:tz&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:c11a81a4a42bf05b71b8320d533680a9:tz&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; など）&lt;/li&gt;
&lt;li&gt;曜日は &lt;code&gt;Mon&lt;/code&gt; （または &lt;code&gt;Monday&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;AM/PM は &lt;code&gt;PM&lt;/code&gt; （または &lt;code&gt;pm&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という感じに 1 からの連番になっている（曜日等は例外だけど）ので，まぁ覚えられるかな？ でもよく忘れるんだよなぁ。
&lt;code&gt;%Y&lt;/code&gt; みたいなのとどちらがいいかは微妙な気がするが，慣れの問題かもしれない。&lt;/p&gt;

&lt;p&gt;典型的なフォーマットは定数化されている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
	ANSIC       = &amp;quot;Mon Jan _2 15:04:05 2006&amp;quot;
	UnixDate    = &amp;quot;Mon Jan _2 15:04:05 MST 2006&amp;quot;
	RubyDate    = &amp;quot;Mon Jan 02 15:04:05 -0700 2006&amp;quot;
	RFC822      = &amp;quot;02 Jan 06 15:04 MST&amp;quot;
	RFC822Z     = &amp;quot;02 Jan 06 15:04 -0700&amp;quot; // RFC822 with numeric zone
	RFC850      = &amp;quot;Monday, 02-Jan-06 15:04:05 MST&amp;quot;
	RFC1123     = &amp;quot;Mon, 02 Jan 2006 15:04:05 MST&amp;quot;
	RFC1123Z    = &amp;quot;Mon, 02 Jan 2006 15:04:05 -0700&amp;quot; // RFC1123 with numeric zone
	RFC3339     = &amp;quot;2006-01-02T15:04:05Z07:00&amp;quot;
	RFC3339Nano = &amp;quot;2006-01-02T15:04:05.999999999Z07:00&amp;quot;
	Kitchen     = &amp;quot;3:04PM&amp;quot;
	// Handy time stamps.
	Stamp      = &amp;quot;Jan _2 15:04:05&amp;quot;
	StampMilli = &amp;quot;Jan _2 15:04:05.000&amp;quot;
	StampMicro = &amp;quot;Jan _2 15:04:05.000000&amp;quot;
	StampNano  = &amp;quot;Jan _2 15:04:05.000000000&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なので，先ほどのコードも出力部分を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(tm.Format(time.RFC3339))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば同じ結果が得られる。
時刻フォーマットは，いったんシステムの中で決めてしまえば同じものを使い回すことになると思うので，定数化してしまえば「フォーマットどうだっけ？」と煩わされることも少ないだろう。&lt;/p&gt;

&lt;p&gt;ところでバージョン 1.5 系の &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Parse()&lt;/code&gt; 関数は日付の解釈が寛容で，各月の末日を31日まで許容している。
たとえば閏年でない2月29日でも&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	tm, err := time.Parse(time.RFC3339, &amp;quot;2015-02-29T23:59:59+09:00&amp;quot;)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	fmt.Println(tm)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;2015-03-01 23:59:59 +0900 +0900
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となり，エラーとならずいい感じ（？）に加減してくれるのだが，バージョン 1.6 からは少し解釈が厳密になりエラーを返すようだ。&lt;/p&gt;

&lt;figure lang=&#34;en&#34;&gt;
&lt;blockquote&gt;
&lt;q&gt;The &lt;a href=&#34;https://tip.golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; package&#39;s &lt;a href=&#34;https://tip.golang.org/pkg/time/#Parse&#34;&gt;&lt;code&gt;Parse&lt;/code&gt;&lt;/a&gt; function has always rejected any day of month larger than 31, such as January 32. In Go 1.6, Parse now also rejects February 29 in non-leap years, February 30, February 31, April 31, June 31, September 31, and November 31.&lt;/q&gt;
&lt;/blockquote&gt;
&lt;figcaption&gt;via &lt;q&gt;&lt;a href=&#34;https://tip.golang.org/doc/go1.6&#34;&gt;Go 1.6 Release Notes - The Go Programming Language&lt;/a&gt;&lt;/q&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;実際に 1.6 で上のコードを実行すると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;parsing time &amp;quot;2015-02-29T23:59:59+09:00&amp;quot;: day out of range
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とエラーが返ってくる。&lt;/p&gt;

&lt;p&gt;ちなみに &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Date()&lt;/code&gt; 関数は更に寛容である。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	tz, err := time.LoadLocation(&amp;quot;Asia/Tokyo&amp;quot;)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	tm := time.Date(2015, 13, 32, 25, 60, 00, 0, tz)
	fmt.Println(tm)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;2016-02-02 02:00:00 +0900 JST
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ブックマーク:c11a81a4a42bf05b71b8320d533680a9&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ymotongpoo.hatenablog.com/entry/2015/12/22/000011&#34;&gt;Goで良い感じに日時をパースするライブラリdatemakiの話とGo 1.6 - YAMAGUCHI::weblog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/ushio_s/items/3e270933641710bbd88e&#34;&gt;golangのtime.Timeの当日00:00:00を取得する方法とベンチマーク - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/masa23/items/e781124a7e0305bc40c4&#34;&gt;Golang 日付のフォーマットでハマった話 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:c11a81a4a42bf05b71b8320d533680a9:m&#34;&gt;厳密にいうと月の値は &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Month&lt;/code&gt; 型である。サンプル・コードのようにリテラルな数値なら気にする必要はないが，変数を &lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Date()&lt;/code&gt; 関数にセットする場合は注意が必要である。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:c11a81a4a42bf05b71b8320d533680a9:m&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:c11a81a4a42bf05b71b8320d533680a9:tz&#34;&gt;時差の MST は米国の山岳部時間（Mountain Standad Time）を指すらしい。ソルトレイクシティとかデンバーとかかな。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:c11a81a4a42bf05b71b8320d533680a9:tz&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>再帰呼び出しと関数テーブル — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/recursive-call-and-function-table/" />
		<id>tag:text.Baldanders.info,2016-01-18:/golang/recursive-call-and-function-table/</id>
		<published>2016-01-18T22:59:07+09:00</published>
		<updated>2016-01-19T21:50:44+09:00</updated>
		<summary>今回は再帰呼び出しの話。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;今回は再帰呼び出しの話。&lt;/p&gt;

&lt;p&gt;再帰呼び出しのサンプルとして典型的なのは&lt;a href=&#34;https://en.wikipedia.org/wiki/Fibonacci_number&#34; title=&#34;Fibonacci number - Wikipedia, the free encyclopedia&#34;&gt;フィボナッチ数&lt;/a&gt;かな。
&lt;a href=&#34;https://en.wikipedia.org/wiki/Fibonacci_number&#34; title=&#34;Fibonacci number - Wikipedia, the free encyclopedia&#34;&gt;フィボナッチ数&lt;/a&gt;の定義を愚直にコードにするとこんな感じになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func fibonacciNumber(n int) int {
	switch n {
	case 0:
		return 0
	case 1:
		return 1
	default:
		return fibonacciNumber(n-2) + fibonacciNumber(n-1)
	}
}

type ff func(int) int

var fib = fibonacciNumber

func main() {
	fmt.Println(fibonacciNumber(40))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般に手続き型言語は再帰呼び出しに弱いと言われている（関数型のほうが有利）。
特に &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の場合は &lt;a href=&#34;http://golang.org/ref/spec#Go_statements&#34;&gt;goroutine&lt;/a&gt; に最適化を割り振っている関係で，関数呼び出しやその戻り&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:90181bd94c22568ae136c2a2c4e81a10:r&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:90181bd94c22568ae136c2a2c4e81a10:r&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; のパフォーマンスが冷遇されているようだ。
したがって，再帰呼び出し部分のパフォーマンスを改善したければ，なるべく呼び出し回数を減らすようにするのがコツである。
たとえば上の&lt;a href=&#34;https://en.wikipedia.org/wiki/Fibonacci_number&#34; title=&#34;Fibonacci number - Wikipedia, the free encyclopedia&#34;&gt;フィボナッチ数&lt;/a&gt;の場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

var fibonacciNumbers = make(map[int]int)

func fibonacciNumber(n int) int {
	switch n {
	case 0:
		return 0
	case 1:
		return 1
	default:
		if fn, ok := fibonacciNumbers[n]; ok {
			return fn
		}
		fn := fibonacciNumber(n-2) + fibonacciNumber(n-1)
		fibonacciNumbers[n] = fn
		return fn
	}
}

func main() {
	fmt.Println(fibonacciNumber(40))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じに計算結果を保持っておくことでかなり改善する。&lt;/p&gt;

&lt;p&gt;ところで，再帰呼び出しで怖いのが無限呼び出しに陥るパターンである。
&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では関数値（function value）を介す場合であれば再帰呼び出しを禁止する。&lt;/p&gt;

&lt;p&gt;たとえば先ほどのコードを以下のように書き換えてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

var fibonacciNumbers = make(map[int]int)

func fibonacciNumber(n int) int {
	switch n {
	case 0:
		return 0
	case 1:
		return 1
	default:
		if fn, ok := fibonacciNumbers[n]; ok {
			return fn
		}
		fn := fib(n-2) + fib(n-1)
		fibonacciNumbers[n] = fn
		return fn
	}
}

type ff func(int) int

var fib ff = fibonacciNumber

func main() {
	fmt.Println(fib(40))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fibonacciNumber()&lt;/code&gt; を &lt;code&gt;fib()&lt;/code&gt; で別名定義しているだけだが，これを実行しようとすると以下のコンパイルエラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prog.go:25: initialization loop:
	prog.go:25 fib refers to
	prog.go:7 fibonacciNumber refers to
	prog.go:25 fib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数値 &lt;code&gt;fib&lt;/code&gt; の部分でエラーになっている点に注目してほしい。&lt;/p&gt;

&lt;p&gt;本当に「ついうっかり」再帰呼び出しになってしまう場合はエラーではじいてもらってありがたいのだが，そうでない場合もある。
あまり例示がうまくなくて申し訳ないのだが，以下の簡単なステート・マシンを考えてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func f0(evt int) int {
	fmt.Println(&amp;quot;processing f0&amp;quot;)
	return 1
}

func f1(evt int) int {
	fmt.Println(&amp;quot;processing f1&amp;quot;)
	return 2
}

func f2(evt int) int {
	fmt.Println(&amp;quot;processing f2&amp;quot;)
	return 3
}

func f3(evt int) int {
	fmt.Println(&amp;quot;processing f3&amp;quot;)
	return 0
}

type fn func(int) int

var fs = []fn{
	f0,
	f1,
	f2,
	f3,
}

func StateMachin(stat, evt int) int {
	return fs[stat](evt)
}

func main() {
	s := 0
	for e := 0; e &amp;lt; 10; e++ {
		s = StateMachin(s, e)
		if s == 0 {
			break
		}
	}
	fmt.Println(&amp;quot;end&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fs&lt;/code&gt; が関数テーブルになっていて，状態 &lt;code&gt;s&lt;/code&gt; とイベント &lt;code&gt;e&lt;/code&gt; に対する処理 &lt;code&gt;fs[s](e)&lt;/code&gt; を呼び出して処理後の状態を返してもらう。
一応 &lt;code&gt;StateMachine()&lt;/code&gt; 関数で詳細を隠蔽しているつもりである&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:90181bd94c22568ae136c2a2c4e81a10:b&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:90181bd94c22568ae136c2a2c4e81a10:b&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;ここで &lt;code&gt;StateMachine(3, evt)&lt;/code&gt; の処理に続けて &lt;code&gt;StateMachine(1, evt)&lt;/code&gt; の処理がしたくなり&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func f3(evt int) int {
    fmt.Println(&amp;quot;processing f3&amp;quot;)
    return StateMachin(1, evt)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと書いたらどうなるか。
もちろんこれもコンパイルエラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prog.go:32: initialization loop:
	prog.go:32 fs refers to
	prog.go:20 f3 refers to
	prog.go:34 StateMachin refers to
	prog.go:32 fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし実際には &lt;code&gt;f3&lt;/code&gt; を無限に呼び出しているわけではないので，このコンパイルエラーでは困ってしまう&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:90181bd94c22568ae136c2a2c4e81a10:a&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:90181bd94c22568ae136c2a2c4e81a10:a&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
このエラーを回避するには関数テーブル &lt;code&gt;fs&lt;/code&gt; を介さなければよい。
たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fs = []fn{
	f0,
	f1,
	f2,
	//f3,
}

func StateMachin(stat, evt int) int {
	if stat == 3 {
		return f3(evt)
	}
	return fs[stat](evt)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば，めでたく &lt;code&gt;f1&lt;/code&gt; → &lt;code&gt;f2&lt;/code&gt; → &lt;code&gt;f3&lt;/code&gt; → &lt;code&gt;f1&lt;/code&gt; とエンドレスにつながる。
ちなみにここでうっかり&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func f3(evt int) int {
	fmt.Println(&amp;quot;processing f3&amp;quot;)
	return StateMachin(3, evt)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと書くと，コンパイルエラーにもならず無限呼び出しが発生する。&lt;/p&gt;

&lt;p&gt;再帰呼び出しは計画的に。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:90181bd94c22568ae136c2a2c4e81a10&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ymotongpoo.hatenablog.com/entry/2015/02/23/165341&#34;&gt;Goで再帰使うと遅くなりますがそれが何だ - YAMAGUCHI::weblog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/zetamatta/items/cc0f29441b16d63472ed&#34;&gt;.\hoge.go:7: initialization loop - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:90181bd94c22568ae136c2a2c4e81a10:r&#34;&gt;再帰呼び出しが「末尾呼び出し（tail call）」の場合は，戻りの最適化でパフォーマンスの向上が期待できるが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;のコンパイラはこの辺の最適化も行っていないらしい。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:90181bd94c22568ae136c2a2c4e81a10:r&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:90181bd94c22568ae136c2a2c4e81a10:b&#34;&gt;実際には別パッケージにしてちゃんとクラス設計すべきだろうけど色々端折っている。ゴメンペコン。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:90181bd94c22568ae136c2a2c4e81a10:b&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:90181bd94c22568ae136c2a2c4e81a10:a&#34;&gt;このコードに限れば &lt;code&gt;StateMachine(1, evt)&lt;/code&gt; ではなく &lt;code&gt;f1(evt)&lt;/code&gt; を呼び出せば済む話なのでこれは言いがかりであるが，「話の都合」ということで軽く流していただけるとありがたい。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:90181bd94c22568ae136c2a2c4e81a10:a&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
	<entry>
		<title>コマンドライン・インタフェースとファサード・パターン — プログラミング言語 Go</title>
		<link rel="alternate" type="text/html" href="http://text.baldanders.info/golang/cli-and-facade-pattern/" />
		<id>tag:text.Baldanders.info,2016-01-05:/golang/cli-and-facade-pattern/</id>
		<published>2016-01-05T22:06:41+09:00</published>
		<updated>2016-05-07T09:33:19+09:00</updated>
		<summary>ファサード・パターンは DDD (Domain-Driven Design) と相性がよい。普通は Web アプリケーションのような多様なサブシステムを持つシステムを設計する際に導入する考え方だが， CLI の場合でもサブコマンドを構成するのであればファサード・パターンがよいだろう。</summary>
		
			<author>
				<name>Spiegel</name>
				<uri>http://www.baldanders.info/spiegel/profile/</uri>
			</author>
			
	<link rel="cc:license" type="application/rdf+xml" href="http://creativecommons.org/licenses/by-sa/4.0/rdf" />


		
		<category term="golang" label="golang" scheme="http://text.baldanders.info/golang" />
		<content type="html" xml:lang="ja" xml:base="http://text.baldanders.info/">

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;コンパイラには &lt;a href=&#34;https://golang.org/pkg/flag/&#34; title=&#34;flag - The Go Programming Language&#34;&gt;&lt;code&gt;flag&lt;/code&gt;&lt;/a&gt; パッケージが標準で提供されており，いわゆるコマンドライン・インタフェース（Command line interface; CLI）の操作はこれでまかなうことができる。
ただし &lt;a href=&#34;https://golang.org/pkg/flag/&#34; title=&#34;flag - The Go Programming Language&#34;&gt;&lt;code&gt;flag&lt;/code&gt;&lt;/a&gt; パッケージではサブコマンドをサポートしていないためサブコマンドを構成したい場合は少し工夫が必要となる。
ちなみにサブコマンドとは，以下のようなコマンドラインの構成になっているアプリケーションである。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ command [golabal options] &amp;lt;sub-command&amp;gt; [sub-options] [arguments]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;たとえば &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;コンパイラの &lt;code&gt;go run&lt;/code&gt; もサブコマンドだし， &lt;a href=&#34;https://git-scm.com/&#34; title=&#34;Git&#34;&gt;git&lt;/a&gt; の &lt;code&gt;git commit&lt;/code&gt; とかもサブコマンドである。&lt;/p&gt;

&lt;h2 id=&#34;コマンドライン-インタフェースと-unix-philosophy:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;コマンドライン・インタフェースと UNIX Philosophy&lt;/h2&gt;

&lt;p&gt;ところで CLI でよく引き合いに出されるのが “&lt;a href=&#34;http://www.ru.j-npcs.org/usoft/WWW/LJ/Articles/unixtenets.html&#34; title=&#34;Tenets of the UNIX Philosophy&#34;&gt;UNIX Philosophy&lt;/a&gt;” と呼ばれるアプリケーションを作る際の哲学というか指針のようなものである。
曰く&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Small is beautiful. （小さいものは美しい）&lt;/li&gt;
&lt;li&gt;Make each program do one thing well. （各プログラムが一つのことをうまくやるようにせよ）&lt;/li&gt;
&lt;li&gt;Build a prototype as soon as possible. （できる限り早くプロトタイプを作れ）&lt;/li&gt;
&lt;li&gt;Choose portability over efficiency. （効率よりも移植しやすさを選べ）&lt;/li&gt;
&lt;li&gt;Store data in flat text files. （単純なテキストファイルにデータを格納せよ）&lt;/li&gt;
&lt;li&gt;Use software leverage to your advantage. （ソフトウェアの効率を優位さとして利用せよ）&lt;/li&gt;
&lt;li&gt;Use shell scripts to increase leverage and portability. （効率と移植性を高めるためにシェルスクリプトを利用せよ）&lt;/li&gt;
&lt;li&gt;Avoid captive user interfaces. （拘束的なユーザーインターフェースは作るな）&lt;/li&gt;
&lt;li&gt;Make every program a Filter. （全てのプログラムはフィルタとして振る舞うようにせよ）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;の9項目&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:up&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:up&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
昨今は UNIX 互換環境でも GUI が普通になってきたので対話型のインタフェースも増えてきたが，それでも従来の CUI shell 上で動作するアプリケーションの需要が減ったわけではなく，サーバサイドではむしろ需要は大きくなっていると言ってもいい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;で CLI アプリケーションを作る際に気をつける点としては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;他のツールと shell を介して連携できるよう標準入出力を使ったフィルタプログラムとする&lt;/li&gt;
&lt;li&gt;外部データの入出力は JSON, YAML, TOML といったテキストを用い UTF-8 文字エンコーディングに統一する&lt;/li&gt;
&lt;li&gt;コードの可搬性（または移植性）を考慮し，プラットフォーム依存を避けるようにする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といったところだろうか。
もともと &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;はクロスプラットフォーム開発に強いため，それほど難しい要件ではないはずである。&lt;/p&gt;

&lt;h2 id=&#34;サブコマンドとファサード-パターン:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;サブコマンドとファサード・パターン&lt;/h2&gt;

&lt;p&gt;サブコマンド方式は一見 “&lt;a href=&#34;http://www.ru.j-npcs.org/usoft/WWW/LJ/Articles/unixtenets.html&#34; title=&#34;Tenets of the UNIX Philosophy&#34;&gt;UNIX Philosophy&lt;/a&gt;” に反しているように見えるが， &lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;の場合は全てのパッケージをひとつの実行モジュールに結合してしまうため，関連する機能をサブコマンドとして組み込むのは悪くないやりかたである。&lt;/p&gt;

&lt;p&gt;サブコマンドを構成する場合は「ファサード・パターン（facade pattern）」で考えるとよい。
「ファサード」は「建物の正面」という意味だそうで，システム内の各サブシステムの窓口のように機能する&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:fcd&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:fcd&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;figure style=&#39;margin:0 auto;text-align:center;&#39;&gt;
&lt;a href=&#34;http://text.baldanders.info/images/facade-pattern.svg&#34;&gt;&lt;img src=&#34;http://text.baldanders.info/images/facade-pattern.svg&#34; alt=&#34;Facade Pattern&#34;&gt;&lt;/a&gt;
&lt;figcaption&gt;&lt;a href=&#34;http://text.baldanders.info/images/facade-pattern.svg&#34;&gt;Facade Pattern&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;この図のようにファサード・パターンは DDD (Domain-Driven Design) と相性がよい。
普通は Web アプリケーションのような多様なサブシステムを含むシステムを設計する際に導入する考え方だが， CLI の場合でもサブコマンドを構成するのであればファサード・パターンがよいだろう。&lt;/p&gt;

&lt;h2 id=&#34;mitchellh-cli-パッケージ:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;mitchellh/cli パッケージ&lt;/h2&gt;

&lt;p&gt;CLI をサポートするパッケージはいくつか公開されているのだが，この中で今回は &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; パッケージを紹介する。
&lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; はサブコマンドをファサード・パターンで実装するのに便利な機能を実装している。&lt;/p&gt;

&lt;h3 id=&#34;command-インタフェース:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;Command インタフェース&lt;/h3&gt;

&lt;p&gt;まずは &lt;code&gt;Command&lt;/code&gt; インタフェース。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// A command is a runnable sub-command of a CLI.
type Command interface {
	// Help should return long-form help text that includes the command-line
	// usage, a brief few sentences explaining the function of the command,
	// and the complete list of flags the command accepts.
	Help() string

	// Run should run the actual command with the given CLI instance and
	// command-line arguments. It should return the exit status when it is
	// finished.
	Run(args []string) int

	// Synopsis should return a one-line, short synopsis of the command.
	// This should be less than 50 characters ideally.
	Synopsis() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Command&lt;/code&gt; インタフェースはサブコマンドの context 情報を構成するのに使う。
&lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; は &lt;code&gt;Command&lt;/code&gt; インタフェースに適合する型（&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt;）のインスタンスを受け取ってサブコマンドの制御を行う&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:t&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:t&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
さらに以下の関数値（function value）を示す型 &lt;code&gt;CommandFactory&lt;/code&gt; も用意されている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// CommandFactory is a type of function that is a factory for commands.
// We need a factory because we may need to setup some state on the
// struct that implements the command itself.
type CommandFactory func() (Command, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように &lt;code&gt;Command&lt;/code&gt; 型のインスタンスを返す関数を型として定義し，この型のリストを作成するのである。&lt;/p&gt;

&lt;h3 id=&#34;cli-構造体:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;CLI 構造体&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; に渡す context 情報は &lt;code&gt;CLI&lt;/code&gt; 構造体にまとめられている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// CLI contains the state necessary to run subcommands and parse the
// command line arguments.
type CLI struct {
	// Args is the list of command-line arguments received excluding
	// the name of the app. For example, if the command &amp;quot;./cli foo bar&amp;quot;
	// was invoked, then Args should be []string{&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;}.
	Args []string

	// Commands is a mapping of subcommand names to a factory function
	// for creating that Command implementation. If there is a command
	// with a blank string &amp;quot;&amp;quot;, then it will be used as the default command
	// if no subcommand is specified.
	Commands map[string]CommandFactory

	// Name defines the name of the CLI.
	Name string

	// Version of the CLI.
	Version string

	// HelpFunc and HelpWriter are used to output help information, if
	// requested.
	//
	// HelpFunc is the function called to generate the generic help
	// text that is shown if help must be shown for the CLI that doesn&#39;t
	// pertain to a specific command.
	//
	// HelpWriter is the Writer where the help text is outputted to. If
	// not specified, it will default to Stderr.
	HelpFunc   HelpFunc
	HelpWriter io.Writer

	once           sync.Once
	isHelp         bool
	subcommand     string
	subcommandArgs []string
	topFlags       []string

	isVersion bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;構造体の中に &lt;code&gt;CommandFactory&lt;/code&gt; のリストが含まれていることがお分かりだろうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Commands map[string]CommandFactory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これによってサブコマンド名と対応する処理を関連付けている。&lt;/p&gt;

&lt;h3 id=&#34;ui-インタフェース:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;Ui インタフェース&lt;/h3&gt;

&lt;p&gt;入出力関数群を持つ &lt;code&gt;Ui&lt;/code&gt; インタフェースは以下のように定義されている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Ui is an interface for interacting with the terminal, or &amp;quot;interface&amp;quot;
// of a CLI. This abstraction doesn&#39;t have to be used, but helps provide
// a simple, layerable way to manage user interactions.
type Ui interface {
	// Ask asks the user for input using the given query. The response is
	// returned as the given string, or an error.
	Ask(string) (string, error)

	// AskSecret asks the user for input using the given query, but does not echo
	// the keystrokes to the terminal.
	AskSecret(string) (string, error)

	// Output is called for normal standard output.
	Output(string)

	// Info is called for information related to the previous output.
	// In general this may be the exact same as Output, but this gives
	// Ui implementors some flexibility with output formats.
	Info(string)

	// Error is used for any error messages that might appear on standard
	// error.
	Error(string)

	// Warn is used for any warning messages that might appear on standard
	// error.
	Warn(string)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更に &lt;code&gt;Ui&lt;/code&gt; の特化クラスとして &lt;code&gt;BasicUi&lt;/code&gt; や &lt;code&gt;PrefixedUi&lt;/code&gt; や &lt;code&gt;ColoredUi&lt;/code&gt; が定義されている。
&lt;code&gt;ColoredUi&lt;/code&gt; は出力をカラーにできるが，残念ながら Windows のコマンドプロンプトには対応していないようだ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Ui&lt;/code&gt; インタフェースは &lt;code&gt;Command&lt;/code&gt; インタフェースと組み合わせてサブコマンド側の context 情報を構成するのに使う。&lt;/p&gt;

&lt;h3 id=&#34;mitchellh-cli-パッケージのメリット:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;mitchellh/cli パッケージのメリット&lt;/h3&gt;

&lt;p&gt;上述したように &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; はサブコマンドをファサード・パターンで実装するのに便利な機能を実装している。
なおかつ &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; ではファサード・パターンを入れ子にすることができる。
たとえばサブコマンドのサブコマンドを構成することもできるのだ。&lt;/p&gt;

&lt;h2 id=&#34;mitchellh-cli-を使ってファサード-パターンを組んでみる:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;mitchellh/cli を使ってファサード・パターンを組んでみる&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; をファサード・パターンとして組みやすくするためのラッパーとして &lt;a href=&#34;https://github.com/spiegel-im-spiegel/gofacade&#34; title=&#34;spiegel-im-spiegel/gofacade&#34;&gt;spiegel-im-spiegel/gofacade&lt;/a&gt; パッケージを作ってみた&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:li&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:li&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;まず，入出力の Context を定義するためのクラスとして &lt;code&gt;Context&lt;/code&gt; 構造体を作った。
中身は &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;&lt;code&gt;cli&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;BasicUi&lt;/code&gt; 構造体を埋め込んでいるだけである&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:ebd1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:ebd1&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//Context inheritance cli.BasicUi
type Context struct {
	//Embedded BasicUi
	*cli.BasicUi
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更に &lt;code&gt;Context&lt;/code&gt; 構造体を包含する &lt;code&gt;Facade&lt;/code&gt; 構造体を定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Facade is context of facade
type Facade struct {
	//UI defines user interface of the Cli
	Cxt *Context
	// commands is a mapping of subcommand names to a factory function
	commands map[string]cli.CommandFactory
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Facade&lt;/code&gt; 構造体には &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;&lt;code&gt;cli&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;CommandFactory&lt;/code&gt; のリストを含んでいる。
このリストに &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;&lt;code&gt;cli&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Command&lt;/code&gt; インタフェースに適合するインスタンスを追加するための関数がこれ&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:cl&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:cl&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// AddCommand add command
func (f *Facade) AddCommand(name string, command cli.Command) {
	f.commands[name] = func() (cli.Command, error) {
		return command, nil
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際にファサードを実行するには以下の関数を起動する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Run facade
func (f *Facade) Run(appName, version string, args []string) (int, error) {
	c := cli.NewCLI(appName, version)
	c.Args = args
	c.Commands = f.commands
	c.HelpWriter = f.Cxt.Writer
	return c.Run()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他に細かい道具はあるが，まぁこんなもんだろう。&lt;/p&gt;

&lt;h3 id=&#34;spiegel-im-spiegel-gofacade-の実装例:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;spiegel-im-spiegel/gofacade の実装例&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/gofacade&#34; title=&#34;spiegel-im-spiegel/gofacade&#34;&gt;spiegel-im-spiegel/gofacade&lt;/a&gt; パッケージの実装例として &lt;a href=&#34;https://github.com/spiegel-im-spiegel/astrocalc&#34; title=&#34;spiegel-im-spiegel/astrocalc&#34;&gt;spiegel-im-spiegel/astrocalc&lt;/a&gt; パッケージに CLI ツールを追加してみた。
こんな感じのコマンドラインを構成してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ astrocalc [-v | -h] mjdn &amp;lt;year&amp;gt; &amp;lt;month&amp;gt; &amp;lt;day&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず &lt;code&gt;astrocalc mjdn&lt;/code&gt; サブコマンドを以下のように定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package mjdnCmd

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/astrocalc/mjdn&amp;quot;
	&amp;quot;github.com/spiegel-im-spiegel/gofacade&amp;quot;
)

// Name は mjdn コマンド名を定義する
const Name string = &amp;quot;mjdn&amp;quot;

// Context は mjdn コマンドのコンテキストを定義する
type Context struct {
	//Embedded gofacade.Context
	*gofacade.Context
	//AppName にはアプリケーション名を格納する
	AppName string
}

// Command は Context のインスタンスを返す
func Command(cxt *gofacade.Context, appName string) *Context {
	return &amp;amp;Context{Context: cxt, AppName: appName}
}

// Synopsis は mjdn コマンドの概要を返す
func (c Context) Synopsis() string {
	return &amp;quot;Calculation of Modified Julian Day&amp;quot;
}

// Help は mjdn コマンドのヘルプを返す
func (c Context) Help() string {
	helpText := `
Usage: astrocalc mjdn &amp;lt;year&amp;gt; &amp;lt;month&amp;gt; &amp;lt;day&amp;gt;
`
	return fmt.Sprintln(strings.TrimSpace(helpText))
}

// Run は mjdn コマンドを実行する
func (c Context) Run(args []string) int {
	flags := flag.NewFlagSet(Name, flag.ContinueOnError)
	flags.Usage = func() {
		c.Error(c.Help())
	}
	// Parse commandline flag
	if err := flags.Parse(args); err != nil {
		return gofacade.ExitCodeError
	}
	if flags.NArg() != 3 {
		c.Error(fmt.Sprintf(&amp;quot;年月日を指定してください\n\n%s&amp;quot;, c.Help()))
		return gofacade.ExitCodeError
	}
	argsStr := flags.Args()
	var ymd = make([]int, 3)
	for i, arg := range argsStr {
		num, err := strconv.Atoi(arg)
		if err != nil {
			c.Error(fmt.Sprintln(err))
			return gofacade.ExitCodeError
		}
		ymd[i] = num
	}
	tm := time.Date(ymd[0], time.Month(ymd[1]), ymd[2], 0, 0, 0, 0, time.UTC)
	c.Output(fmt.Sprint(mjdn.DayNumber(tm)))
	return gofacade.ExitCodeOK
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイントは &lt;code&gt;astrocalc mjdn&lt;/code&gt; サブコマンド用の context 情報として &lt;code&gt;Context&lt;/code&gt; 構造体を定義しているところ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Context は mjdn コマンドのコンテキストを定義する
type Context struct {
	//Embedded gofacade.Context
	*gofacade.Context
	//AppName にはアプリケーション名を格納する
	AppName string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/gofacade&#34; title=&#34;spiegel-im-spiegel/gofacade&#34;&gt;&lt;code&gt;gofacade&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Context&lt;/code&gt; 構造体を埋め込みフィールドで定義しているのがお分かりだろうか。
&lt;a href=&#34;https://github.com/spiegel-im-spiegel/gofacade&#34; title=&#34;spiegel-im-spiegel/gofacade&#34;&gt;&lt;code&gt;gofacade&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Context&lt;/code&gt; はさらに &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;&lt;code&gt;cli&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;BasicUi&lt;/code&gt; 構造体を埋め込んでいる。
また &lt;code&gt;Context&lt;/code&gt; 構造体は &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;&lt;code&gt;cli&lt;/code&gt;&lt;/a&gt;.&lt;code&gt;Command&lt;/code&gt; インタフェースの特化クラスとして実装している。&lt;/p&gt;

&lt;p&gt;では，この &lt;code&gt;Context&lt;/code&gt; 構造体を使ってアプリケーションの起動部分を書いてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;github.com/spiegel-im-spiegel/astrocalc/internal/mjdnCmd&amp;quot;
	&amp;quot;github.com/spiegel-im-spiegel/gofacade&amp;quot;
)

const (
	// Name はアプリケーション名を定義する
	Name string = &amp;quot;astrocalc&amp;quot;
	// Version はアプリケーションのバージョン番号を定義する
	Version string = &amp;quot;0.1.0&amp;quot;
)

func setupFacade(cxt *gofacade.Context) *gofacade.Facade {
	fcd := gofacade.NewFacade(cxt)
	fcd.AddCommand(mjdnCmd.Name, mjdnCmd.Command(cxt, Name))
	return fcd
}

func main() {
	cxt := gofacade.NewContext(os.Stdin, os.Stdout, os.Stderr)
	fcd := setupFacade(cxt)
	rtn, err := fcd.Run(Name, Version, os.Args[1:])
	if err != nil {
		cxt.Error(fmt.Sprintln(err))
	}
	os.Exit(rtn)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;setupFacade()&lt;/code&gt; 関数でファサードを作成し， &lt;code&gt;main()&lt;/code&gt; 関数で実行しているのが分かると思う。
では実際に compile &amp;amp; run してみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\workspace\astrocalc&amp;gt; pushd C:\workspace\astrocalc\src\github.com\spiegel-im-spiegel\astrocalc

C:\workspace\astrocalc\src\github.com\spiegel-im-spiegel\astrocalc&amp;gt; glide up
[INFO] Fetching updates for github.com/spiegel-im-spiegel/gofacade.
[INFO] Found glide.yaml in C:\workspace\astrocalc\src\github.com\spiegel-im-spiegel\astrocalc\vendor\github.com\spiegel-im-spiegel\gofacade/glide.yaml
[INFO] Fetching updates for github.com/mitchellh/cli.
[INFO] Scanning github.com/mitchellh/cli for dependencies.
[INFO] ==&amp;gt; Unknown github.com/bgentry/speakeasy (github.com/bgentry/speakeasy)
[INFO] ==&amp;gt; Unknown github.com/mattn/go-isatty (github.com/mattn/go-isatty)
[INFO] Fetching updates for github.com/bgentry/speakeasy.
[INFO] Fetching updates for github.com/mattn/go-isatty.
[INFO] Scanning github.com/bgentry/speakeasy for dependencies.
[INFO] Scanning github.com/mattn/go-isatty for dependencies.
[INFO] Project relies on 4 dependencies.
[INFO] Writing glide.lock file

C:\workspace\astrocalc\src\github.com\spiegel-im-spiegel\astrocalc&amp;gt; popd

C:\workspace\astrocalc&amp;gt; go install -v github.com/spiegel-im-spiegel/astrocalc
github.com/spiegel-im-spiegel/astrocalc/mjdn
github.com/spiegel-im-spiegel/astrocalc/vendor/github.com/bgentry/speakeasy
github.com/spiegel-im-spiegel/astrocalc/vendor/github.com/mattn/go-isatty
github.com/spiegel-im-spiegel/astrocalc/vendor/github.com/mitchellh/cli
github.com/spiegel-im-spiegel/astrocalc/vendor/github.com/spiegel-im-spiegel/gofacade
github.com/spiegel-im-spiegel/astrocalc/internal/mjdnCmd
github.com/spiegel-im-spiegel/astrocalc

C:\workspace\astrocalc&amp;gt; bin\astrocalc.exe -h
usage: astrocalc [--version] [--help] &amp;lt;command&amp;gt; [&amp;lt;args&amp;gt;]

Available commands are:
    mjdn    Calculation of Modified Julian Day

C:\workspace\astrocalc&amp;gt; bin\astrocalc.exe -h mjdn
Usage: astrocalc mjdn &amp;lt;year&amp;gt; &amp;lt;month&amp;gt; &amp;lt;day&amp;gt;

C:\workspace\astrocalc&amp;gt; bin\astrocalc.exe mjdn 2015 1 1
57023 (2015-01-01)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;よしよし。
うまくいった。
なお &lt;a href=&#34;https://github.com/Masterminds/glide&#34; title=&#34;Masterminds/glide&#34;&gt;glide&lt;/a&gt; については「&lt;a href=&#34;http://text.baldanders.info/golang/vendoring-with-glide/&#34;&gt;Glide で Vendoring&lt;/a&gt;」を参考にどうぞ。&lt;/p&gt;

&lt;h2 id=&#34;ブックマーク:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;ブックマーク&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://yuuki.hatenablog.com/entry/go-cli-unix&#34;&gt;Go言語によるCLIツール開発とUNIX哲学について - ゆううきブログ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tellme.tokyo/post/2015/06/23/unix_cli_tool_go/&#34;&gt;開発者から見た UNIX 哲学とコマンドラインツールと Go言語 - TELLME.TOKYO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ryochack.hatenablog.com/entry/2013/04/17/232753&#34;&gt;Go言語のflagパッケージを使う - uragami note&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/04/17/panicwrap/&#34;&gt;Go言語のCLIツールのpanicをラップしてクラッシュレポートをつくる | SOTA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/kumatch/items/258d7984c0270f6dd73a&#34;&gt;flag 並にシンプルでより強力な CLI パーサ kingpin の紹介 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;spf13/cobra: A Commander for modern Go CLI interactions&lt;/a&gt; : &lt;a href=&#34;https://github.com/docker&#34;&gt;Docker&lt;/a&gt; や &lt;a href=&#34;https://github.com/spf13/hugo&#34;&gt;Hugo&lt;/a&gt; の &lt;a href=&#34;https://github.com/spf13&#34;&gt;Steve Francia (spf13)&lt;/a&gt; さんが公開しているパッケージ。そのうち試したい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://text.baldanders.info/golang/bookmark/&#34;&gt;Go 言語に関するブックマーク集はこちら&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;参考図書:d4a750c9c3ada9f8f4bd4f3022a7bb81&#34;&gt;参考図書&lt;/h2&gt;

&lt;div class=&#34;hreview&#34; &gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8ATHGW/baldandersinf-22/&#34;&gt;&lt;img src=&#34;http://ecx.images-amazon.com/images/I/41mh5r0NwLL._SL160_.jpg&#34; alt=&#34;photo&#34; class=&#34;photo&#34;  /&gt;&lt;/a&gt;&lt;dl &gt;&lt;dt class=&#34;fn&#34;&gt;&lt;a class=&#34;item url&#34; href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8ATHGW/baldandersinf-22/&#34;&gt;増補改訂版 Java言語で学ぶデザインパターン入門&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;結城 浩 &lt;/dd&gt;&lt;dd&gt;SBクリエイティブ 2004-06-18&lt;/dd&gt;&lt;dd&gt;評価&lt;abbr class=&#34;rating&#34; title=&#34;4&#34;&gt;&lt;img src=&#34;http://g-images.amazon.com/images/G/01/detail/stars-4-0.gif&#34; alt=&#34;&#34; /&gt;&lt;/abbr&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;p class=&#34;similar&#34;&gt;&lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1BS/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1BS.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;増補改訂版 Java言語で学ぶデザインパターン入門 マルチスレッド編&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00I8AT1EU/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00I8AT1EU.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Java言語で学ぶリファクタリング入門&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00JEYPPOE/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00JEYPPOE.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;Code Complete 第2版 上　完全なプログラミングを目指して&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B0197SZZZ0/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B0197SZZZ0.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;日経Linux（リナックス） 2016年 1月号 [雑誌]&#34;  /&gt;&lt;/a&gt; &lt;a href=&#34;http://www.amazon.co.jp/exec/obidos/ASIN/B00V2WMQNE/baldandersinf-22/&#34; target=&#34;_top&#34;&gt;&lt;img src=&#34;http://images.amazon.com/images/P/B00V2WMQNE.09._SCTHUMBZZZ_.jpg&#34;  alt=&#34;改訂2版　パーフェクトJava&#34;  /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p class=&#34;description&#34;&gt;結城浩さんによる通称「デザパタ本」。 Java 以外でも使える優れもの。&lt;/p&gt;
&lt;p class=&#34;gtools&#34; &gt;reviewed by &lt;a href=&#39;#maker&#39; class=&#39;reviewer&#39;&gt;Spiegel&lt;/a&gt; on &lt;abbr class=&#34;dtreviewed&#34; title=&#34;2016-01-05&#34;&gt;2016-01-05&lt;/abbr&gt; (powered by &lt;a href=&#34;http://www.goodpic.com/mt/aws/index.html&#34; &gt;G-Tools&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:up&#34;&gt;翻訳は &lt;a href=&#34;https://ja.wikipedia.org/wiki/UNIX%E5%93%B2%E5%AD%A6&#34;&gt;Wikipedia の記事&lt;/a&gt;から拝借させてもらった。ちなみに &lt;a href=&#34;https://ja.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License&#34;&gt;Wikipedia のコンテンツは基本的には by-sa ライセンスで公開&lt;/a&gt;されている。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:up&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:fcd&#34;&gt;ファサード自身はサブシステムの詳細を知らず context 情報を渡して処理をキックするのみなのが特徴。サブシステム側はファサードに依存せず， context 情報さえあれば処理可能にするのがコツである。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:fcd&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:t&#34;&gt;型（&lt;a href=&#34;https://golang.org/ref/spec#Properties_of_types_and_values&#34; title=&#34;Properties of types and values&#34;&gt;type&lt;/a&gt;）については「&lt;a href=&#34;http://text.baldanders.info/golang/object-oriented-programming/&#34;&gt;Go 言語における「オブジェクト」&lt;/a&gt;」を参照のこと。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:t&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:li&#34;&gt;&lt;a href=&#34;https://github.com/spiegel-im-spiegel/gofacade&#34; title=&#34;spiegel-im-spiegel/gofacade&#34;&gt;spiegel-im-spiegel/gofacade&lt;/a&gt; は &lt;a href=&#34;https://creativecommons.org/publicdomain/zero/1.0/&#34;&gt;CC0&lt;/a&gt; で公開している。個人的には実証コードの扱いなので，（著作権情報の書き換えも含めて）自由に利用して 構わない。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:li&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:ebd1&#34;&gt;なんでこんな回りくどいことをしているかというと， &lt;a href=&#34;https://github.com/mitchellh/cli&#34; title=&#34;mitchellh/cli&#34;&gt;mitchellh/cli&lt;/a&gt; パッケージをカプセル化したかったから。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:ebd1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:d4a750c9c3ada9f8f4bd4f3022a7bb81:cl&#34;&gt;&lt;a href=&#34;https://golang.org/&#34; title=&#34;The Go Programming Language&#34;&gt;Go 言語&lt;/a&gt;では関数は全て関数閉包（closure）として機能する。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:d4a750c9c3ada9f8f4bd4f3022a7bb81:cl&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
	</entry>
	
</feed>
