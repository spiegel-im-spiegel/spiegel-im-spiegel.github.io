<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Hugo 0.18.1" />
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel='stylesheet' href='//fonts.googleapis.com/css?family=Noto+Serif%7cNoto+Sans%3a400,700%7cInconsolata%3a400,700' type='text/css'>
<link rel='stylesheet' href='//fonts.googleapis.com/earlyaccess/notosansjp.css' type='text/css'>
<link rel='stylesheet' href='//fonts.googleapis.com/earlyaccess/sawarabimincho.css' type='text/css'>
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/cc-icons/1.2.1/css/cc-icons.min.css">
<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/text-baldanders.css">
<link rel="alternate" href="http://text.baldanders.info/index.xml" type="application/rss+xml" title="text.Baldanders.info">
<meta name="google-site-verification" content="jTjBCslPtf8gwVatiY-GDgGv7pV5csa8aUOw1MRPUD4">
<link rel="stylesheet" href="/css/addon.css">
<link rel="stylesheet" href="/highlightjs/styles/github.css">
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;locale=ja"></script>
<script>
  MathJax.Hub.Config({
    TeX: {
      extensions: ["autoload-all.js"],
      equationNumbers: { autoNumber: "all" }
    },
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    },
    "HTML-CSS": {
      matchFontHeight: false,
      preferredFont: null,
      webFont: "TeX"
    },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>
<title>関数とポインタ — プログラミング言語 Go | text.Baldanders.info</title>
<meta name="description" content="Go 言語の引数は基本的に「値渡し（call by value）」である。「参照渡し（call by reference）」にしたい場合はポインタを使う。">
<meta name="author" content="Spiegel">
<meta name="keywords" content="golang,function,pointer">
<link rel='prev' href='http://text.baldanders.info/golang/zundoko-choir/' title='「ズンドコチェック」なるものが流行っているらしい' />
<link rel='next' href='http://text.baldanders.info/golang/error-handling2/' title='Error の構造化' />
</head>
<body>

<div id='container'>
<header>
<div id="sitetitle"><a href="http://text.baldanders.info/">text.Baldanders.info</a> <a href='/index.xml' title='Feed'><i class='fa fa-rss'></i></a></div>
<p>帰ってきた「しっぽのさきっちょ」</p>
</header>


<main>
<article itemscope itemtype='http://schema.org/BlogPosting' itemref='maker'>
<h1 itemprop='name'>関数とポインタ — <a href="/golang">プログラミング言語 Go</a></h1>
<nav class="tags">
<div><a href="/tags">Tags</a>: #<a href="/tags/function">function</a> #<a href="/tags/golang">golang</a> #<a href="/tags/pointer">pointer</a></div>
<div><a href="https://github.com/spiegel-im-spiegel/spiegel-im-spiegel.github.io/commits/master/golang/function-and-pointer/index.html">History</a></div>
</nav>

<section>


<p>いまさらな内容なのだが覚え書きとして記しておく。</p>

<h2 id="go-言語における-calling-sequence">Go 言語における Calling Sequence</h2>

<p>まずは簡単な足し算の関数を定義してみる。</p>

<pre><code class="language-go">func add(x int, y int) int {
	return x + y
}
</code></pre>

<p><code>add</code> に続く括弧内が引数を定義していて，括弧の後ろの <code>int</code> は返り値の型<sup class="footnote-ref" id="fnref:t"><a rel="footnote" href="#fn:t">1</a></sup> を示している。
<code>add()</code> 関数を呼び出すには以下のように記述する。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func add(x, y int) int {
	return x + y
}

func main() {
	ans := add(42, 13)
	fmt.Println(ans)
}
</code></pre>

<p><code>x</code> と <code>y</code> は同じ int 型なので以下のように記述することもできる。</p>

<pre><code class="language-go">func add(x, y int) int {
	return x + y
}
</code></pre>

<p>返り値として複数の値を定義することもできる。</p>

<pre><code class="language-go">func split(sum int) (int, int) {
	x = sum * 4 / 9
	y = sum - x
	return x, y
}
</code></pre>

<p>また返り値は以下のように名前をつけることもできる。</p>

<pre><code class="language-go">func add(x, y int) (ans int) {
	ans = x + y
	return
}
</code></pre>

<p>最後の <code>return</code> がないとコンパイル・エラーになるので注意。
この書き方は <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">defer</a> 構文と組み合わせるときに威力を発揮する。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	err := r()
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(&quot;Normal End.&quot;)
	}
}

func r() (err error) {
	defer func() {
		if rec := recover(); rec != nil {
			err = fmt.Errorf(&quot;Recovered from: %v&quot;, rec)
		}
	}()

	f()
	err = nil
	return
}

func f() {
	panic(&quot;Panic!&quot;)
}
</code></pre>

<p>このコード<sup class="footnote-ref" id="fnref:p"><a rel="footnote" href="#fn:p">2</a></sup> では <code>r()</code> 関数内で <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">panic</a> を捕まえ， 返り値の <code>err</code> に値をセットしなおしている。</p>

<h3 id="go-言語の引数は-値渡し">Go 言語の引数は「値渡し」</h3>

<p><a href="https://golang.org/" title="The Go Programming Language">Go 言語</a>の引数は基本的に「値渡し（call by value）」である。
たとえば先程の足し算を</p>

<pre><code class="language-go">func add(x, y int) int {
	x += y
	return x
}
</code></pre>

<p>と定義した場合でも</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func add(x, y int) int {
	x += y
	return x
}

func main() {
    x := 42
    y := 13
	ans := add(x, y)
	fmt.Printf(&quot;%d + %d = %d\n&quot;, x, y, ans) //output: 42 + 13 = 55
}
</code></pre>

<p>呼び出し元で <code>add()</code> 関数の引数に渡した instance は関数実行後も変化しない。
このため「値渡し」は thread safe なコードに向いている。
たとえば value object を構成する際には関連する関数は「値渡し」のほうが安全である。
ただし関数呼び出し時に instance の値が常にコピーされるため<sup class="footnote-ref" id="fnref:copy"><a rel="footnote" href="#fn:copy">3</a></sup>，サイズの大きな instance の場合は呼び出し時のコストが高くなる。</p>

<p>引数を「参照渡し（call by reference）」にしたい場合はポインタを使う。
つまり instance のポインタ値を渡すのである。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func add(x, y *int) int {
	*x += *y
	return *x
}

func main() {
	x := 42
	y := 13
	ans := add(&amp;x, &amp;y)
	fmt.Printf(&quot;%d + %d = %d\n&quot;, x, y, ans) //output: 55 + 13 = 55
}
</code></pre>

<p>このコードでは <code>add()</code> 関数実行後の <code>x</code> の値が変更されている。
内部状態を持つ instance を引数に指定する場合は参照渡しにする必要がある。
しかし引数を参照渡しにすると関数実行が thread safe でなくなる可能性がある。
また引数の値が nil の場合も考慮する必要がある。</p>

<p>ちなみに <a href="https://golang.org/" title="The Go Programming Language">Go 言語</a>では通常の方法ではポインタ演算ができない。
たとえば，ついうっかり</p>

<pre><code class="language-go">func add(x, y *int) int {
	x += y
	return *x
}
</code></pre>

<p>とか書いてしまっても</p>

<pre><code class="language-text">invalid operation: x += y (operator + not defined on pointer)
</code></pre>

<p>とコンパイル・エラーになる。
ポインタ演算が必要な場合は <a href="https://golang.org/pkg/unsafe/" title="unsafe - The Go Programming Language"><code>unsafe</code></a> パッケージを使う。</p>

<h3 id="slice-map-channel-は常に-参照渡し">Slice, Map, Channel は常に「参照渡し」</h3>

<p><a href="http://golang.org/ref/spec#Slice_types">slice</a>, <a href="http://golang.org/ref/spec#Map_types">map</a>, <a href="http://golang.org/ref/spec#Channel_types">channel</a> は組み込み型だが内部状態を持つ<sup class="footnote-ref" id="fnref:make"><a rel="footnote" href="#fn:make">4</a></sup>。
したがって，これらの型の instance を引数に渡す場合はつねに「参照渡し」になる（つまり instance のコピーは発生しない）。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func setItem(ary map[int]int, index, item int) {
	ary[index] = item
}

func main() {
    ary := map[int]int{0: 0}
	fmt.Println(ary) //output: map[0:0]
	setItem(ary, 0, 1)
	fmt.Println(ary) //output: map[0:1]
	setItem(ary, 10, 10)
	fmt.Println(ary) //output: map[0:1 10:10]
}
</code></pre>

<p>ただし固定の配列や <a href="http://golang.org/ref/spec#String_types">string</a> 型<sup class="footnote-ref" id="fnref:str"><a rel="footnote" href="#fn:str">5</a></sup> の instance は「値」として振る舞うため<sup class="footnote-ref" id="fnref:n"><a rel="footnote" href="#fn:n">6</a></sup>，引数に指定した場合も「値渡し」になる。
<a href="http://golang.org/ref/spec#Slice_types">slice</a> とは挙動が異なるためテキトーなコードを書いていると混乱しやすい。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func setItem(ary [4]int, index, item int) {
	ary[index] = item
}

func main() {
	ary := [4]int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	setItem(ary, 1, 10)
	fmt.Println(ary) //output: [0 1 2 3]
	ary[2] = 200
	fmt.Println(ary) //output: [0 1 200 3]
}
</code></pre>

<p>固定配列や <a href="http://golang.org/ref/spec#String_types">string</a> 型を「参照渡し」にしたい場合はやはりポインタ値を渡す。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func setItem(ary *[4]int, index, item int) {
	(*ary)[index] = item
}

func main() {
	ary := [4]int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	setItem(&amp;ary, 1, 10)
	fmt.Println(ary) //output: [0 10 2 3]
}
</code></pre>

<p>実際には <a href="http://golang.org/ref/spec#String_types">string</a> 型の instance は「不変（immutable）」なので「参照渡し」が必要な局面はほとんど無いと思われる<sup class="footnote-ref" id="fnref:s"><a rel="footnote" href="#fn:s">7</a></sup>。
固定配列は不変ではないが，配列を操作するのであれば固定配列ではなく <a href="http://golang.org/ref/spec#Slice_types">slice</a> のほうが扱いやすい。
たとえば上のコードでは <code>ary := []int{0, 1, 2, 3}</code> と初期化すれば <a href="http://golang.org/ref/spec#Slice_types">slice</a> として扱える。</p>

<h2 id="method-receiver">Method Receiver</h2>

<p>ある型に関数を関連付ける場合は method receiver を使う。</p>

<pre><code class="language-go">type Vertex struct {
	X int
	Y int
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}
</code></pre>

<p><code>(v Vertex)</code> の部分が method receiver である。
<code>Add()</code> 関数を呼び出すには以下のように記述する。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&quot;X = &quot;, v.X, &quot;, Y = &quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := Vertex{X: 1, Y: 2}
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)  //output: X = 1, Y = 2
	fmt.Println(vv) //output: X = 4, Y = 6
}
</code></pre>

<p>関数の calling sequence としては <code>v.Add(dv)</code> と <code>Vertex.Add(v, dv)</code> は等価である。
つまり <code>v</code> は <code>Add()</code> 関数の0番目の引数として振る舞い，「値渡し」でセットされる。</p>

<p>Method receiver の型をポインタ型にすれば「参照渡し」にできる。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&quot;X = &quot;, v.X, &quot;, Y = &quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := &amp;Vertex{X: 1, Y: 2}
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: X = 4, Y = 6
}
</code></pre>

<p>この場合も calling sequence としては <code>v.Add(dv)</code> と <code>(*Vertex).Add(v, dv)</code> は等価である。</p>

<h3 id="method-receiver-の暗黙的変換">Method Receiver の暗黙的変換</h3>

<p>Method receiver を「値渡し」にした場合，呼び出し元の instance がポインタ型であっても暗黙的に「値渡し」に変換される。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&quot;X = &quot;, v.X, &quot;, Y = &quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := &amp;Vertex{X: 1, Y: 2} //pointer
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)  //output: X = 1, Y = 2
	fmt.Println(vv) //output: X = 4, Y = 6
}
</code></pre>

<p>Method receiver を「参照渡し」にした場合も暗黙的に「参照渡し」に変換される。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&quot;X = &quot;, v.X, &quot;, Y = &quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := Vertex{X: 1, Y: 2} //not pointer
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: X = 4, Y = 6
}
</code></pre>

<h3 id="method-receiver-の値が-nil-の場合">Method Receiver の値が nil の場合</h3>

<p>Method receiver の値が nil の場合はどうなるか。
まずは「値渡し」の場合。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&quot;X = &quot;, v.X, &quot;, Y = &quot;, v.Y)
}

func (v Vertex) Add(dv Vertex) Vertex {
	v.X += dv.X
	v.Y += dv.Y
	return v
}

func main() {
	v := (*Vertex)(nil) //nil
	vv := v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v)
	fmt.Println(vv)
}
</code></pre>

<p>この場合は <code>Add()</code> 関数呼び出し時に <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">panic</a> になる。</p>

<pre><code class="language-text">panic: runtime error: invalid memory address or nil pointer dereference
</code></pre>

<p>まぁこれは分かりやすいよね。
では「参照渡し」の場合はどうなるか。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Vertex struct {
	X int
	Y int
}

func (v Vertex) String() string {
	return fmt.Sprint(&quot;X = &quot;, v.X, &quot;, Y = &quot;, v.Y)
}

func (v *Vertex) Add(dv Vertex) {
	if v == nil {
		return
	}
	v.X += dv.X
	v.Y += dv.Y
}

func main() {
	v := (*Vertex)(nil) //nil
	v.Add(Vertex{X: 3, Y: 4})
	fmt.Println(v) //output: &lt;nil&gt;
}
</code></pre>

<p>実は <code>Add()</code> 関数呼び出し時点では <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">panic</a> にはならない。
上のコードでは <code>v</code> に nil が渡される。
したがって <code>Add()</code> 関数内の条件文を削除すると</p>

<pre><code class="language-go">func (v *Vertex) Add(dv Vertex) {
	v.X += dv.X
	v.Y += dv.Y
}
</code></pre>

<p><code>v</code> 内の要素を参照としたところで <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">panic</a> になる。
Method receiver を「参照渡し」にする場合は nil 値に注意する必要がある。</p>

<h2 id="for-range-構文も-値渡し">for-range 構文も「値渡し」</h2>

<p>余談だが for-range 構文も「値渡し」（つまりコピーが発生する）なので注意が必要である。
たとえば以下のコードで</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	ary := []int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	for _, item := range ary {
		item += 10
	}
	fmt.Println(ary) //output: [0 1 2 3]
}
</code></pre>

<p>for-range 構文内の <code>item</code> は <code>ary</code> 内の要素を指すのではなく要素のコピーである。
したがって <code>item</code> を操作しても <code>ary</code> には影響しない。
<code>ary</code> 内の要素を操作するのであれば素朴に</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	ary := []int{0, 1, 2, 3}
	fmt.Println(ary) //output: [0 1 2 3]
	for i := 0; i &lt; len(ary); i++ {
		ary[i] += 10
	}
	fmt.Println(ary) //output: [10 11 12 13]
}
</code></pre>

<p>とするしかない。</p>

<h2 id="ブックマーク">ブックマーク</h2>

<ul>
<li><a href="https://skatsuta.github.io/2015/12/29/value-receiver-pointer-receiver/">Go 言語の値レシーバとポインタレシーバ | Step by Step</a></li>
</ul>

<p><a href="http://text.baldanders.info/golang/bookmark/">Go 言語に関するブックマーク集はこちら</a>。</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:t">型については「<a href="/golang/object-oriented-programming/">Go 言語における「オブジェクト」</a>」を参照のこと。
 <a class="footnote-return" href="#fnref:t"><sup>[return]</sup></a></li>
<li id="fn:p">このコードについては「<a href="/golang/error-handling/">エラー・ハンドリングについて</a>」で解説している。ちなみに <a href="http://blog.golang.org/defer-panic-and-recover" title="Defer, Panic, and Recover - The Go Blog">panic</a> を潰して error を返すのはエラー・ハンドリングとしてはいいやり方ではない。
 <a class="footnote-return" href="#fnref:p"><sup>[return]</sup></a></li>
<li id="fn:copy">値がどこにコピーされるかは型によって異なる。 <a href="http://golang.org/ref/spec#String_types">string</a> 以外の基本型は値がスタックに積まれる。 <a href="http://golang.org/ref/spec#String_types">string</a> および基本型以外はヒープ領域に値がコピーされそのポインタがスタックに積まれる。
 <a class="footnote-return" href="#fnref:copy"><sup>[return]</sup></a></li>
<li id="fn:make"><a href="http://golang.org/ref/spec#Slice_types">slice</a>, <a href="http://golang.org/ref/spec#Map_types">map</a>, <a href="http://golang.org/ref/spec#Channel_types">channel</a> は内部状態を持つため <code>new()</code> 関数ではなく <code>make()</code> 関数で instance を生成する。
 <a class="footnote-return" href="#fnref:make"><sup>[return]</sup></a></li>
<li id="fn:str"><a href="http://golang.org/ref/spec#String_types">string</a> 型の実体は <code>[]byte</code> 型である。
 <a class="footnote-return" href="#fnref:str"><sup>[return]</sup></a></li>
<li id="fn:n">たとえば固定の配列や <a href="http://golang.org/ref/spec#String_types">string</a> 型の instance は nil 値を持たない。 <a href="http://golang.org/ref/spec#String_types">string</a> 型のゼロ値は空文字列である。
 <a class="footnote-return" href="#fnref:n"><sup>[return]</sup></a></li>
<li id="fn:s">このような需要としては文字列操作で「NULL 状態」が必要な場合であろう。たとえば DBMS にアクセスする場合は NULL 状態を扱う必要がある。なお <a href="https://golang.org/" title="The Go Programming Language">Go 言語</a>のコア・パッケージには <a href="https://golang.org/pkg/database/sql/" title="sql - The Go Programming Language"><code>database/sql</code></a> があり <code>NullString</code> を使うことにより NULL 状態を扱える。このように NULL 状態を扱う必要がある場合は，直にポインタ操作するのではなく，何らかの value object を用意してカプセル化するほうが安全である。
 <a class="footnote-return" href="#fnref:s"><sup>[return]</sup></a></li>
</ol>
</div>

</section>

</article>
</main>
<nav class="page-nav">
<div class="prev-page">&laquo; <a href="/golang/zundoko-choir/">「ズンドコチェック」なるものが流行っているらしい</a></div>
<div class="next-page"><a href="/golang/error-handling2/">Error の構造化</a> &raquo;</div>
</nav>

<aside id='tech-terms'>
<style scoped>
#tech-terms h1 {
  border: solid thin gray;
  margin: 0 0 1rem 0;
  padding: 0 0.5rem 2px 2px;
}
</style>
<h1>Technical Terms</h1>
<div class="cloud" style="font-size:smaller;">
<script type="text/javascript" src="http://e-words.jp/embed.x?e=utf8"></script>
<p class="right">Powered by <a href="hhttp://e-words.jp/p/s-embed.html">e-Words</a></p>
</div>
</aside>
<aside id='feedback'>
<style scoped>
#feedback h1 {
  border: solid thin gray;
  margin: 0 0 1rem 0;
  padding: 0 0.5rem 2px 2px;
}
</style>
<h1>Feedback</h1>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'textbaldandersinfo';
    var disqus_identifier = 'http:\/\/text.baldanders.info\/golang\/function-and-pointer\/';
    var disqus_title = '関数とポインタ';
    var disqus_url = 'http:\/\/text.baldanders.info\/golang\/function-and-pointer\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</aside>

<footer>

	<div class="userinfo">
		<div class="userinfo-avater">
			
				<a href="http://www.baldanders.info/spiegel/profile/"><img src="/images/avatar.jpg" width="48" height="48" alt="avatar"></a>
			
		</div>
		<div class="userinfo-info" id="maker" itemprop='author' itemscope itemtype='http://schema.org/Person'>
			
				Written by <a href="http://www.baldanders.info/spiegel/profile/" rel="cc:attributionURL" property="cc:attributionName" itemprop='name'>Spiegel</a> in <time property='dc:dateCopyrighted'>2016-03-29</time> (revised in <time property='dc:modified'>2016-11-08</time>).
				
	<a rel='cc:license' href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><i class="cc cc-cc"></i>&nbsp;<i class="cc cc-by"></i>&nbsp;<i class="cc cc-sa"></i></a>

			
			
	<ul class="social">
		<li><a href="https://github.com/spiegel-im-spiegel" target="_blank"><i class="fa fa-github"></i></a></li>
		<li><a href="https://twitter.com/spiegel_2007" target="_blank"><i class="fa fa-twitter"></i></a></li>
		
		<li><a href="http://spiegel-im-spiegel.tumblr.com/" target="_blank"><i class="fa fa-tumblr"></i></a></li>
		<li><a href="http://instagram.com/spiegel_2007" target="_blank"><i class="fa fa-instagram"></i></a></li>
		<li><a href="https://www.flickr.com/photos/spiegel/" target="_blank"><i class="fa fa-flickr"></i></a></li>
		<li><a href="https://www.facebook.com/spiegel.im.spiegel" target="_blank"><i class="fa fa-facebook"></i></a></li>
		<li><a href="https://jp.linkedin.com/in/spiegelimspiegel" target="_blank"><i class="fa fa-linkedin"></i></a></li>
		
	</ul>
	<ul class="social">
		<li><a href="http://www.facebook.com/share.php?u=http%3a%2f%2ftext.baldanders.info%2fgolang%2ffunction-and-pointer%2f" rel=”nofollow” target="_blank"><i class="fa fa-facebook-square fa-2x" aria-hidden="true"></i></a></li>
		<li><a href="http://twitter.com/share?text=%e9%96%a2%e6%95%b0%e3%81%a8%e3%83%9d%e3%82%a4%e3%83%b3%e3%82%bf&amp;url=http%3a%2f%2ftext.baldanders.info%2fgolang%2ffunction-and-pointer%2f" rel=”nofollow” target="_blank"><i class="fa fa-twitter-square fa-2x" aria-hidden="true"></i></a></li>
		<li><a href="https://flattr.com/submit/auto?user_id=spiegel&amp;url=http%3a%2f%2ftext.baldanders.info%2fgolang%2ffunction-and-pointer%2f&amp;title=%e9%96%a2%e6%95%b0%e3%81%a8%e3%83%9d%e3%82%a4%e3%83%b3%e3%82%bf" target="_blank"><img src="//button.flattr.com/flattr-badge-large.png" alt="Flattr this" title="Flattr this"></a></li>
	</ul>


		</div>
	</div>

<nav>
<ul class='cloud center'>
<li><a href='https://github.com/spiegel-im-spiegel/spiegel-im-spiegel.github.io'>Repository</a></li>
<li><a href='/reviews/'>Reviews</a></li>
<li><a href='/about-rss/'>Feeds</a></li>
<li><a href='/site-policy/'>Site Policy</a></li>
<li><a href='https://validator.w3.org/nu/?doc=http%3a%2f%2ftext.baldanders.info%2fgolang%2ffunction-and-pointer%2f&amp;showoutline=yes'>Debug</a></li>
</ul>
<ul class='cloud center'>
<li><a href='http://www.baldanders.info/'>Baldanders.info</a></li>
<li><a href='https://scrapbox.io/spiegel-branch/'>Scrapbox</a></li>
<li><a href='http://qiita.com/spiegel-im-spiegel'>Qiita</a></li>
</ul>
<ul class='cloud center'>
<li>Powered by <a href='http://gohugo.io/'>Hugo 0.18.1</a> and <a href="https://github.com/spiegel-im-spiegel/hugo-theme-text">Text</a>.</li>
</ul>
</nav>
</footer>

</div>
<script src="/highlightjs/highlight.pack.js"></script>
<script>
  hljs.configure({
    tabReplace: "    ",	
  });
  hljs.initHighlightingOnLoad();
</script>

</body>
</html>

